{
    "keyword": "unset",
    "opcode": "DILSI_UST",
    "yacc_rule": "| DILSI_UST '(' coreexp ',' coreexp ')' ihold\n{\n    checkbool(\"argument 2 of unset\", $5.boolean);\n    if ($3.typ != DilVarType_e::DILV_INT || $3.dsl != DSL_LFT)\n    {\n        dilfatal(\"Arg 1 of 'unset' not an integer variable\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 2 of 'unset' not an integer\");\n    }\n    else\n    {\n        $$.fst = $3.fst;\n        $$.lst = $7 + 1;\n        wtmp = &tmpl.core[$7];\n        bwrite_ubit8(&wtmp, DILI_UST);\n    }\n}",
    "dilfe_name": "dilfi_uset",
    "c_implementation": "void dilfi_uset(dilprg *p)\n{\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    p->waitcmd--;\n\n    if (dil_type_check(\"unset\", p, 1, v2, TYPEFAIL_NULL, 1, DILV_INT))\n    {\n        switch (v1->type)\n        {\n            case DILV_FAIL:\n                break;\n            case DILV_SINT1R:\n                REMOVE_BIT(*((sbit8 *)v1->ref), v2->val.num);\n                break;\n            case DILV_SINT2R:\n                REMOVE_BIT(*((sbit16 *)v1->ref), v2->val.num);\n                break;\n            case DILV_SINT4R:\n                REMOVE_BIT(*((sbit32 *)v1->ref), v2->val.num);\n                break;\n            case DILV_UINT1R:\n                REMOVE_BIT(*((ubit8 *)v1->ref), v2->val.num);\n                break;\n            case DILV_UINT2R:\n                REMOVE_BIT(*((ubit16 *)v1->ref), v2->val.num);\n                break;\n            case DILV_UINT4R:\n                REMOVE_BIT(*((ubit32 *)v1->ref), v2->val.num);\n                break;\n\n            default:\n                /* not an lvalue! */\n                dil_typeerr(p, \"lvalue unset\");\n                break;\n        }\n    }\n    delete v1;\n    delete v2;\n}",
    "dil_example": "dilbegin fnpri(FN_PRI_RESCUE-1) arrest_check(office : string);\nexternal\n    guard_arrest(office : string, prisoner : unitptr);\n    cuff_target(deputy : unitptr, targ : unitptr, cuffs : unitptr);\n    integer check_outlaw@justice(char : unitptr, juris : string);\n    string get_juris@justice();\nvar\n    u : unitptr;\n    outlaw_status : integer;\n    juris : string;\ncode\n{\n    on_activation((self.position <= POSITION_SLEEPING) or (self.position == POSITION_FIGHTING), skip);\n\n:loop:\n    wait(SFB_CMD, activator.charflags & CHAR_OUTLAW);\n    if (activator == self)\n        goto loop;\n    juris := get_juris@justice();\n    outlaw_status := check_outlaw@justice(activator, juris);\n    if (outlaw_status == 0)\n        goto loop; \n\n    u := equipment(activator,  WEAR_WRIST_R);\n\n    if (u)\n        if ((u.nameidx == \"cuffs\") and (u.zoneidx == \"midgaard\"))\n            goto loop;\n\n    if (outlaw_status == 1)  //if (activator.charflags & CHAR_PROTECTED)\n    {\n        u := load(\"cuffs@midgaard\");\n\n        cuff_target(self, activator, u);\n\n        guard_arrest@midgaard(office, activator);\n    }\n    else\n    {\n        unset(activator.charflags, CHAR_SELF_DEFENCE);\n        // If we have several chars with the same name, this causes havoc\n        //     exec(\"kill \"+activator.name, self);\n        set_fighting(self, activator);\n    }\n\n    goto loop;\n} dilend"
}