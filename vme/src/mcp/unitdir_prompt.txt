Generate MCP entry for DIL keyword: unitdir

=== Yacc rule ===
| DILSE_UDIR '(' dilexp ')'
{
    INITEXP($$);
    if ($3.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 1 of 'unitdir' not string");
    }
    else
    {
        /* Type is ok */
        /* Make nodes dynamic */
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_SLP;
        add_code(&($$), &($3));
        add_ubit8(&($$), DILE_UDIR);
    }
    FREEEXP($3);
}

=== C implementation ===
void dilfe_udir(dilprg *p)
{
    dilval *v = new dilval;
    dilval *v1 = p->stack.pop();

    cNamelist *words = new cNamelist;
    std::string sPath;

    v->type = DILV_SLP;

    switch (dil_getval(v1))
    {
        case DILV_SP:
        {
            if (v1->val.ptr)
            {
                v->atyp = DILA_EXP;
                v->type = DILV_SLP;

                std::filesystem::path uPath{p->frame[0].tmpl->zone->getDILFilePath().value_or(g_cServerConfig.getDILFileDir())};
                uPath += "/units";

                sPath = (char *)v1->val.ptr;
                if (sPath.empty())
                {
                    sPath = ".*";
                }

                boost::filesystem::path full_path(uPath);
                boost::filesystem::directory_iterator end_iter;
                boost::regex expression;

                try
                {
                    expression.assign(sPath);
                }
                catch (...)
                {
                    v->type = DILV_FAIL;
                    break;
                }

                try
                {
                    if ((boost::filesystem::exists(full_path)) && (boost::filesystem::is_directory(full_path)))
                    {
                        for (boost::filesystem::directory_iterator dir_itr(full_path); dir_itr != end_iter; ++dir_itr)
                        {
                            boost::cmatch what;

                            if (regex_match(dir_itr->path().filename().c_str(), what, expression))
                            {
                                words->AppendName(dir_itr->path().filename().c_str());
                            }
                        }
                    }
                }
                catch (const std::exception &ex)
                {
                    v->type = DILV_FAIL;
                    break;
                }

                v->val.ptr = words;
                break;
            }
            else
            {
                v->type = DILV_FAIL;
            }
        }
        break;
        case DILV_FAIL:
        case DILV_NULL:
            v->type = DILV_FAIL;
            break;
        default:
            v->type = DILV_ERR;
            break;
    }

    p->stack.push(v);
    delete v1;
}

=== DIL example ===
dilbegin aware reload_corpse();
var
	corpselist:stringlist;
	u:unitptr;
	ln:integer;
	i:integer;
	x:extraptr;
code
{
heartbeat:=3;
corpselist:=unitdir(".*");
ln:=length(corpselist);

i:=0;
while (i<ln)
	{
	u:=restore(corpselist.[i],null);
	x:=CORPSE_EXTRA in u.extra;
	if (u!=null)
		if (x!=null)
			link (u,findroom(x.descr));
		else
			link (u,findroom("temple@udgaard"));
	i:=i+1;
	}

quit;
} dilend
