Generate MCP entry for DIL keyword: vals

=== Yacc rule ===
| DILSF_VALS /* .vals (extras only) */
{
    INITEXP($$);
    $$.rtyp = DilVarType_e::DILV_EDP;
    $$.typ = DilVarType_e::DILV_ILP;
    $$.dsl = DSL_LFT;
    $$.num = DILF_VALS;
}

=== C implementation ===
case DILF_VALS:
            switch (dil_getval(v1))
            {
                case DILV_NULL: /* not applicable */
                case DILV_FAIL:
                    v->type = DILV_FAIL; /* not applicable */
                    break;

                case DILV_EDP:
                    if (v1->val.ptr)
                    {
                        v->atyp = DILA_NORM;
                        v->type = DILV_ILPR;
                        if (v1->val.ptr)
                        { // MS2020
                            v->ref = &(((extra_descr_data *)v1->val.ptr)->vals);
                        }
                        else
                        {
                            v->ref = nullptr;
                        }
                    }
                    else
                    {
                        v->type = DILV_FAIL; /* not applicable */
                    }
                    break;

                default:
                    v->type = DILV_ERR; /* wrong type */
                    break;
            }
            break;

=== DIL example ===
dilbegin aware Gold_bucket ();
var
len :integer;
 i,t:integer;
 buf:string;
 tmp:string;
 args:stringlist;

code
{

interrupt (SFB_CMD, command("accadd"),add_name);
interrupt (SFB_CMD, command("accdel"),del_name);

:start:
wait (SFB_MSG, TRUE);

if (argument !="lookin" )
 goto start;


 if (length(self.extra.["$dlist"].names)==1)
  {
  sendtext ("No donations this year yet we still need $2400 per year.<br/>",activator);
 goto start;
 }


 len:=length (self.extra.["$dlist"].names);
  buf:="As you look into the bucket you see the images of";
 i:=1;
 while (i<len)
  {
  if (i==1)
  {
  if (i+1==len)
   buf:=buf+" "+self.extra.["$dlist"].names.[i]+".  ";
   else
      buf:=buf+" "+self.extra.["$dlist"].names.[i]+", ";
      }
      else
      {
        if (i+1==len)
   buf:=buf+" and "+ self.extra.["$dlist"].names.[i]+".  ";
   else
     buf:=buf+" "+self.extra.["$dlist"].names.[i]+", ";
      }
   t:=t+self.extra.["$dlist"].vals.[i];
   i:=i+1;
  }
if (t>2400)
 t:=2400;
  t:=(t*100)/2400;
if (t==100)
                                                                                     buf :=buf +"The images seem to fill the bucket, "+
                                                                                     " with their grandeur and generosity.<br/>";
else
  buf:=buf+"The images only seem to fill the bucket %"+itoa(t)+" of the way up. "+
  " There is still room for your image if you are worthy.<br/>";

  buf:=textformat(buf);
  sendtext(buf,activator);

goto start;

:add_name:
if (activator.level<240)
goto start;
block;
if (argument=="")
 {
 sendtext ("who do you want to add<br/>",activator);
 goto start;
 }
 args:=getwords(argument);

 if (length (args) <2)
  {
  sendtext ("Correct format is 'add &lt;amount&gt; &lt;person&gt;'<br/>",activator);
  goto start;
  }

  if (atoi(args.[0])==0)
  {
  sendtext ("The first argument needs to be greater than 0<br/>",activator);
  goto start;
  }

tmp:=getword(argument);
insert(self.extra.["$dlist"].names,length(self.extra.["$dlist"].names),argument);
insert(self.extra.["$dlist"].vals,length(self.extra.["$dlist"].vals),atoi(args.[0]));

store (self,"bucket",TRUE);
goto start;
:del_name:

if (activator.level<200)
goto start;
block;


if (argument=="")
 {
 sendtext ("who do you want to delete<br/>",activator);
 goto start;
 }

t:=argument in self.extra.["$dlist"].names;
if (t>0)
 {
 remove (self.extra.["$dlist"].names,t-1);
  remove (self.extra.["$dlist"].vals,t-1);
   sendtext(argument +" removed from the list<br/>",activator);
 }
else
{
sendtext ("That person is not in the list.<br/>",activator);
}

store (self,"bucket",TRUE);
goto start;
} dilend
