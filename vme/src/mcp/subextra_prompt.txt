Generate MCP entry for DIL keyword: subextra

=== Yacc rule ===
| DILSI_SUE '(' coreexp ',' coreexp ')' ihold
{
    /*fprintf(stderr, "SUE DSL %d TYP %d\n", $3.dsl, $3.typ);*/

    if (($3.typ != DilVarType_e::DILV_EDP) || ($3.dsl != DSL_DYN))
    {
        dilfatal("Arg 1 of 'subextra' not a unit extra description");
    }
    else if ($5.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 2 of 'subextra' not a string");
    }
    else
    {
        $$.fst = $3.fst;
        $$.lst = $7 + 1;
        wtmp = &tmpl.core[$7];
        bwrite_ubit8(&wtmp, DILI_SUE);
    }
}

=== C implementation ===
void dilfi_sue(dilprg *p)
{
    dilval *v2 = p->stack.pop();
    dilval *v1 = p->stack.pop();

    p->waitcmd--;

    switch (v1->type)
    {
        case DILV_FAIL:
        case DILV_EDP:
            break;

        default:
            /* ERROR not right lvalue */
            dil_typeerr(p, "lvalue subextra");
            break;

        case DILV_EDPR:
            if (dil_type_check("subextra", p, 1, v2, TYPEFAIL_NULL, 1, DILV_SP))
            {
                if (v2->val.ptr && v1->ref)
                {
                    // MS2020 bug, check if exd is NULL
                    if (*((extra_descr_data **)v1->ref) != nullptr)
                    {
                        /* *((class extra_descr_data **)v1->ref) =
                            (*((class extra_descr_data **)v1->ref))->remove((char *)v2->val.ptr); */

                        // Save our friend exd here, because rogue_delete is going to change the ref value
                        extra_descr_data *exd = *(extra_descr_data **)v1->ref;

                        rogue_remove((extra_descr_data **)v1->ref, (char *)v2->val.ptr);

                        // Now reuse exd here to clear out any invalid pointers
                        dil_clear_extras(p, exd);

                        // So we can get into a really messy situation here.
                        // If in a DIL program you have two extraptr, e.g. u.extra and myextra := u.extra.
                        // Then call this sub() and delete the head element from u. Next check myextra.name.
                        // It will now reference a deleted memory space. Not sure why this hasn't been an
                        // issue before.
                        //
                        // We could of course now scan for local variables and NULL them out. But what if
                        // there are other DILs that have saved a reference to it? (and are extras even
                        // volatile)
                    }
                }
            }
            break;
    }
    delete v1;
    delete v2;
}

=== DIL example ===
dilbegin fnpri(FN_PRI_MISSION) janitors(rate: integer);
var
   trash : unitptr;
   s : string;
   sl : stringlist;
   msgs : stringlist;
   songs : stringlist;
   sing1 : stringlist;
   move : stringlist;
   msg : integer;
   msg2 : integer;
   obj : unitptr;
   intg : integer;
   inits: integer; // Boolean (added by S)

code
{
   if (inits == FALSE)
   {
      obj := load ("tbag@midgaard");
      link (obj, self);
      obj := null;
      inits := TRUE;
   }

   heartbeat := PULSE_SEC*rate;
   msgs := {"Ewww, a corpse.",
      "Geez, people just leave these things lying around these days.",
      "I wonder who killed that poor sucker.",
      "I always knew that guy was a pansy.",
      "He had it coming to him anyhow."};
   songs:={"sing1"};
   sing1:={"I can see a bare-bottomed mandril,",
      "Slyly eyeing his upper nostril,",
      "If he jumps inside there too,",
      "I really won't know what to do,",
      "I'll be a proud possessor of a kind of nasal zoo,",
      "A nasal zoo.",
      "I've got a ferret sticking up my nose,",
      "And what is worse it constantly explodes,",
      "Ferrets don't explode you say,",
      "But it happened nine times yesterday,",
      "And I should know 'cause each time,",
      "I was standing in the way.",
      "I've got a ferret sticking up my nose,",
      "I've got a ferret sticking up my nose,",
      "How it got there I can't tell,",
      "But now it's there it hurts like hell,",
      "And what is more it radically affects my sense of smell."};

   move := {"fear","cringe","cringe"};

:start:
:collect:
   pause;
   foreach (UNIT_ST_OBJ, trash)
   {
      if (not findsymbolic(self, "tbag@midgaard", FIND_UNIT_IN_ME)) 
         goto s_break;

      if (self.outside.flags & UNIT_FL_NO_BURY) continue;
      if (trash.flags & UNIT_FL_BURIED) continue;
      if (not isset (trash.manipulate, MANIPULATE_TAKE)) continue;
      if (not visible(self,trash)) continue;
      if (can_carry (self, trash, 1) > 0) continue; // Can't carry
      if ("treasure" == trash.zoneidx) continue;
      if ((trash.objecttype == ITEM_CONTAINER) or( trash.objecttype == ITEM_BOAT))
         continue;
      if ((trash.nameidx + trash.zoneidx == "corpsebasis") and (trash.value[2] == 0))
      {
         if (isset (self.outside.flags, UNIT_FL_NO_BURY)) continue;
         secure(trash, collect);
         pause;
         unsecure(trash);
         if (trash.inside != null)
         {
            msg := rnd(0, (length(msgs)-1));
            exec("say "+msgs.[msg], self);
            exec("get all from corpse", self);
            exec("bury "+trash.name, self);
            exec("put all in bag", self);
            continue;
         }

         if ((trash.nameidx + trash.zoneidx == "corpsebasis") and (trash.value[2] == 0) and (trash.inside == null)) 
            goto npc;
         else
         {
            :npc:
            msg := rnd(0, (length(msgs)-1));
            exec("say "+msgs.[msg], self);
            exec("bury "+trash.name, self);
            continue;
         }
      }
      if ((trash.nameidx + trash.zoneidx == "corpsebasis") and (trash.value[2] == 0) and (trash.inside == null))
      {
         secure(trash, collect);
         pause;
         unsecure(trash);
         msg := rnd(0, (length(msgs)-1));
         exec("say "+msgs.[msg], self);
         exec("bury "+trash.name, self);
         continue;
      }
      if ((trash.nameidx + trash.zoneidx == "corpsebasis") and (trash.value[2] == 1) and (trash.inside != null))
      {
         if ("$owner notified" in trash.extra) 
            continue;
         else
         {
            sl := getwords(trash.name);
            s := sl.[2];
            pause;pause;
            exec ("tell "+s+" Your corpse is at "     +self.outside.title +", please pick it up.", self);
            addextra(trash.extra, {"$owner notified"}, "");
            continue;
         }
      }

      if ((trash.nameidx + trash.zoneidx == "corpsebasis") and (trash.value[2] == 1) and (trash.inside == null))
      {
         secure(trash, collect);
         pause;
         unsecure(trash);
         exec("bury "+trash.name, self);
         continue;
      }
      if ((trash.nameidx+"@"+trash.zoneidx == "slime@basis"))
      {
         secure(trash, collect);
         pause;
         exec("say Ewww, slime!", self);
         msg2 := rnd(0, (length(move)-1));
         exec(move.[msg2], self);
         pause;
         exec("emote utters the words, 'fadiz univisa!'..", self);
         act("$2n de-materializes before your very eyes.", A_ALWAYS, self, trash, null, TO_ALL);
         unsecure(trash);
         destroy(trash);
         continue;
      }
      if ((trash.nameidx+"@"+trash.zoneidx == "head@death"))
      {
         secure(trash, collect);
         pause;
         exec("say looks like someone lost their head.", self);
         exec("chuckle", self);
         pause;
         exec("emote utters the words, 'fadiz univisa!'..", self);
         act("$2n de-materializes before your very eyes.", A_ALWAYS, self, trash, null, TO_ALL);
         unsecure(trash);
         destroy(trash);
         continue;
      }

      if ((trash.objecttype == ITEM_FOOD) or (trash.objecttype == ITEM_DRINKCON))
      {
         secure(trash, collect);
         pause;
         exec("get "+trash.name, self);
         if (trash.value[3] > 0)
         {
            exec("say This "+trash.name+" is unfit for consumption!", self);
            act("$1n heaves the $2n into the distance.", A_ALWAYS, self, trash, null, TO_ALL);
            unsecure(trash);
            destroy(trash);
            goto no_food;
         }

         unsecure(trash);
         dilcopy("rotaway@midgaard()",trash);
         act("$1n donates $2n to a worthy cause.", A_ALWAYS, self, trash, null, TO_ALL);
         link(trash, findroom("jandump@midgaard"));

         :no_food:
         pause;
         continue;
      }
      else
      {
         secure(trash, collect);
         exec("get "+trash.name, self);
         if ("bag" in trash.names)
         {
            //   dilcopy("rotaway@midgaard()",trash);
            // log("should be dilcopying 2");
            unsecure(trash);
            exec("put "+ trash.name +" in 2.bag",self);
            pause;
            continue;
         }
         else
         {
            // dilcopy("rotaway@midgaard()",trash);
            // log("should be dilcopying 3");
            unsecure(trash);
            exec("put "+ trash.name +" in bag",self);
            pause;
            continue;
         }
      }
      pause;pause;
   } // Foreach

   goto start;

:s_break:
   addextra (self.extra, {"$block wander"}, "");
   exec("say Where did my trash bag get to?", self);
   pause;
   exec("boggle self", self);
   pause;pause;pause;pause;
   exec("say Well, good time for a break I guess.", self);
   pause;
   exec("rest", self);
   pause;pause;pause;pause;pause;
   exec("emote clears his throat in preparation for a song.", self);
   pause;

   intg := 0;
   while (intg < length(sing1))
   {
      exec("emote sings, '"+sing1.[intg]+"'", self);pause;
      intg := intg+1;
   }

   pause;pause;pause;pause;pause;pause;
   exec("say I'd better get back to work before I get in trouble.", self);
   pause;pause;
   exec("stand", self);
   pause;pause;
   link(load("tbag@midgaard"),self);
   exec("emote gets a trash bag from his back pocket.", self);
   pause;
   exec("say Rule number one: always carry a spare.", self);
   exec("snicker", self);
   pause;pause;pause;pause;
   subextra (self.extra,"$block wander");
   goto start;
} dilend
