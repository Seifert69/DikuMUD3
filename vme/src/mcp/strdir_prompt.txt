Generate MCP entry for DIL keyword: strdir

=== Yacc rule ===
| DILSE_SDIR '(' dilexp ')'
{
    INITEXP($$);
    if ($3.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 1 of 'strdir' not string");
    }
    else
    {
        /* Type is ok */
        /* Make nodes dynamic */
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_SLP;
        add_code(&($$), &($3));
        add_ubit8(&($$), DILE_SDIR);
    }
    FREEEXP($3);
}

=== C implementation ===
void dilfe_sdir(dilprg *p)
{
    dilval *v = new dilval;
    dilval *v1 = p->stack.pop();
    cNamelist *words = new cNamelist;

    v->type = DILV_SLP;

    switch (dil_getval(v1))
    {
        case DILV_SP:
            if (v1->val.ptr)
            {
                v->atyp = DILA_EXP;
                v->type = DILV_SLP;

                std::filesystem::path uPath{p->frame[0].tmpl->zone->getDILFilePath().value_or(g_cServerConfig.getDILFileDir())};
                uPath += "/strings";

                std::string sPath{(char *)v1->val.ptr};
                if (sPath.empty())
                {
                    sPath = ".*";
                }

                boost::filesystem::path full_path(uPath);
                boost::filesystem::directory_iterator end_iter;

                boost::regex expression;

                try
                {
                    expression.assign(sPath);
                }
                catch (std::exception &e)
                {
                    v->type = DILV_ERR;
                    break;
                }

                try
                {
                    if ((boost::filesystem::exists(full_path)) && (boost::filesystem::is_directory(full_path)))
                    {
                        for (boost::filesystem::directory_iterator dir_itr(full_path); dir_itr != end_iter; ++dir_itr)
                        {
                            boost::cmatch what;

                            if (regex_match(dir_itr->path().filename().c_str(), what, expression))
                            {
                                words->AppendName(dir_itr->path().filename().c_str());
                            }
                        }
                    }
                }
                catch (std::exception &ex)
                {
                    v->type = DILV_ERR;
                    break;
                }

                v->val.ptr = words;
            }
            else
            {
                v->type = DILV_FAIL;
            }
            break;
        case DILV_FAIL:
        case DILV_NULL:
            v->type = DILV_FAIL;
            break;
        default:
            v->type = DILV_ERR;
            break;
    }

    p->stack.push(v);
    delete v1;
}

=== DIL example ===
dilbegin boot_comp ();
external 
	integer load_file(cname:string);
var
	rm:unitptr;
	flist:stringlist;
	i:integer;
	ln:integer;
	nl,cl:stringlist;
code
{
	heartbeat:=5*60*PULSE_SEC;
	rm:=restore("comp_obj",null);
	if (rm==null)
	{
		rm:=load("board_obj@competition");
		if (rm==null)
		{
			log ("Competition board_obj error.<br>");
			goto xp_load;
		}
		link(rm,self);
		flist:=strdir(".*.comp");
		i:=0;         
		ln:=length(flist);
		while (i<ln)
		{
			if (flist.[i]=="")
			{
				i:=i+1;
				continue;
			}
			nl:=split(flist.[i],".");
			if (length(nl)<2)
			{
				i:=i+1;
				continue;
			}
			load_file(nl.[0]);
			i:=i+1;
		}
		pause;
		addextra (self.extra,{"competition loaded"},"Extra to fix quick reboot log on problem");
	}
	else 
		link(rm,self);

:xp_load:

	rm:=restore("xp_obj",null);
	if (rm==null)
	{
		rm:=load("xp_obj@competition");
		if (rm==null)
		{
			log ("XP board_obj error.<br>");
			goto dead_load;
		}
	}
	link (rm,self);
	
:dead_load:
	
	rm:=restore("dead_obj",null);
	if (rm==null)
	{
		rm:=load("dead_obj@competition");
		if (rm==null)
		{
			log ("Death board_obj error.<br>");
			quit;
		}
	}
	link (rm,self);
	quit;
} dilend
