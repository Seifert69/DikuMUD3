{
    "keyword": "attack_spell",
    "opcode": "DILSE_ATSP",
    "yacc_rule": "| DILSE_ATSP '(' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    checkbool(\"argument 1 of attack_spell\", $3.boolean);\n\n    if ($3.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 1 of 'attack_spell' not a number\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 2 of 'attack_spell' not a unitptr\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 3 of 'attack_spell' not a unitptr\");\n    }\n    else if ($9.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 4 of 'attack_spell' not a unitptr\");\n    }\n    else if ($11.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 5 of 'attack_spell' not an integer\");\n    }\n    else if (($13.typ != DilVarType_e::DILV_SP) && ($13.typ != DilVarType_e::DILV_NULL))\n    {\n        dilfatal(\"Arg 6 of 'attack_spell' not an string or null\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        make_code(&($9));\n        make_code(&($11));\n        make_code(&($13));\n\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_code(&($$), &($9));\n        add_code(&($$), &($11));\n        add_code(&($$), &($13));\n        add_ubit8(&($$), DILE_ATSP);\n    }\n\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n    FREEEXP($9);\n    FREEEXP($11);\n    FREEEXP($13);\n}",
    "dilfe_name": "dilfe_atsp",
    "c_implementation": "void dilfe_atsp(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v6 = p->stack.pop();\n    dilval *v5 = p->stack.pop();\n    dilval *v4 = p->stack.pop();\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    v->type = DILV_INT;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_INT:\n            switch (dil_getval(v2))\n            {\n                case DILV_UP:\n                    if (!v2->val.ptr || !((unit_data *)v2->val.ptr)->isChar())\n                    {\n                        v->type = DILV_FAIL;\n                    }\n                    else\n                    {\n                        switch (dil_getval(v3))\n                        {\n                            case DILV_UP:\n                                if (!v3->val.ptr)\n                                {\n                                    v->type = DILV_FAIL;\n                                }\n                                else\n                                {\n                                    switch (dil_getval(v4))\n                                    {\n                                        case DILV_UP:\n                                            if (!v4->val.ptr)\n                                            {\n                                                v->type = DILV_FAIL;\n                                            }\n                                            else\n                                            {\n                                                switch (dil_getval(v5))\n                                                {\n                                                    case DILV_INT:\n\n                                                        switch (dil_getval(v6))\n                                                        {\n                                                            case DILV_SP:\n                                                                if (is_in(v1->val.num, SPL_GROUP_MAX, SPL_TREE_MAX - 1) &&\n                                                                    (g_spell_info[v1->val.num].spell_pointer ||\n                                                                     g_spell_info[v1->val.num].tmpl))\n                                                                {\n                                                                    spell_args sa;\n\n                                                                    set_spellargs(&sa,\n                                                                                  (unit_data *)v2->val.ptr,\n                                                                                  (unit_data *)v3->val.ptr,\n                                                                                  (unit_data *)v4->val.ptr,\n                                                                                  nullptr,\n                                                                                  0);\n                                                                    if (str_is_empty((char *)v6->val.ptr) ||\n                                                                        ((char *)v6->val.ptr == nullptr))\n                                                                    {\n                                                                        sa.pEffect = nullptr;\n                                                                    }\n                                                                    else\n                                                                    {\n                                                                        sa.pEffect = str_dup((char *)v6->val.ptr);\n                                                                    }\n\n                                                                    /* cast the spell */\n                                                                    v->val.num = spell_offensive(&sa, v1->val.num, v5->val.num);\n\n                                                                    if (sa.pEffect)\n                                                                        FREE(sa.pEffect);\n                                                                    dil_test_secure(p);\n                                                                }\n                                                                break;\n                                                            case DILV_FAIL:\n                                                                v->type = DILV_FAIL;\n                                                                break;\n                                                            case DILV_NULL:\n                                                            default:\n                                                                v->type = DILV_ERR;\n                                                                break;\n                                                        }\n\n                                                        break;\n                                                    case DILV_FAIL:\n                                                    case DILV_NULL:\n                                                        v->type = DILV_FAIL;\n                                                        break;\n                                                    default:\n                                                        v->type = DILV_ERR;\n                                                        break;\n                                                }\n                                            }\n                                            break;\n                                        case DILV_FAIL:\n                                        case DILV_NULL:\n                                            v->type = DILV_FAIL;\n                                            break;\n                                        default:\n                                            v->type = DILV_ERR;\n                                            break;\n                                    }\n                                }\n                                break;\n                            case DILV_FAIL:\n                            case DILV_NULL:\n                                v->type = DILV_FAIL;\n                                break;\n                            default:\n                                v->type = DILV_ERR;\n                                break;\n                        }\n                    }\n                    break;\n                default:\n                    v->type = DILV_ERR;\n                    break;\n            }\n            break;\n        case DILV_FAIL:\n        case DILV_NULL:\n            v->type = DILV_FAIL;\n            break;\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n    delete v4;\n    delete v5;\n    delete v6;\n}",
    "dil_example": "dilbegin spl_lava_1(medi : unitptr, tgt : unitptr, arg : string,\n                      hm : integer, effect : string);\ncode\n{\n\n  hm := attack_spell(SPL_LAVA_1, self, medi, tgt, 0, effect);\n  quit;\n} dilend"
}