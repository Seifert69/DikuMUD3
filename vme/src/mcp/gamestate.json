{
    "keyword": "gamestate",
    "opcode": "DILSI_GMSTATE",
    "yacc_rule": "| DILSI_GMSTATE '(' coreexp ',' coreexp ')' ihold\n{\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'gamestate' not a unit\");\n    }\n    if ($5.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 1 of 'gamestate' not an integer\");\n    }\n    else\n    {\n        $$.fst = $3.fst;\n        $$.lst = $7 + 1;\n        wtmp = &tmpl.core[$7];\n        bwrite_ubit8(&wtmp, DILI_GMSTATE);\n    }\n}",
    "dilfe_name": "dilfi_gamestate",
    "c_implementation": "void dilfi_gamestate(dilprg *p)\n{\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    if (dil_type_check(\"gamestate\", p, 2, v1, TYPEFAIL_NULL, 1, DILV_UP, v2, TYPEFAIL_NULL, 1, DILV_INT))\n    {\n        if (!((unit_data *)v1->val.ptr)->isPC())\n        {\n            dil_typeerr(p, \"gamestate: Not a pc unit\");\n        }\n        else\n        {\n            switch (v2->val.num)\n            {\n                case GS_PLAY:\n                    UPC((unit_data *)v1->val.ptr)->gstate_togame(p);\n                    break;\n                case GS_QUIT:\n                    extract_unit((unit_data *)v1->val.ptr);\n                    break;\n                case GS_MENU:\n                    UPC((unit_data *)v1->val.ptr)->gstate_tomenu(p);\n                    break;\n                case GS_LINK_DEAD:\n                    if (CHAR_DESCRIPTOR((unit_data *)v1->val.ptr))\n                    {\n                        descriptor_close(CHAR_DESCRIPTOR((unit_data *)v1->val.ptr));\n                    }\n                    break;\n            }\n        }\n    }\n    delete v1;\n    delete v2;\n}",
    "dil_example": "dilbegin aware do_quit(arg : string);\nexternal\n   on_connect@basis();\n\nvar\n   err : integer;\n   goodbye : string;\n   tt:integer;\n   minutes:integer;\n   seconds:integer;\n   u : unitptr;\n   quit_str:string;\n\ncode\n{\n   if (quit_str==\"logging on\")\n      quit;\n\n   heartbeat := PULSE_SEC;\n\n   if (excmdstr != \"quit\")\n   {\n      // MS2020: This is hard to understand :-) But if you're immortal and you quit to the menu\n      // (look below). Then eventually you char gets saved with this do_quit DIL. When the char \n      // is loaded the program runs again, e.g. triggered by the on_connect exec(\"look\"). \n      // Since the DIL doesn't recall (it probably shouldnt because it would recall in the external\n      // funciton). Then I add this little hack to gracefully quit the do_quit without the odd\n      // error message.\n      //\n      if (excmdstr.[0] != \"q\")\n         quit;\n\n      sendtext (\"You can't just type [\"+excmdstr+\"] you must type 'quit' no less to quit!<br/>\",self);\n      quit;\n   }\n\n\n   if (self.type != UNIT_ST_PC) \n      quit;\n\n   if (self.position == POSITION_FIGHTING)\n   {\n      sendtext(\"Not while fighting!<br/>\", self);\n      quit;\n   }\n\n   tt:=atoi(self.extra.[\"$PK_TIMER\"].descr);\n   if (realtime-tt>600)\n      goto cont_quit;\n\n   seconds:=0;\n   minutes:=0;\n   seconds:=realtime-tt;\n   seconds:=600-seconds;\n   minutes:=seconds/60;\n\n   sendtext(\"You are not permitted to log off so soon after a PK fight.<br/>\",self);\n\n   if (minutes<1){\n      if (seconds==1)\n         sendtext (\"You have 1 more second before you can log off.<br/>\",self);\n      else\n         sendtext (\"You have \"+itoa(seconds)+\" more seconds before you can log off.<br/>\",self);\n      quit;\n   }\n   else\n   {\n      seconds :=seconds-(minutes*60);\n      if ((minutes==1) and (seconds==1))\n         sendtext (\"You have 1 minute and 1 second before you can log off.<br/>\",self);\n      else if (minutes==1)\n         sendtext (\"You have 1 minute and \"+itoa(seconds)+\" seconds before you can log off.<br/>\",self);\n      else if (seconds==1)\n         sendtext (\"You have \"+itoa(minutes)+\" minutes and 1 second before you can log off.<br/>\",self);\n      else\n         sendtext (\"You have \"+itoa(minutes)+\" minutes and \"+itoa(seconds)+\" seconds before you can log off.<br/>\",self);\n      quit;\n   }\n\n   :cont_quit:\n   foreach(UNIT_ST_PC,u)\n   {\n      if (u != self)\n      {\n         if (visible(u,self))\n            sendtext(self.name+\" has left the game.<br/>\",u);\n      }\n   }\n\n   //log(\"QUIT PC \" + self.name);\n   if (self.level < 200)\n   {\n      err := loadstr(\"goodbye\",goodbye);\n\n      if (err > 0)\n      {\n         goodbye := textformat(goodbye);\n         sendtext(\"<br/><br/>\"+goodbye, self);\n      }\n\n      sendtext(\"Goodbye, friend.. Come back soon!<br/>\", self);\n      quit_str:=\"logging on\";\n      gamestate(self, GS_QUIT);\n   }\n   else\n   {\n      gamestate(self, GS_MENU);\n      //dilcopy(\"on_connect@basis\", self);\n      on_connect@basis();\n   }\n   quit;\n} dilend"
}