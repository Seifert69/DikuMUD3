= unsecure =
 procedure: '''unsecure'''(u : unitptr);

The '''unsecure''' procedure removes secure protection from a previously secured unit.

== Description ==
This procedure removes the secure protection that was placed on a unit using the [[secure]]() procedure. Once a unit is unsecured, it can be modified, destroyed, or moved by other DIL programs. The secure/unsecure mechanism is used to prevent race conditions and protect units during critical operations.

== PARAMETERS ==
{| class="wikitable"
! Parameter !! Type !! Description
|-
| u || unitptr || The unit to remove secure protection from
|}

== Examples ==
dilbegin unique process_item(item : unitptr);
var
    original_owner : unitptr;
code
{
    // Secure the item to prevent interference
    secure(item, :item_lost);
    
    // Process the item safely
    original_owner := item.outside;
    sendto("Processing " + item.title + "...&n", self);
    
    // Remove secure protection when done
    unsecure(item);
    
    // Continue with normal operations
    act("$1n finishes processing $2n.", A_ALWAYS, self, item, null, TO_ROOM);
} dilend

dilbegin unique janitor_cleanup();
var
    trash : unitptr;
    i : integer;
code
{
    // Find and process trash items
    foreach (UNIT_ST_OBJ, trash)
    {
        if (not findsymbolic(self, "tbag@midgaard", FIND_UNIT_IN_ME)) 
            goto s_break;

        if (self.outside.flags & UNIT_FL_NO_BURY) continue;
        if (trash.flags & UNIT_FL_BURIED) continue;
        if (not isset (trash.manipulate, MANIPULATE_TAKE)) continue;
        if (not visible(self,trash)) continue;
        if (can_carry (self, trash, 1) > 0) continue;

        // Secure trash before processing
        secure(trash, :collect);
        pause;
        
        // Process the trash item
        exec("get " + trash.name, self);
        if (trash.value[3] > 0)
        {
            exec("say This " + trash.name + " is unfit for consumption!", self);
            act("$1n heaves the $2n into the distance.", A_ALWAYS, self, trash, null, TO_ALL);
            unsecure(trash);
            destroy(trash);
            continue;
        }

        // Unsecure after processing
        unsecure(trash);
        dilcopy("rotaway@midgaard()", trash);
        act("$1n donates $2n to a worthy cause.", A_ALWAYS, self, trash, null, TO_ALL);
        link(trash, findroom("jandump@midgaard"));
    }
} dilend

dilbegin unique secure_transfer(item : unitptr, target : unitptr);
var
    success : integer;
code
{
    // Secure item during transfer to prevent interference
    secure(item, :transfer_failed);
    
    // Perform the transfer
    success := transfermoney(self.outside, target, 100);
    
    if (success)
    {
        link(item, target);
        act("$1n transfers $2n to $3n.", A_ALWAYS, self, item, target, TO_ALL);
    }
    else
    {
        act("$1n failed to transfer $2n to $3n.", A_ALWAYS, self, item, target, TO_ALL);
    }
    
    // Always unsecure when done
    unsecure(item);
} dilend

dilbegin unique temporary_protection();
var
    protected_unit : unitptr;
code
{
    protected_unit := self;
    
    // Secure the unit
    secure(protected_unit, :protection_active);
    sendto("You are now protected from interference.&n", protected_unit);
    
    // Simulate some processing time
    heartbeat := PULSE_SEC * 5;
    pause;
    
    // Remove protection
    unsecure(protected_unit);
    sendto("Protection removed.&n", protected_unit);
} dilend

== Usage Notes ==
* The unit parameter must have been previously secured using the [[secure]]() procedure.
* Each call to [[secure]]() should have a corresponding call to '''unsecure'''() to avoid leaving units permanently secured.
* The secure/unsecure mechanism prevents other DIL programs from modifying the unit during critical operations.
* Commonly used when:
** Processing items that might be targeted by other programs
** Transferring items between characters
** Performing complex operations that shouldn't be interrupted
** Temporarily protecting units during calculations or modifications
* If the unit leaves the local environment (destroyed, moved to different location, etc.), the secure is automatically broken and execution jumps to the specified label.
* The procedure is essential for proper resource management and preventing deadlocks.

== Error Handling ==
* If the unit parameter is not a unitptr, a DIL fatal error occurs: "Arg 1 of 'unsecure' not a unit".
* If the unit was not previously secured, the procedure has no effect but does not cause an error.
* If the unit pointer is null, the procedure fails silently.
* The procedure will fail if the unit is not in the current DIL program's local environment.

== Related Functions/Fields ==
* [[secure]] - Secures a unit and sets up protection monitoring
* [[dil_sub_secure]] - Internal function called by unsecure
* [[findsymbolic]] - Used to check if units are in local environment

== See Also ==
* DIL program security mechanisms
* Resource management functions
* Unit protection and synchronization