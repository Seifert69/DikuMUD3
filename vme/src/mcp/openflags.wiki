= openflags =

== Syntax ==
integer '''openflags''' (unit : unitptr)

== Description ==
The '''openflags''' field provides access to the open/close/lock state flags for units. This field contains bit flags that determine whether a unit (typically doors, containers, or objects with lids) is open, closed, locked, or has other special properties.

Based on the C implementation, this field returns a reference to the unit's open flags value, allowing both reading and writing of the flag bits.

== Field Access ==
This is a field access on unitptrs:
 unit.openflags

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Usage Notes ==
The openflags field is read-write (RW) and can be modified directly.
This field uses bit flags that can be tested and modified using [[isset]] and bitwise operations.
Common flag constants include:
* '''EX_CLOSED''' - Unit is closed
* '''EX_LOCKED''' - Unit is locked
* '''EX_OPEN_CLOSE''' - Unit can be opened and closed
* '''EX_PICKPROOF''' - Unit cannot be picked

== Examples ==
=== Checking Open State ===
 dilbegin check_open_state(target : unitptr);
 var
    flags : integer;
 
 code
 {
    if (target == null)
    {
       act("No target specified.", A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    flags := target.openflags;
    
    if (isset(flags, EX_CLOSED))
       act("$1n is closed.", A_ALWAYS, self, target, null, TO_CHAR);
    else
       act("$1n is open.", A_ALWAYS, self, target, null, TO_CHAR);
    
    if (isset(flags, EX_LOCKED))
       act("$1n is locked.", A_ALWAYS, self, target, null, TO_CHAR);
    else
       act("$1n is unlocked.", A_ALWAYS, self, target, null, TO_CHAR);
 } dilend

=== Opening and Closing ===
 dilbegin toggle_door(target : unitptr);
 var
    flags : integer;
 
 code
 {
    if (target == null)
    {
       act("No target specified.", A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    flags := target.openflags;
    
    if (isset(flags, EX_CLOSED))
    {
       // Try to open it
       if (isset(flags, EX_LOCKED))
       {
          act("$1n is locked - you must unlock it first.", A_ALWAYS, self, target, null, TO_CHAR);
       }
       else
       {
          unset(target.openflags, EX_CLOSED);
          act("You open $1n.", A_ALWAYS, self, target, null, TO_CHAR);
          act("$1n opens $2n.", A_SOMEONE, self, target, null, TO_REST);
       }
    }
    else
    {
       // Close it
       set(target.openflags, EX_CLOSED);
       act("You close $1n.", A_ALWAYS, self, target, null, TO_CHAR);
       act("$1n closes $2n.", A_SOMEONE, self, target, null, TO_REST);
    }
 } dilend

=== Lock Management ===
 dilbegin lock_container(container : unitptr);
 var
    flags : integer;
 
 code
 {
    if (container == null)
    {
       act("No container specified.", A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    flags := container.openflags;
    
    // Make sure it's closed first
    if (not isset(flags, EX_CLOSED))
    {
       set(container.openflags, EX_CLOSED);
       act("You close $1n.", A_ALWAYS, self, container, null, TO_CHAR);
    }
    
    // Now lock it
    set(container.openflags, EX_LOCKED);
    act("You lock $1n.", A_ALWAYS, self, container, null, TO_CHAR);
    act("$1n locks $2n.", A_SOMEONE, self, container, null, TO_REST);
 } dilend

=== Unlocking ===
 dilbegin unlock_door(target : unitptr);
 var
    flags : integer;
 
 code
 {
    if (target == null)
    {
       act("No target specified.", A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    flags := target.openflags;
    
    if (not isset(flags, EX_LOCKED))
    {
       act("$1n is not locked.", A_ALWAYS, self, target, null, TO_CHAR);
       return;
    }
    
    // Unlock it
    unset(target.openflags, EX_LOCKED);
    act("You unlock $1n.", A_ALWAYS, self, target, null, TO_CHAR);
    act("$1n unlocks $2n.", A_SOMEONE, self, target, null, TO_REST);
 } dilend

=== Comprehensive State Check ===
 dilbegin analyze_open_state(target : unitptr);
 var
    flags : integer;
    state : string;
 
 code
 {
    if (target == null)
    {
       act("No target specified.", A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    flags := target.openflags;
    state := "";
    
    if (isset(flags, EX_CLOSED))
       state := state + "CLOSED ";
    else
       state := state + "OPEN ";
    
    if (isset(flags, EX_LOCKED))
       state := state + "LOCKED ";
    else
       state := state + "UNLOCKED ";
    
    if (isset(flags, EX_PICKPROOF))
       state := state + "PICKPROOF ";
    
    if (isset(flags, EX_OPEN_CLOSE))
       state := state + "OPENABLE ";
    
    act("$1n state: $2t", A_ALWAYS, self, state, target, TO_CHAR);
    act("Raw flags: $3d", A_ALWAYS, self, flags, target, TO_CHAR);
 } dilend

=== Door Operations ===
 dilbegin door_operations();
 var
    door : unitptr;
    flags : integer;
 
 code
 {
    // Find a door in the room
    door := findunit(self, "door", FIND_UNIT_HERE, null);
    
    if (door == null)
    {
       act("No door found here.", A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    flags := door.openflags;
    
    // Show current state
    act("Door flags: $1d", A_ALWAYS, self, flags, null, TO_CHAR);
    
    // Toggle door state
    if (isset(flags, EX_CLOSED))
    {
       if (isset(flags, EX_LOCKED))
       {
          act("The door is locked.", A_ALWAYS, self, null, null, TO_CHAR);
       }
       else
       {
          unset(door.openflags, EX_CLOSED);
          act("You open the door.", A_ALWAYS, self, null, null, TO_CHAR);
       }
    }
    else
    {
       set(door.openflags, EX_CLOSED);
       act("You close the door.", A_ALWAYS, self, null, null, TO_CHAR);
    }
 } dilend

== Error Handling ==
Always verify the unit pointer is valid before accessing openflags:

 if (unit != null)
 {
    flags := unit.openflags;
 }
 else
 {
    act("Invalid unit pointer.", A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[isset]] - Test if specific flag bits are set
* [[opendiff]] - Open difficulty modifier
* [[exit_info]] - Exit-specific information
* [[exit_diff]] - Exit difficulty values
* [[key]] - Key required to open unit

== See Also ==
* [[unitptr]] - General unit pointer documentation
* [[isset]] - Flag testing function
* [[opendiff]] - Open difficulty field
* [[exit_info]] - Exit information field
* [[key]] - Key field for units
* [[EX_CLOSED]] - Closed flag constant
* [[EX_LOCKED]] - Locked flag constant