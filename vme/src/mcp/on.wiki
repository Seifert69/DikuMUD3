= on =

== Syntax ==
'''on''' (expression, label)

== Description ==
The '''on''' statement is a control structure that sets up conditional interrupts in DIL programs. It allows the program to jump to different labels based on the evaluation of an integer expression, similar to a switch or case statement in other programming languages.

Based on the YACC rule and C implementation, the '''on''' statement evaluates an integer expression and uses it as an index to jump to a specific address in a label table. If the expression evaluates to a valid index, the program jumps to the corresponding label. If the index is invalid or out of range, the program jumps to a default location.

== Parameters ==
{| class="wikitable"
! Parameter !! Type !! Description
|-
| expression || integer || An integer expression that determines which label to jump to
|-
| label || label || The label to jump to when the condition is met, or the special keyword SKIP
|}

== Return Value ==
Returns integer:
* '''integer''' - The index of the interrupt handler that was set up

== Usage Notes ==
The '''on''' statement is used for creating interrupt handlers and conditional branching logic.
The expression must evaluate to an integer value.
The label parameter can be either a user-defined label or the special keyword '''SKIP'''.
When using SKIP, the interrupt is set up but the program doesn't jump to any label.
The interrupt system allows DIL programs to respond to game events and conditions.

== Examples ==
=== Basic Conditional Jump ===
 dilbegin basic_on_example(value : integer);
 code
 {
    on(value, case1);
    on(value + 1, case2);
    on(0, skip);
    
    :case1:
    act("Jumped to case 1", A_ALWAYS, self, null, null, TO_CHAR);
    quit;
    
    :case2:
    act("Jumped to case 2", A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Event-Driven Programming ===
 dilbegin event_handler();
 var
    event_type : integer;
 
 code
 {
    // Set up handlers for different events
    on_activation((self.position == POSITION_FIGHTING), combat_handler);
    on_activation((self.position <= POSITION_SLEEPING), sleep_handler);
    
    // Main program loop
    heartbeat := PULSE_SEC*2;
    pause;
    goto start;
    
    :combat_handler:
    act("Entering combat mode!", A_ALWAYS, self, null, null, TO_CHAR);
    // Combat logic here
    goto start;
    
    :sleep_handler:
    act("Entering sleep mode!", A_ALWAYS, self, null, null, TO_CHAR);
    // Sleep logic here
    goto start;
 } dilend

=== State Machine ===
 dilbegin state_machine();
 var
    state : integer;
 
 code
 {
    state := 0;
    
    :start:
    on(state, state_0);
    on(state, state_1);
    on(state, state_2);
    on(99, skip); // Default case
    
    pause;
    goto start;
    
    :state_0:
    act("In state 0", A_ALWAYS, self, null, null, TO_CHAR);
    state := 1;
    goto start;
    
    :state_1:
    act("In state 1", A_ALWAYS, self, null, null, TO_CHAR);
    state := 2;
    goto start;
    
    :state_2:
    act("In state 2", A_ALWAYS, self, null, null, TO_CHAR);
    state := 0;
    goto start;
 } dilend

=== Menu System ===
 dilbegin menu_system();
 var
    choice : integer;
 
 code
 {
    act("1. Fight", A_ALWAYS, self, null, null, TO_CHAR);
    act("2. Flee", A_ALWAYS, self, null, null, TO_CHAR);
    act("3. Rest", A_ALWAYS, self, null, null, TO_CHAR);
    
    // Wait for player input (simulated here)
    choice := rnd(1, 3);
    
    on(choice, fight_option);
    on(choice, flee_option);
    on(choice, rest_option);
    on(0, skip); // Invalid choice
    
    goto menu_done;
    
    :fight_option:
    act("You choose to fight!", A_ALWAYS, self, null, null, TO_CHAR);
    goto menu_done;
    
    :flee_option:
    act("You choose to flee!", A_ALWAYS, self, null, null, TO_CHAR);
    goto menu_done;
    
    :rest_option:
    act("You choose to rest!", A_ALWAYS, self, null, null, TO_CHAR);
    goto menu_done;
    
    :menu_done:
    quit;
 } dilend

=== Guard Routine Example ===
 dilbegin guard_routine();
 var
    hour : integer;
 
 code
 {
    :start:
    hour := mudhour;
    
    // Set up time-based behavior
    on((hour >= 6) and (hour < 18), day_shift);
    on((hour >= 18) or (hour < 6), night_shift);
    on(25, skip); // Invalid hour case
    
    heartbeat := PULSE_SEC*60; // Check every minute
    pause;
    goto start;
    
    :day_shift:
    act("Guard is on day duty.", A_ALWAYS, self, null, null, TO_CHAR);
    // Day patrol logic
    goto start;
    
    :night_shift:
    act("Guard is on night duty.", A_ALWAYS, self, null, null, TO_CHAR);
    // Night patrol logic
    goto start;
 } dilend

== Error Handling ==
Always ensure the expression evaluates to an integer and the label exists:

 // Valid usage
 on(my_integer, my_label);
 
 // Invalid usage - will cause runtime error
 on(my_string, my_label); // String instead of integer
 on(my_integer, nonexistent_label); // Label doesn't exist

== Related Functions/Fields ==
* [[on_activation]] - Specific interrupt for activation events
* [[interrupt]] - General interrupt system
* [[pause]] - Wait for game pulses
* [[wait]] - Wait for specific conditions
* [[clear]] - Clear interrupts

== See Also ==
* [[on_activation]] - Activation-specific interrupt handler
* [[interrupt]] - Interrupt system overview
* [[pause]] - Program timing control
* [[wait]] - Conditional waiting
* [[goto]] - Unconditional jumping