{
    "keyword": "unitdir",
    "opcode": "DILSE_UDIR",
    "yacc_rule": "| DILSE_UDIR '(' dilexp ')'\n{\n    INITEXP($$);\n    if ($3.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 1 of 'unitdir' not string\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_SLP;\n        add_code(&($$), &($3));\n        add_ubit8(&($$), DILE_UDIR);\n    }\n    FREEEXP($3);\n}",
    "dilfe_name": "dilfe_udir",
    "c_implementation": "void dilfe_udir(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v1 = p->stack.pop();\n\n    cNamelist *words = new cNamelist;\n    std::string sPath;\n\n    v->type = DILV_SLP;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_SP:\n        {\n            if (v1->val.ptr)\n            {\n                v->atyp = DILA_EXP;\n                v->type = DILV_SLP;\n\n                std::filesystem::path uPath{p->frame[0].tmpl->zone->getDILFilePath().value_or(g_cServerConfig.getDILFileDir())};\n                uPath += \"/units\";\n\n                sPath = (char *)v1->val.ptr;\n                if (sPath.empty())\n                {\n                    sPath = \".*\";\n                }\n\n                boost::filesystem::path full_path(uPath);\n                boost::filesystem::directory_iterator end_iter;\n                boost::regex expression;\n\n                try\n                {\n                    expression.assign(sPath);\n                }\n                catch (...)\n                {\n                    v->type = DILV_FAIL;\n                    break;\n                }\n\n                try\n                {\n                    if ((boost::filesystem::exists(full_path)) && (boost::filesystem::is_directory(full_path)))\n                    {\n                        for (boost::filesystem::directory_iterator dir_itr(full_path); dir_itr != end_iter; ++dir_itr)\n                        {\n                            boost::cmatch what;\n\n                            if (regex_match(dir_itr->path().filename().c_str(), what, expression))\n                            {\n                                words->AppendName(dir_itr->path().filename().c_str());\n                            }\n                        }\n                    }\n                }\n                catch (const std::exception &ex)\n                {\n                    v->type = DILV_FAIL;\n                    break;\n                }\n\n                v->val.ptr = words;\n                break;\n            }\n            else\n            {\n                v->type = DILV_FAIL;\n            }\n        }\n        break;\n        case DILV_FAIL:\n        case DILV_NULL:\n            v->type = DILV_FAIL;\n            break;\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    p->stack.push(v);\n    delete v1;\n}",
    "dil_example": "dilbegin aware reload_corpse();\nvar\n\tcorpselist:stringlist;\n\tu:unitptr;\n\tln:integer;\n\ti:integer;\n\tx:extraptr;\ncode\n{\nheartbeat:=3;\ncorpselist:=unitdir(\".*\");\nln:=length(corpselist);\n\ni:=0;\nwhile (i<ln)\n\t{\n\tu:=restore(corpselist.[i],null);\n\tx:=CORPSE_EXTRA in u.extra;\n\tif (u!=null)\n\t\tif (x!=null)\n\t\t\tlink (u,findroom(x.descr));\n\t\telse\n\t\t\tlink (u,findroom(\"temple@udgaard\"));\n\ti:=i+1;\n\t}\n\nquit;\n} dilend"
}