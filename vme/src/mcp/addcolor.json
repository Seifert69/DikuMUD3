{
    "keyword": "addcolor",
    "opcode": "DILSE_ADDCLR",
    "yacc_rule": "| DILSE_ADDCLR '(' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'addcolor' not a unitptr\");\n    }\n    if ($5.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 2 of 'addcolor' not a string\");\n    }\n    if ($7.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 3 of 'addcolor' not a string\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_ubit8(&($$), DILE_ADDCLR);\n    }\n    FREEEXP($5);\n    FREEEXP($7);\n}",
    "dilfe_name": "dilfe_clradd",
    "c_implementation": "void dilfe_clradd(dilprg *p)\n{\n    dilval *v = new dilval;\n\n    char full_name[21];\n    char *color = nullptr;\n    unsigned int x = 0;\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    v->type = DILV_INT;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_NULL:\n            v->type = DILV_FAIL;\n            break;\n        default:\n            v->type = DILV_ERR;\n        case DILV_UP:\n            switch (dil_getval(v2))\n            {\n                case DILV_FAIL:\n                case DILV_NULL:\n                    v->type = DILV_FAIL;\n                    break;\n                default:\n                    v->type = DILV_ERR;\n                case DILV_SP:\n                    switch (dil_getval(v3))\n                    {\n                        default:\n                            v->type = DILV_ERR;\n                        case DILV_FAIL:\n                        case DILV_NULL:\n                            v->type = DILV_FAIL;\n                            break;\n                        case DILV_SP:\n\n                            if (!((unit_data *)v1->val.ptr)->isPC())\n                            {\n                                szonelog(p->sarg->owner->getFileIndex()->getZone(),\n                                         \"DIL %s, Illegal: Tried to add a color to a non pc.\\n\",\n                                         p->sarg->owner->getFileIndexSymName());\n                                v->type = DILV_FAIL;\n                            }\n\n                            if (strlen((char *)v2->val.ptr) > 20)\n                            {\n                                szonelog(p->sarg->owner->getFileIndex()->getZone(),\n                                         \"DIL %s, Illegal: Color key is greater than 20 characters.\\n\",\n                                         p->sarg->owner->getFileIndexSymName());\n                                v->type = DILV_FAIL;\n                            }\n\n                            x = 0;\n                            while (x < strlen((char *)v2->val.ptr))\n                            {\n                                if ((!isalnum(*((char *)v2->val.ptr + x))) && (*((char *)v2->val.ptr + x) != '_'))\n                                {\n                                    szonelog(p->sarg->owner->getFileIndex()->getZone(),\n                                             \"DIL %s, Illegal: Color key contains invalid characters.\\n\",\n                                             p->sarg->owner->getFileIndexSymName());\n                                    v->type = DILV_FAIL;\n                                    break;\n                                }\n                                x++;\n                            }\n\n                            if (v->type != DILV_FAIL)\n                            {\n                                auto *pc = reinterpret_cast<pc_data *>(v1->val.ptr);\n                                if (UPC(pc)->getColor().get((char *)v2->val.ptr, full_name).empty() == false)\n                                {\n                                    v->type = DILV_INT;\n                                    v->val.num = FALSE;\n                                }\n                                else\n                                {\n                                    color = str_escape_format((char *)v3->val.ptr, FALSE);\n                                    auto unused = UPC(pc)->getColor().insert((char *)v2->val.ptr, color);\n                                    FREE(color);\n                                    v->type = DILV_INT;\n                                    v->val.num = TRUE;\n                                }\n                            }\n                            break;\n                    }\n\n                    break;\n            }\n\n            break;\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n}",
    "dil_example": "dilbegin not_used(arg : string);\ncode\n{\n   // The functions in comments here have not been used in any DIL program.\n   // I suppose they're considered obsolete until someone needs them\n   // and they get tested.\n   //\n   // buf := getcolor(\"&br\"); -- NOT USED ANYWHERE\n   // buf := addcolor(); --NOT USED ANYWHERE\n   // buf := delcolor(); --NOT USED ANYWHERE\n   // buf := changecolor(); --NOT USED ANYWHERE\n   // buf := getcmd(); --NOT USED ANYWHERE\n   // buf := clone(); --NOT USED ANYWHERE\n   // buf := global_head(); --NOT USED ANYWHERE\n   // buf := obj_head(); --NOT USED ANYWHERE\n   // buf := npc_head(); --NOT USED ANYWHERE\n   // buf := room_head(); --NOT USED ANYWHERE\n   // buf := zone_head(); --NOT USED ANYWHERE\n   // buf := command_head(); --NOT USED ANYWHERE\n   // buf := strncmp(); --NOT USED ANYWHERE\n   // buf := check_password(); --NOT USED ANYWHERE\n   // buf := acc_total(); --NOT USED ANYWHERE\n   // buf := loglevel(); --NOT USED ANYWHERE\n   // buf := spell_levels(); --NOT USED ANYWHERE\n   // buf := spell_costs(); --NOT USED ANYWHERE\n   // buf := hasfunc(); --NOT USED ANYWHERE\n   // buf := ability_levels(); --NOT USED ANYWHERE\n   // buf := ability_costs(); --NOT USED ANYWHERE\n   // buf := weapon_levels(); --NOT USED ANYWHERE\n   // buf := weapon_costs(); --NOT USED ANYWHERE\n   // buf := skill_levels(); --NOT USED ANYWHERE\n   // buf := skill_costs(); --NOT USED ANYWHERE\n   // buf := lastroom(); --NOT USED ANYWHERE\n   // buf := unit.objs(); --NOT USED ANYWHERE\n   // buf := unit.roomcount(); --NOT USED ANYWHERE\n   // buf := unit.objcount(); --NOT USED ANYWHERE\n   // buf := unit.npccount(); --NOT USED ANYWHERE\n   // buf := unit.resetmode(); --NOT USED ANYWHERE\n   // buf := unit.loadlevel(); --NOT USED ANYWHERE\n\n   quit;\n} dilend"
}