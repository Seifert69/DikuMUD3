{
    "keyword": "capacity",
    "opcode": "DILSF_CAP",
    "yacc_rule": "| DILSF_CAP /* .capacity */\n{\n    INITEXP($$);\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_INT;\n    $$.dsl = DSL_LFT;\n    $$.num = DILF_CAP;\n}",
    "dilfe_name": "DILF_CAP",
    "c_implementation": "case DILF_CAP:\n            switch (dil_getval(v1))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n                case DILV_UP:\n                {\n                    auto *unit = reinterpret_cast<unit_data *>(v1->val.ptr);\n                    if (unit)\n                    {\n                        /* sbit16 capacity */\n                        v->atyp = DILA_NONE;\n                        v->type = DILV_SINT2R;\n                        v->ref = unit->getCapacityPtr();\n                    }\n                    else\n                    {\n                        v->type = DILV_FAIL; /* not applicable */\n                    }\n                }\n                break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n            break;",
    "dil_example": "dilbegin auction();\nvar\n        pc         : unitptr;\n        item       : unitptr;\n        bitem      : unitptr;\n        items      : unitptr;\n        bidmult    : integer;\n        firstbid   : integer;\n        bidstr     : string;\n        seller     : unitptr;\n        bidder     : unitptr;\n        raise      : integer;\n        t          : integer;\n        cont       : unitptr;\n        price      : integer;\n        l          : integer;\n        alist      : stringlist;\n        owner      : string;\n\t\tbname:string;\n\t\tsname:string;\n\t\ttemp2:string;\n\t\ttemp:string;\ncode\n{\nheartbeat:= PULSE_SEC * 10;\n  on_activation((self.position <= POSITION_SLEEPING) or\n               (self.position == POSITION_FIGHTING), skip);\n\n:start:\n\n\n  wait(SFB_CMD, (command(\"auction\") or command(\"bid\") or command(\"list\"))\nand (activator.type == UNIT_ST_PC));\n  block;\n  pc := activator;\n  secure(pc,lost);\n\nif(command(\"auction\"))\n{\n  cont := findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n   if(cont == null)\n    {\n     exec(\"say I can't take your item right now.\", self);\n     goto lost;\n    }\nif((\"platinum\" in argument) or (\"gold\" in argument) or\n   (\"silver\" in argument) or (\"copper\" in argument) or\n   (\"iron\" in argument))\n     {\n      exec(\"say What do I look like, a bank?  Items ONLY.\", self);\n      goto lost;\n     }\ntemp:=argument;\nitem:= findunit(pc, temp, FIND_UNIT_INVEN, null);\ntemp:=argument;\n    if(item == null)\n      {\n        exec(\"say You don't have anything like that, \"+pc.name+\".\", self);\n        goto lost;\n      }\n    if(item.type != UNIT_ST_OBJ)\n      {\n        exec(\"say I only auction items, pal.\", self);\n        goto lost;\n      }\nexec(\"say You're sure you want to auction off \"+item.title+\",\n\"+pc.name+\"?\", self);\nwait(SFB_DONE, (command(\"nod\") or command(\"shake\")) and (pc ==\nactivator));\npc:= activator;\n  if(command(\"shake\"))\n     {\n      exec(\"say Fine.  Make up your mind already.\", self);\n      goto lost;\n     }\n  if(command(\"nod\"))\n   {\ncont:= findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\ntemp2:=temp;\nitem:= findunit(pc,temp, FIND_UNIT_INVEN, null);\ntemp:=temp2;\n   if((cont.weight + item.weight) > cont.capacity)\n    {\n     exec(\"say Sorry, I'm out of free space in here.\", self);\n     exec(\"shrug\", self);\n     goto lost;\n    }\n      link(item, cont);\n      addstring(item.names, pc.name);\n    act(\"$1n tags the item and puts it on one of the shelves.\", A_ALWAYS,\nself, null, pc, TO_VICT);\n    act(\"$1n tags the item and puts it on one of the shelves.\", A_ALWAYS,\nself, null, pc, TO_NOTVICT);\ngoto lost;\n   }\n}\nif(command(\"bid\"))\n{\ntemp:=argument;\nbidder:= pc;\nbname:=bidder.name;\n:begin:\ncont:= findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n   if(cont == null)\n    {\n     exec(\"say I can't take your request right now.\", self);\n     goto lost;\n    }\ncont:= findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n     bitem := cont.inside;\n     while(bitem)\n     {\n       if(temp in bitem.names)\n        {\n         goto foundit;\n        }\n      bitem := (bitem.next);\n     }\n      exec(\"say I don't have anything like that up for auction.\", self);\n      goto lost;\n:foundit:\nalist:=bitem.names;\nif (bname==alist.[length(alist)-1])\n{\nexec (\"say you can't bid on something your selling \"+bname+\", please have patience I will sell it if I can.\",self);\ngoto lost;\n}\nexec(\"say You wish to bid on \"+bitem.title+\", \"+bname+\"?\", self);\n   wait(SFB_DONE, (command(\"nod\") or command(\"shake\")) and (bname\n== activator.name));\n    bidder := activator;\n\nif(command(\"shake\"))\n{\n  exec(\"say Fine then.  Come back when you know what you want to buy.\",\nself);\n  goto lost;\n}\nif(command(\"nod\"))\n{\ncont:= findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n     bitem := cont.inside;\n     while(bitem)\n     {\n       if(temp in bitem.names)\n        {\n         goto findowner;\n        }\n      bitem := (bitem.next);\n     }\n:findowner:\n      l := 0;\n      alist := bitem.names;\n      while(alist.[l] != \"\")\n       {\n        l := l + 1;\n       }\n      owner := alist.[l - 1];\n\n  seller := findunit(self, owner, FIND_UNIT_SURRO, null);\n   if(seller == null)\n    {\n     exec(\"say The one who gave me this item isn't here.  Can't do \"+\n          \"an auction without that person.\", self);\n     goto lost;\n    }\nsname:=seller.name;\n     cont := findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n     bitem := cont.inside;\n     while(bitem)\n     {\n       if(temp in bitem.names)\n        {\n         goto booty;\n        }\n      bitem := (bitem.next);\n     }\n\n:booty:\nexec(\"say \"+sname+\", how much do you wanna auction this for?  \"+\n     \"Say something like '10 silver' or '100 gold'.\", self);\n  wait(SFB_DONE, command(\"say\") and (sname == activator.name));\n    price := atoi(argument);\nif(price <= 0)\n {\n  exec(\"say Look, I don't just give this stuff away.  I need a \"+\n       \"price to start with.\", self);\n  pause;\n  goto booty;\n }\nif(\"platinum\" in argument)\n {\n  bidmult := 40960;\n  goto cont;\n }\nif(\"gold\" in argument)\n {\n  bidmult := 5120;\n  goto cont;\n }\nif(\"silver\" in argument)\n {\n  bidmult := 640;\n  goto cont;\n }\nif(\"copper\" in argument)\n {\n  bidmult := 80;\n  goto cont;\n }\nif(\"iron\" in argument)\n {\n  bidmult := 10;\n  goto cont;\n }\nexec(\"say Um, \"+itoa(price)+\" what?  Oranges?  Mumak furs?\", self);\nexec(\"sigh\", self);\ngoto booty;\n\n:cont:\nfirstbid:= price;\nbidstr:= moneystring((price*bidmult), 1);\nexec(\"emote steps up to the podium.\", self);\n     cont := findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n     bitem := cont.inside;\n     while(bitem)\n     {\n       if(temp in bitem.names)\n        {\n         goto bootsy;\n        }\n      bitem := (bitem.next);\n     }\n:bootsy:\nexec(\"say Folks, up for bidding now is this fine example of \"+bitem.title+\n     \".  The bidding will start at \"+bidstr+\".   Just NOD, folks,\"+\n     \" if you want to match the bid.\", self);\nexec(\"say \"+sname+\", you can SHAKE at any time to accept the most \"+\n     \"recent bid.\", self);\n\n:bidding:\n  wait(SFB_DONE, (command(\"nod\") or command(\"shake\")) and\n(activator.type == UNIT_ST_PC));\n  pc := activator;\nif(command(\"nod\"))\n {\n  if(activator.name == sname)\n   {\n    goto bidding;\n   }\n  bidder := pc;\n  bname := bidder.name;\n  goto match;\n }\nif(command(\"shake\"))\n {\n  if(activator.name != sname)\n   {\n    goto bidding;\n   }\n  seller := pc;\n  goto sold;\n }\ngoto bidding;\n\n:match:\nexec(\"say I hear \"+bidstr+\" from \"+bname+\".\", self);\nraise:= 5;\nprice:= (price + raise);\nbidstr:= moneystring((price*bidmult), 1);\nexec(\"say Do I hear \"+bidstr+\"?  NOD to match, folks.\", self);\ngoto bidding;\n\n:sold:\n {\n     cont := findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n     bitem := cont.inside;\n     while(bitem)\n     {\n       if(temp in bitem.names)\n        {\n         goto butsy;\n        }\n      bitem := (bitem.next);\n     }\n:butsy:\nif(price == firstbid)\n {\n  exec(\"say Sorry, \"+sname+\", but it looks like nobody wants \"+\n       \"to buy \"+bitem.title+\".\", self);\n  goto lost;\n }\nprice:= (price - raise);\nbidstr:= moneystring((price*bidmult), 1);\ntemp2:=bname;\nbidder:= findunit(self, temp2, FIND_UNIT_SURRO, null);\n  if(bidder == null)\n   {\n    exec(\"say Look at that, \"+bname+\" left.  What a jerk!\", self);\n    goto lost;\n   }\n   temp2:=sname;\nseller:= findunit(self, temp2, FIND_UNIT_SURRO, null);\n  if(seller == null)\n   {\n    exec(\"say Look at that, \"+sname+\" left.  What a jerk!\", self);\n    goto lost;\n   }\n\n  t := transfermoney(bidder, seller, (price*bidmult));\n   if(t == FALSE)\n    {\n     exec(\"say Hey, \"+bidder.name+\", you don't have enough money!  Get \"+\n          \"out of my sight!\", self);\n     goto lost;\n    }\n  exec(\"say Sold to \"+bidder.name+\" for \"+bidstr+\"!\", self);\n\n     cont := findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n     bitem := cont.inside;\n     while(bitem)\n     {\n       if(temp in bitem.names)\n        {\n         goto botsy;\n        }\n      bitem := (bitem.next);\n     }\n:botsy:\nlink(bitem, bidder);\nact(\"Roland exchanges the money and the item.\", A_ALWAYS, self, null, null,\nTO_ALL);\ngoto lost;\n}\n}\n}\n\nif(command(\"list\"))\n {\n  cont := findunit(self, \"auccont\", FIND_UNIT_SURRO, null);\n   if(cont == null)\n    {\n     exec(\"say I can't take your request right now.\", self);\n     goto lost;\n    }\nact(\"Items up for auction:\", A_ALWAYS, self, null, pc, TO_VICT);\n   items := cont.inside;\n    if(items == null)\n     {\n      act(\"Nothing.\", A_ALWAYS, self, null, pc, TO_VICT);\n      goto lost;\n     }\n    while(items)\n     {\n\t alist:=items.names;\n\t log (\"Fucking length:  \");\n\t log (itoa(length(alist)));\n      owner := alist.[length(alist)-1];\n      act(\"\"+items.title+\" (\"+owner+\")\", A_ALWAYS, self, null, pc,\nTO_VICT);\n      items := items.next;\n     }\n }\n:lost:\nunsecure(pc);\ngoto start;\n} dilend"
}