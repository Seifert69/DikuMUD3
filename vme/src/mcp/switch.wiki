= switch =
function: '''switch'''(vict : unitptr);

The '''switch''' function changes the character that a player is currently controlling.

== Description ==
This function switches the controlling character from the current player to the specified target character. The player takes control of the target character, effectively switching their perspective in the game world.

The function is commonly used for possession systems, polymorph effects, or character control mechanics. When a player switches to another character, they lose control of their current character and gain control of the target.

== Parameters ==
{| class="wikitable"
! Parameter !! Type !! Description
|-
| vict || unitptr || The target character to switch control to
|}

== Return Value ==
The function does not return a value.

== Examples ==
=== Basic Character Switch ===
 dilbegin switch_character(target : unitptr);
 var
   old_char : unitptr;
 code
 {
   if (self.type != UNIT_ST_PC)
   {
     sendtext("Only players can use this command.<br/>", self);
     quit;
   }
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext("Target must be a character.<br/>", self);
     quit;
   }
   
   old_char := self;
   
   // Perform the switch
   switch(old_char, target);
   
   sendtext("You have switched to " + target.name + ".<br/>", self);
 }
 dilend

=== Polymorph Switch ===
 dilbegin polymorph_control();
 var
   target : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext("Target must be a character.<br/>", self);
     quit;
   }
   
   // Switch to the target character
   switch(self, target);
   
   sendtext("You have polymorphed into " + target.name + ".<br/>", self);
   
   // Now control the target character
   // The player now controls the target character
 }
 dilend

=== Possession System ===
 dilbegin possession_switch();
 var
   target : unitptr;
   old_char : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext("Target must be a character.<br/>", self);
     quit;
   }
   
   old_char := self;
   
   // Switch to target character
   switch(old_char, target);
   
   sendtext("You now control " + target.name + ".<br/>", self);
   
   // Store old character reference for later restoration
   old_char.extra := {"old_character", old_char.name};
 }
 dilend

=== Animal Form Switch ===
 dilbegin animal_form_switch();
 var
   target : unitptr;
   old_char : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext("Target must be a character.<br/>", self);
     quit;
   }
   
   old_char := self;
   
   // Switch to animal form
   switch(old_char, target);
   
   sendtext("You have transformed into " + target.name + " form.<br/>", self);
 }
 dilend

=== Temporary Control Transfer ===
 dilbegin temporary_control();
 var
   target : unitptr;
   old_char : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext("Target must be a character.<br/>", self);
     quit;
   }
   
   old_char := self;
   
   // Switch to target temporarily
   switch(old_char, target);
   
   sendtext("You temporarily control " + target.name + ".<br/>", self);
   
   // Set up automatic return after delay
   pause(PULSE_SEC * 30);
   
   // Switch back to original character
   switch(target, old_char);
   
   sendtext("You have returned to your original form.<br/>", self);
 }
 dilend

=== Multiple Character Management ===
 dilbegin character_manager();
 var
   target : unitptr;
   i : integer;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext("Target must be a character.<br/>", self);
     quit;
   }
   
   // Switch through multiple characters
   i := 0;
   while (i < 5)
   {
     sendtext("Switching to character " + itoa(i) + "<br/>", self);
     switch(self, target);
     pause(PULSE_SEC * 2);
     i := i + 1;
   }
 }
 dilend

=== Safe Switch with Validation ===
 dilbegin safe_switch(target : unitptr);
 var
   old_char : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext("Target must be a character.<br/>", self);
     quit;
   }
   
   // Check if target is valid and exists
   if (target == null)
   {
     sendtext("Invalid target character.<br/>", self);
     quit;
   }
   
   old_char := self;
   
   // Perform the switch
   switch(old_char, target);
   
   sendtext("Successfully switched to " + target.name + ".<br/>", self);
 }
 dilend

=== Switch with Logging ===
 dilbegin logged_switch(target : unitptr);
 var
   old_char : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext("Target must be a character.<br/>", self);
     quit;
   }
   
   old_char := self;
   
   // Log the switch
   log("Character switch: " + old_char.name + " -> " + target.name);
   
   // Perform the switch
   switch(old_char, target);
   
   sendtext("You have switched to " + target.name + ".<br/>", self);
 }
 dilend

== Usage Notes ==
* The function can only be called by players (UNIT_ST_PC)
* The target must be a valid character (UNIT_ST_PC or UNIT_ST_NPC)
* The current player loses control of their current character
* The function does not return a value
* The switch is immediate and affects the game world state
* Common use cases include possession systems, polymorph spells, and character control mechanics

== Error Handling ==
The function handles errors in the following ways:
* Invalid caller (not a player) causes no action
* Invalid target (not a character) causes no action
* Null target causes no action
* No runtime errors are generated for valid parameters

Always validate that both the caller is a player and the target is a valid character before calling the function.

== Related Functions/Fields ==
* [[switched]] - Field to check if a character is currently switched
* unitptr.type - Field to check unit type
* unitptr.name - Field to get character name
* [[log]] - Function for logging switch operations
* [[addextra]] - Function for storing character references

== See Also ==
* DIL Character Control Systems Documentation
* Possession and Switching Mechanics
* Character State Management
* Player vs NPC Control Systems