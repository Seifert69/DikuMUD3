{
    "keyword": "skills",
    "opcode": "DILSF_SKL",
    "yacc_rule": "| DILSF_SKL idx /* .skills */\n{\n    INITEXP($$);\n    copy_code(&($$), &($2));\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_INT;\n    $$.dsl = DSL_LFT;\n    $$.num = DILF_SKL;\n    FREEEXP($2);\n}",
    "dilfe_name": "DILF_SKL",
    "c_implementation": "case DILF_SKL:\n            v2 = p->stack.pop(); /* evaluate index */\n            switch (dil_getval(v1))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n                case DILV_UP:\n                    v->type = DILV_INT;\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            switch (dil_getval(v2))\n            {\n                case DILV_FAIL:\n                    if (v->type != DILV_ERR)\n                    {\n                        v->type = DILV_FAIL; /* not applicable */\n                    }\n                    break;\n                case DILV_INT:\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            if (v->type == DILV_INT)\n            {\n                auto *pc = reinterpret_cast<pc_data *>(v1->val.ptr);\n                if (pc && pc->isPC() && is_in(v2->val.num, 0, SKI_TREE_MAX - 1))\n                {\n                    if (p->frame[0].tmpl->zone->getAccessLevel() == 0)\n                    {\n                        v->atyp = DILA_NONE;\n                        v->type = DILV_SINT2R;\n                        v->ref = pc->getSkillAtIndexPtr(v2->val.num);\n                    }\n                    else\n                    {\n                        v->atyp = DILA_NONE;\n                        v->type = DILV_INT;\n                        v->val.num = pc->getSkillAtIndex(v2->val.num);\n                    }\n                }\n                else\n                {\n                    v->type = DILV_FAIL;\n                }\n            }\n            break;",
    "dil_example": "dilbegin cuffs();\nexternal\n   integer skillresist@function(aa : integer, ad : integer,\n                             sa : integer, sd : integer);\n   cuff_target(deputy : unitptr, targ : unitptr, cuffs : unitptr);\n\nvar\n   deputy : unitptr;\n   targ   : unitptr;\n   skilla : integer;\n   skilld : integer;\n   hm     : integer;\n   depname: string;\ncode\n{\n   :loop:\n   unsecure(deputy);\n   wait(SFB_CMD, command(\"cuff\"));\n\n   if (activator != self.outside)\n     goto loop;\n\n   deputy := activator;\n   secure(deputy, loop);\n\n   block;\n\n   if ((deputy.type == UNIT_ST_PC) and (deputy.skills[SKI_CUFF] <= 0))\n   {\n      act(\"You must practice first.\",\n\t  A_ALWAYS, deputy, null, null, TO_CHAR);\n      goto loop;\n   }\n\n   if (argument == \"\")\n   {\n      act(\"Cuff who?\",\n\t  A_SOMEONE, deputy, null, null, TO_CHAR);\n      goto loop;\n   }\n\n   targ := findunit(deputy, argument, FIND_UNIT_SURRO, null);\n\n   if (targ == null)\n   {\n      act(\"That person is not here!\",\n          A_SOMEONE, deputy, null, null, TO_CHAR);\n      goto loop;\n   }\n\n   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))\n   {\n      act(\"You can't cuff that, silly!\", A_SOMEONE, deputy, null, null,\n\t  TO_CHAR);\n      goto loop;\n   }\n\n   if (targ == deputy)\n   {\n      act(\"Cuffing yourself seems like a bad idea.\",\n          A_HIDEINV, deputy, null, null, TO_CHAR);\n      goto loop;\n   }\n\n   if (not isset(targ.charflags, CHAR_OUTLAW))\n   {\n      act(\"$3n is not wanted.\",\n\t  A_HIDEINV, deputy, null, targ, TO_CHAR);\n      goto loop;\n   }\n\n\n   if (deputy.type == UNIT_ST_PC)\n     skilla := deputy.skills[SKI_CUFF];\n   else\n     skilla := deputy.abilities[ABIL_DEX];\n\n   if (targ.type == UNIT_ST_PC)\n     skilld := targ.skills[SKI_CUFF];\n   else\n     skilld := targ.abilities[ABIL_DEX];\n\n   secure(targ, loop);\n\n   hm := skillresist@function(deputy.abilities[ABIL_DEX],\n\t\t     targ.abilities[ABIL_DEX],\n\t\t     skilla, skilld);\n   if (hm < 0)\n   {\n      act(\"Your attempt at cuffing $3n fails miserably.\",\n\t  A_SOMEONE, deputy, null, targ, TO_CHAR);\n      act(\"$1n attempts to cuff you but fails miserably.\",\n\t  A_SOMEONE, deputy, null, targ, TO_VICT);\n      act(\"$1n attempts to cuff $3n but fails miserably.\",\n\t  A_SOMEONE, deputy, self, targ, TO_NOTVICT);\n      link(self, targ);\n      goto loop;\n   }\n\n   cuff_target(activator, targ, self);\n   /* targ is secured, when broken we reset to loop */\n\n   :cuffed:\n   wait(SFB_CMD, self.equip != WEAR_WRIST_R);\n   // Cuffs are no longer on the wrist, start over\n   goto loop;\n} dilend"
}