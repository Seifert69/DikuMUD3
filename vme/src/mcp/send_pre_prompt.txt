Generate MCP entry for DIL keyword: send_pre

=== Yacc rule ===
| DILSE_SENDPRE '(' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ')'
{
    INITEXP($$);

    if ($3.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 1 of 'send_pre' not a string");
    }
    else if ($5.typ != DilVarType_e::DILV_NULL && $5.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 2 of 'send_pre' not an unit pointer");
    }
    else if ($7.typ != DilVarType_e::DILV_NULL && $7.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 3 of 'send_pre' not an unit pointer");
    }
    else if ($9.typ != DilVarType_e::DILV_NULL && $9.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 4 of 'send_pre' not an unit pointer");
    }
    else if ($11.typ != DilVarType_e::DILV_INT)
    {
        dilfatal("Arg 5 of 'send_pre' not an integer");
    }
    else if ($13.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 6 of 'send_pre' not a string");
    }
    else if ($15.typ != DilVarType_e::DILV_NULL && $15.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 7 of 'send_pre' not an unit pointer");
    }
    else
    {
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_INT;
        make_code(&($3));
        make_code(&($5));
        make_code(&($7));
        make_code(&($9));
        make_code(&($11));
        make_code(&($13));
        make_code(&($15));
        add_code(&($$), &($3));
        add_code(&($$), &($5));
        add_code(&($$), &($7));
        add_code(&($$), &($9));
        add_code(&($$), &($11));
        add_code(&($$), &($13));
        add_code(&($$), &($15));
        add_ubit8(&($$), DILE_SENDPRE);
    }
    FREEEXP($3);
    FREEEXP($5);
    FREEEXP($7);
    FREEEXP($9);
    FREEEXP($13);
    FREEEXP($15);
}

=== C implementation ===
void dilfe_sendpre(dilprg *p)
{
    dilval *v = new dilval;
    command_info *cmd = nullptr;
    dilval *v7 = p->stack.pop();
    dilval *v6 = p->stack.pop();
    dilval *v5 = p->stack.pop();
    dilval *v4 = p->stack.pop();
    dilval *v3 = p->stack.pop();
    dilval *v2 = p->stack.pop();
    dilval *v1 = p->stack.pop();

    v->type = DILV_INT;

    switch (dil_getval(v1))
    {
        case DILV_SP:
            switch (dil_getval(v2))
            {
                case DILV_UP:
                case DILV_NULL:
                    switch (dil_getval(v3))
                    {
                        case DILV_UP:
                        case DILV_NULL:
                            switch (dil_getval(v4))
                            {
                                case DILV_UP:
                                case DILV_NULL:
                                    switch (dil_getval(v5))
                                    {
                                        case DILV_INT:
                                            switch (dil_getval(v6))
                                            {
                                                case DILV_SP:
                                                    switch (dil_getval(v7))
                                                    {
                                                        case DILV_UP:
                                                        case DILV_NULL:
                                                            cmd = ((command_info *)search_trie((char *)v1->val.ptr, g_intr_trie));
                                                            if (!cmd)
                                                            {
                                                                szonelog(p->sarg->owner->getFileIndex()->getZone(),
                                                                         "DIL %s, : Can not send_preprocess. No such command %s\n",
                                                                         p->sarg->owner->getFileIndexSymName(),
                                                                         (char *)v1->val.ptr);
                                                                v->type = DILV_FAIL;
                                                            }
                                                            else
                                                            {
                                                                v->val.num = send_ack((unit_data *)v2->val.ptr,
                                                                                      (unit_data *)v3->val.ptr,
                                                                                      (unit_data *)v4->val.ptr,
                                                                                      &(v5->val.num),
                                                                                      cmd,
                                                                                      (const char *)v6->val.ptr,
                                                                                      (unit_data *)v7->val.ptr);
                                                            }
                                                            break;
                                                        default:
                                                            v->type = DILV_FAIL;
                                                            break;
                                                    }

                                                    break;
                                                default:
                                                    v->type = DILV_FAIL;
                                                    break;
                                            }
                                            break;
                                        default:
                                            v->type = DILV_FAIL;
                                            break;
                                    }

                                    break;
                                default:
                                    v->type = DILV_FAIL;
                                    break;
                            }

                            break;
                        default:
                            v->type = DILV_FAIL;
                            break;
                    }
                    break;
                default:
                    v->type = DILV_FAIL;
                    break;
            }

            break;
        default:
            v->type = DILV_FAIL;
            break;
    }
    p->stack.push(v);
    delete v1;
    delete v2;
    delete v3;
    delete v4;
    delete v5;
    delete v6;
    delete v7;
}

=== DIL example ===
dilbegin climb_dil(arg : string);
external
   checkstand();
   integer checkexit(arg : string, bMessage:integer);
   string  dirstring@function(int123 : integer);
   integer is_hidden(unit2 : unitptr, int1 : integer, unit23 : unitptr);
   integer skillchecksa@skills(skillidx : integer, abiidx : integer, difficulty : integer);
   string exitname@function(room:unitptr, dir:integer);
   fall_dil(damage:integer);
   look_blank@baselook(l1 : unitptr, str12 : string);

var
   fall_to:string;
   res:integer;
   args:stringlist;
   first_arg:string;
   last_arg:string;
   len_arg:integer;
   in_vehicle:integer;
   dir         :  integer;
   send_dir         :string; 
   dir_name:string;
   room:unitptr;
   room_going:unitptr;
   i:integer;
   skilla:integer;
   skillb:integer;
   hm : integer; 
   difficulty:integer;
   damage:integer;
   amount:integer;
   percent:integer;
   exd : extraptr;
   dmg : integer;
   exit_name : string;
   
code
{
   heartbeat := PULSE_SEC * 5;
   checkstand();

   if (self.endurance < 10)
   {
      act("You are too exhausted.", A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   if (arg == "")
   {
      act("Climb what?", A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   room := self.outside;
   if (room.type != UNIT_ST_ROOM)
   {
      act("You can't climb while inside $2n.", A_SOMEONE, self, room, null, TO_CHAR);
      return;      
   }

   dir := checkexit(arg, 1);
   dir_name := dirstring@function(dir);
   exit_name := exitname@function(room, dir);

   if (isset(room.exit_info[dir], EX_CLOSED))
   {
      act("The $2t seems to be closed.", A_SOMEONE, self, exit_name, null, TO_CHAR);
      return;
   }

   if (not isset(room.exit_info[dir], EX_CLIMB))
   {
      act("Doesn't seem like you have to climb the $2t, perhaps just try to move normally?", A_SOMEONE, self, exit_name, null, TO_CHAR);
      return;
   }

   /*
   * test for success and fail including endurance loss
   *	including drunk code
   */	

   room_going := room.exit_to[dir];
   difficulty := room.exit_diff[dir];

   if (self.drunk > 0)
   {
      difficulty := difficulty + 5 * self.drunk;
      act("Climbing under influence isn't easy.", A_SOMEONE, self, null, null, TO_CHAR);
   }

   hm := skillchecksa@skills(SKI_CLIMB, ABIL_DEX, difficulty);
   dmg := 5; /* Default: 5 hits per 10 fail */

   exd := room.extra.["$climb_"+dir_name];
   if (exd != null)
   {
      if (exd.vals != null)
      {
         dmg := exd.vals.[0];
      }
   }

   self.endurance := self.endurance-6;

   if (hm <= 0)
   {
      dmg := dmg * (-hm / 10);

      act("You begin climbing the $2t but slip and fall.",	A_ALWAYS, self, exit_name, null, TO_CHAR);
      act("$1n begins climbing the $2t but slips and falls.", A_HIDEINV, self, exit_name, null, TO_ROOM);
      dilcopy("fall_dil@basemove("+itoa(dmg)+")", self);
      quit;
   }

   /* Issue the command() stuff so that all movers send the command "north" etc to the mud.
   //                        sendtext("after endurance test<br/>",self);
   *   This is necessary for dils like the guard dil.
   */

   res := send_pre(dirstring@function(dir), self, null, null, 0, arg, null);
   if (res != SFR_SHARE)
      quit;

   res := send_pre("climb", self, null, null, 0, arg, null);
   if (res != SFR_SHARE)
      quit;

   link(self, room_going);

   act("$1n climbs in on the $2t.", A_HIDEINV, self, arg , null, TO_ROOM);

   look_blank@baselook(self, ":brief:");   /* get the rooms contents.  The :brief: tells the look dil*/

   send_done("climb", self, null, null, 0, "", null, CMD_AUTO_NONE);
   send_done(dirstring@function(dir), self, null, null, 0, "", null, CMD_AUTO_NONE);
   quit;
} dilend
