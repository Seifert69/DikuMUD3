{
    "keyword": "flog",
    "opcode": "DILSE_FLOG",
    "yacc_rule": "| DILSE_FLOG '(' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    if ($3.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 1 of 'flog' not string\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 2 of 'flog' not string\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 3 of 'flog' not string\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_ubit8(&($$), DILE_FLOG);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n}",
    "dilfe_name": "dilfe_flog",
    "c_implementation": "void dilfe_flog(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n    char *sstr = nullptr;\n    char filename[255];\n\n    v->type = DILV_INT;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_SP:\n            switch (dil_getval(v2))\n            {\n                case DILV_SP:\n                    switch (dil_getval(v3))\n                    {\n                        case DILV_SP:\n                            if (p->frame[0].tmpl->zone->getAccessLevel() > 1)\n                            {\n                                szonelog(p->frame->tmpl->zone, \"DIL '%s' attempt to access logs w/o access.\", p->frame->tmpl->prgname);\n                                p->waitcmd = WAITCMD_QUIT;\n                            }\n                            else\n                            {\n                                strcpy(filename, g_cServerConfig.getLogDir().c_str());\n                                strcat(filename, (char *)v1->val.ptr);\n                                sstr = str_dup((char *)v2->val.ptr);\n                                v->val.num = save_string(filename, &sstr, (char *)v3->val.ptr);\n                                FREE(sstr);\n                            }\n                            break;\n                        case DILV_FAIL:\n                        case DILV_NULL:\n                            v->type = DILV_FAIL;\n                            break;\n                        default:\n                            v->type = DILV_ERR;\n                            break;\n                    }\n\n                    break;\n                case DILV_FAIL:\n                case DILV_NULL:\n                    v->type = DILV_FAIL;\n                    break;\n                default:\n                    v->type = DILV_ERR;\n                    break;\n            }\n\n            break;\n        case DILV_FAIL:\n        case DILV_NULL:\n            v->type = DILV_FAIL;\n            break;\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n}",
    "dil_example": "dilbegin aware cmd_bugs(st : string);\nvar\n   t : string;\n   z : unitptr;\n   i : integer;\ncode\n{\n   if (self.type!=UNIT_ST_PC)\n      return;\n   sendtext(\"Enter your bug reports. You have approximately 4000 \"+\n            \"characters to work with. Note that if you input only a \"+\n            \"single word or nothing at all, it will abort.<br/>\", self);\n   beginedit(self);\n   wait(SFB_EDIT, self == activator);\n   t := argument;\n   if (length(getwords(t)) < 2)\n   {\n      sendtext(\"Insufficient report. Exiting.<br/>\", self);\n      quit;\n   }\n   z := self.outside;\n   while (z.type != UNIT_ST_ROOM)\n      z := z.outside;\n   t := z.symname + \" [\"+self.name+\"] \" + asctime(realtime)+ argument;\n   t := textformat(t);\n   i := flog(\"bugs\", t, \"a\");\n   sendtext(\"Thank you. They will be corrected.<br/>\", self);\n   dispatch(\"discord msg #bugs @\" + self.name + \" bug report: \" + t); // Send to dispatcher.py via pipeDispatcher\n\n   quit;\n} dilend"
}