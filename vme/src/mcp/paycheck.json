{
    "keyword": "paycheck",
    "opcode": "DILSE_PCK",
    "yacc_rule": "| DILSE_PCK '(' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    $$.boolean = 1;\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'paycheck' not a unitptr\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 2 of 'paycheck' not a unitptr\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n        make_code(&($3));\n        make_code(&($5));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_ubit8(&($$), DILE_PCK);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n}",
    "dilfe_name": "dilfe_pck",
    "c_implementation": "void dilfe_pck(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    v->type = DILV_INT;\n\n    // Don't evaluate in case accounting is off. Evaluating might fail\n    // and lead to undesired results.\n    if (g_cServerConfig.isAccounting() == false)\n    {\n        v->val.num = 1;\n    }\n    else\n    {\n        switch (dil_getval(v1))\n        {\n            case DILV_FAIL:\n            case DILV_NULL:\n                v->type = DILV_FAIL;\n                break;\n            case DILV_UP:\n                if (!v1->val.ptr || !((unit_data *)v1->val.ptr)->isChar())\n                {\n                    v->type = DILV_FAIL;\n                }\n                else\n                {\n                    switch (dil_getval(v2))\n                    {\n                        case DILV_FAIL:\n                        case DILV_NULL:\n                            v->type = DILV_FAIL;\n                            break;\n                        case DILV_UP:\n                            if (!v2->val.ptr)\n                            {\n                                v->type = DILV_FAIL;\n                            }\n                            else\n                            {\n                                v->val.num = pay_point_charlie((unit_data *)v1->val.ptr, (unit_data *)v2->val.ptr);\n                            }\n                            break;\n                        default:\n                            v->type = DILV_ERR;\n                            break;\n                    }\n                }\n\n                break;\n            default:\n                v->type = DILV_ERR;\n                break;\n        }\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n}",
    "dil_example": "dilbegin self_walk(mover : unitptr, direc : integer, arg : string, follows : integer);\nexternal\n   look_blank@baselook(l1 : unitptr, str12 : string);\n   move_follower(u3 : unitptr, d3 : integer, u4 : unitptr, arg34 : string);\n   unitptr unit_room@function(unit1 : unitptr);\n   integer is_hidden(unit2 : unitptr, int1 : integer, room2 : unitptr);\n   integer movementloss(int2 : integer);\n   show_lv_walk(unit5 : unitptr, int5 : integer, room5 : unitptr);\n   show_ar_walk(unit6 : unitptr, int6 : integer, room6 : unitptr);\n   string  dirstring@function(int123 : integer);\n   integer issetclimb@function(d:integer);\n\nvar\n   room_in               :  unitptr;\n   room_going            :  unitptr;\n   pc_fol                :  unitptr;\n   old_pc                :  unitptr;\n   mu                    :  unitptr;\n   exit_hidden           :  integer;\n   exit_descr            :  extraptr;\n   dirlist               :  stringlist;\n   opplist               :  stringlist;\n   test                  :  integer;\n   end_need              :  integer;\n   text                  :  string;\n   res                   :  integer;\n\ncode\n{\n   room_in :=unit_room@function(mover);\n\n   /* Issue the command() stuff so that all movers send the command \"north\" etc to the mud.\n      This is necessary for dils like the guard dil. */\n\n   text := dirstring@function(direc);\n\n   if (follows)\n      res := send_pre(text, mover, null, null, 0, arg, null);\n   else\n      res := SFR_SHARE;\n\n   room_going := unit_room@function(mover);    /* This will be redefined, just want to use it to save creating another var*/\n\n   if ((res != SFR_SHARE) or (room_in != room_going))\n      return;\n\n   if (not room_in.exit_to[direc])\n   {\n      act(\"Alas, you cannot go that way...\", A_SOMEONE, mover, null, null, TO_CHAR);\n      return;\n   }\n\n   test := is_hidden(mover, direc, room_in);\n   if ((isset(room_in.exit_info[direc], EX_CLOSED)) and (test))\n   {\n      act(\"Alas, you cannot go that way...\", A_SOMEONE, mover, null, null, TO_CHAR);\n      return;\n   }\n\n   if (isset(room_in.exit_info[direc], EX_CLOSED))\n   {\n      act(\"The $2t seems to be closed.\", A_SOMEONE, mover, room_in.exit_names[direc].[0], null, TO_CHAR);\n      return;\n   }\n\n   if (issetclimb@function(direc))\n   {\n      act(\"Alas, you must climb to go that way.\", A_SOMEONE, mover, null, null, TO_CHAR);\n      return;\n   }\n\n   room_going := room_in.exit_to[direc];\n\n   if ((not(paycheck(mover, room_going))) and (mover.level < IMMORTAL_LEVEL))\n      return;\n\n  /* Swimming Code : We are finally going to allow players to use that 100% swimming skill.\n     every movement will cost 50 points of endurance (unless the IS_FISH_NAME extra is found, then it is 1)\n     and also there will be a skill check to determine if there is drowning damage. If\n \t  it can use water or land it will use the is-amphib extra Darg added */\n\n   if ((room_going.movement == SECT_WATER_SAIL) or (room_in.movement == SECT_WATER_SAIL))\n   {\n      if ((not mover.extra.[SWIM_ON_NAME]) and ((not mover.extra.[IS_FISH_NAME]) or (not mover.extra.[IS_AMPHIB_NAME])))\n      {\n         act(\"You might want to swim or get a boat.\", A_ALWAYS, mover, null, null, TO_CHAR);\n         return;\n      }\n      \n    if ((mover.type == UNIT_ST_NPC) and (mover.race >=RACE_ARTHROPODA_MIN) and (mover.race <=RACE_ARTHROPODA_MAX))\n\t   goto insect;\n\n    if ((mover.type == UNIT_ST_NPC) and (mover.extra.[IS_FISH_NAME]))\n\t   goto fish;\n\n\tif ((mover.type == UNIT_ST_NPC) and (mover.extra.[IS_AMPHIB_NAME]))\n\t   goto amphib;\n\n\n    if (mover.type == UNIT_ST_PC)\n       test := openroll(5,100) + mover.skills[SKI_SWIMMING] + mover.abilities[ABIL_CON] - 100;\n\n    else\n       test := openroll(5,100) + mover.abilities[ABIL_CON] + mover.abilities[ABIL_DEX] - 100;\n\n    if (test < 0)\n       {act (\"As you try to swim, you flounder and take in water!\", A_ALWAYS, mover, null, null, TO_CHAR);\n        act (\"$1n tries to swim, but flounders and takes in water!\", A_ALWAYS, mover, null, null, TO_REST);\n        mover.hp := mover.hp - rnd(10,50);\n        position_update(mover);\n        return;\n       }\n   }\nelse if (mover.extra.[IS_FISH_NAME])   /* If the mover is a fish, then we dont want them walking on land */\n     return;\n\n\nend_need := movementloss(room_in.movement);\ntest := movementloss(room_going.movement);\n\nend_need := (end_need + test) / 2;\n\nif ((mover.extra.[IS_FISH_NAME]) and (end_need > 1))\n   end_need := 1;\n\nif ((mover.endurance - end_need < 0) and (not follows))\n   {act(\"You are too exhausted to move.\", A_SOMEONE, mover, null, null, TO_CHAR);\n    return;\n   }\nelse if (mover.endurance - end_need < 0)\n   {act(\"You are too exhausted to follow.\", A_SOMEONE, mover, null, null, TO_CHAR);\n    return;\n   }\n/* MS2020 MOVED THIS TO ENTANGLED_2 darg added to block movement while entangled \n if ((mover.type == UNIT_ST_PC)and (dilfind (\"entangled@spells\", mover)) and (follows))\n   {\n   act(\"The vines prevent you from moving you best inform your group!\", A_ALWAYS, mover, null, null, TO_CHAR);\n  return;\n       } */\n\n\n:amphib:\n    if ((mover.race >=RACE_ARTHROPODA_MIN)\n\tand (mover.race <=RACE_ARTHROPODA_MAX))\n{\n if (mover.endurance <= 10)\n { mover.endurance := mover.max_endurance;\n   position_update(mover);\n }\n  mover.endurance := mover.endurance - rnd(1,5);\n  position_update(mover);\n}\n\n:insect:\nif (mover.extra.[IS_AMPHIB_NAME])\n{\n if (mover.endurance <= 10)\n { mover.endurance := mover.max_endurance;\n   position_update(mover);\n }\n  mover.endurance := mover.endurance - rnd(1,5);\n  position_update(mover);\n}\n\n:fish:\n/* OK, the person can move, so we now do the movement and check for followers. */\n\ndirlist := {\"north\",\"east\",\"south\",\"west\",\"up\",\"down\",\n            \"northeast\", \"northwest\",\"southeast\",\"southwest\"};\n\n\n\nif (follows)\n  act(\"You follow $2n.\", A_ALWAYS, mover, mover.master, null, TO_CHAR);\n\nshow_lv_walk(mover, direc, room_in);    /* Show the leaving acts */\n\nif (mover.level < IMMORTAL_LEVEL)                      /* If not an immortal */\n      mover.endurance := mover.endurance - end_need;   /* drain endurance and do the move */\n\nlink(mover, room_going);\n\nshow_ar_walk(mover, direc, room_going);   /* show arrival acts */\n\nlook_blank@baselook(mover, \":brief:\");   /* get the rooms contents.  The :brief: tells the look dil*/\n                                  /* to check the player for PC_BRIEF flag */\n\nif (room_going == room_in)             /* This is here to keep infinite loops from happening when rooms */\n   return;                             /* link back on themselves */\n\n\nsend_done (dirlist.[direc], mover, null, null, 0, \"\", null, CMD_AUTO_NONE);\n\n/* Using the new getfollower and followercount, we have replaced the cumbersome\n   code with a sleek coding that should be much faster.\n*/\n\ntext := dirstring@function(direc);\n\nif (mover.followercount > 0)                    /* If mover has followers, then check the room for them*/\n    move_follower(mover, direc, room_in, arg);\n\nreturn;\n\n} dilend"
}