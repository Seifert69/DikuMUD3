{
    "keyword": "return",
    "opcode": "DILSI_RTS",
    "yacc_rule": "| DILSI_RTS ihold\n{\n    if (!dilistemplate)\n    {\n        dilfatal(\"return only allowed in templates\");\n    }\n    if (tmpl.rtnt != DilVarType_e::DILV_ERR)\n    {\n        dilfatal(\"no return expression expected\");\n    }\n\n    /* WAS: bwrite_ubit8(&wcore,DILI_RTS); */ /* the instruction */\n\n    wtmp = &tmpl.core[$2];\n    bwrite_ubit8(&wtmp, DILI_RTS); /* the instruction */\n\n    $$.fst = $2;\n    $$.lst = $2 + 1;\n}\n\n------\n\n| DILSI_RTS '(' coreexp ')' ihold\n{\n    if (!dilistemplate)\n    {\n        dilfatal(\"return only allowed in templates\");\n    }\n    if (tmpl.rtnt != $3.typ)\n    {\n        dilfatal(\"return expression not of correct type\");\n    }\n    wtmp = &tmpl.core[$5];\n    bwrite_ubit8(&wtmp, DILI_RTF); /* the instruction */\n    $$.fst = $3.fst;\n    $$.lst = $5 + 1;\n}",
    "dilfe_name": "dilfi_rtf",
    "c_implementation": "void dilfi_rtf(dilprg *p)\n{\n    p->waitcmd--;\n\n    if (p->fp == p->frame)\n    {\n        /* just stop execution, never discard last frame! */\n        p->waitcmd = WAITCMD_QUIT;\n        return;\n    }\n\n    // When rtnt == DILV_ERR then it's returning from a procedure, otherwise a function\n    if (p->fp->tmpl->rtnt == DILV_ERR)\n    {\n        if (p->stack.length() != p->fp->stacklen)\n        {\n            slog(LOG_ALL,\n                 0,\n                 \"DIL %s@%s on %s: DILV_ERR Unexpected stack length after procedure call.\",\n                 p->fp->tmpl->prgname,\n                 p->fp->tmpl->zone->getName(),\n                 p->sarg->owner->getFileIndexSymName());\n            p->waitcmd = WAITCMD_QUIT;\n            return;\n        }\n    }\n    else\n    {\n        // The 'return' statement has placed a variable on the stack, so\n        // let's get it and make it a copy on the stack\n        if (p->stack.length() != p->fp->stacklen + 1)  // +1 for the return statement variable\n        {\n            slog(LOG_ALL,\n                 0,\n                 \"DIL %s@%s on %s: Unexpected stack length after function call.\",\n                 p->fp->tmpl->prgname,\n                 p->fp->tmpl->zone->getName(),\n                 p->sarg->owner->getFileIndexSymName());\n            p->waitcmd = WAITCMD_QUIT;\n            return;\n        }\n\n        dilval *v1 = p->stack.pop();\n\n        ubit8 typ = dil_getval(v1);\n        if (typ != p->fp->tmpl->rtnt)\n        {\n            slog(LOG_ALL, 0, \"DIL: Error return types do not match.\");\n            p->waitcmd = WAITCMD_QUIT;\n            delete v1;\n            return;\n        }\n\n        dilval *v = new dilval;\n\n        switch (typ)\n        {\n            case DILV_UP:\n                v->type = DILV_UP;\n                v->atyp = DILA_NORM;\n                v->val.ptr = (unit_data *)v1->val.ptr;\n                break;\n\n            case DILV_SP:\n                v->type = DILV_SP;\n                v->atyp = DILA_EXP;\n                v->val.ptr = str_dup((char *)v1->val.ptr);\n                break;\n\n            case DILV_SLP:\n                v->type = DILV_SLP;\n                v->atyp = DILA_EXP;\n                v->val.ptr = ((cNamelist *)v1->val.ptr)->Duplicate();\n                break;\n\n            case DILV_ILP:\n                v->type = DILV_ILP;\n                v->atyp = DILA_EXP;\n                v->val.ptr = ((cintlist *)v1->val.ptr)->Duplicate();\n                break;\n\n            case DILV_EDP:\n                v->type = DILV_EDP;\n                v->atyp = DILA_NORM;\n                v->val.ptr = (extra_descr_data *)v1->val.ptr;\n                break;\n\n            case DILV_ZP:\n                v->type = DILV_ZP;\n                v->atyp = DILA_NORM;\n                v->val.ptr = (zone_type *)v1->val.ptr;\n                break;\n\n            case DILV_CP:\n                v->type = DILV_CP;\n                v->atyp = DILA_NORM;\n                v->val.ptr = (command_info *)v1->val.ptr;\n                break;\n\n            case DILV_INT:\n                v->type = DILV_INT;\n                v->atyp = DILA_NONE;\n                v->val.num = v1->val.num;\n                break;\n\n            default:\n                v->type = DILV_ERR;\n                dil_typeerr(p, \"function call evaltuated to failed result.\");\n                break;\n        }\n        delete v1;\n\n        // Push the copied return value so that it can be assigned\n        p->stack.push(v);\n    }\n\n    bool doSecureTest = p->fp->wasSecureTested;\n\n    // Pop and free the current frame, change fp to the new frame\n    int i = p->fp - p->frame - 1;\n    dilframe *cfrm = p->fp;\n    p->fp = &p->frame[i];\n    dil_free_frame(cfrm);\n\n    // Now we've arrived at the new frame (the old frame returning from was removed)\n    // Let's see if we need to do a trickle secure() test and possibly change execution point\n    //\n    if (doSecureTest)\n    {\n        if (dil_test_secure(p) == true)\n        {\n            // We changed the point of execution. This could be in the middle of an assignment.\n            // If it was in an assignment for example, then the stack will be wrong with two\n            // stack entries. If for example a function call without assignment, stack will be\n            // wrong with 1 stack entry. This will fix the stack according to the secure \n            // changing point of execution\n            //\n            while (p->stack.length() != p->fp->stacklen)\n            {\n                if (p->stack.length() <= 0)\n                {\n                    slog(LOG_ALL, 0, \"TERRIBLE STACK ERROR DIL %s\", p->fp->tmpl->prgname);\n                    p->waitcmd = WAITCMD_QUIT;\n                    return;\n                }\n\n                delete(p->stack.pop());\n            }\n        }\n    }\n}",
    "dil_example": "dilbegin cuff_target(deputy : unitptr, targ : unitptr, cuffs : unitptr);\nvar\n   depname: string;\n\ncode\n{\n   act(\"You cuff $3n.\", A_SOMEONE, deputy, null, targ, TO_CHAR);\n   act(\"$1n surprises you and put $2n around your wrists.\", A_SOMEONE, deputy, cuffs, targ, TO_VICT);\n   act(\"$1n puts $2n around $3N's wrists.\", A_SOMEONE, deputy, cuffs, targ, TO_NOTVICT);\n\n   follow(targ, deputy);\n   depname := deputy.name;\n   link(cuffs, targ);\n   unequip(equipment(targ, WEAR_WRIST_R));\n   addequip(cuffs, WEAR_WRIST_R);\n   dilcopy(\"cuffed@midgaard(\"+depname+\")\", targ);\n   dilcopy(\"cuffed2@midgaard(\"+depname+\")\", targ);\n\n   exec(\"sigh\", targ); /* Do this to activate the DILs */\n   return;\n} dilend"
}