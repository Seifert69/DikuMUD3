{
    "keyword": "meleeattack",
    "opcode": "DILSE_MEL",
    "yacc_rule": "| DILSE_MEL '(' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    checkbool(\"argument 1 of MeleeAttack\", $3.boolean);\n\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'MeleeAttack' not a unitptr\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 2 of 'MeleeAttack' not a unitptr\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 3 of 'MeleeAttack' not an integer\");\n    }\n    else if ($9.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 4 of 'MeleeAttack' not an integer\");\n    }\n    else if ($11.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 5 of 'MeleeAttack' not an integer\"); // added 'primary' variable to check if we should use offhand or not\n    }\n\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        make_code(&($9));\n        make_code(&($11));\n\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_code(&($$), &($9));\n        add_code(&($$), &($11));\n        add_ubit8(&($$), DILE_MEL);\n    }\n\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n    FREEEXP($9);\n    FREEEXP($11);\n}",
    "dilfe_name": "dilfe_mel",
    "c_implementation": "void dilfe_mel(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v5 = p->stack.pop();\n    dilval *v4 = p->stack.pop();\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    v->type = DILV_INT;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_UP:\n            if (!v1->val.ptr || !((unit_data *)v1->val.ptr)->isChar())\n            {\n                v->type = DILV_FAIL;\n            }\n            else\n            {\n                switch (dil_getval(v2))\n                {\n                    case DILV_UP:\n                        if (!v2->val.ptr || !((unit_data *)v2->val.ptr)->isChar())\n                        {\n                            v->type = DILV_FAIL;\n                        }\n                        else\n                        {\n                            switch (dil_getval(v3))\n                            {\n                                case DILV_INT:\n                                    switch (dil_getval(v4))\n                                    {\n                                        case DILV_INT:\n\t\t\t\t\t\tswitch (dil_getval(v5)) // added new option to deal with primary vs secondary weapon\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DILV_INT:\n\t\t\t\t\t\t\t\tv->val.num = one_hit((unit_data *)v1->val.ptr,\n                                                                (unit_data *)v2->val.ptr,\n                                                                v3->val.num,\n                                                                v4->val.num,\n                                                                v5->val.num,\n                                                                TRUE);\n\t\t\t\t\t\t\t\tdil_test_secure(p);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tv->type = DILV_ERR;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n                                            break;\n                                        default:\n                                            v->type = DILV_ERR;\n                                            break;\n                                    }\n\n                                    break;\n                                default:\n                                    v->type = DILV_ERR;\n                                    break;\n                            }\n                        }\n\n                        break;\n                    case DILV_FAIL:\n                    case DILV_NULL:\n                        v->type = DILV_FAIL;\n                        break;\n                    default:\n                        v->type = DILV_ERR;\n                        break;\n                }\n            }\n\n            break;\n        case DILV_FAIL:\n        case DILV_NULL:\n            v->type = DILV_FAIL;\n            break;\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n    delete v4;\n    delete v5;\n}",
    "dil_example": "dilbegin spider();\nvar\n   u : unitptr;\n   i : integer;\n\ncode\n{\n   heartbeat := PULSE_SEC*5;\n   on_activation((self.position <= POSITION_SLEEPING) or\n\t\t (self.position == POSITION_FIGHTING), skip);\n\n   :loop:\n   wait(SFB_MSG, argument == \"webaction\");\n\n   if (self.outside.nameidx != \"on_web\")\n     goto loop;\n\n   act(\"$1n jumps down through the web to prey on a victim.\",\n       A_HIDEINV, self, null, null, TO_ROOM);\n\n   link(self, findroom(\"under_web@haon_dor\"));\n   /* Now find the victim */\n   foreach (UNIT_ST_PC|UNIT_ST_NPC, u)\n   {\n      if ((u.nameidx != \"spider\") and\n          (u.nameidx != \"queen_spider\"))\n      {\n\t act(\"$1n drops down on $3n from the web above!\",\n\t     A_SOMEONE, self, null, u, TO_NOTVICT);\n\t act(\"$1n drops down on you from the web above!\",\n\t     A_SOMEONE, self , null, u, TO_VICT);\n\n\t i := cast_spell(SPL_POISON, self, self, u, \"\");\n\t i := cast_spell(SPL_POISON, self, self, u, \"\");\n\t i := meleeattack(self, u, +75, WPN_BITE,TRUE);\n\t goto done;\n      }\n   }\n\n   :done:\n\twhile (self.position == POSITION_FIGHTING) pause;\n   pause;\n\n   /* This could be a fun extension: If the spider survives, let it look\n      for a corpse (foreach) and put web all around it. It then moves the\n      \"encased\" corpse into the den of the queen (and the corpse \"rot\"\n      is removed too (subaff)). */\n\n   if (self.position < POSITION_STANDING)\n   {\n      exec(\"stand\", self);\n      pause;\n   }\n\n   exec (\"u\", self);\n\n   goto loop;\n} dilend"
}