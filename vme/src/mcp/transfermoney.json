{
    "keyword": "transfermoney",
    "opcode": "DILSE_TRMO",
    "yacc_rule": "| DILSE_TRMO '(' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n\n    if (($3.typ != DilVarType_e::DILV_UP) && ($3.typ != DilVarType_e::DILV_NULL))\n    {\n        dilfatal(\"Arg 1 of 'transfermoney' not a unitptr\");\n    }\n    else if (($5.typ != DilVarType_e::DILV_UP) && ($5.typ != DilVarType_e::DILV_NULL))\n    {\n        dilfatal(\"Arg 2 of 'transfermoney' not a unitptr\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 3 of 'transfermoney' not an integer\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_ubit8(&($$), DILE_TRMO);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n}",
    "dilfe_name": "dilfe_trmo",
    "c_implementation": "void dilfe_trmo(dilprg *p)\n{\n    dilval *v = new dilval;\n    char buf[1024];\n    int i = 0;\n    buf[0] = 0;\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    v->type = DILV_INT;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_FAIL:\n            v->type = DILV_FAIL;\n            break;\n        case DILV_NULL:\n        case DILV_UP:\n            if (v1->val.ptr && !((unit_data *)v1->val.ptr)->isChar())\n            {\n                v->type = DILV_FAIL;\n            }\n            else\n            {\n                switch (dil_getval(v2))\n                {\n                    case DILV_FAIL:\n                        v->type = DILV_FAIL;\n                        break;\n                    case DILV_NULL:\n                    case DILV_UP:\n                        if (v2->val.ptr && !((unit_data *)v2->val.ptr)->isChar())\n                        {\n                            v->type = DILV_FAIL;\n                        }\n                        else\n                        {\n                            switch (dil_getval(v3))\n                            {\n                                case DILV_FAIL:\n                                case DILV_NULL:\n                                    v->type = DILV_FAIL;\n                                    break;\n                                case DILV_INT:\n                                    break;\n                                default:\n                                    v->type = DILV_ERR;\n                                    break;\n                            }\n                        }\n\n                        break;\n                    default:\n                        v->type = DILV_ERR;\n                        break;\n                }\n            }\n            break;\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    v->val.num = 0;\n\n    if (v->type == DILV_INT && (v1->val.ptr || v2->val.ptr))\n    {\n        if (v1->val.ptr == nullptr)\n        {\n            for (i = 0; i <= MAX_CURRENCY; ++i)\n            {\n                strcat(buf, \" \");\n                strcat(buf, money_string(v3->val.num, i, TRUE));\n            }\n\n            slog(LOG_ALL,\n                 0,\n                 \"%s was given %s by DIL %s.\",\n                 ((unit_data *)v2->val.ptr)->getNames().Name(),\n                 buf,\n                 p->sarg->owner->getFileIndexSymName());\n            money_transfer(nullptr, (unit_data *)v2->val.ptr, v3->val.num, local_currency((unit_data *)v2->val.ptr));\n            v->val.num = 1;\n        }\n        else if (v2->val.ptr == nullptr)\n        {\n            if (char_can_afford((unit_data *)v1->val.ptr, v3->val.num, local_currency((unit_data *)v1->val.ptr)))\n            {\n                money_transfer((unit_data *)v1->val.ptr, nullptr, v3->val.num, local_currency((unit_data *)v1->val.ptr));\n                v->val.num = 1;\n            }\n        }\n        else\n        {\n            if (char_can_afford((unit_data *)v1->val.ptr, v3->val.num, local_currency((unit_data *)v2->val.ptr)))\n            {\n                money_transfer((unit_data *)v1->val.ptr, (unit_data *)v2->val.ptr, v3->val.num, local_currency((unit_data *)v2->val.ptr));\n                v->val.num = 1;\n            }\n        }\n    }\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n}",
    "dil_example": "dilbegin item_charge(base_charge:integer);\nexternal\n  string accept_dil@function (pc:unitptr,s:string);\n\nvar\n   tcost   : integer;\n   state   : integer;\n   magmod  : integer;\n   addmag  : integer;\n   die     : integer;\n   result  : integer;\n   percent : integer;\n   thing   : unitptr;\n   pc      : unitptr;\n   answer  : string;\n   mn      : string;\n\ncode\n{\n\n:init:\n   heartbeat := PULSE_SEC*5;\n   self.spells[SPL_RECONSTRUCT] := 200;\n   self.abilities[ABIL_BRA] := 150;\n   self.abilities[ABIL_MAG] := 150;   \n   position_update(self);\n:start:\n   wait (SFB_DONE,( (command(\"give\")) and (self==target) ));\n\npc:=activator;\nthing:=medium;\nsecure(pc,lost_pc);\nsecure(thing,lost_pc);\n\nif( not visible( self, pc ) )\n   {\n      exec(\"say I only do business with people I can see.\", self );\n      exec(\"drop \" + (thing.name), self);\n      goto lost_pc;\n   }\n\ndilcopy (\"busy@function(Please wait I am busy with other work right now.\",\nself)\n;\n\nif (thing.type!=UNIT_ST_OBJ)\n   {\n      exec (\"say How am I supposed to recharge that then \"+pc.name+\"?\",self);\n      exec (\"bonk \" + pc.name,self);\n      goto give_back;\n   }\n\nif ((thing.objecttype!=ITEM_WAND) and (thing.objecttype!=ITEM_STAFF))\n   {\n      exec (\"say How am I supposed to recharge that then \"+pc.name+\"?\",self);\n      exec (\"bonk \" + pc.name,self);\n      goto give_back;\n   }\n\n/* If people don't wish their wands/staffs rechargable by shops, they declare\n   an extra, $norecharge, on the item. */\n\nif (\"$norecharge\" in thing.extra)\n   {\n      exec (\"say I can't recharge this \" + thing.title +\n            \",\" + pc.name +\". It is beyond my ability.\", self);\n      goto give_back;\n   }\n\nif ( thing.value[1] == thing.value[4] )\n   {\n      exec(\"say It is fully charged, what do you want \" +\n           \"to go charging it for?!?\", self);\n      exec(\"bonk \" + pc.name, self);\n      goto give_back;\n   }\n\nstate:=thing.value[4]-thing.value[1];\ngoto how_much;\n\n\n:broken_thing:\n   exec(\"say Oh my, it's broken. I can't fix that. I suggest \" +\n        \"you try to obtain another.\", self);\n   goto give_back;\n\n:not_possible:\n   exec(\"say Oh dear, I'm afraid that it's past the point \" +\n           \"of no return. Repairing it would only make it \" +\n           \"worse \" + pc.name + \".\", self);\n   goto give_back;\n\n:how_much:\n   tcost := (base_charge*160); /* Base cost in 1 gold 2 sp. Modified by\n                                   how badly damaged the item is and its\n                                   Magical Modifier */\n   tcost := tcost * state;     /* Adjust for how bad the damage is */\n   magmod := thing.value[0]; /* Take spell power into account    */\n\n   if (magmod > 0)\n   {\n      addmag := magmod; /* 1 gp per mag point */\n      tcost := tcost * addmag;  /* Final cost         */\n   }\n\n   mn := moneystring(tcost, 0);\n   exec (\"say It will cost you \" + mn + \" for me to \" +\n         \"recharge that for you.\", self);\n   answer := accept_dil@function(pc, \"Are you sure you want me to recharge it?\");\n   pause;\n\n   if (answer==\"no\")\n   {\n      exec(\"say Very well. Come back to me when you want it recharged.\",self);\n      goto give_back;\n   }\n\n   if (transfermoney(pc, self, tcost))\n   {\n      exec(\", touches \" + thing.name + \" softly and begins to chant...\", self);\n:repair_it:\n      if(thing.objecttype==ITEM_WAND)\n        result := cast_spell(SPL_CHARGE_WAND, self, self, thing, \"\");\n      else\n        result := cast_spell(SPL_CHARGE_STAFF, self, self, thing, \"\");\n      if (thing.value[1] < thing.value[4]) goto repair_it;\n      heartbeat:=PULSE_SEC*1;\n      pause;\n      exec(\"say There, hope you like it, \" + pc.name + \"!\", self);\n      heartbeat:=PULSE_SEC*5;\n      goto give_back;\n   }\n   else goto no_money;\n\n:no_money:\n   exec (\"say You can't afford my services right now. Please come back \" +\n         \"when you have enough money.\",self);\n   goto give_back;\n\n:give_back:\n   act( self.name + \" returns your \" + thing.name + \" to you.\",\n       A_ALWAYS,pc,null,null,TO_CHAR);\n   act(self.name + \" returns $1n's \" + thing.name + \" to $1m.\",\n       A_SOMEONE,pc,null,null,TO_REST);\n   link(thing,pc);\n   goto lost_pc;\n\n:lost_pc:\n   die := dildestroy (\"busy@function\",self);\n   unsecure(pc);\n   unsecure(thing);\n   goto start;\n} dilend"
}