{
    "keyword": "command",
    "opcode": "DILSE_CMDS",
    "yacc_rule": "| DILSE_CMDS '(' dilexp ')'\n{\n    INITEXP($$);\n    $$.boolean = 1;\n    if ($3.typ == DilVarType_e::DILV_SP)\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n        make_code(&($3));\n        add_code(&($$), &($3));\n        add_ubit8(&($$), DILE_CMDS);\n    }\n    else if ($3.typ == DilVarType_e::DILV_INT)\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n        make_code(&($3));\n        add_code(&($$), &($3));\n        add_ubit8(&($$), DILE_CMDS);\n    }\n    else\n    {\n        dilfatal(\"Arg 1 of 'command' not a string or an integer\");\n    }\n    FREEEXP($3);\n}",
    "dilfe_name": "dilfe_cmds",
    "c_implementation": "void dilfe_cmds(dilprg *p)\n{\n    dilval *v = new dilval;\n    /* Check if the input command might the supplied argument */\n    dilval *v1 = p->stack.pop();\n\n    switch (dil_getval(v1))\n    {\n        case DILV_FAIL:\n        case DILV_NULL:\n            v->type = DILV_FAIL;\n            break;\n        case DILV_SP:\n            if (v1->val.ptr)\n            {\n                v->type = DILV_INT;\n                v->atyp = DILA_NONE;\n                v->val.num = is_command(p->sarg->cmd, (char *)v1->val.ptr);\n            }\n            else\n            {\n                v->type = DILV_FAIL;\n            }\n            break;\n\n        case DILV_INT:\n            v->type = DILV_INT;\n            v->val.num = (p->sarg->cmd->no == v1->val.num);\n            break;\n\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n    p->stack.push(v);\n    delete v1;\n}",
    "dil_example": "dilbegin item_charge(base_charge:integer);\nexternal\n  string accept_dil@function (pc:unitptr,s:string);\n\nvar\n   tcost   : integer;\n   state   : integer;\n   magmod  : integer;\n   addmag  : integer;\n   die     : integer;\n   result  : integer;\n   percent : integer;\n   thing   : unitptr;\n   pc      : unitptr;\n   answer  : string;\n   mn      : string;\n\ncode\n{\n\n:init:\n   heartbeat := PULSE_SEC*5;\n   self.spells[SPL_RECONSTRUCT] := 200;\n   self.abilities[ABIL_BRA] := 150;\n   self.abilities[ABIL_MAG] := 150;   \n   position_update(self);\n:start:\n   wait (SFB_DONE,( (command(\"give\")) and (self==target) ));\n\npc:=activator;\nthing:=medium;\nsecure(pc,lost_pc);\nsecure(thing,lost_pc);\n\nif( not visible( self, pc ) )\n   {\n      exec(\"say I only do business with people I can see.\", self );\n      exec(\"drop \" + (thing.name), self);\n      goto lost_pc;\n   }\n\ndilcopy (\"busy@function(Please wait I am busy with other work right now.\",\nself)\n;\n\nif (thing.type!=UNIT_ST_OBJ)\n   {\n      exec (\"say How am I supposed to recharge that then \"+pc.name+\"?\",self);\n      exec (\"bonk \" + pc.name,self);\n      goto give_back;\n   }\n\nif ((thing.objecttype!=ITEM_WAND) and (thing.objecttype!=ITEM_STAFF))\n   {\n      exec (\"say How am I supposed to recharge that then \"+pc.name+\"?\",self);\n      exec (\"bonk \" + pc.name,self);\n      goto give_back;\n   }\n\n/* If people don't wish their wands/staffs rechargable by shops, they declare\n   an extra, $norecharge, on the item. */\n\nif (\"$norecharge\" in thing.extra)\n   {\n      exec (\"say I can't recharge this \" + thing.title +\n            \",\" + pc.name +\". It is beyond my ability.\", self);\n      goto give_back;\n   }\n\nif ( thing.value[1] == thing.value[4] )\n   {\n      exec(\"say It is fully charged, what do you want \" +\n           \"to go charging it for?!?\", self);\n      exec(\"bonk \" + pc.name, self);\n      goto give_back;\n   }\n\nstate:=thing.value[4]-thing.value[1];\ngoto how_much;\n\n\n:broken_thing:\n   exec(\"say Oh my, it's broken. I can't fix that. I suggest \" +\n        \"you try to obtain another.\", self);\n   goto give_back;\n\n:not_possible:\n   exec(\"say Oh dear, I'm afraid that it's past the point \" +\n           \"of no return. Repairing it would only make it \" +\n           \"worse \" + pc.name + \".\", self);\n   goto give_back;\n\n:how_much:\n   tcost := (base_charge*160); /* Base cost in 1 gold 2 sp. Modified by\n                                   how badly damaged the item is and its\n                                   Magical Modifier */\n   tcost := tcost * state;     /* Adjust for how bad the damage is */\n   magmod := thing.value[0]; /* Take spell power into account    */\n\n   if (magmod > 0)\n   {\n      addmag := magmod; /* 1 gp per mag point */\n      tcost := tcost * addmag;  /* Final cost         */\n   }\n\n   mn := moneystring(tcost, 0);\n   exec (\"say It will cost you \" + mn + \" for me to \" +\n         \"recharge that for you.\", self);\n   answer := accept_dil@function(pc, \"Are you sure you want me to recharge it?\");\n   pause;\n\n   if (answer==\"no\")\n   {\n      exec(\"say Very well. Come back to me when you want it recharged.\",self);\n      goto give_back;\n   }\n\n   if (transfermoney(pc, self, tcost))\n   {\n      exec(\", touches \" + thing.name + \" softly and begins to chant...\", self);\n:repair_it:\n      if(thing.objecttype==ITEM_WAND)\n        result := cast_spell(SPL_CHARGE_WAND, self, self, thing, \"\");\n      else\n        result := cast_spell(SPL_CHARGE_STAFF, self, self, thing, \"\");\n      if (thing.value[1] < thing.value[4]) goto repair_it;\n      heartbeat:=PULSE_SEC*1;\n      pause;\n      exec(\"say There, hope you like it, \" + pc.name + \"!\", self);\n      heartbeat:=PULSE_SEC*5;\n      goto give_back;\n   }\n   else goto no_money;\n\n:no_money:\n   exec (\"say You can't afford my services right now. Please come back \" +\n         \"when you have enough money.\",self);\n   goto give_back;\n\n:give_back:\n   act( self.name + \" returns your \" + thing.name + \" to you.\",\n       A_ALWAYS,pc,null,null,TO_CHAR);\n   act(self.name + \" returns $1n's \" + thing.name + \" to $1m.\",\n       A_SOMEONE,pc,null,null,TO_REST);\n   link(thing,pc);\n   goto lost_pc;\n\n:lost_pc:\n   die := dildestroy (\"busy@function\",self);\n   unsecure(pc);\n   unsecure(thing);\n   goto start;\n} dilend"
}