{
    "keyword": "exit_key",
    "opcode": "DILSF_EXITKEY",
    "yacc_rule": "| DILSF_EXITKEY idx /* .exit_info */\n{\n    INITEXP($$);\n    copy_code(&($$), &($2));\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_SP;\n    $$.dsl = DSL_LFT;\n    $$.num = DILF_EXITKEY;\n    FREEEXP($2);\n}",
    "dilfe_name": "DILF_EXITKEY",
    "c_implementation": "case DILF_EXITKEY:\n            v2 = p->stack.pop(); /* evaluate index */\n\n            switch (dil_getval(v1))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n                case DILV_UP:\n                    v->type = DILV_SPR;\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            switch (dil_getval(v2))\n            {\n                case DILV_FAIL:\n                    if (v->type != DILV_ERR)\n                    {\n                        v->type = DILV_FAIL; /* not applicable */\n                    }\n                    break;\n                case DILV_INT:\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            if (v->type == DILV_SPR)\n            {\n                if (v1->val.ptr && ((unit_data *)v1->val.ptr)->isRoom() && is_in(v2->val.num, 0, MAX_EXIT) &&\n                    ROOM_EXIT((unit_data *)v1->val.ptr, v2->val.num))\n                {\n                    v->atyp = DILA_NORM;\n                    v->ref = ROOM_EXIT((unit_data *)v1->val.ptr, v2->val.num)->getKeyPtr();\n                }\n                else\n                {\n                    v->type = DILV_FAIL;\n                }\n            }\n\n            break;",
    "dil_example": "dilbegin lock_dil(arg : string);\nexternal\n   integer is_hidden(u1 : unitptr, int1 : integer, u2 : unitptr);\n   string  dirstring@function(i2 : integer);\n   integer checkdoor(arg : string);\n\nvar\n   mykey:unitptr;\n   item       :  unitptr;\n   pc         :  unitptr;\n   arg1       :  string;\n   arg2       :  string;\n   arg3       :  stringlist;\n   dir        :  integer;\n   test       :  integer;\n   count      :  integer;\n   counter    :  integer;\n   rm:unitptr;\n   i:integer;\n   ct:integer;\ncode\n{\n   if (self.position < POSITION_RESTING)\n   {\n      act(\"All you can do right now, is think about the stars!\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   if (arg == \"\")\n   {\n      act(\"Lock what?\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   /* next we see if the player has anything in his inventory or around him that he can lock */\n\n   arg1 := arg;       /* saves the string in case we need it later */\n\n   item :=findunit(self, arg1, FIND_UNIT_HERE, null);\n\n      /* If there is no item or we cant see it, check the doors in the room */\n   if (item == null)\n      goto check_doors;\n\n   if (not visible(self, item))\n      goto check_doors;\n\n   if (isset(item.flags, UNIT_FL_BURIED))\n      goto check_doors;\n\n      /* If it cant be opened, it cant be locked. let the player know */\n   if (not isset(item.openflags, EX_OPEN_CLOSE))\n   {\n      act(\"That is impossible\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n      /* Check to make sure the object has a 'key' associated with it. */\n   if (item.key == \"\")\n   {\n      act(\"Odd, you can't seem to find a keyhole.\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n      /* See if it is opened */\n   if (not isset(item.openflags, EX_CLOSED))\n   {\n      act(\"Maybe you should close it first...\", A_ALWAYS, self, item, null, TO_CHAR);\n      return;\n   }\n\n   /* Check if it is locked */\n   if (isset(item.openflags, EX_LOCKED))\n   {\n      act(\"It is already locked!\", A_ALWAYS, self, item, null, TO_CHAR);\n      return;\n   }\n\n   pc := findsymbolic(self, item.key , FIND_UNIT_IN_ME);\n\n   if ((pc == null) and (self.level < IMMORTAL_LEVEL))    /* Imms dont need keys. */\n   {\n      act(\"You don't seem to have the proper key.\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   act(\"You lock $2n - *cluck*\", A_ALWAYS, self, item, null, TO_CHAR);\n   act(\"$1n locks $2n - *cluck*\", A_ALWAYS, self, item, null, TO_REST);\n\n   set(item.openflags, EX_LOCKED);\n\n   send_done (\"lock\", self, null,item, 0, \"\", item, CMD_AUTO_NONE);\n\n   return;\n\n   :check_doors:\n\n   /* first we are going to check if the player dictated what direction\n      they want to lock */\n\n   arg2 := arg;            /* save arg for later use */\n   arg1 := getword(arg2);  /* Check arg2 for directions */\n   arg3 := split(arg1, \".\");   /* checking for 2.door, 3.door, etc */\n\n   if (length(arg3) > 1)\n   {\n      count := atoi(arg3.[0]);\n      if (count > 0)\n         arg1 := arg3.[1];\n   }\n\n\n   item := self.outside;\n\n   /* Find the room the player is in.  If the player is in something that is\n      transparent, we take that objects outside as our item */\n   if ((item.type != UNIT_ST_ROOM) and (isset(item.flags, UNIT_FL_TRANS)))\n      item := item.outside;\n\n\n   /* If not a room, no doors */\n   if (item.type != UNIT_ST_ROOM)\n   {\n      act(\"You see no $2t here.\", A_ALWAYS, self, arg, null, TO_CHAR);\n      return;\n   }\n\n   dir := checkdoor(arg);\n\n   /*  That direction has no such door */\n   if (dir == -1)\n   {\n      act(\"You see no such exit in that direction.\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   if (not isset(item.exit_info[dir], EX_CLOSED))\n   {\n      act(\"Perhaps you should close it first....\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   /* UNCOMMENT WHEN THIS COMES IN */\n   if (item.exit_key[dir] == \"\")\n   {\n      act(\"Odd - you can't seem to find a keyhole.\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n\n   if (isset(item.exit_info[dir], EX_LOCKED))\n   {\n      act(\"It is already locked.\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   /* UNCOMMENT THIS WHEN THIS COMES IN */\n   mykey := findsymbolic(self, item.exit_key[dir] , FIND_UNIT_IN_ME);\n\n   if ((mykey == null) and (self.level < IMMORTAL_LEVEL))    // Imms dont need keys.\n   {\n      act(\"You don't seem to have the proper key.\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   act(\"You lock the $2t - *cluck*\", A_ALWAYS, self, item.exit_names[dir].[0], null, TO_CHAR);\n   act(\"$1n locks the $2t - *cluck*\", A_HIDEINV, self, item.exit_names[dir].[0], null, TO_REST);\n\n   pc := item.exit_to[dir].inside;\n   rm:= item.exit_to[dir];\n\n   i:=0;\n   ct:=FALSE;\n   while (i <= MAX_EXIT)\n   {\n      if (rm.exit_to[i]==item)\n      {\n         ct:=TRUE;\n         break;\n      }\n      i:=i+1;\n   }\n\n   if ((pc != null) and (ct==TRUE))\n      act(\"A soft *cluck* comes from the $2t.\", A_SOMEONE, pc, item.exit_to[dir].exit_names[i].[0], null, TO_ALL);\n      \n   set(item.exit_info[dir], EX_LOCKED);\n   if (ct==TRUE)\n      set(item.exit_to[dir].exit_info[i], EX_LOCKED);\n\n   send_done (\"lock\", self, mykey, null, 0, \"\", mykey, CMD_AUTO_NONE);\n   return;\n} dilend"
}