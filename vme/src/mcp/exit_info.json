{
    "keyword": "exit_info",
    "opcode": "DILSF_XNF",
    "yacc_rule": "| DILSF_XNF idx /* .exit_info */\n{\n    INITEXP($$);\n    copy_code(&($$), &($2));\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_INT;\n    $$.dsl = DSL_LFT;\n    $$.num = DILF_XNF;\n    FREEEXP($2);\n}",
    "dilfe_name": "DILF_XNF",
    "c_implementation": "case DILF_XNF:\n            v2 = p->stack.pop(); /* evaluate index */\n            switch (dil_getval(v1))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n                case DILV_UP:\n                    v->type = DILV_UINT1R;\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            switch (dil_getval(v2))\n            {\n                case DILV_FAIL:\n                    if (v->type != DILV_ERR)\n                    {\n                        v->type = DILV_FAIL; /* not applicable */\n                    }\n                    break;\n                case DILV_INT:\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            if (v->type == DILV_UINT1R)\n            {\n                if (v1->val.ptr && ((unit_data *)v1->val.ptr)->isRoom() && is_in(v2->val.num, 0, MAX_EXIT) &&\n                    ROOM_EXIT((unit_data *)v1->val.ptr, v2->val.num))\n                {\n                    v->atyp = DILA_NONE;\n                    v->ref = ROOM_EXIT((unit_data *)v1->val.ptr, v2->val.num)->getDoorFlagsPtr();\n                }\n                else\n                {\n                    v->type = DILV_FAIL;\n                }\n            }\n            break;",
    "dil_example": "dilbegin knock(arg : string);\n\nexternal\n   integer is_hidden@basemove(u1 : unitptr, int1 : integer, u2 : unitptr);\n   string  dirstring@function(i2 : integer);\n   integer checkdoor@basemove(arg : string);\n   integer rev_dir@function(i : integer);\n\nvar\n      item       :  unitptr;\n      pc         :  unitptr;\n      arg1       :  string;\n      arg2       :  string;\n      arg3       :  stringlist;\n      dir        :  integer;\n      oppdir     :  integer;\n      test       :  integer;\n      count      :  integer;\n      counter    :  integer;\n\ncode\n{\n   if (self.position < POSITION_RESTING)\n   {\n      act(\"All you can do right now, is think about the stars!\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   if (arg == \"\")\n   {\n      act(\"knock on what?\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   /* next we see if the player has anything in his inventory or around him that he can knock on */\n   arg1 := arg;       // saves the string in case we need it later\n\n   item := findunit(self, arg1, FIND_UNIT_HERE, null);\n\n   /* If there is no item or we cant see it, check the doors in the room */\n   if (item == null)\n      goto check_doors;\n\n   // First figure out if we are knocking on the item, or from inside the item\n   pc := self.outside;\n   while (pc)\n   {\n      if (item == pc)\n         break;\n\n      pc := pc.outside;\n   }\n\n   // I decided that if you're inside a container you can always see it\n   // Therefore the off (not pc) statement\n   if ((not visible(self, item)) and (not pc))\n      goto check_doors;\n\n   if (pc)  // Knocking from the inside\n   {\n      if (isset(item.flags, UNIT_FL_BURIED))\n         act(\"You hear a knocking sound from below.\", A_SOMEONE, item, null, null, TO_ALL);\n      else if (isset(item.openflags, EX_CLOSED) or (not isset(item.flags, UNIT_FL_TRANS)))\n         act(\"You hear a loud knocking from $1n.\", A_SOMEONE, item, null, null, TO_ALL);\n   }\n   else // knocking ON the object, we must be able to see it, check its not buried\n   {\n      if (isset(item.flags, UNIT_FL_BURIED))\n         goto check_doors;\n\n      if (isset(item.openflags, EX_CLOSED) or (not isset(item.flags, UNIT_FL_TRANS)))\n         if (item.inside)\n            act(\"You hear a loud knocking from $2n.\", A_SOMEONE, item.inside, item, null, TO_ALL);\n   }\n\n   // message to everyone in the same location\n   act(\"You knock on $2m.\", A_SOMEONE, self, item, null, TO_CHAR);\n   act(\"$1n knocks on $3n.\", A_SOMEONE, self, null, item,TO_NOTVICT);\n   act(\"$1n knocks on you.\", A_SOMEONE, self, null, item, TO_VICT);\n\n   send_done (\"knock\", self, null, item, 0, \"\", null, CMD_AUTO_NONE);\n   return;\n\n\n   :check_doors:\n   /* first we are going to check if the player dictated what direction they want to open */\n   /* set up so we can close 'both' doors (room player is in and room the door leads to.) */\n\n   dir := checkdoor@basemove(arg);\n\n   if (dir == -1)\n   {\n      act(\"You see no such exit in that direction.\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   item := self.outside;\n   while (item.type != UNIT_ST_ROOM)\n      item := item.outside;\n\n   if (not isset(item.exit_info[dir], EX_CLOSED))\n   {\n      act(\"You knock on the open $2t.\", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_CHAR);\n      act(\"$1n knocks on the open $2t.\", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_REST);\n   }\n   else\n   {\n      act(\"You knock on the $2t.\", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_CHAR);\n      act(\"$1n knocks on the $2t.\", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_REST);\n   }\n\n   pc := item.exit_to[dir].inside;\n   if (pc != null)\n   {\n      oppdir := rev_dir@function(dir);\n\n      if (not isset(item.exit_info[dir], EX_CLOSED))\n      {\n         act(\"$3n knocks on the open $2t.\", A_SOMEONE, pc, item.exit_to[dir].exit_names[oppdir].[0] , self, TO_ALL);\n      }\n      else\n      {\n         act(\"You hear a knocking coming from $2t.\", A_ALWAYS, pc,item.exit_to[dir].exit_names[oppdir].[0] , self, TO_ALL);\n      }\n   }\n\n   send_done (\"knock\", self, null, null, 0, \"\", null, CMD_AUTO_NONE);\n   return;\n} dilend"
}