{
    "keyword": "cast_spell",
    "opcode": "DILSE_CAST",
    "yacc_rule": "| DILSE_CAST '(' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    checkbool(\"argument 1 of cast\", $3.boolean);\n\n    if ($3.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 1 of 'cast_spell' not a number\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 2 of 'cast_spell' not a unitptr\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 3 of 'cast_spell' not a unitptr\");\n    }\n    else if ($9.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 4 of 'cast_spell' not a unitptr\");\n    }\n    else if ($11.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 5 of 'cast_spell' not a string\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        make_code(&($9));\n        make_code(&($11));\n\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_code(&($$), &($9));\n        add_code(&($$), &($11));\n        add_ubit8(&($$), DILE_CAST2);\n    }\n\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n    FREEEXP($9);\n    FREEEXP($11);\n}\n\n------\n\n| DILSE_CAST '(' coreexp ',' coreexp ',' coreexp ',' coreexp ')' ihold\n{\n    checkbool(\"argument 1 of cast\", $3.boolean);\n    if ($3.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 1 of 'cast_spell' not a number\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 2 of 'cast_spell' not a unitptr\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 3 of 'cast_spell' not a unitptr\");\n    }\n    else if ($9.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 4 of 'cast_spell' not a unitptr\");\n    }\n    else\n    {\n        $$.fst = $3.fst;\n        $$.lst = $11 + 1;\n        wtmp = &tmpl.core[$11];\n        bwrite_ubit8(&wtmp, DILI_CAST);\n    }\n}",
    "dilfe_name": "dilfi_cast",
    "c_implementation": "void dilfi_cast(dilprg *p)\n{\n    dilval *v4 = p->stack.pop();\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n    unit_data *caster = nullptr;\n    unit_data *medium = nullptr;\n    unit_data *target = nullptr;\n\n    p->waitcmd--;\n\n    if (dil_type_check(\"cast\",\n                       p,\n                       4,\n                       v1,\n                       TYPEFAIL_NULL,\n                       1,\n                       DILV_INT,\n                       v2,\n                       TYPEFAIL_NULL,\n                       1,\n                       DILV_UP,\n                       v3,\n                       TYPEFAIL_NULL,\n                       1,\n                       DILV_UP,\n                       v4,\n                       TYPEFAIL_NULL,\n                       1,\n                       DILV_UP))\n    {\n        caster = (unit_data *)v2->val.ptr;\n        medium = (unit_data *)v3->val.ptr;\n        target = (unit_data *)v4->val.ptr;\n\n        if (is_in(v1->val.num, SPL_GROUP_MAX, SPL_TREE_MAX - 1) && caster && caster->isChar() && medium &&\n            (g_spell_info[v1->val.num].spell_pointer || g_spell_info[v1->val.num].tmpl))\n        {\n            /* cast the spell */\n            spell_perform(v1->val.num, MEDIA_SPELL, caster, medium, target, \"\");\n            dil_test_secure(p);\n        }\n    }\n\n    delete v1;\n    delete v2;\n    delete v3;\n    delete v4;\n}",
    "dil_example": "dilbegin item_charge(base_charge:integer);\nexternal\n  string accept_dil@function (pc:unitptr,s:string);\n\nvar\n   tcost   : integer;\n   state   : integer;\n   magmod  : integer;\n   addmag  : integer;\n   die     : integer;\n   result  : integer;\n   percent : integer;\n   thing   : unitptr;\n   pc      : unitptr;\n   answer  : string;\n   mn      : string;\n\ncode\n{\n\n:init:\n   heartbeat := PULSE_SEC*5;\n   self.spells[SPL_RECONSTRUCT] := 200;\n   self.abilities[ABIL_BRA] := 150;\n   self.abilities[ABIL_MAG] := 150;   \n   position_update(self);\n:start:\n   wait (SFB_DONE,( (command(\"give\")) and (self==target) ));\n\npc:=activator;\nthing:=medium;\nsecure(pc,lost_pc);\nsecure(thing,lost_pc);\n\nif( not visible( self, pc ) )\n   {\n      exec(\"say I only do business with people I can see.\", self );\n      exec(\"drop \" + (thing.name), self);\n      goto lost_pc;\n   }\n\ndilcopy (\"busy@function(Please wait I am busy with other work right now.\",\nself)\n;\n\nif (thing.type!=UNIT_ST_OBJ)\n   {\n      exec (\"say How am I supposed to recharge that then \"+pc.name+\"?\",self);\n      exec (\"bonk \" + pc.name,self);\n      goto give_back;\n   }\n\nif ((thing.objecttype!=ITEM_WAND) and (thing.objecttype!=ITEM_STAFF))\n   {\n      exec (\"say How am I supposed to recharge that then \"+pc.name+\"?\",self);\n      exec (\"bonk \" + pc.name,self);\n      goto give_back;\n   }\n\n/* If people don't wish their wands/staffs rechargable by shops, they declare\n   an extra, $norecharge, on the item. */\n\nif (\"$norecharge\" in thing.extra)\n   {\n      exec (\"say I can't recharge this \" + thing.title +\n            \",\" + pc.name +\". It is beyond my ability.\", self);\n      goto give_back;\n   }\n\nif ( thing.value[1] == thing.value[4] )\n   {\n      exec(\"say It is fully charged, what do you want \" +\n           \"to go charging it for?!?\", self);\n      exec(\"bonk \" + pc.name, self);\n      goto give_back;\n   }\n\nstate:=thing.value[4]-thing.value[1];\ngoto how_much;\n\n\n:broken_thing:\n   exec(\"say Oh my, it's broken. I can't fix that. I suggest \" +\n        \"you try to obtain another.\", self);\n   goto give_back;\n\n:not_possible:\n   exec(\"say Oh dear, I'm afraid that it's past the point \" +\n           \"of no return. Repairing it would only make it \" +\n           \"worse \" + pc.name + \".\", self);\n   goto give_back;\n\n:how_much:\n   tcost := (base_charge*160); /* Base cost in 1 gold 2 sp. Modified by\n                                   how badly damaged the item is and its\n                                   Magical Modifier */\n   tcost := tcost * state;     /* Adjust for how bad the damage is */\n   magmod := thing.value[0]; /* Take spell power into account    */\n\n   if (magmod > 0)\n   {\n      addmag := magmod; /* 1 gp per mag point */\n      tcost := tcost * addmag;  /* Final cost         */\n   }\n\n   mn := moneystring(tcost, 0);\n   exec (\"say It will cost you \" + mn + \" for me to \" +\n         \"recharge that for you.\", self);\n   answer := accept_dil@function(pc, \"Are you sure you want me to recharge it?\");\n   pause;\n\n   if (answer==\"no\")\n   {\n      exec(\"say Very well. Come back to me when you want it recharged.\",self);\n      goto give_back;\n   }\n\n   if (transfermoney(pc, self, tcost))\n   {\n      exec(\", touches \" + thing.name + \" softly and begins to chant...\", self);\n:repair_it:\n      if(thing.objecttype==ITEM_WAND)\n        result := cast_spell(SPL_CHARGE_WAND, self, self, thing, \"\");\n      else\n        result := cast_spell(SPL_CHARGE_STAFF, self, self, thing, \"\");\n      if (thing.value[1] < thing.value[4]) goto repair_it;\n      heartbeat:=PULSE_SEC*1;\n      pause;\n      exec(\"say There, hope you like it, \" + pc.name + \"!\", self);\n      heartbeat:=PULSE_SEC*5;\n      goto give_back;\n   }\n   else goto no_money;\n\n:no_money:\n   exec (\"say You can't afford my services right now. Please come back \" +\n         \"when you have enough money.\",self);\n   goto give_back;\n\n:give_back:\n   act( self.name + \" returns your \" + thing.name + \" to you.\",\n       A_ALWAYS,pc,null,null,TO_CHAR);\n   act(self.name + \" returns $1n's \" + thing.name + \" to $1m.\",\n       A_SOMEONE,pc,null,null,TO_REST);\n   link(thing,pc);\n   goto lost_pc;\n\n:lost_pc:\n   die := dildestroy (\"busy@function\",self);\n   unsecure(pc);\n   unsecure(thing);\n   goto start;\n} dilend"
}