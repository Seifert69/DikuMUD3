{
    "keyword": "getinteger",
    "opcode": "DILSE_GINT",
    "yacc_rule": "| DILSE_GINT '(' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    if ($3.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 1 of 'getinteger' not integer\");\n    }\n    else if (($5.typ != DilVarType_e::DILV_UP) && ($5.typ != DilVarType_e::DILV_NULL))\n    {\n        dilfatal(\"Arg 2 of 'getinteger' not unitptr\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 3 of 'getinteger' not integer\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Function is not _yet_ static */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_ubit8(&($$), DILE_GINT);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n}",
    "dilfe_name": "dilfe_gint",
    "c_implementation": "void dilfe_gint(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v3 = p->stack.pop(); // INT\n    dilval *v2 = p->stack.pop(); // UNIT\n    dilval *v1 = p->stack.pop(); // INT\n\n    unit_data *p_u = nullptr;\n    int p_i = 0;\n    int idx = 0;\n\n    v->type = DILV_INT;\n    v->val.num = 0;\n\n    switch (dil_getval(v3))\n    {\n        case DILV_FAIL:\n            v->type = DILV_FAIL; /* failed */\n            break;\n\n        case DILV_INT:\n            p_i = v3->val.num;\n            break;\n\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n\n    switch (dil_getval(v2))\n    {\n        case DILV_FAIL:\n            v->type = DILV_FAIL; /* failed */\n            break;\n\n        case DILV_UP:\n        case DILV_NULL:\n            p_u = (unit_data *)v2->val.ptr;\n            break;\n\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n\n    switch (dil_getval(v1))\n    {\n        case DILV_FAIL:\n            v->type = DILV_FAIL; /* failed */\n            break;\n\n        case DILV_INT:\n            idx = v1->val.num;\n            break;\n\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n\n    if (v->type == DILV_INT)\n    {\n        time_t t;\n        tm *timeInfo;\n        switch (idx)\n        {\n            case DIL_GINT_MANAREG:\n                if ((p_u != nullptr) && p_u->isChar())\n                {\n                    v->val.num = mana_gain(p_u);\n                }\n                break;\n\n            case DIL_GINT_HITREG:\n                if ((p_u != nullptr) && p_u->isChar())\n                {\n                    v->val.num = hit_gain(p_u);\n                }\n                break;\n\n            case DIL_GINT_MOVEREG:\n                if ((p_u != nullptr) && p_u->isChar())\n                {\n                    v->val.num = move_gain(p_u);\n                }\n                break;\n\n            case DIL_GINT_EFFDEX:\n                if ((p_u != nullptr) && p_u->isChar())\n                {\n                    v->val.num = effective_dex(p_u);\n                }\n                break;\n\n            case DIL_GINT_REQXP:\n                v->val.num = required_xp(p_i);\n                break;\n\n            case DIL_GINT_LEVELXP:\n                v->val.num = level_xp(p_i);\n                break;\n\n            case DIL_GINT_DESCRIPTOR:\n                if ((p_u != nullptr) && p_u->isPC())\n                {\n                    v->val.num = (CHAR_DESCRIPTOR(p_u) != nullptr);\n                }\n                else\n                {\n                    v->val.num = 1;\n                }\n                break;\n\n            case DIL_GINT_CRIMENO:\n                v->val.num = new_crime_serial_no();\n                break;\n\n            case DIL_GINT_BONUS_A:\n                v->val.num = bonus_map_a(p_i);\n                break;\n\n            case DIL_GINT_BONUS_B:\n                v->val.num = bonus_map_b(p_i);\n                break;\n\n            case DIL_GINT_REALYEAR:\n                t = time(0);\n                timeInfo = gmtime(&t);\n                v->val.num = 1900 + timeInfo->tm_year;\n                break;\n\n            case DIL_GINT_REALMONTH:\n                t = time(0);\n                timeInfo = gmtime(&t);\n                v->val.num = timeInfo->tm_mon + 1;\n                break;\n\n            case DIL_GINT_REALDAY:\n                t = time(0);\n                timeInfo = gmtime(&t);\n                v->val.num = timeInfo->tm_mday;\n                break;\n\n            default:\n                v->type = DILV_FAIL; /* failed */\n                slog(LOG_ALL, 0, \"getinteger() was given incorrect index %d by DIL %s.\", idx, p->sarg->owner->getFileIndexSymName());\n                break;\n        }\n    }\n\n    p->stack.push(v);\n\n    delete v1;\n    delete v2;\n    delete v3;\n}",
    "dil_example": "dilbegin integer lose_exp(u:unitptr);\nexternal\n\tinteger max@function(a:integer,b:integer);\n\tinteger min@function(a:integer,b:integer);\n\nvar\n\tloss:integer;\n\tl0:integer; // XP required to your current level\n\tl1:integer; // XP required to your current level+1\n\ncode\n{\n   heartbeat:=3;\n   if (u.type != UNIT_ST_PC)\n      return(0);\n\n   /* Up to level 3 is sacred experience                          */\n   if (u.vlevel <= 3)\n      return(0);\n\n   /* This first line takes care of any xp earned above required level. */\n   l0 := getinteger(DIL_GINT_REQXP, null, u.vlevel);\n   l1 := getinteger(DIL_GINT_REQXP, null, u.vlevel+1);\n   // log(\"l1 = \" + itoa(l1) + \"   l0 = \" + itoa(l0) + \"   l1-l0 = \" + itoa(l1-l0));\n\n   // Lose half the XP earned above your current level (you should level up)\n   loss := max@function(0, (u.exp-l0)/2);\n   // log(\"loss 1 = \" + itoa(loss));\n\n   /* This line makes sure, that you lose at most half a level...       */\n   loss := min@function(loss, (l1-l0)/2);\n   // log(\"loss 2 = \" + itoa(loss));\n\n   /* This line takes care of the case where you have less or almost    */\n   /* equal XP to your required. You thus lose at least 1/5th your      */\n   /* level.                                                            */\n   loss := max@function(loss, (l1-l0)/5);\n   // log(\"loss 3 = \" + itoa(loss));\n\n   if (loss < 0)\n      loss:=0;\n\n   // log(\"loss result = \" + itoa(loss));\n\n   return(loss);\n} dilend"
}