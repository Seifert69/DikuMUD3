= cmdptr =
 type: '''cmdptr'''

The '''cmdptr''' type represents a command pointer that provides access to command information in the DikuMUD command system.

== Description ==
A '''cmdptr''' is a pointer type that references individual commands in the global command table. Each command contains information such as its name, required level, position requirements, command type, and logging level. Command pointers are commonly used for command validation, permission checking, and creating command help systems.

The cmdptr type supports traversal through linked lists using the next and previous fields, allowing iteration through all available commands in the system.

== Field Access ==
{| class="wikitable"
! Field !! Type !! Access !! Description
|-
| name || string || Read-only || The command name string
|-
| type || integer || Read-only || Command type identifier (social, skill, or regular command)
|-
| level || integer || Read-only || Minimum character level required to use the command
|-
| loglevel || integer || Read-only || Minimum character level that can see log entries (0 = no logging)
|-
| position || integer || Read-only || Minimum position required to use the command
|-
| next || cmdptr || Read-only || Pointer to the next command in the list
|-
| previous || cmdptr || Read-only || Pointer to the previous command in the list
|}

== Availability ==
The cmdptr type is used with the following functions and operations:
* '''chead()''' - Returns the first command in the global command list
* '''getcommand(s : string)''' - Returns a specific command by name
* '''getcmd(s : string)''' - Alternative function to get a command by name

== Examples ==
=== List All Commands ===
 dilbegin list_all_commands();
 var
    cmd : cmdptr;
    info : string;
    count : integer;
 code
 {
    cmd := chead();
    count := 0;
    
    while (cmd) {
       info := cmd.name + " (lvl:" + itoa(cmd.level) + 
                 " pos:" + itoa(cmd.position) + 
                 " type:" + itoa(cmd.type) + ")";
       act("CMD: $2t", A_ALWAYS, self, info, null, TO_CHAR);
       cmd := cmd.next;
       count := count + 1;
    }
    
    act("Total commands: " + itoa(count), A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Check Command Access ===
 dilbegin check_command_access(cmd_name : string);
 var
    cmd : cmdptr;
 code
 {
    cmd := getcommand(cmd_name);
    
    if (not cmd) {
       act("Command '" + cmd_name + "' does not exist.", A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act("Command: " + cmd.name, A_ALWAYS, self, cmd.level, null, TO_CHAR);
       act("Required level: " + itoa(cmd.level), A_ALWAYS, self, cmd.position, null, TO_CHAR);
       act("Required position: " + itoa(cmd.position), A_ALWAYS, self, cmd.type, null, TO_CHAR);
    act("Command type: " + itoa(cmd.type), A_ALWAYS, self, cmd.loglevel, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Analysis ===
 dilbegin analyze_commands();
 var
    cmd : cmdptr;
    total, socials, skills : integer;
 code
 {
    total := 0;
    socials := 0;
    skills := 0;
    
    cmd := chead();
    
    while (cmd) {
       total := total + 1;
       
       if (cmd.type == 1)  // Assuming type 1 = social
          socials := socials + 1;
       else if (cmd.type == 2)  // Assuming type 2 = skill
          skills := skills + 1;
       
       cmd := cmd.next;
    }
    
    act("Command analysis:", A_ALWAYS, self, null, null, TO_CHAR);
    act("Total commands: " + itoa(total), A_ALWAYS, self, null, null, TO_CHAR);
    act("Social commands: " + itoa(socials), A_ALWAYS, self, null, null, TO_CHAR);
    act("Skill commands: " + itoa(skills), A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

== Usage Notes ==
* Command pointers are read-only; you cannot modify command properties through cmdptr
* The command list is a doubly-linked list, allowing both forward and backward traversal
* Command types are typically defined as constants in the system (social, skill, regular command)
* Position requirements use standard position constants (standing, sitting, fighting, etc.)
* A loglevel of 0 indicates that the command does not generate log entries
* Use '''chead()''' to get the first command and traverse with '''next''' to iterate through all commands

== Error Handling ==
* Accessing fields on a null cmdptr will result in a DILV_FAIL condition
* '''getcommand()''' and '''getcmd()''' return null if the command is not found
* Always check if a cmdptr is valid before accessing its fields

== Related Functions ==
* [[Manual:DIL_Manual/chead|chead]] - Get the first command in the global command list
* [[Manual:DIL_Manual/getcommand|getcommand]] - Get a specific command by name
* [[Manual:DIL_Manual/getcmd|getcmd]] - Alternative function to get a command by name

== See Also ==
* [[Manual:DIL_Manual/command|command]] - Command field for checking current command
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command activation wait flag
* [[Manual:DIL_Manual/global command list|global command list]] - System command registry