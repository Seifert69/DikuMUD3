{
    "keyword": "findunit",
    "opcode": "DILSE_FNDU",
    "yacc_rule": "| DILSE_FNDU '(' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    checkbool(\"argument 3 of findunit\", $7.boolean);\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'findunit' not a unit\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 2 of 'findunit' not a string\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 3 of 'findunit' not integer\");\n    }\n    else if ($9.typ != DilVarType_e::DILV_UP && $9.typ != DilVarType_e::DILV_NULL)\n    {\n        dilfatal(\"Arg 4 of 'findunit' not unit\");\n    }\n    else if ($11.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 5 of 'findunit' not integer\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_UP;\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        make_code(&($9));\n        make_code(&($11));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_code(&($$), &($9));\n        add_code(&($$), &($11));\n        add_ubit8(&($$), DILE_FNDU2);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n    FREEEXP($9);\n    FREEEXP($11);\n}\n\n------\n\n| DILSE_FNDU '(' dilexp ',' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    checkbool(\"argument 3 of findunit\", $7.boolean);\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'findunit' not a unit\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 2 of 'findunit' not a string\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 3 of 'findunit' not integer\");\n    }\n    else if ($9.typ != DilVarType_e::DILV_UP && $9.typ != DilVarType_e::DILV_NULL)\n    {\n        dilfatal(\"Arg 4 of 'findunit' not unit\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_UP;\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        make_code(&($9));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_code(&($$), &($9));\n        add_ubit8(&($$), DILE_FNDU);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n    FREEEXP($9);\n}",
    "dilfe_name": "dilfe_fndu",
    "c_implementation": "void dilfe_fndu(dilprg *p)\n{\n    dilval *v = new dilval;\n    /* Find a unit */\n    dilval *v4 = p->stack.pop();\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    switch (dil_getval(v1))\n    {\n        case DILV_FAIL:\n            v->type = DILV_FAIL;\n            break;\n\n        case DILV_UP:\n            if (v1->val.ptr)\n            {\n                v->type = DILV_UP;\n            }\n            else\n            {\n                v->type = DILV_NULL; /* not applicable UP */\n            }\n            break;\n\n        case DILV_NULL:\n            v->type = DILV_NULL;\n            break;\n\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    switch (dil_getval(v2))\n    {\n        case DILV_FAIL:\n            if (v->type != DILV_ERR)\n            {\n                v->type = DILV_FAIL;\n            }\n            break;\n\n        case DILV_SP:\n            if (v->type != DILV_ERR)\n            {\n                if (!v2->val.ptr)\n                {\n                    v->type = DILV_NULL; /* not applicable SP */\n                }\n                else if (!*((char *)v2->val.ptr))\n                {\n                    v->type = DILV_NULL; /* not applicable SP */\n                }\n            }\n            break;\n\n        case DILV_NULL:\n            if ((v->type != DILV_ERR) && (v->type != DILV_FAIL))\n            {\n                v->type = DILV_NULL; /* not applicable */\n            }\n            break;\n\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n\n    switch (dil_getval(v3))\n    {\n        case DILV_FAIL:\n            if (v->type != DILV_ERR)\n            {\n                v->type = DILV_FAIL;\n            }\n            break;\n\n        case DILV_INT:\n            break;\n\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n\n    switch (dil_getval(v4))\n    {\n        case DILV_FAIL:\n            if (v->type != DILV_ERR)\n            {\n                v->type = DILV_FAIL;\n            }\n            break;\n\n        case DILV_UP:\n            break;\n\n        case DILV_NULL: /* null pointer */\n            if ((v->type != DILV_ERR) && (v->type != DILV_FAIL))\n            {\n                v4->val.ptr = nullptr;\n            }\n            break;\n\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n\n    if (v->type == DILV_UP)\n    {\n        char *c = (char *)v2->val.ptr;\n\n        v->atyp = DILA_NORM;\n        v->val.ptr = find_unit_dil((unit_data *)v1->val.ptr, &c, (unit_data *)v4->val.ptr, v3->val.num);\n\n        if (v2->atyp == DILA_NORM && v2->type == DILV_SPR)\n        {\n            memmove(v2->val.ptr, c, strlen(c) + 1);\n        }\n        else if (p->sarg->arg == (const char *)v2->val.ptr)\n        {\n            p->sarg->arg = c; /* Update argument if argument is argument! :) */\n        }\n\n        if (!v->val.ptr)\n        {\n            v->type = DILV_NULL;\n        }\n    }\n    else\n    {\n        v->type = DILV_FAIL;\n    }\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n    delete v4;\n}",
    "dil_example": "dilbegin captain(jailname : string);\nexternal\n   integer walk_room@function (s:string,i:integer);\n   putin_safe(prisoner : unitptr);\n   integer add_reward@justice(criminal_symname : string, criminal_idx : integer, crime_type: integer);\nvar\n   tf:integer;\n   prisoner : unitptr;\n   u : unitptr;\n   nextu : unitptr;\n   safe : unitptr;\n   cuffs : unitptr;\n   c : string;\n\ncode\n{\n   heartbeat := PULSE_SEC * 10;\n\n   on_activation((self.position <= POSITION_SLEEPING) or\n                 (self.position == POSITION_FIGHTING), skip);\n\n   :findsafe:\n   tf:=walk_room@function(\"accuse_room\"+\"@\"+self.outside.zoneidx,4);\n   safe := findunit(self, \"safe\", FIND_UNIT_SURRO, self);\n   if (safe == null)\n     safe := self;\n\n   secure(safe, findsafe);\n\n   :loop:\n   pause;\n\n   /* See if any prisoner is in this room */\n   foreach (UNIT_ST_PC|UNIT_ST_NPC, prisoner)\n   {\n      cuffs := equipment(prisoner, WEAR_WRIST_R);\n      if (cuffs and (cuffs.nameidx == \"cuffs\") and\n                    (cuffs.zoneidx == \"midgaard\"))\n      {\n         if (isset(prisoner.charflags, CHAR_OUTLAW))\n           goto gotone;\n      }\n   }\n\n   goto loop;\n\n   :gotone:\n   putin_safe(prisoner);\n\n   act(\"$3n opens the jail door, and pushes $1n through.\",\n       A_SOMEONE, prisoner, null, self, TO_NOTVICT);\n   act(\"You are pushed into the jail by $3n.\",\n       A_SOMEONE, prisoner, null, self, TO_CHAR);\n\n   dilcopy(\"jailstay@midgaard(12)\", prisoner);\n\n\n   link(prisoner, findroom(jailname));\n\n   goto loop;\n} dilend"
}