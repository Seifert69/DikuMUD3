{
    "keyword": "abilities",
    "opcode": "DILSF_ABL",
    "yacc_rule": "| DILSF_ABL idx /* . abilities */\n{\n    INITEXP($$);\n    copy_code(&($$), &($2));\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_INT;\n    $$.dsl = DSL_LFT;\n    $$.num = DILF_ABL;\n    FREEEXP($2);\n}",
    "dilfe_name": "DILF_ABL",
    "c_implementation": "case DILF_ABL:\n            v2 = p->stack.pop(); /* evaluate index */\n            switch (dil_getval(v2))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n\n                case DILV_INT:\n                    v->type = DILV_INT;\n                    break;\n\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            switch (dil_getval(v1))\n            {\n                case DILV_FAIL:\n                    if (v->type != DILV_ERR)\n                    {\n                        v->type = DILV_FAIL; /* not applicable */\n                    }\n                    break;\n                case DILV_UP:\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            if (v->type == DILV_INT)\n            {\n                auto *character = reinterpret_cast<char_data *>(v1->val.ptr);\n                if (character && character->isChar() && is_in(v2->val.num, 0, ABIL_TREE_MAX - 1))\n                {\n                    if (character->isPC())\n                    {\n                        if (p->frame[0].tmpl->zone->getAccessLevel() == 0)\n                        {\n                            v->atyp = DILA_NONE;\n                            v->type = DILV_SINT2R;\n                            v->ref = character->getAbilityAtIndexPtr(v2->val.num);\n                        }\n                        else\n                        {\n                            v->atyp = DILA_NONE;\n                            v->type = DILV_INT;\n                            v->val.num = character->getAbilityAtIndex(v2->val.num);\n                        }\n                    }\n                    else\n                    {\n                        v->atyp = DILA_NONE;\n                        v->type = DILV_UINT2R;\n                        v->ref = character->getAbilityAtIndexPtr(v2->val.num);\n                    }\n                }\n                else\n                {\n                    v->type = DILV_FAIL;\n                }\n            }\n            break;",
    "dil_example": "dilbegin item_charge(base_charge:integer);\nexternal\n  string accept_dil@function (pc:unitptr,s:string);\n\nvar\n   tcost   : integer;\n   state   : integer;\n   magmod  : integer;\n   addmag  : integer;\n   die     : integer;\n   result  : integer;\n   percent : integer;\n   thing   : unitptr;\n   pc      : unitptr;\n   answer  : string;\n   mn      : string;\n\ncode\n{\n\n:init:\n   heartbeat := PULSE_SEC*5;\n   self.spells[SPL_RECONSTRUCT] := 200;\n   self.abilities[ABIL_BRA] := 150;\n   self.abilities[ABIL_MAG] := 150;   \n   position_update(self);\n:start:\n   wait (SFB_DONE,( (command(\"give\")) and (self==target) ));\n\npc:=activator;\nthing:=medium;\nsecure(pc,lost_pc);\nsecure(thing,lost_pc);\n\nif( not visible( self, pc ) )\n   {\n      exec(\"say I only do business with people I can see.\", self );\n      exec(\"drop \" + (thing.name), self);\n      goto lost_pc;\n   }\n\ndilcopy (\"busy@function(Please wait I am busy with other work right now.\",\nself)\n;\n\nif (thing.type!=UNIT_ST_OBJ)\n   {\n      exec (\"say How am I supposed to recharge that then \"+pc.name+\"?\",self);\n      exec (\"bonk \" + pc.name,self);\n      goto give_back;\n   }\n\nif ((thing.objecttype!=ITEM_WAND) and (thing.objecttype!=ITEM_STAFF))\n   {\n      exec (\"say How am I supposed to recharge that then \"+pc.name+\"?\",self);\n      exec (\"bonk \" + pc.name,self);\n      goto give_back;\n   }\n\n/* If people don't wish their wands/staffs rechargable by shops, they declare\n   an extra, $norecharge, on the item. */\n\nif (\"$norecharge\" in thing.extra)\n   {\n      exec (\"say I can't recharge this \" + thing.title +\n            \",\" + pc.name +\". It is beyond my ability.\", self);\n      goto give_back;\n   }\n\nif ( thing.value[1] == thing.value[4] )\n   {\n      exec(\"say It is fully charged, what do you want \" +\n           \"to go charging it for?!?\", self);\n      exec(\"bonk \" + pc.name, self);\n      goto give_back;\n   }\n\nstate:=thing.value[4]-thing.value[1];\ngoto how_much;\n\n\n:broken_thing:\n   exec(\"say Oh my, it's broken. I can't fix that. I suggest \" +\n        \"you try to obtain another.\", self);\n   goto give_back;\n\n:not_possible:\n   exec(\"say Oh dear, I'm afraid that it's past the point \" +\n           \"of no return. Repairing it would only make it \" +\n           \"worse \" + pc.name + \".\", self);\n   goto give_back;\n\n:how_much:\n   tcost := (base_charge*160); /* Base cost in 1 gold 2 sp. Modified by\n                                   how badly damaged the item is and its\n                                   Magical Modifier */\n   tcost := tcost * state;     /* Adjust for how bad the damage is */\n   magmod := thing.value[0]; /* Take spell power into account    */\n\n   if (magmod > 0)\n   {\n      addmag := magmod; /* 1 gp per mag point */\n      tcost := tcost * addmag;  /* Final cost         */\n   }\n\n   mn := moneystring(tcost, 0);\n   exec (\"say It will cost you \" + mn + \" for me to \" +\n         \"recharge that for you.\", self);\n   answer := accept_dil@function(pc, \"Are you sure you want me to recharge it?\");\n   pause;\n\n   if (answer==\"no\")\n   {\n      exec(\"say Very well. Come back to me when you want it recharged.\",self);\n      goto give_back;\n   }\n\n   if (transfermoney(pc, self, tcost))\n   {\n      exec(\", touches \" + thing.name + \" softly and begins to chant...\", self);\n:repair_it:\n      if(thing.objecttype==ITEM_WAND)\n        result := cast_spell(SPL_CHARGE_WAND, self, self, thing, \"\");\n      else\n        result := cast_spell(SPL_CHARGE_STAFF, self, self, thing, \"\");\n      if (thing.value[1] < thing.value[4]) goto repair_it;\n      heartbeat:=PULSE_SEC*1;\n      pause;\n      exec(\"say There, hope you like it, \" + pc.name + \"!\", self);\n      heartbeat:=PULSE_SEC*5;\n      goto give_back;\n   }\n   else goto no_money;\n\n:no_money:\n   exec (\"say You can't afford my services right now. Please come back \" +\n         \"when you have enough money.\",self);\n   goto give_back;\n\n:give_back:\n   act( self.name + \" returns your \" + thing.name + \" to you.\",\n       A_ALWAYS,pc,null,null,TO_CHAR);\n   act(self.name + \" returns $1n's \" + thing.name + \" to $1m.\",\n       A_SOMEONE,pc,null,null,TO_REST);\n   link(thing,pc);\n   goto lost_pc;\n\n:lost_pc:\n   die := dildestroy (\"busy@function\",self);\n   unsecure(pc);\n   unsecure(thing);\n   goto start;\n} dilend"
}