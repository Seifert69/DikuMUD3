Generate MCP entry for DIL keyword: gamestate

=== Yacc rule ===
| DILSI_GMSTATE '(' coreexp ',' coreexp ')' ihold
{
    if ($3.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 1 of 'gamestate' not a unit");
    }
    if ($5.typ != DilVarType_e::DILV_INT)
    {
        dilfatal("Arg 1 of 'gamestate' not an integer");
    }
    else
    {
        $$.fst = $3.fst;
        $$.lst = $7 + 1;
        wtmp = &tmpl.core[$7];
        bwrite_ubit8(&wtmp, DILI_GMSTATE);
    }
}

=== C implementation ===
void dilfi_gamestate(dilprg *p)
{
    dilval *v2 = p->stack.pop();
    dilval *v1 = p->stack.pop();

    if (dil_type_check("gamestate", p, 2, v1, TYPEFAIL_NULL, 1, DILV_UP, v2, TYPEFAIL_NULL, 1, DILV_INT))
    {
        if (!((unit_data *)v1->val.ptr)->isPC())
        {
            dil_typeerr(p, "gamestate: Not a pc unit");
        }
        else
        {
            switch (v2->val.num)
            {
                case GS_PLAY:
                    UPC((unit_data *)v1->val.ptr)->gstate_togame(p);
                    break;
                case GS_QUIT:
                    extract_unit((unit_data *)v1->val.ptr);
                    break;
                case GS_MENU:
                    UPC((unit_data *)v1->val.ptr)->gstate_tomenu(p);
                    break;
                case GS_LINK_DEAD:
                    if (CHAR_DESCRIPTOR((unit_data *)v1->val.ptr))
                    {
                        descriptor_close(CHAR_DESCRIPTOR((unit_data *)v1->val.ptr));
                    }
                    break;
            }
        }
    }
    delete v1;
    delete v2;
}

=== DIL example ===
dilbegin aware do_quit(arg : string);
external
   on_connect@basis();

var
   err : integer;
   goodbye : string;
   tt:integer;
   minutes:integer;
   seconds:integer;
   u : unitptr;
   quit_str:string;

code
{
   if (quit_str=="logging on")
      quit;

   heartbeat := PULSE_SEC;

   if (excmdstr != "quit")
   {
      // MS2020: This is hard to understand :-) But if you're immortal and you quit to the menu
      // (look below). Then eventually you char gets saved with this do_quit DIL. When the char 
      // is loaded the program runs again, e.g. triggered by the on_connect exec("look"). 
      // Since the DIL doesn't recall (it probably shouldnt because it would recall in the external
      // funciton). Then I add this little hack to gracefully quit the do_quit without the odd
      // error message.
      //
      if (excmdstr.[0] != "q")
         quit;

      sendtext ("You can't just type ["+excmdstr+"] you must type 'quit' no less to quit!<br/>",self);
      quit;
   }


   if (self.type != UNIT_ST_PC) 
      quit;

   if (self.position == POSITION_FIGHTING)
   {
      sendtext("Not while fighting!<br/>", self);
      quit;
   }

   tt:=atoi(self.extra.["$PK_TIMER"].descr);
   if (realtime-tt>600)
      goto cont_quit;

   seconds:=0;
   minutes:=0;
   seconds:=realtime-tt;
   seconds:=600-seconds;
   minutes:=seconds/60;

   sendtext("You are not permitted to log off so soon after a PK fight.<br/>",self);

   if (minutes<1){
      if (seconds==1)
         sendtext ("You have 1 more second before you can log off.<br/>",self);
      else
         sendtext ("You have "+itoa(seconds)+" more seconds before you can log off.<br/>",self);
      quit;
   }
   else
   {
      seconds :=seconds-(minutes*60);
      if ((minutes==1) and (seconds==1))
         sendtext ("You have 1 minute and 1 second before you can log off.<br/>",self);
      else if (minutes==1)
         sendtext ("You have 1 minute and "+itoa(seconds)+" seconds before you can log off.<br/>",self);
      else if (seconds==1)
         sendtext ("You have "+itoa(minutes)+" minutes and 1 second before you can log off.<br/>",self);
      else
         sendtext ("You have "+itoa(minutes)+" minutes and "+itoa(seconds)+" seconds before you can log off.<br/>",self);
      quit;
   }

   :cont_quit:
   foreach(UNIT_ST_PC,u)
   {
      if (u != self)
      {
         if (visible(u,self))
            sendtext(self.name+" has left the game.<br/>",u);
      }
   }

   //log("QUIT PC " + self.name);
   if (self.level < 200)
   {
      err := loadstr("goodbye",goodbye);

      if (err > 0)
      {
         goodbye := textformat(goodbye);
         sendtext("<br/><br/>"+goodbye, self);
      }

      sendtext("Goodbye, friend.. Come back soon!<br/>", self);
      quit_str:="logging on";
      gamestate(self, GS_QUIT);
   }
   else
   {
      gamestate(self, GS_MENU);
      //dilcopy("on_connect@basis", self);
      on_connect@basis();
   }
   quit;
} dilend
