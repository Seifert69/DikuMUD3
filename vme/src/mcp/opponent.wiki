= opponent =
 function: integer '''opponent'''(u1 : unitptr, u2 : unitptr);

== Description ==
The '''opponent'''() function checks if two characters are in combat with each other. This function determines whether one unit is directly engaged in combat with another unit, either as attacker or defender.

Based on the C implementation, this function uses the `CHAR_COMBAT` and `FindOpponent()` methods to determine combat relationships between characters.

== Parameters ==
{| class="wikitable"
! Parameter !! Type !! Description
|-
| u1 || unitptr || First character to check combat relationship
|-
| u2 || unitptr || Second character to check combat relationship
|}

== Return Value ==
Returns integer:
* '''TRUE''' (1) - If u1 is in combat with u2
* '''FALSE''' (0) - If u1 is not in combat with u2

== Usage Notes ==
The function checks for direct combat engagement between two characters.
In most combat systems, a character typically has one primary opponent but may be engaged with multiple opponents.
This function is directional - opponent(u1, u2) may return different result than opponent(u2, u1).
Both characters must be valid unit pointers of type UNIT_ST_PC or UNIT_ST_NPC.
Characters must be awake and capable of combat (not sleeping, etc.).

== Examples ==
=== Basic Combat Check ===
 dilbegin check_combat_status(char1 : unitptr, char2 : unitptr);
 var
    in_combat : integer;
 
 code
 {
    in_combat := opponent(char1, char2);
    
    if (in_combat)
       act("$1n is fighting with $2n.", A_ALWAYS, self, char1, char2, TO_CHAR);
    else
       act("$1n is not fighting with $2n.", A_ALWAYS, self, char1, char2, TO_CHAR);
 } dilend

=== Target Validation ===
 dilbegin validate_attack_target(target : unitptr);
 var
    can_attack : integer;
 
 code
 {
    if (target == null)
    {
       act("No target specified.", A_ALWAYS, self, null, null, TO_CHAR);
       return FALSE;
    }
    
    if ((target.type != UNIT_ST_PC) and (target.type != UNIT_ST_NPC))
    {
       act("$1n is not a valid combat target.", A_ALWAYS, self, target, null, TO_CHAR);
       return FALSE;
    }
    
    can_attack := opponent(self, target);
    
    if (can_attack)
       act("You can attack $1n.", A_ALWAYS, self, target, null, TO_CHAR);
    else
       act("You are not in combat with $1n.", A_ALWAYS, self, target, null, TO_CHAR);
    
    return can_attack;
 } dilend

== Error Handling ==
Always validate parameters before calling opponent:

 if ((u1 != null) and (u2 != null) and
     ((u1.type == UNIT_ST_PC) or (u1.type == UNIT_ST_NPC)) and
     ((u2.type == UNIT_ST_PC) or (u2.type == UNIT_ST_NPC)))
 {
    result := opponent(u1, u2);
 }
 else
 {
    act("Invalid unit pointers for opponent check.", A_ALWAYS, self, null, null, TO_CHAR);
    return FALSE;
 }

== Related Functions/Fields ==
* [[set_fighting]] - Set two characters to fight each other
* [[fighting]] - Get current opponent of a character
* [[opponentcount]] - Number of opponents a character is fighting
* [[position]] - Character position (affects combat ability)
* [[CHAR_SELF_DEFENCE]] - Self-defense character flag
* [[CHAR_LEGAL_TARGET]] - Legal target character flag

== See Also ==
* [[unit_st_pc and unit_st_npc]] - Character-specific fields
* [[set_fighting]] - Manual combat setup
* [[fighting]] - Current opponent field
* [[meleeattack]] - Perform melee attack
* [[meleedamage]] - Calculate melee damage
* [[position]] - Character positioning system