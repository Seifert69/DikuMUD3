{
    "keyword": "opendiff",
    "opcode": "DILSF_OPENDIFF",
    "yacc_rule": "| DILSF_OPENDIFF /* .opendiff */\n{\n    INITEXP($$);\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_INT;\n    $$.dsl = DSL_LFT;\n    $$.num = DILF_OPENDIFF;\n}",
    "dilfe_name": "DILF_OPENDIFF",
    "c_implementation": "case DILF_OPENDIFF:\n            switch (dil_getval(v1))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n                case DILV_UP:\n                {\n                    auto *unit = reinterpret_cast<unit_data *>(v1->val.ptr);\n                    if (unit)\n                    {\n                        /* ubit8 openflags */\n                        v->atyp = DILA_NONE;\n                        v->type = DILV_UINT1R;\n                        v->ref = unit->getOpenDifficultyPtr();\n                    }\n                    else\n                    {\n                        v->type = DILV_FAIL; /* not applicable */\n                    }\n                }\n                break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n            break;",
    "dil_example": "dilbegin picklock(arg : string);\nexternal\n   integer is_hidden@basemove(u1 : unitptr, int1 : integer, u2 :unitptr);\n   string  dirstring@function(i2 : integer);\n   integer skillchecksa(skillidx : integer, abiidx : integer, difficulty : integer);\n   checkstand@basemove();\n   integer checkdoor@basemove(arg : string);\n\nvar\n   item       :  unitptr;\n   pc         :  unitptr;\n   arg1       :  string;\n   arg2       :  string;\n   arg3       :  stringlist;\n   dir        :  integer;\n   oppdir     :  intlist;\n   test       :  integer;\n   count      :  integer;\n   counter    :  integer;\n   hm         :  integer;\n   aa         :  integer;\n   ab         :  integer;\n   ba         :  integer;\n   bb         :  integer;\n\ncode\n{\n   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_PICK_LOCK] <= 0))\n   {\n      act(\"Perhaps you should practice first.\", A_ALWAYS, self, null, null, TO_CHAR);\n      quit;\n   }\n\n   checkstand@basemove();\n\n   if (arg == \"\")\n   {\n      act(\"Pick what?\", A_ALWAYS, self, null, null, TO_CHAR);\n      quit;\n   }\n\n   if (self.endurance < 1)\n   {\n      act(\"You're too exhausted to pick locks right now.\", A_SOMEONE, self, null, null, TO_CHAR);\n      quit;\n   }\n\n   /* next we see if the player has anything in his inventory or around him that he can lock */\n\n   arg1 := arg;       /* saves the string in case we need it later */\n\n   item := findunit(self, arg1, FIND_UNIT_HERE, null);\n\n   /* If there is no item or we cant see it, check the doors in the room */\n   if (item == null)\n      goto check_doors;\n\n   if (not visible(self, item))\n      goto check_doors;\n\n   if (isset(item.flags, UNIT_FL_BURIED))\n      goto check_doors;\n\n   /* If it cant be opened, it cant be locked. let the player know */\n   if (not isset(item.openflags, EX_OPEN_CLOSE))\n   {\n      act(\"That is impossible\", A_ALWAYS, self, null, null, TO_CHAR);\n      quit;\n   }\n\n   /* Check to make sure the object has a 'key' associated with it. */\n   if (item.key == \"\")\n   {\n      act(\"Odd, you can't seem to find a keyhole.\", A_ALWAYS, self, null, null, TO_CHAR);\n       quit;\n   }\n\n   /* See if it is opened */\n   if (not isset(item.openflags, EX_CLOSED))\n   {\n      act(\"It isn't even closed.....\", A_ALWAYS, self, item, null, TO_CHAR);\n      quit;\n   }\n\n   /* Check if it is locked */\n   if (not isset(item.openflags, EX_LOCKED))\n   {\n      act(\"Oh... it wasn't locked, after all.\", A_ALWAYS, self, item, null, TO_CHAR);\n      quit;\n   }\n\n   if (self.level < IMMORTAL_LEVEL)\n   {\n      if (isset(item.openflags, EX_PICKPROOF))\n         hm := -1;\n      else\n         hm := skillchecksa(SKI_PICK_LOCK, ABIL_DEX, item.opendiff);\n   }\n   else\n      hm := 1;    /* imms always pick */\n\n   if (hm < 0)\n   {\n      act(\"You fail to pick the $2N.\", A_ALWAYS, self, item, null, TO_CHAR);\n      act(\"$1n fails to pick the $2N.\", A_SOMEONE, self, item, null, TO_REST);\n      self.endurance := self.endurance + hm;\n      quit;\n   }\n\n   act(\"You successfully pick the $2N - *click*\", A_ALWAYS, self, item, null,TO_CHAR);\n   act(\"$1n picks the $2n - *click*\", A_ALWAYS, self, item, null, TO_REST);\n   unset(item.openflags, EX_LOCKED);\n   quit;\n\n\n:check_doors:\n   dir := checkdoor@basemove(arg);\n\n   item := self.outside;\n   if (item.type != UNIT_ST_ROOM)\n      item:=item.outside;\n      \n   if (not isset(item.exit_info[dir], EX_CLOSED))\n   {\n      act(\"Perhaps you should close it first....\", A_ALWAYS, self, null, null,TO_CHAR);\n      quit;\n   }\n\n   if (item.exit_key[dir] == \"\")\n   {\n      act(\"Odd - you can't seem to find a keyhole.\", A_ALWAYS, self, null, null, TO_CHAR);\n      quit;\n   }\n\n   if (not isset(item.exit_info[dir], EX_LOCKED))\n   {\n      act(\"Oh... it wasn't locked, after all.\", A_ALWAYS, self, null, null, TO_CHAR);\n      quit;\n   }\n\n   if (isset(item.exit_info[dir], EX_PICKPROOF))\n   {\n      act(\"This door seems to be pick proof.\",\n      A_ALWAYS, self, null, null, TO_CHAR);\n         act(\"$1n Tries to pick the door but finds it impossible.\",\n      A_SOMEONE, self, null, null, TO_REST);\n      quit;\n   }\n\n   if (self.level < IMMORTAL_LEVEL)\n   {\n      hm := skillchecksa(SKI_PICK_LOCK, ABIL_DEX, item.exit_diff[dir]);\n   }\n   else\n      hm := 100;    /* imms always pick */\n\n   if (hm < 0)\n   {\n      act(\"You fail to pick the $2t.\", A_ALWAYS, self, item.exit_names[dir].[0], null, TO_CHAR);\n      act(\"$1n fails to pick the $2t.\", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_REST);\n      self.endurance := self.endurance + hm;\n      quit;\n   }\n\n   act(\"You successfully pick the $2t - *click*\", A_ALWAYS, self, item.exit_names[dir].[0], null, TO_CHAR);\n   act(\"$1n picks the $2t - *click*\", A_HIDEINV, self, item.exit_names[dir].[0], null, TO_REST);\n\n   unset(item.exit_info[dir], EX_LOCKED);\n   unset(item.exit_to[dir].exit_info[oppdir.[dir]], EX_LOCKED);\n\n   pc := item.exit_to[dir].inside;\n\n   if (pc != null)\n      act(\"A soft *click* comes from the $2t.\", A_SOMEONE, pc, item.exit_to[dir].exit_names[oppdir.[dir]].[0], null, TO_ALL);\n   quit;\n} dilend"
}