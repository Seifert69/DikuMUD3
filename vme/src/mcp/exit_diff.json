{
    "keyword": "exit_diff",
    "opcode": "DILSF_EXITDIFF",
    "yacc_rule": "| DILSF_EXITDIFF idx /* .exit_difficulty */\n{\n    INITEXP($$);\n    copy_code(&($$), &($2));\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_INT;\n    $$.dsl = DSL_LFT;\n    $$.num = DILF_EXITDIFF;\n    FREEEXP($2);\n}",
    "dilfe_name": "DILF_EXITDIFF",
    "c_implementation": "case DILF_EXITDIFF:\n            v2 = p->stack.pop(); /* evaluate index */\n            switch (dil_getval(v1))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n                case DILV_UP:\n                    v->type = DILV_UINT1R;\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            switch (dil_getval(v2))\n            {\n                case DILV_FAIL:\n                    if (v->type != DILV_ERR)\n                    {\n                        v->type = DILV_FAIL; /* not applicable */\n                    }\n                    break;\n                case DILV_INT:\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n\n            if (v->type == DILV_UINT1R)\n            {\n                if (v1->val.ptr && ((unit_data *)v1->val.ptr)->isRoom() && is_in(v2->val.num, 0, MAX_EXIT) &&\n                    ROOM_EXIT((unit_data *)v1->val.ptr, v2->val.num))\n                {\n                    v->atyp = DILA_NONE;\n                    v->ref = ROOM_EXIT((unit_data *)v1->val.ptr, v2->val.num)->getSkillDifficultyPtr();\n                }\n                else\n                {\n                    v->type = DILV_FAIL;\n                }\n            }\n            break;",
    "dil_example": "dilbegin climb_dil(arg : string);\nexternal\n   checkstand();\n   integer checkexit(arg : string, bMessage:integer);\n   string  dirstring@function(int123 : integer);\n   integer is_hidden(unit2 : unitptr, int1 : integer, unit23 : unitptr);\n   integer skillchecksa@skills(skillidx : integer, abiidx : integer, difficulty : integer);\n   string exitname@function(room:unitptr, dir:integer);\n   fall_dil(damage:integer);\n   look_blank@baselook(l1 : unitptr, str12 : string);\n\nvar\n   fall_to:string;\n   res:integer;\n   args:stringlist;\n   first_arg:string;\n   last_arg:string;\n   len_arg:integer;\n   in_vehicle:integer;\n   dir         :  integer;\n   send_dir         :string; \n   dir_name:string;\n   room:unitptr;\n   room_going:unitptr;\n   i:integer;\n   skilla:integer;\n   skillb:integer;\n   hm : integer; \n   difficulty:integer;\n   damage:integer;\n   amount:integer;\n   percent:integer;\n   exd : extraptr;\n   dmg : integer;\n   exit_name : string;\n   \ncode\n{\n   heartbeat := PULSE_SEC * 5;\n   checkstand();\n\n   if (self.endurance < 10)\n   {\n      act(\"You are too exhausted.\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   if (arg == \"\")\n   {\n      act(\"Climb what?\", A_ALWAYS, self, null, null, TO_CHAR);\n      return;\n   }\n\n   room := self.outside;\n   if (room.type != UNIT_ST_ROOM)\n   {\n      act(\"You can't climb while inside $2n.\", A_SOMEONE, self, room, null, TO_CHAR);\n      return;      \n   }\n\n   dir := checkexit(arg, 1);\n   dir_name := dirstring@function(dir);\n   exit_name := exitname@function(room, dir);\n\n   if (isset(room.exit_info[dir], EX_CLOSED))\n   {\n      act(\"The $2t seems to be closed.\", A_SOMEONE, self, exit_name, null, TO_CHAR);\n      return;\n   }\n\n   if (not isset(room.exit_info[dir], EX_CLIMB))\n   {\n      act(\"Doesn't seem like you have to climb the $2t, perhaps just try to move normally?\", A_SOMEONE, self, exit_name, null, TO_CHAR);\n      return;\n   }\n\n   /*\n   * test for success and fail including endurance loss\n   *\tincluding drunk code\n   */\t\n\n   room_going := room.exit_to[dir];\n   difficulty := room.exit_diff[dir];\n\n   if (self.drunk > 0)\n   {\n      difficulty := difficulty + 5 * self.drunk;\n      act(\"Climbing under influence isn't easy.\", A_SOMEONE, self, null, null, TO_CHAR);\n   }\n\n   hm := skillchecksa@skills(SKI_CLIMB, ABIL_DEX, difficulty);\n   dmg := 5; /* Default: 5 hits per 10 fail */\n\n   exd := room.extra.[\"$climb_\"+dir_name];\n   if (exd != null)\n   {\n      if (exd.vals != null)\n      {\n         dmg := exd.vals.[0];\n      }\n   }\n\n   self.endurance := self.endurance-6;\n\n   if (hm <= 0)\n   {\n      dmg := dmg * (-hm / 10);\n\n      act(\"You begin climbing the $2t but slip and fall.\",\tA_ALWAYS, self, exit_name, null, TO_CHAR);\n      act(\"$1n begins climbing the $2t but slips and falls.\", A_HIDEINV, self, exit_name, null, TO_ROOM);\n      dilcopy(\"fall_dil@basemove(\"+itoa(dmg)+\")\", self);\n      quit;\n   }\n\n   /* Issue the command() stuff so that all movers send the command \"north\" etc to the mud.\n   //                        sendtext(\"after endurance test<br/>\",self);\n   *   This is necessary for dils like the guard dil.\n   */\n\n   res := send_pre(dirstring@function(dir), self, null, null, 0, arg, null);\n   if (res != SFR_SHARE)\n      quit;\n\n   res := send_pre(\"climb\", self, null, null, 0, arg, null);\n   if (res != SFR_SHARE)\n      quit;\n\n   link(self, room_going);\n\n   act(\"$1n climbs in on the $2t.\", A_HIDEINV, self, arg , null, TO_ROOM);\n\n   look_blank@baselook(self, \":brief:\");   /* get the rooms contents.  The :brief: tells the look dil*/\n\n   send_done(\"climb\", self, null, null, 0, \"\", null, CMD_AUTO_NONE);\n   send_done(dirstring@function(dir), self, null, null, 0, \"\", null, CMD_AUTO_NONE);\n   quit;\n} dilend"
}