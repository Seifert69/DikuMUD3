Generate MCP entry for DIL keyword: fits

=== Yacc rule ===
| DILSE_FIT '(' dilexp ',' dilexp ',' dilexp ')'
{
    INITEXP($$);

    if ($3.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 1 of 'fits' not an unitptr.");
    }
    else if ($5.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 2 of 'fits' not an unitptr.");
    }
    else if ($7.typ != DilVarType_e::DILV_INT)
    {
        dilfatal("Arg 3 of 'fits' not an integer.");
    }
    else
    {
        /* Type is ok */
        /* Make nodes dynamic */
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_SP;

        make_code(&($3));
        make_code(&($5));
        make_code(&($7));

        add_code(&($$), &($3));
        add_code(&($$), &($5));
        add_code(&($$), &($7));
        add_ubit8(&($$), DILE_FIT);
    }

    FREEEXP($3);
    FREEEXP($5);
    FREEEXP($7);
}

=== C implementation ===
void dilfe_fits(dilprg *p)
{
    dilval *v = new dilval;
    dilval *v3 = p->stack.pop();
    dilval *v2 = p->stack.pop();
    dilval *v1 = p->stack.pop();
    char *c = nullptr;

    v->type = DILV_SP;

    switch (dil_getval(v1))
    {
        case DILV_UP:
            if (!v1->val.ptr || !((unit_data *)v1->val.ptr)->isChar())
            {
                v->type = DILV_FAIL;
            }
            else
            {
                switch (dil_getval(v2))
                {
                    case DILV_UP:
                        if (!v2->val.ptr || !((unit_data *)v2->val.ptr)->isObj())
                        {
                            v->type = DILV_FAIL;
                        }
                        else
                        {
                            switch (dil_getval(v3))
                            {
                                case DILV_INT:
                                    c = obj_wear_size((unit_data *)v1->val.ptr, (unit_data *)v2->val.ptr, v3->val.num);

                                    v->atyp = DILA_EXP;
                                    v->val.ptr = str_dup(c == nullptr ? "" : c);
                                    break;
                                default:
                                    v->type = DILV_ERR;
                                    break;
                            }
                        }
                        break;
                    case DILV_NULL:
                    case DILV_FAIL:
                        v->type = DILV_FAIL;
                        break;
                    default:
                        v->type = DILV_ERR;
                        break;
                }
            }

            break;
        case DILV_NULL:
        case DILV_FAIL:
            v->type = DILV_FAIL;
            break;
        default:
            v->type = DILV_ERR;
            break;
    }

    p->stack.push(v);
    delete v1;
    delete v2;
    delete v3;
}

=== DIL example ===
dilbegin resize_func(item1:integer, item2:integer, item3:integer,
                     arm_type:integer, arm_type2:integer,
                     cash:integer, a_name:string);
external
  string accept_dil@function (pc:unitptr,s:string);
var
  mn:string;
  answer:string;
  i:integer;
  amount:integer;
  pc:unitptr;
  size:string;
  tgt:unitptr;
  diff:integer;
code
{
   heartbeat := PULSE_SEC*5;
   :start:
   wait (SFB_DONE,command ("give") and
	 (self==target));

   if (not (visible(self, activator)))
   {
      exec("say I can't resize it when I can't see you!.",self);
      exec("drop "+medium.name, self);
      goto start;
   }

   pc := activator;
   secure (pc,lostpc);
   tgt := medium;
   secure (tgt,lostitem);
   dilcopy ("busy@function(Please wait I am busy with other work right now.",
            self);

   if (not (tgt.type&UNIT_ST_OBJ))
   {
      exec ("say I can't resize that, "+pc.name+".",self);
      :giveit:
      link (tgt, pc);
      act ("$2n gives $3n to $1n",
	   A_SOMEONE,pc,self,tgt,TO_REST);
      act ("$2n gives $3n to you.",
	   A_SOMEONE,pc,self,tgt,TO_CHAR);
      i := dildestroy ("busy@function",self);
      unsecure (pc);
      unsecure (tgt);
      goto start;
   }

   if ("$resize" in tgt.extra)
   {
      exec ("say It cant be resize any more, "+pc.name+".",self);
      goto giveit;
   }

   if ((tgt.objecttype != item1) and
       (tgt.objecttype != item2) and
       (tgt.objecttype != item3))
   {
      exec ("say I can not resize this, I am only a "+a_name+".",self);
      goto giveit;
   }


   if (tgt.objecttype == ITEM_ARMOR)
   {
      if ((tgt.value[0]!=arm_type) and
          (arm_type2!=tgt.value[0]))
      {
         exec ("say I can't resize that I am only a "+a_name+".",self);
         goto giveit;
      }
   }

   amount := (100*tgt.height) / pc.height;
   if (amount > 100)
     diff := amount - 100;
   else
     diff := 100 - amount;

   if (diff==0) goto  no_need;
   i := cash*diff;
   mn := moneystring(i, TRUE);

   exec ("say That will cost "+mn+" to have that resized.",self);

   answer := accept_dil@function(pc, "Do you want this resized or not?");
   pause;

   if (answer=="no")
      goto no;

   if (transfermoney(pc, self, i))
   {
      exec ("resize "+tgt.name+" "+pc.name,self);

      if (not ("$resized" in tgt.extra))
      {
         exec ("say I am sorry, I do not seem to be able to resize this, "+
               "after all I am just a "+a_name+".",self);
         diff := transfermoney(self,pc, i);
         goto giveit;
      }

      exec ("say There you go, thats the best I can do.",self);
      goto giveit;
   }
   else
     goto no_money;

   :no:
   exec ("say Very well then come back when you want me to.",self);
   goto giveit;

   :no_need:
   exec ("say It already fits you. I should charge you for "+
         "waisting my time!",self);
   goto giveit;

   :no_money:
   exec ("say You don't seem to have enough money. Come back when you "+
         "have found enough to pay me.",self);
   goto giveit;

   :lostpc:
   :lostitem:
   i := dildestroy ("busy@function",self);

   unsecure (pc);
   unsecure (tgt);
   goto start;
} dilend
