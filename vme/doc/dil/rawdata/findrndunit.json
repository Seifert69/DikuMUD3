{
    "keyword": "findrndunit",
    "opcode": "DILSE_FNDRU",
    "yacc_rule": "| DILSE_FNDRU '(' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'findrndunit' not an unitptr.\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 2 of 'findrndunit' not an integer.\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 3 of 'findrndunit' not an integer\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_UP;\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_ubit8(&($$), DILE_FNDRU);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n}",
    "dilfe_name": "dilfe_fndru",
    "c_implementation": "void dilfe_fndru(dilprg *p)\n{\n    dilval *v = new dilval;\n    /* Find a unit */\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    switch (dil_getval(v1))\n    {\n        case DILV_FAIL:\n            v->type = DILV_FAIL;\n            break;\n        case DILV_UP:\n            if (v1->val.ptr)\n            {\n                v->type = DILV_UP;\n            }\n            else\n            {\n                v->type = DILV_NULL; /* not applicable UP */\n            }\n            break;\n        case DILV_NULL:\n            v->type = DILV_NULL;\n            break;\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    switch (dil_getval(v2))\n    {\n        case DILV_FAIL:\n            if (v->type != DILV_ERR)\n            {\n                v->type = DILV_FAIL;\n            }\n            break;\n        case DILV_INT:\n            break;\n\n        case DILV_NULL:\n            if ((v->type != DILV_ERR) && (v->type != DILV_FAIL))\n            {\n                v->type = DILV_NULL; /* not applicable */\n            }\n            break;\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n\n    switch (dil_getval(v3))\n    {\n        case DILV_FAIL:\n            if (v->type != DILV_ERR)\n            {\n                v->type = DILV_FAIL;\n            }\n            break;\n        case DILV_INT:\n            break;\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n\n    if (v->type == DILV_UP)\n    {\n        v->atyp = DILA_NORM;\n        v->val.ptr = random_unit((unit_data *)v1->val.ptr, v2->val.num, v3->val.num);\n\n        if (!v->val.ptr)\n        {\n            v->type = DILV_NULL;\n        }\n    }\n    else\n    {\n        v->type = DILV_FAIL;\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n}",
    "dil_example": "dilbegin gift_func(count:integer,i:integer);\nexternal\n  string gift_name (i:integer);\nvar\n item: unitptr;\n  namer:string;\n  place:unitptr;\n  gift:unitptr;\ncode\n{\n  namer:=gift_name(count);\n  gift:=load (namer+\"@\"+\"hallows23\");\n\nif ((gift.nameidx == \"tot_bag2\") and (gift.loadcount > 250))\n{\ndestroy(gift);\nreturn;\n}\nelse if ((gift.nameidx == \"tot_bag3\") and (gift.loadcount > 175))\n{\ndestroy(gift);\nreturn;\n}\nelse if ((gift.nameidx == \"tot_bag4\") and (gift.loadcount > 150))\n{\ndestroy(gift);\nreturn;\n}\n\n\n  log(\"loaded\"+namer+\"@\"+\"hallows23\");\n\n\n  :loop:\n  if (i==0)\n  place:=findrndunit (self,FIND_UNIT_WORLD,UNIT_ST_NPC);\n  else\n  place:=findrndunit (self,FIND_UNIT_WORLD,UNIT_ST_ROOM);\n\n  if ((place==null) or\n  (place==self)) goto loop;\n\nitem:=place;\n\nwhile (item.type!=UNIT_ST_ROOM)\n {\n if (item.type==UNIT_ST_PC)\n   goto loop;\n  item:=item.outside;\n  }\n\n  link (gift,place);\n  return ;\n  } dilend"
}