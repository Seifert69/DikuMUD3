Generate MCP entry for DIL keyword: changecolor

=== Yacc rule ===
| DILSE_CHGCLR '(' dilexp ',' dilexp ',' dilexp ')'
{
    INITEXP($$);

    if ($3.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 1 of 'changecolor' not a unitptr");
    }
    if ($5.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 2 of 'changecolor' not a string");
    }
    if ($7.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 3 of 'changecolor' not a string");
    }
    else
    {
        /* Type is ok */
        /* Make nodes dynamic */
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_INT;
        make_code(&($3));
        make_code(&($5));
        make_code(&($7));
        add_code(&($$), &($3));
        add_code(&($$), &($5));
        add_code(&($$), &($7));
        add_ubit8(&($$), DILE_CHGCLR);
    }
    FREEEXP($5);
    FREEEXP($7);
}

=== C implementation ===
void dilfe_clrchg(dilprg *p)
{
    dilval *v = new dilval;

    char full_name[21];
    char *color = nullptr;
    unsigned int x = 0;
    dilval *v3 = p->stack.pop();
    dilval *v2 = p->stack.pop();
    dilval *v1 = p->stack.pop();

    v->type = DILV_INT;
    switch (dil_getval(v1))
    {
        case DILV_NULL:
            v->type = DILV_FAIL;
            break;
        default:
            v->type = DILV_ERR;
        case DILV_UP:
            switch (dil_getval(v2))
            {
                case DILV_FAIL:
                case DILV_NULL:
                    v->type = DILV_FAIL;
                    break;
                default:
                    v->type = DILV_ERR;
                case DILV_SP:
                    switch (dil_getval(v3))
                    {
                        default:
                            v->type = DILV_ERR;
                        case DILV_FAIL:
                        case DILV_NULL:
                            v->type = DILV_FAIL;
                            break;
                        case DILV_SP:

                            if (!((unit_data *)v1->val.ptr)->isPC())
                            {
                                szonelog(p->sarg->owner->getFileIndex()->getZone(),
                                         "DIL %s, Illegal: Tried to change a color to a non pc.\n",
                                         p->sarg->owner->getFileIndexSymName());
                                v->type = DILV_FAIL;
                            }

                            if (strlen((char *)v2->val.ptr) > 20)
                            {
                                szonelog(p->sarg->owner->getFileIndex()->getZone(),
                                         "DIL %s, Illegal: Color key is greater than 20 characters.\n",
                                         p->sarg->owner->getFileIndexSymName());
                                v->type = DILV_FAIL;
                            }

                            x = 0;
                            while (x < strlen((char *)v2->val.ptr))
                            {
                                if ((!isalnum(*((char *)v2->val.ptr + x))) && (*((char *)v2->val.ptr + x) != '_'))
                                {
                                    szonelog(p->sarg->owner->getFileIndex()->getZone(),
                                             "DIL %s, Illegal: Color key contains invalid characters.\n",
                                             p->sarg->owner->getFileIndexSymName());
                                    v->type = DILV_FAIL;
                                    break;
                                }
                                x++;
                            }

                            if (v->type != DILV_FAIL)
                            {
                                auto *pc = reinterpret_cast<pc_data *>(v1->val.ptr);
                                if (UPC(pc)->getColor().get((char *)v2->val.ptr, full_name).empty() == false)
                                {
                                    color = str_escape_format((char *)v3->val.ptr, FALSE);
                                    auto unused = UPC(pc)->getColor().change((char *)v2->val.ptr, color);
                                    FREE(color);
                                    v->type = DILV_INT;
                                    v->val.num = TRUE;
                                }
                                else
                                {
                                    v->type = DILV_INT;
                                    v->val.num = FALSE;
                                }
                            }
                            break;
                    }

                    break;
            }

            break;
    }

    p->stack.push(v);
    delete v1;
    delete v2;
    delete v3;
}

=== DIL example ===
dilbegin not_used(arg : string);
code
{
   // The functions in comments here have not been used in any DIL program.
   // I suppose they're considered obsolete until someone needs them
   // and they get tested.
   //
   // buf := getcolor("&br"); -- NOT USED ANYWHERE
   // buf := addcolor(); --NOT USED ANYWHERE
   // buf := delcolor(); --NOT USED ANYWHERE
   // buf := changecolor(); --NOT USED ANYWHERE
   // buf := getcmd(); --NOT USED ANYWHERE
   // buf := clone(); --NOT USED ANYWHERE
   // buf := global_head(); --NOT USED ANYWHERE
   // buf := obj_head(); --NOT USED ANYWHERE
   // buf := npc_head(); --NOT USED ANYWHERE
   // buf := room_head(); --NOT USED ANYWHERE
   // buf := zone_head(); --NOT USED ANYWHERE
   // buf := command_head(); --NOT USED ANYWHERE
   // buf := strncmp(); --NOT USED ANYWHERE
   // buf := check_password(); --NOT USED ANYWHERE
   // buf := acc_total(); --NOT USED ANYWHERE
   // buf := loglevel(); --NOT USED ANYWHERE
   // buf := spell_levels(); --NOT USED ANYWHERE
   // buf := spell_costs(); --NOT USED ANYWHERE
   // buf := hasfunc(); --NOT USED ANYWHERE
   // buf := ability_levels(); --NOT USED ANYWHERE
   // buf := ability_costs(); --NOT USED ANYWHERE
   // buf := weapon_levels(); --NOT USED ANYWHERE
   // buf := weapon_costs(); --NOT USED ANYWHERE
   // buf := skill_levels(); --NOT USED ANYWHERE
   // buf := skill_costs(); --NOT USED ANYWHERE
   // buf := lastroom(); --NOT USED ANYWHERE
   // buf := unit.objs(); --NOT USED ANYWHERE
   // buf := unit.roomcount(); --NOT USED ANYWHERE
   // buf := unit.objcount(); --NOT USED ANYWHERE
   // buf := unit.npccount(); --NOT USED ANYWHERE
   // buf := unit.resetmode(); --NOT USED ANYWHERE
   // buf := unit.loadlevel(); --NOT USED ANYWHERE

   quit;
} dilend
