{
    "keyword": "illum",
    "opcode": "DILSF_ILL",
    "yacc_rule": "| DILSF_ILL /* .illum */\n{\n    INITEXP($$);\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_INT;\n    $$.dsl = DSL_DYN;\n    $$.num = DILF_ILL;\n}",
    "dilfe_name": "DILF_ILL",
    "c_implementation": "case DILF_ILL:\n            switch (dil_getval(v1))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n                case DILV_UP:\n                    if (v1->val.ptr)\n                    {\n                        v->atyp = DILA_NONE;\n                        v->type = DILV_INT;\n                        v->val.num = ((unit_data *)v1->val.ptr)->getTransparentLightOutput();\n                    }\n                    else\n                    {\n                        v->type = DILV_FAIL; /* not applicable */\n                    }\n                    break;\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n            break;",
    "dil_example": "dilbegin aware do_set(base_arg: string);\n\nexternal integer search_block(str: string, lst: stringlist);\n         integer get_bit(arg: string, struct: string);\n         integer get_type(arg: string, struct: string);\n         stringlist get_mwords(arg: string);\n\n         string unit_fi_data(field: integer, subf: integer);\n\n         show_fields();\n\nvar arg   : string;\n    targ  : unitptr;\n    tgt   : string;\n    ext   : extraptr;\n\n    field : integer;\n    lvl   : integer;\n    ut    : integer;\n    at    : integer;\n\n    valarg: integer;\n    typarg: integer;\n    strarg: string;\n    untarg: unitptr;\n\n    s     : string;\n    st    : string;\n    l     : integer;\n    sl    : stringlist;\n\ncode\n{\n    if (self.type != UNIT_ST_PC) \n        quit;\n\n    if (base_arg == \"\")\n    {\n        sendtext(\"Syntax: set &lt;name&gt; &lt;field&gt; &lt;arguments&gt;.<br/>\", self);\n        quit;\n    }\n\n    /* Find target */\n    tgt:= base_arg;\n    arg:= getword (base_arg);\n\n    if (arg == \"room\")\n        targ := self.outside;\n    else if (arg == \"self\")\n        targ := self;\n    else\n    {\n        base_arg := arg + \" \" + base_arg;\n        targ := findunit (self, base_arg, FIND_UNIT_HERE, null);\n\n        if (targ == null)\n        {\n            sendtext(\"No such thing around.<br/>\", self);\n            quit;\n        }\n        else if ((targ.type == UNIT_ST_OBJ) and (targ.objecttype == ITEM_MONEY))\n        {\n            sendtext(\"You can't modify money yet, sorry.<br/>\", self);\n            quit;\n        }\n    }\n\n    /* Find field to change */\n    :find_field:\n\n    arg:= getword (base_arg);\n\n    field:= search_block(arg, UNIT_FIELD_NAMES);\n\n    if ((field == -1) or (arg == \"\"))\n    {\n        sendtext(\"Invalid field.<br/>\", self);\n        show_fields();\n        quit;\n    }\n\n    /* check if level of users is ok */\n    s:= unit_fi_data(field, FI_MIN_PC);\n    lvl:= atoi(s);\n\n    if ((targ.type == UNIT_ST_PC) and (targ != self) and\n        (self.level < lvl))\n        {\n        sendtext(\"Authority to set field for OTHER PLAYERS denied!<br/>\", self);\n        return;\n        }\n\n\n    s:= unit_fi_data(field, FI_MIN_SLF);\n    lvl:= atoi(s);\n        \n    if ((targ.type == UNIT_ST_PC) and (targ == self) and\n    (self.level < lvl))\n    {\n    sendtext(\"Authority to set field for yourself denied!<br/>\", self);\n    return;\n    }\n\n\n    s:= unit_fi_data(field, FI_MIN_OTH);\n    lvl:= atoi(s);\n\n    if ((targ.type != UNIT_ST_PC) and (targ != self) and\n        (self.level < lvl))\n    {\n    sendtext(\"Authority to set field denied!<br/>\", self);\n    return;\n    }\n\n    /* see if field is valid for unit */\n    s:= unit_fi_data(field, FI_UTYPE);\n    ut:= atoi(s);\n\n    if (((ut == UT_RM )  and (targ.type != UNIT_ST_ROOM)) or\n        ((ut == UT_OBJ)  and (targ.type !=  UNIT_ST_OBJ)) or\n        ((ut == UT_NPC)  and (targ.type !=  UNIT_ST_NPC)) or\n        ((ut == UT_PC )  and (targ.type !=   UNIT_ST_PC)) or\n        ((ut == UT_CH )  and not(targ.type & UNIT_ST_PC|UNIT_ST_NPC)))\n        {\n        sendtext(\"Field invalid for type of unit.<br/>\", self);\n        quit;\n        }\n\n    s:= unit_fi_data(field, FI_ATYPE);\n    at:= atoi(s);\n\n    if (at == AT_STR)\n        if (base_arg == \"\")\n            {\n            sendtext (\"Argument expected.<br/>\", self);\n            quit;\n            }\n\n/* if (at == AT_DES) */\n    /* currently void */\n\nif (at == AT_VAL)\n    {\n    sendtext(\"Arg:<value><br/>\", self);\n    arg := getword(base_arg);\n\n    if (arg == \"\")\n        {\n        sendtext(\"Numeric argument expected.<br/>\", self);\n        quit;\n        }\n\n    valarg := atoi(arg);\n    sendtext(\"Value is \"+itoa(valarg)+\"<br/>\", self);\n    }\n\nif (at == AT_BIT)\n    {\n    sendtext(\"Arg:<bitlist><br/>\", self);\n    arg := getword(base_arg);\n\n    s := unit_fi_data(field, FI_STRUCT);\n    valarg := get_bit(arg, s);\n\n    if (valarg == -1) \n        {\n        sendtext(\"Invalid or missing bit for field<br/><br/>\",self);\n        quit;\n        }\n\n    sendtext (\"Bit found is \"+itoa(valarg)+\"<br/>\", self);\n    }\n\nif (at == AT_TYP)\n    {\n    sendtext(\"Arg:<type><br/>\", self);\n    arg := getword(base_arg);\n    \n    s := unit_fi_data(field, FI_STRUCT);\n    typarg := get_type(arg, s);\n\n    if (typarg == -1) \n        {\n        sendtext(\"Invalid or missing bit for field<br/><br/>\",self);\n        quit;\n        }\n\n    /* Find a way to put type in a word, later on */\n    sendtext (\"Type found is \"+itoa(typarg)+\"<br/>\", self);\n    }\n \nif (at == AT_UNT)\n    {\n    sendtext(\"Arg:<unitpath><br/>\",self);\n    strarg := getword(base_arg);\n    \n    untarg := load(strarg);\n\n    if (untarg == null)\n        {\n        sendtext(\"Invalid or missing unit path for field.<br/>\", self);\n        quit;\n        }\n    sendtext(\"Unit pointer is [\"+untarg.nameidx+\"@\"+untarg.zoneidx+\"]<br/>\", self);\n\n    destroy (untarg);\n    }\n\nif (at == AT_KEYDES)\n    {\n    sendtext (\"Arg:&lt;string&gt; (description)<br/>\", self);\n    if (base_arg == \"\")\n        {\n        sendtext (\"Missing string argument.<br/>\", self);\n        quit;\n        }\n    /* DES part currently void */\n    }\n\nif (at == AT_TYPVAL)\n    {\n    sendtext(\"Arg:<type> <value><br/>\", self);\n    arg := getword(base_arg);\n\n    s := unit_fi_data(field, FI_STRUCT);\n    typarg := get_type(arg, s);\n\n    if (typarg == -1) \n        {\n        sendtext(\"Invalid or missing bit for field<br/><br/>\",self);\n        quit;\n        }\n\n    sendtext(\"Type found is \"+itoa(typarg)+\"<br/>\", self);\n\n    arg := getword(base_arg);\n    if (arg == \"\")\n        {\n        sendtext(\"Numeric argument expected.<br/>\", self);\n        quit;\n        }\n\n    valarg := atoi(arg);\n    sendtext(\"Value is \"+itoa(valarg)+\"<br/>\", self);\n    }\n\nif (at == AT_DIRBIT)\n    {\n    sendtext(\"Arg:<direction> <bitlist><br/>\", self);\n    arg := getword(base_arg);\n\n    typarg := get_type(arg, \"dirs\");\n    \n    if ((typarg == -1) or (arg == \"\"))\n        {\n        sendtext(\"Invalid direction.<br/>\", self);\n        quit;\n        }\n\n    sl := DIR_STRUCT;\n    sendtext (\"Direction found is \"+sl.[typarg]+\" [\"+itoa(typarg)+\n        \"]<br/>\", self);\n\n    arg := getword(base_arg);\n\n    s := unit_fi_data(field, FI_STRUCT);\n    valarg := get_bit(arg, s);\n\n    if (valarg == -1)\n        {\n        sendtext(\"Invalid or missing bit for field.<br/>\", self);\n        quit;\n        }\n\n    sendtext (\"Bit found is \"+itoa(valarg)+\"<br/>\", self);\n    }\n\nif (at == AT_DIRSTR)\n    {\n    sendtext(\"Arg:&lt;direction&gt; &lt;string&gt;<br/>\", self);\n\n    arg := getword(base_arg);\n    typarg := get_type(arg, \"dirs\");\n    \n    if ((typarg == -1) or (arg == \"\"))\n        {\n        sendtext(\"Invalid direction.<br/>\", self);\n        quit;\n        }\n\n    sl := DIR_STRUCT;\n    sendtext (\"Direction found is \"+sl.[typarg]+\" [\"+itoa(typarg)+\n        \"]<br/>\", self);\n\n    if (base_arg == \"\")\n        {\n        sendtext(\"Missing string argument.<br/>\", self);    \n        quit;\n        }\n\n     }\n\nif (at == AT_DIRUNT)\n    {\n    sendtext(\"Arg:&lt;direction&gt; &lt;unitpath&gt;<br/>\", self);\n\n    arg := getword(base_arg);\n    typarg := get_type(arg, \"dirs\");\n    \n    if ((typarg == -1) or (arg == \"\"))\n        {\n        sendtext(\"Invalid or missing direction.<br/>\", self);\n        quit;\n        }\n\n    sl := DIR_STRUCT;\n    sendtext (\"Direction found is \"+sl.[typarg]+\" [\"+itoa(typarg)+\n        \"]<br/>\", self);\n    \n    arg := getword(base_arg);\n\n    untarg := load(arg);\n    if (untarg == null)\n        {\n        sendtext(\"Invalid or missing unit path for field.<br/>\", self);\n        quit;\n        }\n\n    sendtext(\"Unit pointer is [\"+untarg.nameidx+\"@\"+untarg.zoneidx+\"]<br/>\", self);\n\n    destroy (untarg);\n    }        \n\nif (at == AT_DIRDES)\n    {\n    sendtext(\"Arg:&lt;direction&gt; (description)<br/>\", self);\n    \n    arg := getword(base_arg);\n    typarg := get_type(arg, \"dirs\");\n    \n    if ((typarg == -1) or (arg == \"\"))\n        {\n        sendtext(\"Invalid or missing direction.<br/>\", self);\n        quit;\n        }\n\n    sl := DIR_STRUCT;\n    sendtext (\"Direction found is \"+sl.[typarg]+\" [\"+itoa(typarg)+\n        \"]<br/>\", self);\n    \n    /* DES part currently void */\n    }\n\nif ((at < 1) and (at > 13))\n    {\n    sendtext(\"Forbidden argument type for field, please contact \"+\n        \"implementators.<br/>\", self);\n    quit;\n    }\n\n\n/* The actual data will now be set */\n/* field is the set field being changed */\n\nif (field == 0)         /* add-name */\n    {\n    if ((targ.type == UNIT_ST_PC) and (self.level < 255))\n        {\n        sendtext(\"Not allowed to modify PC's.<br/>\", self);\n        quit;\n        }\n\n    addstring(targ.names, base_arg);\n    sendtext(\"The extra name was added.<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 1)         /* del-name */\n    {\n    if (length(targ.names) < 2)\n        {\n        sendtext(\"Must have a minimum of one name.<br/>\", self);\n        quit;\n        }\n    \n    substring(targ.names, base_arg);\n    sendtext(\"Name may have been deleted.<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 2)         /* title */\n    {\n    targ.title := base_arg;\n    sendtext(\"Title modified.<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 3)         /* outside description */\n    {\n    sendtext(\"Modifying long outside description.<br/>\", self);\n\n    secure (targ, lost);\n\n    beginedit(self);\n    wait (SFB_EDIT, (self == activator));\n    strarg := textformat(argument);\n\n    targ.outside_descr := strarg;\n    unsecure (targ);\n\n    goto end_set;\n    }\n        \nif (field == 4)         /* add-extra */\n    {\n    /* Should now accept extra names with more than one word */\n    sl := get_mwords(base_arg);\n\n    if (sl.[0] == \"\")\n        {\n        sendtext (\"No extra names given.<br/>\", self);\n        quit;\n        }\n\n    sendtext(\"Searching for \"+sl.[0]+\".<br/>\", self);\n\n    ext := sl.[0] in targ.extra;\n\n    if (not ext)\n        {\n        sendtext(\"New field.<br/>\", self);\n        addextra (targ.extra, sl, \"\");\n        }\n\n    /* Add the rest of the names if they do not exist */\n    else\n        {\n        l := 0;\n        while (l < length(sl))\n            {\n            if (not (sl.[l] in ext))\n                addstring (ext.names, sl.[l]);\n            l := l + 1;\n            }\n\n        sendtext(\"Modifying existing description.<br/>\", self);\n        }\n\n    secure (targ, lost);\n\n    beginedit(self);\n    wait(SFB_EDIT, (self == activator));\n    strarg := textformat(argument);\n\n    ext := sl.[0] in targ.extra;\n    ext.descr := strarg;\n\n    unsecure (targ);\n    goto end_set;\n    }\n\nif (field == 5)         /* del-extra */\n    {\n    if (base_arg == \"\")\n        {\n        sendtext(\"You must supply a field name.<br/>\", self);\n        quit;\n        }\n\n    if (not (base_arg in targ.extra))\n        {\n        sendtext(\"No field with that keyword.<br/>\", self);\n        quit;\n        }\n\n    subextra (targ.extra, base_arg);\n    sendtext(\"Field deleted.<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 6)         /* manipulate */\n    {\n    targ.manipulate := valarg;\n    goto end_set;\n    }\n\nif (field == 7)         /* unit-flags */\n    {\n    targ.flags := valarg;\n    goto end_set;\n    }\n\nif (field == 8)         /* weight */\n    {\n    set_weight_base(targ, valarg);\n    goto end_set;\n    }\n\nif (field == 9)         /* capacity */\n    {\n    targ.capacity := valarg;\n    goto end_set;\n    }\n    \nif (field == 10)        /* max_hp */\n    {\n    targ.max_hp := valarg;\n    goto end_set;\n    }\n\nif (field == 11)        /* hp */\n    {\n    targ.hp := valarg;\n    goto end_set;\n    }\n\nif (field == 12)        /* key */\n    {\n//targ.key :=base_arg;\n// untarg; \nsendtext (targ.key,self);\n    sendtext(\"Key needed modified to \"+base_arg+\".<br/>\", self);\n\n    goto end_set;\n    }\n\nif (field == 13)        /* alignment */\n    {\n    if ((valarg >= -1000) and (valarg <= 1000))\n        targ.alignment := valarg;\n    else\n        sendtext(\"Value must be in -1000..+1000!<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 14)        /* open-flags */\n    {\n    targ.openflags := valarg;\n    goto end_set;\n    }\n\nif (field == 15)        /* tgh OBSOLETE */\n    {\n/*  targ.tgh := valarg; */\n    goto end_set;\n    }\n    \nif (field == 16)        /* lights */\n    {\n    /* Light and illum disabled for now for problems caused by them */\n/*    targ.light := valarg; */\n    setbright(targ, valarg);\n/*    targ.illum := valarg; */\n\n    sendtext(\"WARNING: This value is absolute and will cause 'darkness' \"+\n        \"bugs if not used properly! Only use this to fix darkness\"+\n        \" - use bright for changing the illumination!<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 17)        /* bright */\n    {\n    if ((valarg < -6) or (valarg > 6))\n        {\n        sendtext(\"Value expected -6..+6<br/>\", self);\n        quit;\n        }\n\n    setbright (targ, valarg);\n    goto end_set;\n    }\n\nif (field == 18)        /* room-flags */\n    {\n    targ.roomflags := valarg;\n    goto end_set;\n    }\n\nif (field == 19)        /* movement */\n    {\n    targ.movement := typarg;\n    goto end_set;\n    }\n\nif (field == 20)        /* cc-info */\n    {\n    /* Trash */\n    if (valarg == -1)\n        {\n        sendtext(\"Erasing CC information.<br/>\", self);\n        /* Ask Whistler about how this is handled:\n        PC_ACCOUNT(unt).last4  = -1;\n        */\n/*        targ.crack := 0; */\n        }\n\n    else\n        {\n        if ((valarg >= 0) and (valarg <= 9999))\n            {\n            sendtext(\"Setting CC information.<br/>\", self);\n/*            PC_ACCOUNT(unt).last4  = valarg; */\n/*            targ.crack := 0; */\n            }\n        else\n            sendtext(\"Illegal value, expected -1 or 0..9999.<br/>\", self);\n        }\n    goto end_set;\n    }\n\nif (field == 21)        /* add-dir-name */\n    {\n    if (targ.exit_to[typarg] == null)\n        {\n        sendtext(\"No such exit.<br/>\", self);\n        quit;\n        }\n\n    addstring (targ.exit_names[typarg], base_arg);\n    sendtext(\"Name added to the exit's names.<br/>\", self);\n\n    goto end_set;\n    }\n\nif (field == 22)        /* del-dir-name */\n    {\n    if (targ.exit_to[typarg] == null)\n        {\n        sendtext(\"No such exit.<br/>\", self);\n        quit;\n        }\n\n    substring (targ.exit_names[typarg], base_arg);\n    sendtext(\"Name might have been removed.<br/>\", self);\n\n    goto end_set;\n    }\n\nif (field == 23)        /* dir-flags */\n    {\n    if (targ.exit_to[typarg] == null)\n        {\n        sendtext(\"No such exit.<br/>\", self);\n        quit;\n        }\n\n    targ.exit_info[typarg] := valarg;\n    goto end_set;\n    }\n\nif (field == 24)        /* dir-key */\n    {\n    if (targ.exit_to[typarg] == null)\n        {\n        sendtext(\"No such exit.<br/>\", self);\n        quit;\n        }\n\n/*    targ.exit_key[typarg] := untarg; */\n    sendtext(\"Function currently unavailable.<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 25)        /* value0 */\n    {\n    if (targ.objecttype == ITEM_MONEY)\n        {\n        sendtext(\"Operation not allowed on this type of object.<br/>\", self);\n        quit;\n        }\n\n    targ.value[0] := valarg;\n    goto end_set;\n    }\n\nif (field == 26)        /* value1 */\n    {\n    if (targ.objecttype == ITEM_MONEY)\n        {\n        sendtext(\"Operation not allowed on this type of object.<br/>\", self);\n        quit;\n        }\n\n    targ.value[1] := valarg;\n    goto end_set;\n    }\n\nif (field == 27)        /* value2 */\n    {\n    if (targ.objecttype == ITEM_MONEY)\n        {\n        sendtext(\"Operation not allowed on this type of object.<br/>\", self);\n        quit;\n        }\n\n    targ.value[2] := valarg;\n    goto end_set;\n    }\n\nif (field == 28)        /* value3 */\n    {\n    if (targ.objecttype == ITEM_MONEY)\n        {\n        sendtext(\"Operation not allowed on this type of object.<br/>\", self);\n        quit;\n        }\n\n    targ.value[3] := valarg;\n    goto end_set;\n    }\n\nif (field == 29)        /* value4 */\n    {\n    if (targ.objecttype == ITEM_MONEY)\n        {\n        sendtext(\"Operation not allowed on this type of object.<br/>\", self);\n        quit;\n        }\n\n    targ.value[4] := valarg;\n    goto end_set;\n    }\n\nif (field == 30)        /* obj-flags */\n    {\n    targ.objectflags := valarg;\n    goto end_set;\n    }\n\nif (field == 31)        /* cost */\n    {\n    if (targ.objecttype == ITEM_MONEY)\n        {\n        sendtext(\"Operation not allowed on this type of object.<br/>\", self);\n        quit;\n        }\n\n/*  Might add pieces conversion later */\n    targ.cost := valarg;\n    goto end_set;\n    }\n\nif (field == 32)        /* rent */\n    {\n    targ.rent := valarg;\n    goto end_set;\n    }\n\nif (field == 33)        /* type */\n    {\n    if (targ.objecttype == ITEM_MONEY)\n        {\n        sendtext(\"Operation not allowed on this type of object.<br/>\", self);\n        quit;\n        }\n\n    if (typarg == ITEM_MONEY)\n        {\n        sendtext(\"Operation not allowed to that kind of object.<br/>\", self);\n        quit;\n        }\n\n    targ.objecttype := typarg;\n    goto end_set;\n    }\n\nif (field == 34)        /* equip */\n    {\n    /* This is not how the old set worked, but I cannot change the value\n       of equip directly in dil */\n    addequip(targ, typarg);\n    goto end_set;\n    }\n\n/* Guild-name and pwd not really tested */\nif (field == 35)        /* guild-name */\n    {\n    /* I'm not sure what that should do, null a guild name? */\n    if (base_arg == \"none\")\n        {\n        if (targ.guild != null)\n            targ.guild := null;\n        sendtext(\"Changed.<br/>\", self);\n        goto end_set;\n        }\n\n    targ.guild := base_arg;\n    sendtext(\"Changed.<br/>\", self);\n    goto end_set;\n    }\n        \nif (field == 36)        /* pwd */\n    {\n    if (self.level < targ.level)\n        {\n        log(\"WARNING: \"+self.name+\" attemped to set \"+targ.name+\n            \"'s password.\");\n        sendtext(\"You can not change a password of a higher level \"+\n            \"immortal.<br/>\", self);\n        }\n\n    else\n        {\n        log(\"PASSWORD: \"+self.name+\" changed \"+targ.name+\"'s password.\");\n/*      strncpy(PC_PWD(unt), crypt(strarg, UNIT_NAME(unt)), 10);   */\n\n        set_password(targ, base_arg);\n        sendtext(\"Password changed.<br/>\", self);\n        }\n\n    goto end_set;\n    }\n\nif (field == 37)        /* pc-flags */\n    {\n    targ.pcflags := valarg;\n    goto end_set;\n    }\n\nif (field == 38)        /* crimes */\n    {\n    targ.crimes := valarg;\n    goto end_set;\n    }\n\nif (field == 39)        /* drunk */\n    {\n    targ.drunk := valarg;\n    goto end_set;\n    }\n\nif (field == 40)        /* full */\n    {\n    targ.full := valarg;\n    goto end_set;\n    }\n\nif (field == 41)        /* thirsty */\n    {\n    targ.thirst := valarg;\n    goto end_set;\n    }\n\nif (field == 42)        /* default-pos */\n    {\n    targ.defaultpos := valarg;\n    goto end_set;\n    }\n\nif (field == 43)        /* npc-flags */\n    {\n    targ.npcflags := valarg;\n    goto end_set;\n    }\n\nif (field == 44)        /* hometown */\n    {\n    targ.hometown := base_arg;\n    goto end_set;\n    }\n\nif (field == 45)        /* exp */\n    {\n    /* Add a max exp, maybe */\n    targ.exp := valarg;\n    goto end_set;\n    }\n\nif (field == 46)        /* char-flags */\n    {\n    targ.charflags := valarg;\n    goto end_set;\n    }\n\nif (field == 47)        /* mana */\n    {\n    targ.mana := valarg;\n    goto end_set;\n    }\n\nif (field == 48)        /* endurance */\n    {\n    targ.endurance := valarg;\n    goto end_set;\n    }\n\nif (field == 49)        /* attack-type */\n    {\n    targ.attack_type := typarg;\n    goto end_set;\n    }\n\nif (field == 50)        /* natural-armor*/\n    {\n\t    targ.natural_armour := typarg;\n    goto end_set;\n    }\n\nif (field == 51)        /* height/size */\n    {\n    targ.height := valarg;\n    goto end_set;\n    }\n\nif (field == 52)        /* race */\n    {\n    targ.race := valarg;\n    goto end_set;\n    }\n\nif (field == 53)        /* sex */\n    {\n    targ.sex := typarg;\n    goto end_set;\n    }\n\nif (field == 54)        /* level */\n    {\n    if ((valarg >= 0) and (valarg <= 199)) sendtext(\"Field disabled.<br/>\", self);\n/*        targ.level := valarg; */\n\n    else\n        sendtext(\"Shame on you: Value must be in 0..199!<br/>\", self);\n\n    goto end_set;\n    }\n\nif (field == 55)        /* position */\n    {\n    targ.position := typarg;\n    goto end_set;\n    }\n\nif (field == 56)        /* ability */\n    {\n    if ((valarg >= 0) and (valarg <= 250))\n        targ.abilities[typarg] := valarg;\n\n    else\n        sendtext(\"Shame on you: Value must be in 0%..250%!<br/>\", self);\n\n    goto end_set;\n    }\n\nif (field == 57)        /* skill-points */\n    {\n    targ.skill_points := valarg;\n    goto end_set;\n    }\n\nif (field == 58)        /* ability-points */\n    {\n    targ.ability_points := valarg;\n    goto end_set;\n    }\n\nif (field == 59)        /* remove-affect */\n    {\n    if (isaff(targ, valarg))\n        {\n        subaff(targ, valarg);\n        sendtext(\"Affect attempted removed.<br/>\", self);\n        }\n\n    else\n        sendtext(\"No such affect.<br/>\", self);\n\n    goto end_set;\n    }\n\nif (field == 60)        /* add-quest */\n    {\n    if (not (\"|\" in base_arg))\n        {\n        /* If no | char in argument, assume it is the old add-quest */\n        sl := null;\n        addstring (sl, base_arg);\n\n        addextra(targ.quests, sl, \"\");\n\n        sendtext(\"New quest.<br/>\", self);\n        }\n\n    else\n        {\n        /* Should now accept extra names with more than one word */\n        sl := get_mwords(base_arg);\n    \n        if (sl.[0] == \"\")\n            {\n            sendtext (\"No quest names given.<br/>\", self);\n            quit;\n            }\n    \n        sendtext(\"Searching for \"+sl.[0]+\".<br/>\", self);\n    \n        ext := sl.[0] in targ.quests;\n    \n        if (not ext)\n            {\n            sendtext(\"New quest.<br/>\", self);\n            addextra (targ.quests, sl, \"\");\n            }\n    \n        /* Add the rest of the names if they do not exist */\n        else\n            {\n            l := 0;\n            while (l < length(sl))\n                {\n                if (not (sl.[l] in ext))\n                    addstring (ext.names, sl.[l]);\n                l := l + 1;\n                }\n    \n            sendtext(\"Modifying existing description.<br/>\", self);\n            }\n    \n        secure (targ, lost);\n    \n        beginedit(self);\n        wait(SFB_EDIT, (self == activator));\n        strarg := textformat(argument);\n    \n        ext := sl.[0] in targ.quests;\n        ext.descr := strarg;\n    \n        unsecure (targ);\n        }\n    goto end_set;\n    }\n\nif (field == 61)        /*del-quest */\n    {\n    sendtext(\"Attempting to remove such a quest.<br/>\", self);\n\n    subextra(targ.quests, base_arg);\n    goto end_set;\n    }\n\nif (field == 62)        /* speed */\n    {\n    /* Need higher level access */\n    if ((valarg >= SPEED_MIN) and (valarg <= SPEED_MAX))\n          sendtext(\"Field disabled.<br/>\", self);\n/*        targ.speed := valarg; */\n\n    else\n        sendtext(\"Speed must be in [\"+itoa(SPEED_MIN)+\"..\"+\n            itoa(SPEED_MAX)+\"]!<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 63)        /* add-info */\n    {\n    /* I assume this is the same as add-extra and copy so */\n    /* Should now accept extra names with more than one word */\n    sl := get_mwords(base_arg);\n\n    if (sl.[0] == \"\")\n        {\n        sendtext (\"No info names given.<br/>\", self);\n        quit;\n        }\n\n    sendtext(\"Searching for \"+sl.[0]+\".<br/>\", self);\n\n    ext := sl.[0] in targ.info;\n\n    if (not ext)\n        {\n        sendtext(\"New field.<br/>\", self);\n        addextra (targ.info, sl, \"\");\n        }\n\n    /* Add the rest of the names if they do not exist */\n    else\n        {\n        l := 0;\n        while (l < length(sl))\n            {\n            if (not (sl.[l] in ext))\n                addstring (ext.names, sl.[l]);\n            l := l + 1;\n            }\n\n        sendtext(\"Modifying existing description.<br/>\", self);\n        }\n\n    secure (targ, lost);\n\n    beginedit(self);\n    wait(SFB_EDIT, (self == activator));\n    strarg := textformat(argument);\n\n    ext := sl.[0] in targ.info;\n    ext.descr := strarg;\n\n    unsecure (targ);\n    goto end_set;\n    }\n\nif (field == 64)        /* del-info */\n    {\n    sendtext (\"Attempting to remove such an info.<br/>\", self);\n\n    subextra (targ.info, base_arg);\n    goto end_set;\n    }\n\nif (field == 65)       /* access */\n    {\n    /* Disabled */\n/*    targ.access := valarg; */\n    sendtext (\"Field disabled.<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 66)        /* promptstr */\n    {\n    targ.prompt := base_arg;\n    goto end_set;\n    }\n\nif (field == 67)        /* age */\n    {\n    /* Actually sets birth */\n    /* The 10..1000 restriction was removed */\n    log (\"SET: \"+self.name+\" set \"+targ.name+\"'s age from \"+\n        itoa(targ.birth/(SECS_PER_MUD_YEAR))+\" to \"+itoa(valarg));\n\n    targ.birth := realtime - (valarg*SECS_PER_MUD_YEAR);\n    sendtext(\"Age set.<br/>\", self);\n\n    goto end_set;\n    }\n\nif (field == 68)        /* lifespan */\n    {\n    /* The 10.1000 restriction was removed */\n    log (\"SET: \"+self.name+\" set \"+targ.name+\"'s age from \"+\n        itoa(targ.lifespan)+\" to \"+itoa(valarg));\n\n    targ.lifespan := valarg;\n    goto end_set;\n    }\n\n/* New fields */\nif (field == 69)        /* inside-descr */\n    {\n    sendtext(\"Modifying long inside description.<br/>\", self);\n\n    secure (targ, lost);\n\n    beginedit(self);\n    wait (SFB_EDIT, (self == activator));\n    strarg := textformat(argument);\n\n    targ.inside_descr := strarg;\n    unsecure (targ);\n\n    goto end_set;\n    }\n\nif (field == 70)        /* attack-bonus */\n    {\n/*    targ.offensive := valarg; */\n    sendtext(\"Field disabled.<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 71)        /* defense-bonus */\n    {\n/*    targ.defensive := valarg; */\n    sendtext(\"Field disabled.<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 72)        /* magic-resistance */\n    {\n    targ.spells[SPL_NONE] := valarg;\n    goto end_set;\n    }\n\nif (field == 73)        /* textformat */\n    {\n    sendtext(\"Formatting data...<br/>\", self);\n\n    base_arg := textformat(base_arg);\n    goto find_field;\n    }\n\nif (field == 74)        /* ins-name */\n    {\n    if ((targ.type == UNIT_ST_PC) and (self.level < 255))\n        {\n        sendtext (\"Not allowed to modify PC's.<br/>\", self);\n        return;\n        }\n    \n    strarg := getword(base_arg);\n    \n    if ((atoi(strarg) == 0) and (strarg != \"0\")) // Let's forget about \"00\"\n        {\n        sendtext (\"Illegal insert position, appending at end.<br/>\", self);\n        valarg := length(targ.names);\n        }\n    \n    else\n        valarg := atoi(strarg);\n    \n    if (valarg > length(targ.names))\n        {\n        sendtext (\"Out of range index, appending at the end.<br/>\", self);\n        valarg := length(targ.names) - 1;\n        }\n    \n    if (valarg < 0)\n        {\n        sendtext (\"Index below 0, appending as first.<br/>\", self);\n        valarg := 0;\n        }\n    \n    // The following is an hack because insert(sl, 0, str) doesn't work\n    if (valarg == 0)\n        {\n        insert (targ.names, 1, base_arg);\n        strarg := targ.names.[0];\n        targ.names.[0] := targ.names.[1];\n        targ.names.[1] := strarg;\n        }\n    \n    else\n        insert (targ.names, valarg, base_arg);\n    \n    sendtext (\"The extra name was inserted at position \"+\n        itoa(valarg)+\".<br/>\",self);\n    goto end_set;\n    }\n\nif (field == 75)        /* rem-name */\n    {\n    if (length(targ.names) <= 1)\n        {\n        sendtext(\"Must have a minimum of one name.<br/>\", self);\n        quit;\n        }\n\n    if (valarg > length(targ.names))\n        {\n        sendtext (\"Out of range index, removing last name.<br/>\", self);\n        valarg := length(targ.names) - 1;\n        }\n    \n    if (valarg < 0)\n        {\n        sendtext (\"Index below 0, removing first name.<br/>\", self);\n        valarg := 0;\n        }\n    \n    remove (targ.names, valarg);\n    \n    sendtext(\"Name may have been removed at position \"+\n        itoa(valarg)+\".<br/>\", self);\n    goto end_set;\n    }\n\nif (field == 76)        /* look-descr */\n    {\n    sendtext(\"Modifying long description.<br/>\", self);\n\n    secure (targ, lost);\n\n    beginedit(self);\n    wait (SFB_EDIT, (self == activator));\n    strarg := textformat(argument);\n    sl := null;\n    \n    subextra (targ.extra, \"\");\n    addextra (targ.extra, sl, strarg);\n    \n    unsecure (targ);\n\n    goto end_set;\n    }\n\nsendtext (\"Oops. Bad field!<br/>\", self);\n\n:lost:\nsendtext (\"Target lost.<br/>\", self);\nquit;\n\n:end_set:\nsl:= UNIT_FIELD_NAMES;\ns:= sl.[field];\n\nif (targ.type == UNIT_ST_PC)\n    tgt := targ.name;\nif ((targ.type == UNIT_ST_NPC) or (targ.type == UNIT_ST_OBJ))\n    tgt := targ.title;\nif (targ.type == UNIT_ST_ROOM)\n    tgt := targ.nameidx+\"@\"+targ.zoneidx;\n\nif ((at == AT_VAL) or (at == AT_BIT))\n    log (self.name+\" sets \"+tgt+\"'s \"+s+\" to \"+itoa(valarg)+\".\");\n    \nif (at == AT_TYP)\n    {\n    st := unit_fi_data(field, FI_STRUCT);\n\n    if (st == \"sect_mv\")\n        sl := SECT_MV_STRUCT;\n    if (st == \"obj_typ\")\n        sl := OBJ_TYP_STRUCT;\n    if (st == \"obj_pos\")\n        sl := OBJ_POS_STRUCT;\n    if (st == \"att_typ\")\n        sl := ATT_TYP_STRUCT;\n    if (st == \"ch_pos\")\n        sl := CH_POS_STRUCT;\n    if (st == \"abil\")\n        sl := ABIL_STRUCT;\n\n    st := sl.[typarg];\n\n    log (self.name+\" sets \"+tgt+\"'s \"+s+\" to \"+st+\".\");\n    }\n\nif (at == AT_STR)\n    log (self.name+\" sets \"+tgt+\"'s \"+s+\" to \"+strarg+\".\");\n\nif ((at == AT_DES) or (at == AT_UNT) or (at == AT_KEYDES))\n    log (self.name+\" sets \"+tgt+\"'s field: \"+s+\".\");\n\n/* Since there is currently only one AT_TYPVAL we assume it is abil */\nif (at == AT_TYPVAL)\n    {\n    sl := ABIL_STRUCT;\n\n    st := sl.[typarg];\n\n    log (self.name+\" sets \"+tgt+\"'s \"+s+\"[\"+st+\"] to \"+itoa(valarg)+\".\");\n    }\n\nif ((at == AT_DIRBIT) or (at == AT_DIRSTR) or \n    (at == AT_DIRUNT) or (at == AT_DIRDES))\n    {\n    sl := DIR_STRUCT;\n\n    st := sl.[typarg];\n\n    log (self.name+\" sets \"+tgt+\"'s dir, \"+st+\"'s field: \"+s+\".\");\n    }\n\n\n/* There is no field of type AT_TYPDES currently available */\nif (at == AT_TYPDES)\n    log (self.name+\" sets \"+tgt+\"'s \"+s+\".\");\n\nquit;\n\n} dilend"
}