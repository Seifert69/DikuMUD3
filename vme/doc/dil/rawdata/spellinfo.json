{
    "keyword": "spellinfo",
    "opcode": "DILSE_SPLI",
    "yacc_rule": "| DILSE_SPLI '(' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    $$.boolean = 1;\n\n    if ($3.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 1 of 'spellinfo' not an integer\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_INT || $5.dsl != DSL_LFT)\n    {\n        dilfatal(\"Arg 2 of 'spellinfo' not an integer variable\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_INT || $7.dsl != DSL_LFT)\n    {\n        dilfatal(\"Arg 3 of 'spellinfo' not an integer variable\");\n    }\n    else if ($9.typ != DilVarType_e::DILV_INT || $9.dsl != DSL_LFT)\n    {\n        dilfatal(\"Arg 4 of 'spellinfo' not an integer variable\");\n    }\n    else if ($11.typ != DilVarType_e::DILV_INT || $11.dsl != DSL_LFT)\n    {\n        dilfatal(\"Arg 5 of 'spellinfo' not an integer variable\");\n    }\n    else if ($13.typ != DilVarType_e::DILV_INT || $13.dsl != DSL_LFT)\n    {\n        dilfatal(\"Arg 6 of 'spellinfo' not an integer variable\");\n    }\n    else if ($15.typ != DilVarType_e::DILV_INT || $15.dsl != DSL_LFT)\n    {\n        dilfatal(\"Arg 7 of 'spellinfo' not an integer variable\");\n    }\n    else if ($17.typ != DilVarType_e::DILV_INT || $17.dsl != DSL_LFT)\n    {\n        dilfatal(\"Arg 8 of 'spellinfo' not an integer variable\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_SP;\n\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n        make_code(&($9));\n        make_code(&($11));\n        make_code(&($13));\n        make_code(&($15));\n        make_code(&($17));\n\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_code(&($$), &($9));\n        add_code(&($$), &($11));\n        add_code(&($$), &($13));\n        add_code(&($$), &($15));\n        add_code(&($$), &($17));\n        add_ubit8(&($$), DILE_SPLI);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n    FREEEXP($9);\n    FREEEXP($11);\n    FREEEXP($13);\n    FREEEXP($15);\n    FREEEXP($17);\n}",
    "dilfe_name": "dilfe_spli",
    "c_implementation": "void dilfe_spli(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v8 = p->stack.pop();\n    dilval *v7 = p->stack.pop();\n    dilval *v6 = p->stack.pop();\n    dilval *v5 = p->stack.pop();\n    dilval *v4 = p->stack.pop();\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    v->type = DILV_SP;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_INT:\n            if (!is_in(v1->val.num, SPL_ALL, SPL_TREE_MAX - 1))\n            {\n                v->type = DILV_FAIL;\n            }\n            else\n            {\n                switch (v2->type)\n                {\n                    case DILV_SINT4R:\n                    case DILV_UINT4R:\n                        switch (v3->type)\n                        {\n                            case DILV_SINT4R:\n                            case DILV_UINT4R:\n                                switch (v4->type)\n                                {\n                                    case DILV_SINT4R:\n                                    case DILV_UINT4R:\n                                        switch (v5->type)\n                                        {\n                                            case DILV_SINT4R:\n                                            case DILV_UINT4R:\n                                                switch (v6->type)\n                                                {\n                                                    case DILV_SINT4R:\n                                                    case DILV_UINT4R:\n                                                        switch (v7->type)\n                                                        {\n                                                            case DILV_SINT4R:\n                                                            case DILV_UINT4R:\n                                                                switch (v8->type)\n                                                                {\n                                                                    case DILV_SINT4R:\n                                                                    case DILV_UINT4R:\n                                                                        /* pName := spellinfo(SPL_LIGHTNING_3, nRealm, nSphere, nMana,\n                                                                         * bOffensive, nResistType, bvMedia, bvTargets); */\n\n                                                                        /* We're home free... */\n\n                                                                        *((ubit32 *)v2->ref) = g_spell_info[v1->val.num].realm;\n                                                                        *((ubit32 *)v3->ref) = g_SplColl.tree[v1->val.num].parent;\n                                                                        *((ubit32 *)v4->ref) = g_spell_info[v1->val.num].usesmana;\n                                                                        *((ubit32 *)v5->ref) = g_spell_info[v1->val.num].offensive;\n                                                                        *((ubit32 *)v6->ref) = g_spell_info[v1->val.num].cast_type;\n                                                                        *((ubit32 *)v7->ref) = g_spell_info[v1->val.num].media;\n                                                                        *((ubit32 *)v8->ref) = g_spell_info[v1->val.num].targets;\n\n                                                                        v->type = DILV_SP;\n                                                                        v->atyp = DILA_EXP;\n                                                                        v->val.ptr = str_dup(g_SplColl.text[v1->val.num] == nullptr\n                                                                                                 ? \"\"\n                                                                                                 : g_SplColl.text[v1->val.num]);\n                                                                        break;\n\n                                                                    default:\n                                                                        v->type = DILV_ERR;\n                                                                        break;\n                                                                }\n\n                                                                break;\n\n                                                            default:\n                                                                v->type = DILV_ERR;\n                                                                break;\n                                                        }\n\n                                                        break;\n\n                                                    default:\n                                                        v->type = DILV_ERR;\n                                                        break;\n                                                }\n\n                                                break;\n\n                                            default:\n                                                v->type = DILV_ERR;\n                                                break;\n                                        }\n\n                                        break;\n\n                                    default:\n                                        v->type = DILV_ERR;\n                                        break;\n                                }\n\n                                break;\n\n                            default:\n                                v->type = DILV_ERR;\n                                break;\n                        }\n\n                        break;\n                    default:\n                        v->type = DILV_ERR;\n                        break;\n                }\n            }\n\n            break;\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n    delete v4;\n    delete v5;\n    delete v6;\n    delete v7;\n    delete v8;\n}",
    "dil_example": "dilbegin do_setskill(arg : string);\n\nexternal\n   integer skillindex(s1 : string);\n   integer weaponindex(s1 : string);\n\nvar\n\n  item        :  unitptr;\n  cnt         :  integer;\n  stype       :  string;\n  sname       :  string;\n  sdef        :  integer;\n  samnt       :  integer;\n  schk        :  integer;\n  temp        :  string;\n  slist       :  stringlist;\n  scomp       :  stringlist;\n  buffer      :  string;\n  t1          :  integer;\n  t2          :  integer;\n  t3          :  integer;\n  t4          :  integer;\n  t5          :  integer;\n  t6          :  integer;\n  t7          :  integer;\n\n\ncode{\n\n\n if (arg == \"\")\n    {\n      sendtext(\"Syntax: setskill <name> (skill|spell|weapon) <field> <value>.<br/>\", self);\n      sendtext(\"For skills with spaces, use underscore, e.g. armor_soft_leather<br/>\", self);\n      quit;\n    }\n\n temp := arg;\n cnt := 1;\n\n:loop:\n\n item := findunit(self, temp, FIND_UNIT_GLOBAL, null);\n\n if ((item) and (not visible(self, item)))\n    {\n      cnt := cnt + 1;\n      temp := itoa(cnt) + \".\" + arg;\n      goto loop;\n    }\n\n if (item == null)\n    {\n      sendtext(\"No such player or mobile to setskill on.<br/>\", self);\n      quit;\n    }\n\n\n if ((item.type != UNIT_ST_PC) and (item.type != UNIT_ST_NPC))\n    {\n      sendtext(\"Setskill can only be used on PC's or NPC's.<br/>\", self);\n      quit;\n    }\n\n stype := getword(temp);\n\n if (stype == \"skill\")\n     goto set_skill;\n\n if (stype == \"spell\")\n     goto set_spell;\n\n if (stype == \"weapon\")\n     goto set_weapon;\n\n sendtext(\"Your options are either 'skill', 'spell' or 'weapon'.<br/>\", self);\n quit;\n\n\n:set_skill:\n\n  if (item.type == UNIT_ST_NPC)\n     {\n       sendtext(\"Mobiles cannot have skills set in this manner.<br/>\", self);\n       quit;\n     }\n\n  sname := getword(temp);\n\n  if (sname == \"\")\n       sdef := -1;\n  else\n     {\n       slist := split(sname, \"_\");\n\n       sname := slist.[0];\n\n       cnt := 1;\n\n       while (cnt < length(slist))\n           {\n             sname := sname + \" \" + slist.[cnt];\n             cnt := cnt + 1;\n           }\n\n\n       sdef := skillindex(sname);\n     }\n\n  if (sdef == -1)\n     {\n       buffer := \"Invalid skill, please choose from the following:<br/>\";\n\n       sdef := 0;\n       while (sdef < SKI_TREE_MAX)\n          {\n            sname := skill_name(sdef);\n\n            if (sname == \"\")\n                break;\n\n            buffer := buffer + sname + \"<br/>\";\n\n            sdef := sdef + 1;\n          }\n\n       sendtext(buffer, self);\n       quit;\n     }\n\n  temp := getword(temp);\n  samnt := atoi(temp);\n  item.skills[sdef] := samnt;\n  sname := skill_name(sdef);\n\n  act(\"$2n's skill in \" + sname + \" is set to $3t.\", A_ALWAYS, self, item, itoa(samnt), TO_CHAR);\n\n  quit;\n\n\n\n:set_weapon:\n\n  sname := getword(temp);\n\n  if (sname == \"\")\n       sdef := -1;\n  else\n     {\n       slist := split(sname, \"_\");\n\n       sname := slist.[0];\n\n       cnt := 1;\n\n       while (cnt < length(slist))\n           {\n             sname := sname + \" \" + slist.[cnt];\n             cnt := cnt + 1;\n           }\n\n\n       sdef := weaponindex(sname);\n     }\n\n  if (sdef == -1)\n     {\n       buffer := \"Invalid weapon, please choose from the following:<br/>\";\n\n       sdef := 0;\n       while (sdef < WPN_TREE_MAX)\n          {\n            sname := weapon_name(sdef);\n\n            if (sname == \"\")\n                break;\n\n            buffer := buffer + sname + \"<br/>\";\n\n            sdef := sdef + 1;\n          }\n\n       sendtext(buffer, self);\n       quit;\n     }\n\n  if ((item.type == UNIT_ST_NPC) and (sdef >= WPN_GROUP_MAX))\n     {\n       sendtext(\"Mobiles can only have weapon groups set.<br/>\", self);\n       quit;\n     }\n\n  temp := getword(temp);\n  samnt := atoi(temp);\n  item.weapons[sdef] := samnt;\n  sname := weapon_name(sdef);\n\n  act(\"$2n's skill in \" + sname + \" is set to $3t.\", A_ALWAYS, self, item, itoa(samnt), TO_CHAR);\n\n  quit;\n\n\n:set_spell:\n\n  sname := getword(temp);\n\n  if (sname == \"\")\n       sdef := -1;\n  else\n     {\n       slist := split(sname, \"_\");\n\n       sname := slist.[0];\n\n       cnt := 1;\n\n       while (cnt < length(slist))\n          {\n            sname := sname + \" \" + slist.[cnt];\n            cnt := cnt + 1;\n          }\n\n\n       sdef := spellindex(sname);\n     }\n\n  if (sdef == -1)\n     {\n       buffer := \"Invalid spell, please choose from the following:<br/>\";\n\n       sdef := 0;\n       while (sdef < SPL_TREE_MAX)\n          {\n            sname := spellinfo(sdef, t1, t2, t3, t4, t5, t6, t7);\n\n            if (sname == \"\")\n                break;\n\n            buffer := buffer + sname + \"<br/>\";\n\n            sdef := sdef + 1;\n          }\n\n       sendtext(buffer, self);\n       quit;\n     }\n\n  if ((item.type == UNIT_ST_NPC) and (sdef >= SPL_GROUP_MAX))\n     {\n       sendtext(\"Mobiles can only have spell groups set.<br/>\", self);\n       quit;\n     }\n\n  temp := getword(temp);\n  samnt := atoi(temp);\n  item.spells[sdef] := samnt;\n  sname := spellinfo(sdef, t1, t2, t3, t4, t5, t6, t7);\n\n  act(\"$2n's skill in \" + sname + \" is set to $3t.\", A_ALWAYS, self, item, itoa(samnt), TO_CHAR);\n\n  quit;\n\n\n} dilend"
}