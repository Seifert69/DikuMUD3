{
    "keyword": "pathto",
    "opcode": "DILSE_PATH",
    "yacc_rule": "| DILSE_PATH '(' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'pathto' not a unitptr\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 2 of 'pathto' not a unitptr\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_INT;\n        make_code(&($3));\n        make_code(&($5));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_ubit8(&($$), DILE_PATH);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n}",
    "dilfe_name": "dilfe_path",
    "c_implementation": "void dilfe_path(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    v->type = DILV_INT;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_UP:\n            if (!v1->val.ptr)\n            {\n                v->type = DILV_FAIL;\n            }\n            else\n            {\n                switch (dil_getval(v2))\n                {\n                    case DILV_UP:\n                        if (!v2->val.ptr)\n                        {\n                            v->type = DILV_FAIL;\n                        }\n                        else\n                        {\n                            unit_data *u1 = nullptr;\n                            unit_data *u2 = nullptr;\n                            u1 = unit_room((unit_data *)v1->val.ptr);\n                            u2 = unit_room((unit_data *)v2->val.ptr);\n\n                            v->val.num = move_to(u1, u2);\n                        }\n                        break;\n                    case DILV_FAIL:\n                    case DILV_NULL:\n                        v->type = DILV_FAIL;\n                        break;\n                    default:\n                        v->type = DILV_ERR;\n                        break;\n                }\n            }\n\n            break;\n        case DILV_FAIL:\n        case DILV_NULL:\n            v->type = DILV_FAIL;\n            break;\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n}",
    "dil_example": "dilbegin do_wpath(arg: string);\nvar\n   dir : integer;\n   u : unitptr;\n   uin : unitptr;\n   sl : stringlist;\n\ncode\n{\n   if (arg == \"\")\n   {\n      sendtext(\"Please specify an object you'd like a path to.<br/>\", self);\n      return;\n   }\n\n   log(\"1\");\n   u := findunit(self, arg, FIND_UNIT_WORLD, null, UNIT_ST_PC|UNIT_ST_NPC|UNIT_ST_OBJ|UNIT_ST_ROOM);\n\n   log(\"2\");\n   if (not u)\n   {\n      u := findsymbolic(arg);\n\n      if (not u)\n      {\n         sendtext(\"Can't locate a unit named \" + arg + \"<br/>\", self);\n         return;\n      }\n   }\n\n   uin := u;\n   while (uin.type != UNIT_ST_ROOM)\n      uin := uin.outside;\n\n   dir := pathto(self, u);\n\n   log(\"3b\");\n   sl := DIR_SL_LONG;\n\n   log(\"4\");\n   sendtext(\"Ola<br/>\", self);\n   sendtext(\"Found \"+u.nameidx+\"@\"+u.zoneidx+\" which is located in <a cmd='goto #'>\" + uin.nameidx + \"@\" + uin.zoneidx + \"</a><br/>\", self);\n   sendtext(\"Direction: \" + sl.[dir] + \"(\"+itoa(dir)+\")<br/>\", self);\n   log(\"5\");\n   quit;\n} dilend"
}