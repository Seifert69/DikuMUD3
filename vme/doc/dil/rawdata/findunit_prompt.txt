Generate MCP entry for DIL keyword: findunit

=== Yacc rule ===
| DILSE_FNDU '(' dilexp ',' dilexp ',' dilexp ',' dilexp ',' dilexp ')'
{
    INITEXP($$);
    checkbool("argument 3 of findunit", $7.boolean);
    if ($3.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 1 of 'findunit' not a unit");
    }
    else if ($5.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 2 of 'findunit' not a string");
    }
    else if ($7.typ != DilVarType_e::DILV_INT)
    {
        dilfatal("Arg 3 of 'findunit' not integer");
    }
    else if ($9.typ != DilVarType_e::DILV_UP && $9.typ != DilVarType_e::DILV_NULL)
    {
        dilfatal("Arg 4 of 'findunit' not unit");
    }
    else if ($11.typ != DilVarType_e::DILV_INT)
    {
        dilfatal("Arg 5 of 'findunit' not integer");
    }
    else
    {
        /* Type is ok */
        /* Make nodes dynamic */
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_UP;
        make_code(&($3));
        make_code(&($5));
        make_code(&($7));
        make_code(&($9));
        make_code(&($11));
        add_code(&($$), &($3));
        add_code(&($$), &($5));
        add_code(&($$), &($7));
        add_code(&($$), &($9));
        add_code(&($$), &($11));
        add_ubit8(&($$), DILE_FNDU2);
    }
    FREEEXP($3);
    FREEEXP($5);
    FREEEXP($7);
    FREEEXP($9);
    FREEEXP($11);
}

------

| DILSE_FNDU '(' dilexp ',' dilexp ',' dilexp ',' dilexp ')'
{
    INITEXP($$);
    checkbool("argument 3 of findunit", $7.boolean);
    if ($3.typ != DilVarType_e::DILV_UP)
    {
        dilfatal("Arg 1 of 'findunit' not a unit");
    }
    else if ($5.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 2 of 'findunit' not a string");
    }
    else if ($7.typ != DilVarType_e::DILV_INT)
    {
        dilfatal("Arg 3 of 'findunit' not integer");
    }
    else if ($9.typ != DilVarType_e::DILV_UP && $9.typ != DilVarType_e::DILV_NULL)
    {
        dilfatal("Arg 4 of 'findunit' not unit");
    }
    else
    {
        /* Type is ok */
        /* Make nodes dynamic */
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_UP;
        make_code(&($3));
        make_code(&($5));
        make_code(&($7));
        make_code(&($9));
        add_code(&($$), &($3));
        add_code(&($$), &($5));
        add_code(&($$), &($7));
        add_code(&($$), &($9));
        add_ubit8(&($$), DILE_FNDU);
    }
    FREEEXP($3);
    FREEEXP($5);
    FREEEXP($7);
    FREEEXP($9);
}

=== C implementation ===
void dilfe_fndu(dilprg *p)
{
    dilval *v = new dilval;
    /* Find a unit */
    dilval *v4 = p->stack.pop();
    dilval *v3 = p->stack.pop();
    dilval *v2 = p->stack.pop();
    dilval *v1 = p->stack.pop();

    switch (dil_getval(v1))
    {
        case DILV_FAIL:
            v->type = DILV_FAIL;
            break;

        case DILV_UP:
            if (v1->val.ptr)
            {
                v->type = DILV_UP;
            }
            else
            {
                v->type = DILV_NULL; /* not applicable UP */
            }
            break;

        case DILV_NULL:
            v->type = DILV_NULL;
            break;

        default:
            v->type = DILV_ERR;
            break;
    }

    switch (dil_getval(v2))
    {
        case DILV_FAIL:
            if (v->type != DILV_ERR)
            {
                v->type = DILV_FAIL;
            }
            break;

        case DILV_SP:
            if (v->type != DILV_ERR)
            {
                if (!v2->val.ptr)
                {
                    v->type = DILV_NULL; /* not applicable SP */
                }
                else if (!*((char *)v2->val.ptr))
                {
                    v->type = DILV_NULL; /* not applicable SP */
                }
            }
            break;

        case DILV_NULL:
            if ((v->type != DILV_ERR) && (v->type != DILV_FAIL))
            {
                v->type = DILV_NULL; /* not applicable */
            }
            break;

        default:
            v->type = DILV_ERR; /* wrong type */
            break;
    }

    switch (dil_getval(v3))
    {
        case DILV_FAIL:
            if (v->type != DILV_ERR)
            {
                v->type = DILV_FAIL;
            }
            break;

        case DILV_INT:
            break;

        default:
            v->type = DILV_ERR; /* wrong type */
            break;
    }

    switch (dil_getval(v4))
    {
        case DILV_FAIL:
            if (v->type != DILV_ERR)
            {
                v->type = DILV_FAIL;
            }
            break;

        case DILV_UP:
            break;

        case DILV_NULL: /* null pointer */
            if ((v->type != DILV_ERR) && (v->type != DILV_FAIL))
            {
                v4->val.ptr = nullptr;
            }
            break;

        default:
            v->type = DILV_ERR; /* wrong type */
            break;
    }

    if (v->type == DILV_UP)
    {
        char *c = (char *)v2->val.ptr;

        v->atyp = DILA_NORM;
        v->val.ptr = find_unit_dil((unit_data *)v1->val.ptr, &c, (unit_data *)v4->val.ptr, v3->val.num);

        if (v2->atyp == DILA_NORM && v2->type == DILV_SPR)
        {
            memmove(v2->val.ptr, c, strlen(c) + 1);
        }
        else if (p->sarg->arg == (const char *)v2->val.ptr)
        {
            p->sarg->arg = c; /* Update argument if argument is argument! :) */
        }

        if (!v->val.ptr)
        {
            v->type = DILV_NULL;
        }
    }
    else
    {
        v->type = DILV_FAIL;
    }
    p->stack.push(v);
    delete v1;
    delete v2;
    delete v3;
    delete v4;
}

=== DIL example ===
dilbegin captain(jailname : string);
external
   integer walk_room@function (s:string,i:integer);
   putin_safe(prisoner : unitptr);
   integer add_reward@justice(criminal_symname : string, criminal_idx : integer, crime_type: integer);
var
   tf:integer;
   prisoner : unitptr;
   u : unitptr;
   nextu : unitptr;
   safe : unitptr;
   cuffs : unitptr;
   c : string;

code
{
   heartbeat := PULSE_SEC * 10;

   on_activation((self.position <= POSITION_SLEEPING) or
                 (self.position == POSITION_FIGHTING), skip);

   :findsafe:
   tf:=walk_room@function("accuse_room"+"@"+self.outside.zoneidx,4);
   safe := findunit(self, "safe", FIND_UNIT_SURRO, self);
   if (safe == null)
     safe := self;

   secure(safe, findsafe);

   :loop:
   pause;

   /* See if any prisoner is in this room */
   foreach (UNIT_ST_PC|UNIT_ST_NPC, prisoner)
   {
      cuffs := equipment(prisoner, WEAR_WRIST_R);
      if (cuffs and (cuffs.nameidx == "cuffs") and
                    (cuffs.zoneidx == "midgaard"))
      {
         if (isset(prisoner.charflags, CHAR_OUTLAW))
           goto gotone;
      }
   }

   goto loop;

   :gotone:
   putin_safe(prisoner);

   act("$3n opens the jail door, and pushes $1n through.",
       A_SOMEONE, prisoner, null, self, TO_NOTVICT);
   act("You are pushed into the jail by $3n.",
       A_SOMEONE, prisoner, null, self, TO_CHAR);

   dilcopy("jailstay@midgaard(12)", prisoner);


   link(prisoner, findroom(jailname));

   goto loop;
} dilend
