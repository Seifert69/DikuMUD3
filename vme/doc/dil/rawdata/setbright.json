{
    "keyword": "setbright",
    "opcode": "DILSI_SBT",
    "yacc_rule": "| DILSI_SBT '(' coreexp ',' coreexp ')' ihold\n{\n    checkbool(\"argument 2 of setbright\", $5.boolean);\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'setbright' not an unitptr\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 2 of 'setbright' not an integer\");\n    }\n    else\n    {\n        $$.fst = $3.fst;\n        $$.lst = $7 + 1;\n        wtmp = &tmpl.core[$7];\n        bwrite_ubit8(&wtmp, DILI_SBT);\n    }\n}",
    "dilfe_name": "dilfi_sbt",
    "c_implementation": "void dilfi_sbt(dilprg *p)\n{\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n    int dif = 0;\n\n    if (dil_type_check(\"setbright\", p, 2, v1, TYPEFAIL_NULL, 1, DILV_UP, v2, FAIL_NULL, 1, DILV_INT))\n    {\n        if (v1->val.ptr)\n        {\n            dif = v2->val.num - ((unit_data *)v1->val.ptr)->getLightOutput();\n\n            modify_bright((unit_data *)v1->val.ptr, dif);\n        }\n    }\n\n    delete v1;\n    delete v2;\n}",
    "dil_example": "dilbegin integer enc_light(u : unitptr, bonuslvl : integer, data : string);\nexternal\n    integer successroll(il : intlist, rollskew : integer);\n    identify(u :unitptr, norm : string, improved: string);\nvar\n    i : integer;\ncode\n{\n    if (bonuslvl > 7)\n    {\n        bonuslvl := 7;\n        log(\"enc_light bonuslvlifier too large \");\n    }\n    if (bonuslvl < -7)\n    {\n        bonuslvl := -7;\n        log(\"enc_light bonuslvlifier too small \");\n    }\n\n    i := successroll({50, 80, 95}, bonuslvl*5);\n\n    if (i == 0)\n        return(1);\n\n    setbright(u, i); // 0..3\n    identify(u, \"Emits a magical light.\", \"Emits a magical light +\" + itoa(i) +\".\");\n\n    return (1);\n} dilend"
}