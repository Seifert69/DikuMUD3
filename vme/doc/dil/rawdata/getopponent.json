{
    "keyword": "getopponent",
    "opcode": "DILSE_GOPP",
    "yacc_rule": "| DILSE_GOPP '(' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n    $$.boolean = 1;\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'getopponent' not a unitptr\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 2 of 'getopponent' not a integer\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_UP;\n        make_code(&($3));\n        make_code(&($5));\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_ubit8(&($$), DILE_GOPP);\n    }\n    FREEEXP($3);\n    FREEEXP($5);\n}",
    "dilfe_name": "dilfe_gopp",
    "c_implementation": "void dilfe_gopp(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n\n    switch (dil_getval(v1))\n    {\n        case DILV_UP:\n            if (!v1->val.ptr || !((unit_data *)v1->val.ptr)->isChar())\n            {\n                v->type = DILV_FAIL;\n            }\n            else\n            {\n                switch (dil_getval(v2))\n                {\n                    case DILV_INT:\n\n                        if (v2->val.num >= 0)\n                        {\n                            if (CHAR_COMBAT((unit_data *)v1->val.ptr))\n                            {\n                                v->val.ptr = CHAR_COMBAT((unit_data *)v1->val.ptr)->Opponent((int)v2->val.num);\n                                if (v->val.ptr)\n                                {\n                                    v->atyp = DILA_NORM;\n                                    v->type = DILV_UP;\n                                }\n                                else\n                                {\n                                    v->val.ptr = nullptr;\n                                    v->atyp = DILA_NORM;\n                                    v->type = DILV_NULL;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            v->val.ptr = nullptr;\n                            v->atyp = DILA_NORM;\n                            v->type = DILV_NULL;\n                        }\n                        break;\n                    default:\n                        v->type = DILV_ERR;\n                        break;\n                }\n            }\n\n            break;\n        case DILV_FAIL:\n        case DILV_NULL:\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n}",
    "dil_example": "dilbegin string get_pos (looker : unitptr, u:unitptr);\n\nvar\n\n     p    :  stringlist;\n     i    :  integer;\n     pc   :  unitptr;\n\ncode{\n\ni := u.position;\np := {\" is lying here, dead ... creepy.\",\n      \" is lying here, mortally wounded.\",\n      \" is lying here, incapacitated.\",\n      \" is lying here, stunned.\",\n      \" is sleeping here.\",\n      \" is resting here.\",\n      \" is sitting here.\",\n      \" is here, fighting \",\n      \" is standing here.\"};\n\nif (i != 7)\n    return (p.[i]);\n\n\nif ((u.fighting == null) and (u.opponentcount == 0))\n    return (p.[i] + \"someone who has already left.\");\n\npc := getopponent(u, 0);\n\nif (u.fighting == null)\n    return (p.[i] + pc.name + \" at a distance.\");\n\nif (u.fighting == looker)\n    return (p.[i] + \"YOU!\");\n\nreturn (p.[i] + u.fighting.name);\n\n} dilend"
}