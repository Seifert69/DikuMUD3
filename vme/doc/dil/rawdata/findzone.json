{
    "keyword": "findzone",
    "opcode": "DILSE_FNDZ",
    "yacc_rule": "| DILSE_FNDZ '(' dilexp ')'\n{\n    INITEXP($$);\n    if ($3.typ != DilVarType_e::DILV_SP)\n    {\n        dilfatal(\"Arg 1 of 'findzone' not string\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_ZP;\n        make_code(&($3));\n        add_code(&($$), &($3));\n        add_ubit8(&($$), DILE_FNDZ);\n    }\n    FREEEXP($3);\n}",
    "dilfe_name": "dilfe_fndz",
    "c_implementation": "void dilfe_fndz(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v1 = p->stack.pop();\n\n    switch (dil_getval(v1))\n    {\n        case DILV_FAIL:\n            v->type = DILV_FAIL;\n            break;\n        case DILV_SP:\n            v->atyp = DILA_NORM;\n            v->type = DILV_ZP;\n            if (v1->val.ptr)\n            {\n                v->val.ptr = find_zone((const char *)v1->val.ptr);\n                if (v->val.ptr == nullptr)\n                {\n                    v->type = DILV_NULL; /* not found */\n                }\n            }\n            else\n            {\n                v->type = DILV_NULL; /* not found */\n            }\n\n            break;\n        case DILV_NULL:\n            v->type = DILV_NULL; /* not found */\n            break;\n        default:\n            v->type = DILV_ERR; /* wrong type */\n            break;\n    }\n    p->stack.push(v);\n    delete v1;\n}",
    "dil_example": "dilbegin cmd_reset(arg : string);\nvar\n   z : zoneptr;\n   u : unitptr;\ncode\n{\n   if (arg == \"\")\n   {\n      u := self.outside;\n      while (u.type != UNIT_ST_ROOM)\n          u := u.outside;\n      z := findzone(u.zone);\n   }\n   else\n   {\n      z := findzone(arg);\n   }\n\n   if (z == null)\n   {\n       sendtext(\"Could not find a zone named \"+ arg + \"<br/>\", self);\n       quit;\n   }\n\n   sendtext(\"Resetting zone \"+ z.name + \"<br/>\", self);\n   zonereset(z);\n\n   quit;\n} dilend"
}