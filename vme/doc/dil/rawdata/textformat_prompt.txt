Generate MCP entry for DIL keyword: textformat

=== Yacc rule ===
| DILSE_TXF '(' dilexp ')'
{
    INITEXP($$);
    if ($3.typ != DilVarType_e::DILV_SP)
    {
        dilfatal("Arg 1 of 'textformat' not string variable");
    }
    else
    {
        /* Type is ok */
        /* Make nodes dynamic */
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_SP;
        add_code(&($$), &($3));
        add_ubit8(&($$), DILE_TXF);
    }
    FREEEXP($3);
}

=== C implementation ===
void dilfe_txf(dilprg *p)
{
    dilval *v = new dilval;
    dilval *v1 = p->stack.pop();
    char *dest = nullptr;

    switch (dil_getval(v1))
    {
        case DILV_NULL:
        case DILV_FAIL:
            v->type = DILV_FAIL; /* failed */
            break;

        case DILV_SP:
            if (v1->val.ptr)
            {
                int n = str_escape_size((char *)v1->val.ptr, strlen((char *)v1->val.ptr));
                CREATE(dest, char, n);

                v->atyp = DILA_EXP;
                v->type = DILV_SP;
                str_escape_format((char *)v1->val.ptr, dest, n, FALSE);

                v->val.ptr = str_dup(dest);
                FREE(dest);
            }
            else
            {
                v->type = DILV_FAIL; /* NULL string */
            }
            break;

        default:
            v->type = DILV_ERR; /* wrong type */
            break;
    }
    p->stack.push(v);
    delete v1;
}

=== DIL example ===
dilbegin aware Gold_bucket ();
var
len :integer;
 i,t:integer;
 buf:string;
 tmp:string;
 args:stringlist;

code
{

interrupt (SFB_CMD, command("accadd"),add_name);
interrupt (SFB_CMD, command("accdel"),del_name);

:start:
wait (SFB_MSG, TRUE);

if (argument !="lookin" )
 goto start;


 if (length(self.extra.["$dlist"].names)==1)
  {
  sendtext ("No donations this year yet we still need $2400 per year.<br/>",activator);
 goto start;
 }


 len:=length (self.extra.["$dlist"].names);
  buf:="As you look into the bucket you see the images of";
 i:=1;
 while (i<len)
  {
  if (i==1)
  {
  if (i+1==len)
   buf:=buf+" "+self.extra.["$dlist"].names.[i]+".  ";
   else
      buf:=buf+" "+self.extra.["$dlist"].names.[i]+", ";
      }
      else
      {
        if (i+1==len)
   buf:=buf+" and "+ self.extra.["$dlist"].names.[i]+".  ";
   else
     buf:=buf+" "+self.extra.["$dlist"].names.[i]+", ";
      }
   t:=t+self.extra.["$dlist"].vals.[i];
   i:=i+1;
  }
if (t>2400)
 t:=2400;
  t:=(t*100)/2400;
if (t==100)
                                                                                     buf :=buf +"The images seem to fill the bucket, "+
                                                                                     " with their grandeur and generosity.<br/>";
else
  buf:=buf+"The images only seem to fill the bucket %"+itoa(t)+" of the way up. "+
  " There is still room for your image if you are worthy.<br/>";

  buf:=textformat(buf);
  sendtext(buf,activator);

goto start;

:add_name:
if (activator.level<240)
goto start;
block;
if (argument=="")
 {
 sendtext ("who do you want to add<br/>",activator);
 goto start;
 }
 args:=getwords(argument);

 if (length (args) <2)
  {
  sendtext ("Correct format is 'add &lt;amount&gt; &lt;person&gt;'<br/>",activator);
  goto start;
  }

  if (atoi(args.[0])==0)
  {
  sendtext ("The first argument needs to be greater than 0<br/>",activator);
  goto start;
  }

tmp:=getword(argument);
insert(self.extra.["$dlist"].names,length(self.extra.["$dlist"].names),argument);
insert(self.extra.["$dlist"].vals,length(self.extra.["$dlist"].vals),atoi(args.[0]));

store (self,"bucket",TRUE);
goto start;
:del_name:

if (activator.level<200)
goto start;
block;


if (argument=="")
 {
 sendtext ("who do you want to delete<br/>",activator);
 goto start;
 }

t:=argument in self.extra.["$dlist"].names;
if (t>0)
 {
 remove (self.extra.["$dlist"].names,t-1);
  remove (self.extra.["$dlist"].vals,t-1);
   sendtext(argument +" removed from the list<br/>",activator);
 }
else
{
sendtext ("That person is not in the list.<br/>",activator);
}

store (self,"bucket",TRUE);
goto start;
} dilend
