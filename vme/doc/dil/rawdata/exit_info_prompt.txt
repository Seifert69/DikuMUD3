Generate MCP entry for DIL keyword: exit_info

=== Yacc rule ===
| DILSF_XNF idx /* .exit_info */
{
    INITEXP($$);
    copy_code(&($$), &($2));
    $$.rtyp = DilVarType_e::DILV_UP;
    $$.typ = DilVarType_e::DILV_INT;
    $$.dsl = DSL_LFT;
    $$.num = DILF_XNF;
    FREEEXP($2);
}

=== C implementation ===
case DILF_XNF:
            v2 = p->stack.pop(); /* evaluate index */
            switch (dil_getval(v1))
            {
                case DILV_NULL: /* not applicable */
                case DILV_FAIL:
                    v->type = DILV_FAIL; /* not applicable */
                    break;
                case DILV_UP:
                    v->type = DILV_UINT1R;
                    break;
                default:
                    v->type = DILV_ERR; /* wrong type */
                    break;
            }

            switch (dil_getval(v2))
            {
                case DILV_FAIL:
                    if (v->type != DILV_ERR)
                    {
                        v->type = DILV_FAIL; /* not applicable */
                    }
                    break;
                case DILV_INT:
                    break;
                default:
                    v->type = DILV_ERR; /* wrong type */
                    break;
            }

            if (v->type == DILV_UINT1R)
            {
                if (v1->val.ptr && ((unit_data *)v1->val.ptr)->isRoom() && is_in(v2->val.num, 0, MAX_EXIT) &&
                    ROOM_EXIT((unit_data *)v1->val.ptr, v2->val.num))
                {
                    v->atyp = DILA_NONE;
                    v->ref = ROOM_EXIT((unit_data *)v1->val.ptr, v2->val.num)->getDoorFlagsPtr();
                }
                else
                {
                    v->type = DILV_FAIL;
                }
            }
            break;

=== DIL example ===
dilbegin knock(arg : string);

external
   integer is_hidden@basemove(u1 : unitptr, int1 : integer, u2 : unitptr);
   string  dirstring@function(i2 : integer);
   integer checkdoor@basemove(arg : string);
   integer rev_dir@function(i : integer);

var
      item       :  unitptr;
      pc         :  unitptr;
      arg1       :  string;
      arg2       :  string;
      arg3       :  stringlist;
      dir        :  integer;
      oppdir     :  integer;
      test       :  integer;
      count      :  integer;
      counter    :  integer;

code
{
   if (self.position < POSITION_RESTING)
   {
      act("All you can do right now, is think about the stars!", A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   if (arg == "")
   {
      act("knock on what?", A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   /* next we see if the player has anything in his inventory or around him that he can knock on */
   arg1 := arg;       // saves the string in case we need it later

   item := findunit(self, arg1, FIND_UNIT_HERE, null);

   /* If there is no item or we cant see it, check the doors in the room */
   if (item == null)
      goto check_doors;

   // First figure out if we are knocking on the item, or from inside the item
   pc := self.outside;
   while (pc)
   {
      if (item == pc)
         break;

      pc := pc.outside;
   }

   // I decided that if you're inside a container you can always see it
   // Therefore the off (not pc) statement
   if ((not visible(self, item)) and (not pc))
      goto check_doors;

   if (pc)  // Knocking from the inside
   {
      if (isset(item.flags, UNIT_FL_BURIED))
         act("You hear a knocking sound from below.", A_SOMEONE, item, null, null, TO_ALL);
      else if (isset(item.openflags, EX_CLOSED) or (not isset(item.flags, UNIT_FL_TRANS)))
         act("You hear a loud knocking from $1n.", A_SOMEONE, item, null, null, TO_ALL);
   }
   else // knocking ON the object, we must be able to see it, check its not buried
   {
      if (isset(item.flags, UNIT_FL_BURIED))
         goto check_doors;

      if (isset(item.openflags, EX_CLOSED) or (not isset(item.flags, UNIT_FL_TRANS)))
         if (item.inside)
            act("You hear a loud knocking from $2n.", A_SOMEONE, item.inside, item, null, TO_ALL);
   }

   // message to everyone in the same location
   act("You knock on $2m.", A_SOMEONE, self, item, null, TO_CHAR);
   act("$1n knocks on $3n.", A_SOMEONE, self, null, item,TO_NOTVICT);
   act("$1n knocks on you.", A_SOMEONE, self, null, item, TO_VICT);

   send_done ("knock", self, null, item, 0, "", null, CMD_AUTO_NONE);
   return;


   :check_doors:
   /* first we are going to check if the player dictated what direction they want to open */
   /* set up so we can close 'both' doors (room player is in and room the door leads to.) */

   dir := checkdoor@basemove(arg);

   if (dir == -1)
   {
      act("You see no such exit in that direction.", A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   item := self.outside;
   while (item.type != UNIT_ST_ROOM)
      item := item.outside;

   if (not isset(item.exit_info[dir], EX_CLOSED))
   {
      act("You knock on the open $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_CHAR);
      act("$1n knocks on the open $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_REST);
   }
   else
   {
      act("You knock on the $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_CHAR);
      act("$1n knocks on the $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_REST);
   }

   pc := item.exit_to[dir].inside;
   if (pc != null)
   {
      oppdir := rev_dir@function(dir);

      if (not isset(item.exit_info[dir], EX_CLOSED))
      {
         act("$3n knocks on the open $2t.", A_SOMEONE, pc, item.exit_to[dir].exit_names[oppdir].[0] , self, TO_ALL);
      }
      else
      {
         act("You hear a knocking coming from $2t.", A_ALWAYS, pc,item.exit_to[dir].exit_names[oppdir].[0] , self, TO_ALL);
      }
   }

   send_done ("knock", self, null, null, 0, "", null, CMD_AUTO_NONE);
   return;
} dilend
