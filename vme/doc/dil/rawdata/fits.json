{
    "keyword": "fits",
    "opcode": "DILSE_FIT",
    "yacc_rule": "| DILSE_FIT '(' dilexp ',' dilexp ',' dilexp ')'\n{\n    INITEXP($$);\n\n    if ($3.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 1 of 'fits' not an unitptr.\");\n    }\n    else if ($5.typ != DilVarType_e::DILV_UP)\n    {\n        dilfatal(\"Arg 2 of 'fits' not an unitptr.\");\n    }\n    else if ($7.typ != DilVarType_e::DILV_INT)\n    {\n        dilfatal(\"Arg 3 of 'fits' not an integer.\");\n    }\n    else\n    {\n        /* Type is ok */\n        /* Make nodes dynamic */\n        $$.dsl = DSL_DYN;\n        $$.typ = DilVarType_e::DILV_SP;\n\n        make_code(&($3));\n        make_code(&($5));\n        make_code(&($7));\n\n        add_code(&($$), &($3));\n        add_code(&($$), &($5));\n        add_code(&($$), &($7));\n        add_ubit8(&($$), DILE_FIT);\n    }\n\n    FREEEXP($3);\n    FREEEXP($5);\n    FREEEXP($7);\n}",
    "dilfe_name": "dilfe_fits",
    "c_implementation": "void dilfe_fits(dilprg *p)\n{\n    dilval *v = new dilval;\n    dilval *v3 = p->stack.pop();\n    dilval *v2 = p->stack.pop();\n    dilval *v1 = p->stack.pop();\n    char *c = nullptr;\n\n    v->type = DILV_SP;\n\n    switch (dil_getval(v1))\n    {\n        case DILV_UP:\n            if (!v1->val.ptr || !((unit_data *)v1->val.ptr)->isChar())\n            {\n                v->type = DILV_FAIL;\n            }\n            else\n            {\n                switch (dil_getval(v2))\n                {\n                    case DILV_UP:\n                        if (!v2->val.ptr || !((unit_data *)v2->val.ptr)->isObj())\n                        {\n                            v->type = DILV_FAIL;\n                        }\n                        else\n                        {\n                            switch (dil_getval(v3))\n                            {\n                                case DILV_INT:\n                                    c = obj_wear_size((unit_data *)v1->val.ptr, (unit_data *)v2->val.ptr, v3->val.num);\n\n                                    v->atyp = DILA_EXP;\n                                    v->val.ptr = str_dup(c == nullptr ? \"\" : c);\n                                    break;\n                                default:\n                                    v->type = DILV_ERR;\n                                    break;\n                            }\n                        }\n                        break;\n                    case DILV_NULL:\n                    case DILV_FAIL:\n                        v->type = DILV_FAIL;\n                        break;\n                    default:\n                        v->type = DILV_ERR;\n                        break;\n                }\n            }\n\n            break;\n        case DILV_NULL:\n        case DILV_FAIL:\n            v->type = DILV_FAIL;\n            break;\n        default:\n            v->type = DILV_ERR;\n            break;\n    }\n\n    p->stack.push(v);\n    delete v1;\n    delete v2;\n    delete v3;\n}",
    "dil_example": "dilbegin resize_func(item1:integer, item2:integer, item3:integer,\n                     arm_type:integer, arm_type2:integer,\n                     cash:integer, a_name:string);\nexternal\n  string accept_dil@function (pc:unitptr,s:string);\nvar\n  mn:string;\n  answer:string;\n  i:integer;\n  amount:integer;\n  pc:unitptr;\n  size:string;\n  tgt:unitptr;\n  diff:integer;\ncode\n{\n   heartbeat := PULSE_SEC*5;\n   :start:\n   wait (SFB_DONE,command (\"give\") and\n\t (self==target));\n\n   if (not (visible(self, activator)))\n   {\n      exec(\"say I can't resize it when I can't see you!.\",self);\n      exec(\"drop \"+medium.name, self);\n      goto start;\n   }\n\n   pc := activator;\n   secure (pc,lostpc);\n   tgt := medium;\n   secure (tgt,lostitem);\n   dilcopy (\"busy@function(Please wait I am busy with other work right now.\",\n            self);\n\n   if (not (tgt.type&UNIT_ST_OBJ))\n   {\n      exec (\"say I can't resize that, \"+pc.name+\".\",self);\n      :giveit:\n      link (tgt, pc);\n      act (\"$2n gives $3n to $1n\",\n\t   A_SOMEONE,pc,self,tgt,TO_REST);\n      act (\"$2n gives $3n to you.\",\n\t   A_SOMEONE,pc,self,tgt,TO_CHAR);\n      i := dildestroy (\"busy@function\",self);\n      unsecure (pc);\n      unsecure (tgt);\n      goto start;\n   }\n\n   if (\"$resize\" in tgt.extra)\n   {\n      exec (\"say It cant be resize any more, \"+pc.name+\".\",self);\n      goto giveit;\n   }\n\n   if ((tgt.objecttype != item1) and\n       (tgt.objecttype != item2) and\n       (tgt.objecttype != item3))\n   {\n      exec (\"say I can not resize this, I am only a \"+a_name+\".\",self);\n      goto giveit;\n   }\n\n\n   if (tgt.objecttype == ITEM_ARMOR)\n   {\n      if ((tgt.value[0]!=arm_type) and\n          (arm_type2!=tgt.value[0]))\n      {\n         exec (\"say I can't resize that I am only a \"+a_name+\".\",self);\n         goto giveit;\n      }\n   }\n\n   amount := (100*tgt.height) / pc.height;\n   if (amount > 100)\n     diff := amount - 100;\n   else\n     diff := 100 - amount;\n\n   if (diff==0) goto  no_need;\n   i := cash*diff;\n   mn := moneystring(i, TRUE);\n\n   exec (\"say That will cost \"+mn+\" to have that resized.\",self);\n\n   answer := accept_dil@function(pc, \"Do you want this resized or not?\");\n   pause;\n\n   if (answer==\"no\")\n      goto no;\n\n   if (transfermoney(pc, self, i))\n   {\n      exec (\"resize \"+tgt.name+\" \"+pc.name,self);\n\n      if (not (\"$resized\" in tgt.extra))\n      {\n         exec (\"say I am sorry, I do not seem to be able to resize this, \"+\n               \"after all I am just a \"+a_name+\".\",self);\n         diff := transfermoney(self,pc, i);\n         goto giveit;\n      }\n\n      exec (\"say There you go, thats the best I can do.\",self);\n      goto giveit;\n   }\n   else\n     goto no_money;\n\n   :no:\n   exec (\"say Very well then come back when you want me to.\",self);\n   goto giveit;\n\n   :no_need:\n   exec (\"say It already fits you. I should charge you for \"+\n         \"waisting my time!\",self);\n   goto giveit;\n\n   :no_money:\n   exec (\"say You don't seem to have enough money. Come back when you \"+\n         \"have found enough to pay me.\",self);\n   goto giveit;\n\n   :lostpc:\n   :lostitem:\n   i := dildestroy (\"busy@function\",self);\n\n   unsecure (pc);\n   unsecure (tgt);\n   goto start;\n} dilend"
}