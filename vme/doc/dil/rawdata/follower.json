{
    "keyword": "follower",
    "opcode": "DILSF_FOL",
    "yacc_rule": "| DILSF_FOL /* .follower */\n{\n    INITEXP($$);\n    $$.rtyp = DilVarType_e::DILV_UP;\n    $$.typ = DilVarType_e::DILV_UP;\n    $$.dsl = DSL_DYN;\n    $$.num = DILF_FOL;\n}",
    "dilfe_name": "DILF_FOL",
    "c_implementation": "case DILF_FOL:\n            switch (dil_getval(v1))\n            {\n                case DILV_NULL: /* not applicable */\n                case DILV_FAIL:\n                    v->type = DILV_FAIL; /* not applicable */\n                    break;\n                case DILV_UP:\n                {\n                    auto *character = reinterpret_cast<char_data *>(v1->val.ptr);\n                    if (character && character->isChar())\n                    {\n                        if (CHAR_FOLLOWERS(character))\n                        {\n                            v->atyp = DILA_NORM;\n                            v->type = DILV_UPR;\n                            v->ref = character->getFollowers()->getFollowerPtr();\n                        }\n                        else\n                        {\n                            v->atyp = DILA_NORM;\n                            v->type = DILV_NULL;\n                            v->val.ptr = nullptr;\n                        }\n                    }\n                    else\n                    {\n                        v->type = DILV_FAIL;\n                    }\n                }\n                break;\n\n                default:\n                    v->type = DILV_ERR; /* wrong type */\n                    break;\n            }\n            break;",
    "dil_example": "dilbegin do_split(arg: string);\n\nexternal string coinstring@function(coins: integer, typ: string, ext:\ninteger);\n         integer transfercoins@function (a: unitptr, t: unitptr,\n                                         coins: integer, typ: string);\nvar mast : unitptr;\n    sel  : integer;\n\n    in_gr: integer;\n    kids : integer;\n    coins: integer;\n    spval: integer;\n    ctype: string;\n    done : integer;\n\n    u    : unitptr;\n    ms   : string;\n    s    : string;\n    tmp  : string;\n    i    : integer;\n    l    : integer;\n\n//    beta_list: stringlist;\n\ncode\n{\n\n// Not used til something gets wrong\n/* beta_list := {\"Stormtamer\", \"Whistler\", \"Tooth\", \"Ginger\", \"Jashiree\",\n\"Aelf\",\n    \"Tiggy\", \"Gothmog\"};\n\nif (not (self.name in beta_list)) // Hardcoded list for beta testing\n    {\n    sendtext(\"Sorry, this command is under evaluation.<br/>\", self);\n    return;\n    }\n*/\narg:= getword(arg);\nsel:= arg in {\"iron\", \"copper\", \"silver\", \"gold\", \"platinum\", \"all\"};\n\nif (sel <= 0)\n    sel := arg in {\"ip\", \"cp\", \"sp\", \"gp\", \"pp\"};\n\nif (sel <= 0) /* still not found */\n    {\n    act (\"You can only split iron, copper, silver, gold, or platinum pieces\"+\n        \"(or all of them).\", A_ALWAYS, self, null, null, TO_CHAR);\n    return;\n    }\n\nsel:= sel - 1;\nkids:= 1; /* We expect at least one splitter, self */\n\nif (self.master)\n    {\n    if (self.master.master)\n        {\n        mast := self;\n        in_gr := FALSE;\n        }\n\n    else if (not isset (self.charflags, CHAR_GROUP) or\n        not isset(self.master.charflags, CHAR_GROUP))\n        {\n        mast := self;\n        in_gr := FALSE;\n        }\n\n    else\n        {\n        mast := self.master;\n        in_gr := TRUE;\n\n        foreach (UNIT_ST_PC|UNIT_ST_NPC, u)\n            {\n            if (u == self) continue;\n            if ((u.master != mast) and (u != mast)) continue;\n            if (not isset(u.charflags, CHAR_GROUP)) continue;\n\n            kids := kids + 1; /* To know how many groupies there are in room\n*/\n            }\n\n        }\n    }\n\nelse\n    {\n    mast := self;\n\n    if (not self.follower)\n        in_gr := FALSE;\n\n    else if (not isset(self.charflags, CHAR_GROUP))\n        in_gr := FALSE;\n\n    else foreach (SPLIT_CHARS, u)\n        {\n        if (u == self) continue;\n        if (not visible(self, u)) continue;\n\n        if (u.master != mast) continue;\n        if (not isset(u.charflags, CHAR_GROUP)) continue;\n\n        in_gr := TRUE;\n        kids := kids + 1;\n        }\n    }\n\nif (not in_gr)\n    {\n    act(\"You become rather picky with your loot.\",A_ALWAYS, self, null,\nnull, TO_CHAR);\n    act(\"$1n peers around, greedily playing with $1s money.\",A_HIDEINV,\nself, null, null, TO_REST);\n    return;\n    }\n\ni:= flog (\"split.log\", asctime(realtime)+\": \"+self.name+\" called the split\"+\n        \"command (\"+itoa(sel)+\")\", \"a\");\n\nif (sel == 5)\n    goto split_all;\n\nif (sel == 0)\n    ctype := IRON_PIECE;\nif (sel == 1)\n    ctype := COPPER_PIECE;\nif (sel == 2)\n    ctype := SILVER_PIECE;\nif (sel == 3)\n    ctype := GOLD_PIECE;\nif (sel == 4)\n    ctype := PLATINUM_PIECE;\n\ncoins:= purse(self, ctype);\n\nif (coins < kids) /* There are less coins of that type than group members */\n    {\n    act(\"Splitting \"+itoa(coins)+\" coins evenly between \"+itoa(kids)+\n        \" people might be quite a puzzle...\",A_ALWAYS, self, null, null,\nTO_CHAR);\n    return;\n    }\n\nspval:= coins / kids;\n\nms:= coinstring@function (coins, ctype, TRUE);\n\ntmp:= ms;\ns:= getword(tmp);\ns:= tmp; /* To get the \"platinum pieces\" or such, without the amount */\n\nms:= coinstring@function (spval, ctype, TRUE);\n\nact (\"You start splitting your \"+s+\" between your group members.\",\n    A_ALWAYS, self, null, null, TO_CHAR);\nact (\"$1n starts splitting $1s \"+s+\".\",A_HIDEINV, self, null, null,\nTO_REST);\n\nforeach (SPLIT_CHARS, u)\n    {\n\n    if (u == self)\n        {\n        act(\"You keep \"+ms+\" for yourself.\",A_ALWAYS, self, null, null,\nTO_CHAR);\n        continue;\n        }\n\n    if (not visible(self, u)) continue;\n\n    if ( ((u.master != mast) and (u != mast)) or\n        not isset(u.charflags, CHAR_GROUP))\n        continue; /* Not a grouped */\n\n    act (\"You give $3n \"+ms+\".\", A_HIDEINV, self, null, u, TO_CHAR);\n    act (\"$1n gives $3n \"+ms+\".\", A_HIDEINV, self, null, u, TO_NOTVICT);\n    act (\"$1n gives you \"+ms+\".\", A_HIDEINV, self, null, u, TO_VICT);\n\n    i := flog (\"split.log\", asctime(realtime)+\": \"+self.name+\" split \"+\n        itoa(coins)+\" \"+ctype+\" to \"+ms+\" (to \"+u.name+\")\", \"a\");\n\n    i := transfercoins@function (self, u, spval, ctype);\n\n    if (i == FALSE)\n        act(\"You realize something is wrong with $1n's money.\",\n            A_HIDEINV, self, null, u, TO_VICT);\n    }\n\ni:= flog (\"split.log\", asctime(realtime)+\": \"+self.name+\" returned from the\"+\n    \"split command.\", \"a\");\nreturn;\n\n:split_all:\n\nact (\"You start splitting your money between your group members.\",\n    A_ALWAYS, self, null, null, TO_CHAR);\nact (\"$1n starts splitting $1s money.\",\n    A_HIDEINV, self, null, null, TO_REST);\n\n\nl:= MAX_MONEY;\nms:= \"\";\n\nwhile (l >= 0)\n    {\n    if (l == 0)\n        ctype := IRON_PIECE;\n    if (l == 1)\n        ctype := COPPER_PIECE;\n    if (l == 2)\n        ctype := SILVER_PIECE;\n    if (l == 3)\n        ctype := GOLD_PIECE;\n    if (l == 4)\n        ctype := PLATINUM_PIECE;\n\n    coins := purse(self, ctype);\n\n    if (coins < kids)\n        {\n        l := l - 1;\n        continue;\n        }\n\n    spval := coins / kids;\n    s := coinstring@function (spval, ctype, TRUE);\n\n    if (ms == \"\")\n        ms := s;\n\n    else\n        ms := ms + \", \" + s;\n\n    foreach (SPLIT_CHARS, u)\n        {\n\n        if (u == self)\n            continue;\n\n        if (not visible(self, u)) continue;\n\n        if ( ((u.master != mast) and (u != mast)) or\n        not isset(u.charflags, CHAR_GROUP))\n        continue; /* Not a grouped */\n\n        i := transfercoins@function (self, u, spval, ctype);\n\n        if (i == FALSE)\nact(\"You realize something is wrong with $1n's money.\",A_HIDEINV, self,\nnull, u, TO_VICT);\n\n        i := flog (\"split.log\", asctime(realtime)+\": \"+self.name+\" split \"+\n            itoa(coins)+\" \"+ctype+\" to \"+s+\" (to \"+u.name+\")\", \"a\");\n\n        }\n\n    done := TRUE;\n    l := l - 1;\n    }\n\nforeach (SPLIT_CHARS, u)\n    {\n    if (u == self)\n        {\n        act(\"You keep \"+ms+\" for yourself.\",A_ALWAYS, self, null, null,\nTO_CHAR);\n        continue;\n        }\n\n    if (not visible(self, u)) continue;\n\n    if ( ((u.master != mast) and (u != mast)) or\n        not isset(u.charflags, CHAR_GROUP))\n        continue; /* Not a grouped */\n\n    act (\"You give $3n \"+ms+\".\", A_HIDEINV, self, null, u, TO_CHAR);\n    act (\"$1n gives $3n \"+ms+\".\", A_HIDEINV, self, null, u, TO_NOTVICT);\n    act (\"$1n gives you \"+ms+\".\", A_HIDEINV, self, null, u, TO_VICT);\n    }\n\nif (not done)\n    {\n    act(\"You realize you do not have enough money to split it between all \"+\n        \"your party members.\", A_ALWAYS, self, null, null, TO_CHAR);\n    act(\"$1n seems to realize $1s purse is empty.\",\n        A_HIDEINV, self, null, null, TO_REST);\n    }\n\ni:= flog (\"split.log\", asctime(realtime)+\": \"+self.name+\" returned from the\"+\n        \"split command.\", \"a\");\nreturn;\n\n} dilend"
}