Generate MCP entry for DIL keyword: transfermoney

=== Yacc rule ===
| DILSE_TRMO '(' dilexp ',' dilexp ',' dilexp ')'
{
    INITEXP($$);

    if (($3.typ != DilVarType_e::DILV_UP) && ($3.typ != DilVarType_e::DILV_NULL))
    {
        dilfatal("Arg 1 of 'transfermoney' not a unitptr");
    }
    else if (($5.typ != DilVarType_e::DILV_UP) && ($5.typ != DilVarType_e::DILV_NULL))
    {
        dilfatal("Arg 2 of 'transfermoney' not a unitptr");
    }
    else if ($7.typ != DilVarType_e::DILV_INT)
    {
        dilfatal("Arg 3 of 'transfermoney' not an integer");
    }
    else
    {
        /* Type is ok */
        /* Make nodes dynamic */
        $$.dsl = DSL_DYN;
        $$.typ = DilVarType_e::DILV_INT;
        make_code(&($3));
        make_code(&($5));
        make_code(&($7));
        add_code(&($$), &($3));
        add_code(&($$), &($5));
        add_code(&($$), &($7));
        add_ubit8(&($$), DILE_TRMO);
    }
    FREEEXP($3);
    FREEEXP($5);
    FREEEXP($7);
}

=== C implementation ===
void dilfe_trmo(dilprg *p)
{
    dilval *v = new dilval;
    char buf[1024];
    int i = 0;
    buf[0] = 0;
    dilval *v3 = p->stack.pop();
    dilval *v2 = p->stack.pop();
    dilval *v1 = p->stack.pop();

    v->type = DILV_INT;

    switch (dil_getval(v1))
    {
        case DILV_FAIL:
            v->type = DILV_FAIL;
            break;
        case DILV_NULL:
        case DILV_UP:
            if (v1->val.ptr && !((unit_data *)v1->val.ptr)->isChar())
            {
                v->type = DILV_FAIL;
            }
            else
            {
                switch (dil_getval(v2))
                {
                    case DILV_FAIL:
                        v->type = DILV_FAIL;
                        break;
                    case DILV_NULL:
                    case DILV_UP:
                        if (v2->val.ptr && !((unit_data *)v2->val.ptr)->isChar())
                        {
                            v->type = DILV_FAIL;
                        }
                        else
                        {
                            switch (dil_getval(v3))
                            {
                                case DILV_FAIL:
                                case DILV_NULL:
                                    v->type = DILV_FAIL;
                                    break;
                                case DILV_INT:
                                    break;
                                default:
                                    v->type = DILV_ERR;
                                    break;
                            }
                        }

                        break;
                    default:
                        v->type = DILV_ERR;
                        break;
                }
            }
            break;
        default:
            v->type = DILV_ERR;
            break;
    }

    v->val.num = 0;

    if (v->type == DILV_INT && (v1->val.ptr || v2->val.ptr))
    {
        if (v1->val.ptr == nullptr)
        {
            for (i = 0; i <= MAX_CURRENCY; ++i)
            {
                strcat(buf, " ");
                strcat(buf, money_string(v3->val.num, i, TRUE));
            }

            slog(LOG_ALL,
                 0,
                 "%s was given %s by DIL %s.",
                 ((unit_data *)v2->val.ptr)->getNames().Name(),
                 buf,
                 p->sarg->owner->getFileIndexSymName());
            money_transfer(nullptr, (unit_data *)v2->val.ptr, v3->val.num, local_currency((unit_data *)v2->val.ptr));
            v->val.num = 1;
        }
        else if (v2->val.ptr == nullptr)
        {
            if (char_can_afford((unit_data *)v1->val.ptr, v3->val.num, local_currency((unit_data *)v1->val.ptr)))
            {
                money_transfer((unit_data *)v1->val.ptr, nullptr, v3->val.num, local_currency((unit_data *)v1->val.ptr));
                v->val.num = 1;
            }
        }
        else
        {
            if (char_can_afford((unit_data *)v1->val.ptr, v3->val.num, local_currency((unit_data *)v2->val.ptr)))
            {
                money_transfer((unit_data *)v1->val.ptr, (unit_data *)v2->val.ptr, v3->val.num, local_currency((unit_data *)v2->val.ptr));
                v->val.num = 1;
            }
        }
    }
    p->stack.push(v);
    delete v1;
    delete v2;
    delete v3;
}

=== DIL example ===
dilbegin item_charge(base_charge:integer);
external
  string accept_dil@function (pc:unitptr,s:string);

var
   tcost   : integer;
   state   : integer;
   magmod  : integer;
   addmag  : integer;
   die     : integer;
   result  : integer;
   percent : integer;
   thing   : unitptr;
   pc      : unitptr;
   answer  : string;
   mn      : string;

code
{

:init:
   heartbeat := PULSE_SEC*5;
   self.spells[SPL_RECONSTRUCT] := 200;
   self.abilities[ABIL_BRA] := 150;
   self.abilities[ABIL_MAG] := 150;   
   position_update(self);
:start:
   wait (SFB_DONE,( (command("give")) and (self==target) ));

pc:=activator;
thing:=medium;
secure(pc,lost_pc);
secure(thing,lost_pc);

if( not visible( self, pc ) )
   {
      exec("say I only do business with people I can see.", self );
      exec("drop " + (thing.name), self);
      goto lost_pc;
   }

dilcopy ("busy@function(Please wait I am busy with other work right now.",
self)
;

if (thing.type!=UNIT_ST_OBJ)
   {
      exec ("say How am I supposed to recharge that then "+pc.name+"?",self);
      exec ("bonk " + pc.name,self);
      goto give_back;
   }

if ((thing.objecttype!=ITEM_WAND) and (thing.objecttype!=ITEM_STAFF))
   {
      exec ("say How am I supposed to recharge that then "+pc.name+"?",self);
      exec ("bonk " + pc.name,self);
      goto give_back;
   }

/* If people don't wish their wands/staffs rechargable by shops, they declare
   an extra, $norecharge, on the item. */

if ("$norecharge" in thing.extra)
   {
      exec ("say I can't recharge this " + thing.title +
            "," + pc.name +". It is beyond my ability.", self);
      goto give_back;
   }

if ( thing.value[1] == thing.value[4] )
   {
      exec("say It is fully charged, what do you want " +
           "to go charging it for?!?", self);
      exec("bonk " + pc.name, self);
      goto give_back;
   }

state:=thing.value[4]-thing.value[1];
goto how_much;


:broken_thing:
   exec("say Oh my, it's broken. I can't fix that. I suggest " +
        "you try to obtain another.", self);
   goto give_back;

:not_possible:
   exec("say Oh dear, I'm afraid that it's past the point " +
           "of no return. Repairing it would only make it " +
           "worse " + pc.name + ".", self);
   goto give_back;

:how_much:
   tcost := (base_charge*160); /* Base cost in 1 gold 2 sp. Modified by
                                   how badly damaged the item is and its
                                   Magical Modifier */
   tcost := tcost * state;     /* Adjust for how bad the damage is */
   magmod := thing.value[0]; /* Take spell power into account    */

   if (magmod > 0)
   {
      addmag := magmod; /* 1 gp per mag point */
      tcost := tcost * addmag;  /* Final cost         */
   }

   mn := moneystring(tcost, 0);
   exec ("say It will cost you " + mn + " for me to " +
         "recharge that for you.", self);
   answer := accept_dil@function(pc, "Are you sure you want me to recharge it?");
   pause;

   if (answer=="no")
   {
      exec("say Very well. Come back to me when you want it recharged.",self);
      goto give_back;
   }

   if (transfermoney(pc, self, tcost))
   {
      exec(", touches " + thing.name + " softly and begins to chant...", self);
:repair_it:
      if(thing.objecttype==ITEM_WAND)
        result := cast_spell(SPL_CHARGE_WAND, self, self, thing, "");
      else
        result := cast_spell(SPL_CHARGE_STAFF, self, self, thing, "");
      if (thing.value[1] < thing.value[4]) goto repair_it;
      heartbeat:=PULSE_SEC*1;
      pause;
      exec("say There, hope you like it, " + pc.name + "!", self);
      heartbeat:=PULSE_SEC*5;
      goto give_back;
   }
   else goto no_money;

:no_money:
   exec ("say You can't afford my services right now. Please come back " +
         "when you have enough money.",self);
   goto give_back;

:give_back:
   act( self.name + " returns your " + thing.name + " to you.",
       A_ALWAYS,pc,null,null,TO_CHAR);
   act(self.name + " returns $1n's " + thing.name + " to $1m.",
       A_SOMEONE,pc,null,null,TO_REST);
   link(thing,pc);
   goto lost_pc;

:lost_pc:
   die := dildestroy ("busy@function",self);
   unsecure(pc);
   unsecure(thing);
   goto start;
} dilend
