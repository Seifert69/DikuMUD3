<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
   <page>
     <title>Manual:DIL_Manual/DIL_Documentation_Structure</title>
     <ns>0</ns>
     <id>791455</id>
     <revision>
       <id>1611458</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of DIL_Documentation_Structure.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= DikuMUD3 DIL Documentation =

== 1. Language Fundamentals ==

=== 1.1 Data Types ===

==== Basic Types ====
; [[Manual:DIL_Manual/integer|integer]] : Basic numeric data type
: Used for mathematical operations and counters
; [[Manual:DIL_Manual/string|string]] : Text data type
: Used for messages, names, and descriptions

==== Complex Types ====
; [[Manual:DIL_Manual/unitptr|unitptr]] : Unit pointer data type
: References to game units (characters, objects, rooms)
; [[Manual:DIL_Manual/integerlist|integerlist]] : Integer list data type
: Collections of integer values
; [[Manual:DIL_Manual/stringlist|stringlist]] : String list data type
: Collections of string values

==== Type Conversion Functions ====
; [[Manual:DIL_Manual/atoi|atoi]] : Convert [[Manual:DIL_Manual/string|string]] to [[Manual:DIL_Manual/integer|integer]]
: Parses numeric values from text
; [[Manual:DIL_Manual/itoa|itoa]] : Convert [[Manual:DIL_Manual/integer|integer]] to [[Manual:DIL_Manual/string|string]]
: Formats numbers as text

=== 1.2 Variables and Constants ===

==== Built-in Variables ====
; [[Manual:DIL_Manual|self]] : [[Manual:DIL_Manual/unitptr|unitptr]]
: Current unit executing the DIL program
; [[Manual:DIL_Manual|activator]] : [[Manual:DIL_Manual/unitptr|unitptr]]
: Unit that activated the current DIL program
; [[Manual:DIL_Manual|argument]] : [[Manual:DIL_Manual/string|string]]
: Arguments provided with the command
; [[Manual:DIL_Manual|command]] : [[Manual:DIL_Manual/string|string]]
: The command that was executed
; [[Manual:DIL_Manual|cmdstr]] : [[Manual:DIL_Manual/string|string]]
: Full command string
; [[Manual:DIL_Manual|null]] : null value
: Represents null/empty value

==== Unit Type Constants ====
; [[Manual:DIL_Manual|UNIT_ST_PC]] : Player character unit type
: Identifies player-controlled characters
; [[Manual:DIL_Manual|UNIT_ST_NPC]] : Non-player character unit type
: Identifies computer-controlled characters
; [[Manual:DIL_Manual|UNIT_ST_OBJ]] : Object unit type
: Identifies items and objects
; [[Manual:DIL_Manual|UNIT_ST_ROOM]] : Room unit type
: Identifies locations and areas

==== Game Constants ====
; [[Manual:DIL_Manual|POSITION_*]] : Position constants
: Character positions (standing, sitting, fighting, etc.)
; [[Manual:DIL_Manual|CHAR_*]] : Character flag constants
: Character states and affects
; [[Manual:DIL_Manual|OBJ_*]] : Object flag constants
: Object properties and states
; [[Manual:DIL_Manual|ROOM_*]] : Room flag constants
: Room properties and characteristics

=== 1.3 Control Structures ===

==== Conditional ====
; [[Manual:DIL_Manual/if|if]] : Conditional statement
: Executes code based on boolean conditions
; [[Manual:DIL_Manual/switch|switch]] : Multi-way conditional
: Selects between multiple code paths

==== Loops ====
; [[Manual:DIL_Manual/while|while]] : Loop construct
: Repeats code while condition is true
; [[Manual:DIL_Manual/goto|goto]] : Unconditional jump
: Transfers control to labeled statements
; [[Manual:DIL_Manual/break|break]] : Loop control
: Exit from loop
; [[Manual:DIL_Manual/continue|continue]] : Loop control
: Continue to next iteration

==== Functions ====
; [[Manual:DIL_Manual/return|return]] : Return from function
: Exits current function with optional value
; [[Manual:DIL_Manual/quit|quit]] : Terminate DIL program
: Ends program execution immediately

=== 1.4 Operators and Expressions ===

==== Arithmetic Operators ====
; + : Addition
: Mathematical addition
; - : Subtraction
: Mathematical subtraction
; * : Multiplication
: Mathematical multiplication
; / : Division
: Mathematical division

==== Comparison Operators ====
; = : Equality test
: Checks if values are equal
; &lt; : Less than
: Numeric comparison
; &gt; : Greater than
: Numeric comparison
; &lt;= : Less than or equal
: Numeric comparison
; &gt;= : Greater than or equal
: Numeric comparison

==== Logical Operators ====
; [[Manual:DIL_Manual/and|and]] : Logical AND
: Boolean conjunction
; [[Manual:DIL_Manual/or|or]] : Logical OR
: Boolean disjunction
; [[Manual:DIL_Manual/not|not]] : Logical NOT
: Boolean negation

==== Bit Operations ====
; [[Manual:DIL_Manual/set|set]] : Set bits
: Turn on bit flags
; [[Manual:DIL_Manual/unset|unset]] : Clear bits
: Turn off bit flags
; [[Manual:DIL_Manual/isset|isset]] : Test bits
: Check bit flags

== 2. Unit System ==

=== 2.1 Unit Types ===

==== Player Characters (UNIT_ST_PC) ====
; [[Manual:DIL_Manual/birth|birth]] : Creation timestamp
: When the character was created
; [[Manual:DIL_Manual/skills|skills]] : Skill proficiencies array
: Character skill values
; [[Manual:DIL_Manual/skill_points|skill_points]] : Available skill points
: Points for skill advancement
; [[Manual:DIL_Manual/pcflags|pcflags]] : Player-specific flags
: Player-only properties
; [[Manual:DIL_Manual/acc_balance|acc_balance]] : Account balance
: Bank account funds
; [[Manual:DIL_Manual/acc_total|acc_total]] : Total assets
: Complete wealth
; [[Manual:DIL_Manual/acc_modify|acc_modify]] : Modify account
: Account operations
; [[Manual:DIL_Manual/playtime|playtime]] : Play time
: Time spent playing
; [[Manual:DIL_Manual/gamestate|gamestate]] : Game state
: Player game state
; [[Manual:DIL_Manual/quests|quests]] : Quest information
: Player quest data
; [[Manual:DIL_Manual/notes|notes]] : Notes
: Player notes
; [[Manual:DIL_Manual/lifespan|lifespan]] : Lifespan
: Character lifespan
; [[Manual:DIL_Manual/reset_level|reset_level]] : Reset level
: Character level reset
; [[Manual:DIL_Manual/reset_race|reset_race]] : Reset race
: Character race reset
; [[Manual:DIL_Manual/reset_vlevel|reset_vlevel]] : Reset virtual level
: Virtual level reset

==== Non-Player Characters (UNIT_ST_NPC) ====
; [[Manual:DIL_Manual/npcflags|npcflags]] : NPC-specific flags
: NPC behavior and properties
; [[Manual:DIL_Manual/hometown|hometown]] : Home location
: NPC&apos;s origin location
; [[Manual:DIL_Manual/profession|profession]] : Profession
: NPC job/role
; [[Manual:DIL_Manual/master|master]] : Master/leader
: NPC leader
; [[Manual:DIL_Manual/follower|follower]] : Follower
: NPC follower
; [[Manual:DIL_Manual/followercount|followercount]] : Number of followers
: Count of followers
; [[Manual:DIL_Manual/getfollower|getfollower]] : Get specific follower
: Get specific follower unit
; [[Manual:DIL_Manual/follow|follow]] : Follow relationship
: Following behavior

==== Objects (UNIT_ST_OBJ) ====
; [[Manual:DIL_Manual/objectflags|objectflags]] : Object properties
: Object state and characteristics
; [[Manual:DIL_Manual/objecttype|objecttype]] : Object classification
: Type of object (weapon, armor, container, etc.)
; [[Manual:DIL_Manual/value|value]] : Monetary value
: Object&apos;s worth in currency
; [[Manual:DIL_Manual/cost|cost]] : Item cost
: Purchase price
; [[Manual:DIL_Manual/rent|rent]] : Rental cost
: Equipment rental fees
; [[Manual:DIL_Manual/weight|weight]] : Current weight
: Total weight including contents
; [[Manual:DIL_Manual/baseweight|baseweight]] : Base weight
: Empty weight of object
; [[Manual:DIL_Manual/capacity|capacity]] : Carrying capacity
: Maximum weight capacity
; [[Manual:DIL_Manual/manipulate|manipulate]] : Manipulation flags
: How object can be handled
; [[Manual:DIL_Manual/key|key]] : Key value
: Object key
; [[Manual:DIL_Manual/idx|idx]] : Index
: Object index
; [[Manual:DIL_Manual/fits|fits]] : Check if fits
: Check if object fits
; [[Manual:DIL_Manual/can_carry|can_carry]] : Check if can carry
: Check carry capacity
; [[Manual:DIL_Manual/illum|illum]] : Illumination
: Object illumination
; [[Manual:DIL_Manual/light|light]] : Light source
: Object light output
; [[Manual:DIL_Manual/fname|fname]] : File name
: Object file name
; [[Manual:DIL_Manual/names|names]] : Object names
: Object name list
; [[Manual:DIL_Manual/extra|extra]] : Extra descriptions
: Additional descriptions
; [[Manual:DIL_Manual/extraptr|extraptr]] : Extra description pointer
: Pointer to extra descriptions

==== Rooms (UNIT_ST_ROOM) ====
; [[Manual:DIL_Manual/roomflags|roomflags]] : Room properties
: Room characteristics and states
; [[Manual:DIL_Manual/zoneidx|zoneidx]] : Zone index
: Which zone the room belongs to
; [[Manual:DIL_Manual/mapx|mapx]] : Map X coordinate
: Horizontal position
; [[Manual:DIL_Manual/mapy|mapy]] : Map Y coordinate
: Vertical position
; [[Manual:DIL_Manual/bright|bright]] : Brightness level
: Light level in room
; [[Manual:DIL_Manual/light|light]] : Light sources
: Available illumination
; [[Manual:DIL_Manual/islight|islight]] : Light check
: Whether room is lit
; [[Manual:DIL_Manual/movement|movement]] : Movement type
: Room movement restrictions
; [[Manual:DIL_Manual/exit_to|exit_to]] : Exit destinations
: Where exits lead
; [[Manual:DIL_Manual/exit_names|exit_names]] : Exit names
: Exit identifiers
; [[Manual:DIL_Manual/exit_info|exit_info]] : Exit properties
: Exit characteristics
; [[Manual:DIL_Manual/exit_key|exit_key]] : Exit key
: Key required for exit
; [[Manual:DIL_Manual/exit_diff|exit_diff]] : Exit difficulty
: Exit difficulty level
; [[Manual:DIL_Manual/resetmode|resetmode]] : Reset mode
: Zone reset behavior
; [[Manual:DIL_Manual/resettime|resettime]] : Reset time
: Reset schedule
; [[Manual:DIL_Manual/lastroom|lastroom]] : Last room
: Previous room location

=== 2.2 Character Fields ===

==== Core Attributes ====
; [[Manual:DIL_Manual/abilities|abilities]] : Ability scores array
: Character attributes (STR, DEX, CON, etc.)
; [[Manual:DIL_Manual/ability_points|ability_points]] : Available ability points
: Points for abilities
; [[Manual:DIL_Manual/ability_levels|ability_levels]] : Ability level requirements
: Advancement requirements
; [[Manual:DIL_Manual/ability_costs|ability_costs]] : Ability costs
: Experience costs
; [[Manual:DIL_Manual/level|level]] : Character level
: Experience and power level
; [[Manual:DIL_Manual/vlevel|vlevel]] : Virtual level
: Effective level
; [[Manual:DIL_Manual/alignment|alignment]] : Moral alignment
: Good/evil alignment value
; [[Manual:DIL_Manual/race|race]] : Racial type
: Character&apos;s race
; [[Manual:DIL_Manual/sex|sex]] : Gender
: Character gender
; [[Manual:DIL_Manual/height|height]] : Character height
: Physical height
; [[Manual:DIL_Manual/weight|weight]] : Character weight
: Physical weight
; [[Manual:DIL_Manual/speed|speed]] : Movement speed
: Movement speed value

==== Combat Attributes ====
; [[Manual:DIL_Manual/position|position]] : Current position
: Physical state (standing, fighting, etc.)
; [[Manual:DIL_Manual/defaultpos|defaultpos]] : Default position
: Default position state
; [[Manual:DIL_Manual/position_update|position_update]] : Update character position
: Update position based on HP
; [[Manual:DIL_Manual/attack_type|attack_type]] : Unarmed attack type
: Natural combat style
; [[Manual:DIL_Manual/fighting|fighting]] : Combat opponent
: Current combat target
; [[Manual:DIL_Manual/opponent|opponent]] : Combat target
: Alternative opponent reference
; [[Manual:DIL_Manual/getopponent|getopponent]] : Get opponent
: Get current opponent
; [[Manual:DIL_Manual/opponentcount|opponentcount]] : Number of opponents
: Count of opponents
; [[Manual:DIL_Manual/hp|hp]] : Hit points
: Current health
; [[Manual:DIL_Manual/max_hp|max_hp]] : Maximum hit points
: Health capacity
; [[Manual:DIL_Manual/endurance|endurance]] : Endurance
: Current endurance
; [[Manual:DIL_Manual/max_endurance|max_endurance]] : Maximum endurance
: Endurance capacity
; [[Manual:DIL_Manual/mana|mana]] : Mana points
: Current mana
; [[Manual:DIL_Manual/max_mana|max_mana]] : Maximum mana
: Mana capacity
; [[Manual:DIL_Manual/natural_armour|natural_armour]] : Natural armor
: Built-in armor
; [[Manual:DIL_Manual/defensive|defensive]] : Defense value
: Protection rating
; [[Manual:DIL_Manual/offensive|offensive]] : Attack value
: Combat effectiveness

==== Skills &amp; Spells ====
; [[Manual:DIL_Manual/skills|skills]] : Skill proficiencies
: Character skill values
; [[Manual:DIL_Manual/skill_points|skill_points]] : Available skill points
: Points for advancement
; [[Manual:DIL_Manual/skill_levels|skill_levels]] : Skill level requirements
: Advancement thresholds
; [[Manual:DIL_Manual/skill_costs|skill_costs]] : Skill costs
: Training costs
; [[Manual:DIL_Manual/skill_name|skill_name]] : Get skill name
: Get name from skill index
; [[Manual:DIL_Manual/spells|spells]] : Spell proficiencies
: Magical ability levels
; [[Manual:DIL_Manual/spell_levels|spell_levels]] : Spell level requirements
: Magical advancement
; [[Manual:DIL_Manual/spell_costs|spell_costs]] : Spell costs
: Magical training costs
; [[Manual:DIL_Manual/spellindex|spellindex]] : Spell index lookup
: Find spell by index
; [[Manual:DIL_Manual/spellinfo|spellinfo]] : Spell information
: Detailed spell data
; [[Manual:DIL_Manual/weapons|weapons]] : Weapon proficiencies
: Combat skill levels
; [[Manual:DIL_Manual/weapon_levels|weapon_levels]] : Weapon requirements
: Weapon skill thresholds
; [[Manual:DIL_Manual/weapon_costs|weapon_costs]] : Weapon costs
: Weapon training costs
; [[Manual:DIL_Manual/weapon_name|weapon_name]] : Weapon name
: Get weapon type name
; [[Manual:DIL_Manual/weapon_info|weapon_info]] : Weapon information
: Detailed weapon data

==== Flags &amp; States ====
; [[Manual:DIL_Manual/charflags|charflags]] : Character flags
: States and affects
; [[Manual:DIL_Manual/visible|visible]] : Visibility
: Character visibility
; [[Manual:DIL_Manual/isplayer|isplayer]] : Check if player
: Player check
; [[Manual:DIL_Manual/power|power]] : Power level
: Character power
; [[Manual:DIL_Manual/crimes|crimes]] : Criminal record
: Criminal history

==== Economic ====
; [[Manual:DIL_Manual/purse|purse]] : Money container
: Character&apos;s wealth
; [[Manual:DIL_Manual/paycheck|paycheck]] : Regular income
: Periodic earnings
; [[Manual:DIL_Manual/transfermoney|transfermoney]] : Transfer currency
: Move money between characters
; [[Manual:DIL_Manual/moneystring|moneystring]] : Format money
: Display currency properly

==== Social ====
; [[Manual:DIL_Manual/hometown|hometown]] : Home location
: Character&apos;s home
; [[Manual:DIL_Manual/guild|guild]] : Guild affiliation
: Guild membership
; [[Manual:DIL_Manual/master|master]] : Master/leader
: Character&apos;s master
; [[Manual:DIL_Manual/follower|follower]] : Follower
: Character followers
; [[Manual:DIL_Manual/followercount|followercount]] : Number of followers
: Count of followers
; [[Manual:DIL_Manual/getfollower|getfollower]] : Get specific follower
: Get follower unit
; [[Manual:DIL_Manual/follow|follow]] : Follow relationship
: Following behavior

==== Equipment ====
; [[Manual:DIL_Manual/equipment|equipment]] : Equipment slots
: Worn items
; [[Manual:DIL_Manual/equip|equip]] : Equip item
: Wear/wield object
; [[Manual:DIL_Manual/unequip|unequip]] : Remove equipment
: Take off item
; [[Manual:DIL_Manual/addequip|addequip]] : Add equipment
: Add equipment item

=== 2.3 Object Fields ===

==== Basic Properties ====
; [[Manual:DIL_Manual/name|name]] : Object name
: Short identifier
; [[Manual:DIL_Manual/title|title]] : Object title
: Descriptive name
; [[Manual:DIL_Manual/descr|descr]] : Description
: Detailed description
; [[Manual:DIL_Manual/names|names]] : Object names
: List of object names
; [[Manual:DIL_Manual/extra|extra]] : Extra descriptions
: Additional descriptions
; [[Manual:DIL_Manual/extraptr|extraptr]] : Extra description pointer
: Pointer to extra descriptions
; [[Manual:DIL_Manual/fname|fname]] : File name
: Object file name

==== Physical Properties ====
; [[Manual:DIL_Manual/weight|weight]] : Current weight
: Total weight including contents
; [[Manual:DIL_Manual/baseweight|baseweight]] : Base weight
: Empty weight of object
; [[Manual:DIL_Manual/value|value]] : Monetary value
: Object&apos;s worth
; [[Manual:DIL_Manual/cost|cost]] : Item cost
: Purchase price
; [[Manual:DIL_Manual/rent|rent]] : Rental cost
: Equipment rental fees

==== Container Properties ====
; [[Manual:DIL_Manual/capacity|capacity]] : Carrying capacity
: Maximum weight capacity
; [[Manual:DIL_Manual/manipulate|manipulate]] : Manipulation flags
: How object can be handled
; [[Manual:DIL_Manual/key|key]] : Key value
: Object key
; [[Manual:DIL_Manual/idx|idx]] : Index
: Object index
; [[Manual:DIL_Manual/fits|fits]] : Check if fits
: Check if object fits
; [[Manual:DIL_Manual/can_carry|can_carry]] : Check if can carry
: Check carry capacity

==== Magical Properties ====
; [[Manual:DIL_Manual/illum|illum]] : Illumination
: Object illumination
; [[Manual:DIL_Manual/light|light]] : Light source
: Object light output

==== Type &amp; Flags ====
; [[Manual:DIL_Manual/objectflags|objectflags]] : Object flags
: Object characteristics
; [[Manual:DIL_Manual/objecttype|objecttype]] : Object type
: Object classification

=== 2.4 Room Fields ===

==== Basic Properties ====
; [[Manual:DIL_Manual/name|name]] : Room name
: Short identifier
; [[Manual:DIL_Manual/title|title]] : Room title
: Descriptive name
; [[Manual:DIL_Manual/descr|descr]] : Room description
: Detailed description

==== Environmental ====
; [[Manual:DIL_Manual/bright|bright]] : Brightness level
: Light level in room
; [[Manual:DIL_Manual/light|light]] : Light sources
: Available illumination
; [[Manual:DIL_Manual/islight|islight]] : Light check
: Whether room is lit
; [[Manual:DIL_Manual/movement|movement]] : Movement type
: Room movement restrictions

==== Exits ====
; [[Manual:DIL_Manual/exit_to|exit_to]] : Exit destinations
: Where exits lead
; [[Manual:DIL_Manual/exit_names|exit_names]] : Exit names
: Exit identifiers
; [[Manual:DIL_Manual/exit_info|exit_info]] : Exit properties
: Exit characteristics
; [[Manual:DIL_Manual/exit_key|exit_key]] : Exit key
: Key required for exit
; [[Manual:DIL_Manual/exit_diff|exit_diff]] : Exit difficulty
: Exit difficulty level

==== Location &amp; Zone ====
; [[Manual:DIL_Manual/mapx|mapx]] : Map X coordinate
: Horizontal position
; [[Manual:DIL_Manual/mapy|mapy]] : Map Y coordinate
: Vertical position
; [[Manual:DIL_Manual/zoneidx|zoneidx]] : Zone index
: Zone membership
; [[Manual:DIL_Manual/lastroom|lastroom]] : Last room
: Previous room location

==== Reset Properties ====
; [[Manual:DIL_Manual/resetmode|resetmode]] : Reset mode
: Zone reset behavior
; [[Manual:DIL_Manual/resettime|resettime]] : Reset time
: Reset schedule

==== Flags ====
; [[Manual:DIL_Manual/roomflags|roomflags]] : Room flags
: Room properties

=== 2.5 Unit Operations ===

==== Finding Units ====
; [[Manual:DIL_Manual/findunit|findunit]] : Search for units
: Find units by name and location
; [[Manual:DIL_Manual/findsymbolic|findsymbolic]] : Find by symbolic name
: Locate units by symbolic reference
; [[Manual:DIL_Manual/findroom|findroom]] : Find room by name
: Locate specific rooms
; [[Manual:DIL_Manual/findrndunit|findrndunit]] : Find random unit
: Find random unit
; [[Manual:DIL_Manual/findzone|findzone]] : Find zone
: Locate specific zone

==== Creating/Destroying ====
; [[Manual:DIL_Manual/load|load]] : Load unit from database
: Create new unit instance
; [[Manual:DIL_Manual/destroy|destroy]] : Destroy unit
: Remove unit from game
; [[Manual:DIL_Manual/delunit|delunit]] : Delete unit
: Permanent unit removal
; [[Manual:DIL_Manual/clone|clone]] : Duplicate unit
: Create copy of unit

==== Linking ====
; [[Manual:DIL_Manual/link|link]] : Link units together
: Establish parent-child relationships
; [[Manual:DIL_Manual/outside|outside]] : Outside container
: External container reference
; [[Manual:DIL_Manual/inside|inside]] : Inside container
: Internal container reference
; [[Manual:DIL_Manual/inside_descr|inside_descr]] : Inside description
: Inside container description
; [[Manual:DIL_Manual/outside_descr|outside_descr]] : Outside description
: Outside container description

==== Movement ====
; [[Manual:DIL_Manual/transfer|transfer]] : Move unit
: Relocate unit to new location
; [[Manual:DIL_Manual/setroomexit|setroomexit]] : Set room exit
: Define room connections
; [[Manual:DIL_Manual/pathto|pathto]] : Path finding
: Find path to location

==== Item Operations ====
; [[Manual:DIL_Manual/remove|remove]] : Remove item
: Remove from inventory
; [[Manual:DIL_Manual/insert|insert]] : Insert item
: Add to inventory

==== Equipment Operations ====
; [[Manual:DIL_Manual/equip|equip]] : Equip item
: Wear/wield object
; [[Manual:DIL_Manual/unequip|unequip]] : Remove equipment
: Take off item
; [[Manual:DIL_Manual/addequip|addequip]] : Add equipment
: Add equipment item

== 3. Communication System ==

=== 3.1 Message Functions ===

==== Basic Messaging ====
; [[Manual:DIL_Manual/sendtext|sendtext]] : Send text to unit
: Direct message delivery
; [[Manual:DIL_Manual/sendto|sendto]] : Send message to unit
: Alternative message function
; [[Manual:DIL_Manual/send|send]] : Send message
: Basic message delivery
; [[Manual:DIL_Manual/sendtoall|sendtoall]] : Send to all units
: Broadcast message
; [[Manual:DIL_Manual/sendtoalldil|sendtoalldil]] : Send to all DIL programs
: Message all programs

==== Formatted Messaging ====
; [[Manual:DIL_Manual/act|act]] : Send formatted social message
: Complex message with formatters
; [[Manual:DIL_Manual/sact|sact]] : Send formatted message (alternative)
: Alternative formatted messaging

==== Specialized ====
; [[Manual:DIL_Manual/pagestring|pagestring]] : Send paginated output
: Long text with pagination
; [[Manual:DIL_Manual/send_pre|send_pre]] : Send preparation message
: Pre-action notification
; [[Manual:DIL_Manual/send_done|send_done]] : Send completion message
: Post-action notification

=== 3.2 Message Formatters ===

==== Character References ====
; $1 : First character name
: Actor in action
; $2 : Second character name
: Medium or object
; $3 : Third character name
: Target or victim

==== Gender-Aware References ====
; $5 : Gender-aware pronoun (subject)
: he/she/it
; $6 : Gender-aware pronoun (object)
: him/her/it
; $n : Gender-aware possessive
: his/her/its

==== Visibility Flags ====
; A_* : Action visibility flags
: Who sees the action
; TO_* : Target specification
: Message recipients

=== 3.3 Input/Output ===

==== Command Processing ====
; [[Manual:DIL_Manual/argument|argument]] : Command arguments
: Parameters passed to command
; [[Manual:DIL_Manual/command|command]] : Command name
: The command executed
; [[Manual:DIL_Manual/cmdstr|cmdstr]] : Command string
: Full command text
; [[Manual:DIL_Manual/excmdstr|excmdstr]] : Expanded command string
: Expanded command with aliases
; [[Manual:DIL_Manual/excmdstr_case|excmdstr_case]] : Case-sensitive command
: Case-sensitive command
; [[Manual:DIL_Manual/getcmd|getcmd]] : Get command
: Get command pointer

==== User Interaction ====
; [[Manual:DIL_Manual/pause|pause]] : Wait for input
: Suspend execution for user input
; [[Manual:DIL_Manual/exec|exec]] : Execute command
: Run game command
; [[Manual:DIL_Manual/prompt|prompt]] : Set prompt
: Set user prompt
; [[Manual:DIL_Manual/clear|clear]] : Clear screen
: Clear user display
; [[Manual:DIL_Manual/help|help]] : Help system
: Display help information

==== Text Processing ====
; [[Manual:DIL_Manual/substring|substring]] : Extract substring
: Get portion of string
; [[Manual:DIL_Manual/split|split]] : Split string
: Divide string into parts
; [[Manual:DIL_Manual/replace|replace]] : Replace text
: Substitute text patterns
; [[Manual:DIL_Manual/left|left]] : Left portion
: Get left part
; [[Manual:DIL_Manual/right|right]] : Right portion
: Get right part
; [[Manual:DIL_Manual/length|length]] : String length
: Number of characters
; [[Manual:DIL_Manual/strcmp|strcmp]] : String comparison
: Compare two strings
; [[Manual:DIL_Manual/strncmp|strncmp]] : Partial comparison
: Compare string portions
; [[Manual:DIL_Manual/getword|getword]] : Get word
: Extract single word
; [[Manual:DIL_Manual/getwords|getwords]] : Get words
: Extract word list
; [[Manual:DIL_Manual/textformat|textformat]] : Format text
: Apply formatting rules
; [[Manual:DIL_Manual/toupper|toupper]] : Uppercase conversion
: Convert to uppercase
; [[Manual:DIL_Manual/tolower|tolower]] : Lowercase conversion
: Convert to lowercase
; [[Manual:DIL_Manual/addstring|addstring]] : Add string
: Add to string collection
; [[Manual:DIL_Manual/delstr|delstr]] : Delete string
: Delete from string collection
; [[Manual:DIL_Manual/savestr|savestr]] : Save string
: Save string data
; [[Manual:DIL_Manual/loadstr|loadstr]] : Load string
: Load string data

== 4. Game Systems ==

=== 4.1 Combat System ===

==== Combat State ====
; [[Manual:DIL_Manual/fighting|fighting]] : Combat opponent
: Current combat target
; [[Manual:DIL_Manual/opponent|opponent]] : Combat target
: Alternative opponent reference
; [[Manual:DIL_Manual/getopponent|getopponent]] : Get opponent
: Get current opponent
; [[Manual:DIL_Manual/opponentcount|opponentcount]] : Number of opponents
: Count of opponents
; [[Manual:DIL_Manual/position|position]] : Combat position
: Fighting stance/state

==== Combat Control ====
; [[Manual:DIL_Manual/set_fighting|set_fighting]] : Start combat
: Initiate combat
; [[Manual:DIL_Manual/stop_fighting|stop_fighting]] : End combat
: Terminate combat

==== Attack Types ====
; [[Manual:DIL_Manual/attack_type|attack_type]] : Unarmed combat
: Natural attack style
; [[Manual:DIL_Manual/weapon_info|weapon_info]] : Weapon data
: Weapon statistics
; [[Manual:DIL_Manual/weapon_name|weapon_name]] : Weapon name
: Get weapon type name
; [[Manual:DIL_Manual/meleeattack|meleeattack]] : Melee attack
: Perform melee attack
; [[Manual:DIL_Manual/attack_spell|attack_spell]] : Attack spell
: Cast attack spell
; [[Manual:DIL_Manual/cast_spell|cast_spell]] : Cast spell
: Cast any spell

==== Damage Calculation ====
; [[Manual:DIL_Manual/meleedamage|meleedamage]] : Melee damage
: Calculate combat damage
; [[Manual:DIL_Manual/defensive|defensive]] : Defense value
: Protection rating
; [[Manual:DIL_Manual/offensive|offensive]] : Attack value
: Combat effectiveness

=== 4.2 Skills &amp; Abilities ===

==== Ability System ====
; [[Manual:DIL_Manual/abilities|abilities]] : Ability scores
: Character attributes
; [[Manual:DIL_Manual/ability_levels|ability_levels]] : Ability level requirements
: Advancement requirements
; [[Manual:DIL_Manual/ability_costs|ability_costs]] : Ability costs
: Experience costs
; [[Manual:DIL_Manual/ability_points|ability_points]] : Available ability points
: Points for abilities

==== Skill System ====
; [[Manual:DIL_Manual/skills|skills]] : Skill proficiencies
: Character skill values
; [[Manual:DIL_Manual/skill_levels|skill_levels]] : Skill level requirements
: Advancement thresholds
; [[Manual:DIL_Manual/skill_costs|skill_costs]] : Skill costs
: Training costs
; [[Manual:DIL_Manual/skill_points|skill_points]] : Available skill points
: Points for advancement
; [[Manual:DIL_Manual/skill_name|skill_name]] : Get skill name
: Get name from skill index

==== Spell System ====
; [[Manual:DIL_Manual/spells|spells]] : Spell proficiencies
: Magical ability levels
; [[Manual:DIL_Manual/spell_levels|spell_levels]] : Spell level requirements
: Magical advancement
; [[Manual:DIL_Manual/spell_costs|spell_costs]] : Spell costs
: Magical training costs
; [[Manual:DIL_Manual/spellindex|spellindex]] : Spell index lookup
: Find spell by index
; [[Manual:DIL_Manual/spellinfo|spellinfo]] : Spell information
: Detailed spell data

==== Weapon System ====
; [[Manual:DIL_Manual/weapons|weapons]] : Weapon proficiencies
: Combat skill levels
; [[Manual:DIL_Manual/weapon_levels|weapon_levels]] : Weapon requirements
: Weapon skill thresholds
; [[Manual:DIL_Manual/weapon_costs|weapon_costs]] : Weapon costs
: Weapon training costs
; [[Manual:DIL_Manual/weapon_name|weapon_name]] : Weapon name
: Get weapon type name
; [[Manual:DIL_Manual/weapon_info|weapon_info]] : Weapon information
: Detailed weapon data

=== 4.3 Economic System ===

==== Money Operations ====
; [[Manual:DIL_Manual/transfermoney|transfermoney]] : Transfer currency
: Move money between characters
; [[Manual:DIL_Manual/moneystring|moneystring]] : Format money
: Display currency properly

==== Character Money ====
; [[Manual:DIL_Manual/purse|purse]] : Money container
: Character&apos;s wealth
; [[Manual:DIL_Manual/acc_balance|acc_balance]] : Account balance
: Bank account funds
; [[Manual:DIL_Manual/acc_total|acc_total]] : Total assets
: Complete wealth
; [[Manual:DIL_Manual/acc_modify|acc_modify]] : Modify account
: Account operations
; [[Manual:DIL_Manual/paycheck|paycheck]] : Regular income
: Periodic earnings

==== Commercial Transactions ====
; [[Manual:DIL_Manual/cost|cost]] : Item cost
: Purchase price
; [[Manual:DIL_Manual/value|value]] : Item value
: Sale price
; [[Manual:DIL_Manual/rent|rent]] : Rental cost
: Equipment rental fees

=== 4.4 Time &amp; Calendar ===

==== Game Time ====
; [[Manual:DIL_Manual/mudday|mudday]] : Day of month
: In-game day
; [[Manual:DIL_Manual/mudhour|mudhour]] : Hour of day
: In-game hour
; [[Manual:DIL_Manual/mudmonth|mudmonth]] : Month
: In-game month
; [[Manual:DIL_Manual/mudyear|mudyear]] : Year
: In-game year

==== Real Time ====
; [[Manual:DIL_Manual/realtime|realtime]] : Real-world time
: System time
; [[Manual:DIL_Manual/heartbeat|heartbeat]] : Game tick
: Time pulse
; [[Manual:DIL_Manual/asctime|asctime]] : Time formatting
: Format time display

==== Time Functions ====
; [[Manual:DIL_Manual/wait|wait]] : Wait for condition
: Delay execution
; [[Manual:DIL_Manual/sleep|sleep]] : Sleep duration
: Timed pause

=== 4.5 Experience &amp; Advancement ===

==== Experience ====
; [[Manual:DIL_Manual/exp|exp]] : Experience points
: Current experience
; [[Manual:DIL_Manual/experience|experience]] : Experience value
: Alternative experience reference
; [[Manual:DIL_Manual/exptol|exptol]] : Experience to level
: Experience needed for next level

==== Levels ====
; [[Manual:DIL_Manual/level|level]] : Current level
: Character level
; [[Manual:DIL_Manual/vlevel|vlevel]] : Virtual level
: Effective level
; [[Manual:DIL_Manual/loadlevel|loadlevel]] : Load level
: Content difficulty level

==== Progression ====
; [[Manual:DIL_Manual/skill_points|skill_points]] : Available skill points
: Points for advancement
; [[Manual:DIL_Manual/ability_points|ability_points]] : Available ability points
: Points for abilities

== 5. Utility Functions ==

=== 5.1 String Operations ===

==== Basic ====
; [[Manual:DIL_Manual/length|length]] : String length
: Number of characters
; [[Manual:DIL_Manual/substring|substring]] : Extract portion
: Get substring
; [[Manual:DIL_Manual/left|left]] : Left portion
: Get left part
; [[Manual:DIL_Manual/right|right]] : Right portion
: Get right part

==== Comparison ====
; [[Manual:DIL_Manual/strcmp|strcmp]] : String comparison
: Compare two strings
; [[Manual:DIL_Manual/strncmp|strncmp]] : Partial comparison
: Compare string portions

==== Conversion ====
; [[Manual:DIL_Manual/atoi|atoi]] : String to integer
: Parse number from text
; [[Manual:DIL_Manual/itoa|itoa]] : Integer to string
: Format number as text
; [[Manual:DIL_Manual/toupper|toupper]] : Uppercase conversion
: Convert to uppercase
; [[Manual:DIL_Manual/tolower|tolower]] : Lowercase conversion
: Convert to lowercase

==== Formatting ====
; [[Manual:DIL_Manual/textformat|textformat]] : Format text
: Apply formatting rules
; [[Manual:DIL_Manual/moneystring|moneystring]] : Format currency
: Display money properly

==== Text Processing ====
; [[Manual:DIL_Manual/split|split]] : Split string
: Divide string into parts
; [[Manual:DIL_Manual/replace|replace]] : Replace text
: Substitute text patterns
; [[Manual:DIL_Manual/getword|getword]] : Get word
: Extract single word
; [[Manual:DIL_Manual/getwords|getwords]] : Get words
: Extract word list
; [[Manual:DIL_Manual/addstring|addstring]] : Add string
: Add to string collection
; [[Manual:DIL_Manual/delstr|delstr]] : Delete string
: Delete from string collection
; [[Manual:DIL_Manual/savestr|savestr]] : Save string
: Save string data
; [[Manual:DIL_Manual/loadstr|loadstr]] : Load string
: Load string data

=== 5.2 Mathematical Functions ===

==== Random ====
; [[Manual:DIL_Manual/rnd|rnd]] : Random number
: Generate random value
; [[Manual:DIL_Manual/openroll|openroll]] : Open dice roll
: Dice roll with modifiers

==== Arithmetic ====
; [[Manual:DIL_Manual/max|max]] : Maximum value
: Find larger value
; [[Manual:DIL_Manual/min|min]] : Minimum value
: Find smaller value
; [[Manual:DIL_Manual/abs|abs]] : Absolute value
: Positive magnitude

==== Bit Operations ====
; [[Manual:DIL_Manual/set|set]] : Set bits
: Turn on bit flags
; [[Manual:DIL_Manual/unset|unset]] : Clear bits
: Turn off bit flags
; [[Manual:DIL_Manual/isset|isset]] : Test bits
: Check bit flags

=== 5.3 List Operations ===

==== Integer Lists ====
; [[Manual:DIL_Manual/integerlist|integerlist]] : Integer collection
: List of integers
; [[Manual:DIL_Manual/getinteger|getinteger]] : Get integer from list
: Extract integer value

==== String Lists ====
; [[Manual:DIL_Manual/stringlist|stringlist]] : String collection
: List of strings
; [[Manual:DIL_Manual/getwords|getwords]] : Extract words
: Get word list

==== Navigation ====
; [[Manual:DIL_Manual/next|next]] : Next item
: Move to next element
; [[Manual:DIL_Manual/previous|previous]] : Previous item
: Move to previous element
; [[Manual:DIL_Manual/head|head]] : First item
: Get first element
; [[Manual:DIL_Manual/ghead|ghead]] : Global head
: Global list head
; [[Manual:DIL_Manual/gnext|gnext]] : Global next
: Global next item
; [[Manual:DIL_Manual/gprevious|gprevious]] : Global previous
: Global previous item

=== 5.4 System Utilities ===

==== Logging ====
; [[Manual:DIL_Manual/log|log]] : System log
: Write to log file
; [[Manual:DIL_Manual/flog|flog]] : File log
: Write to specific file
; [[Manual:DIL_Manual/logcrime|logcrime]] : Crime log
: Write to crime log
; [[Manual:DIL_Manual/loglevel|loglevel]] : Log level
: Set logging level

==== Debugging ====
; [[Manual:DIL_Manual/debug|debug]] : Debug output
: Debug information
; [[Manual:DIL_Manual/info|info]] : Information output
: System information
; [[Manual:DIL_Manual/hasfunc|hasfunc]] : Check function
: Test function existence

==== Administration ====
; [[Manual:DIL_Manual/secure|secure]] : Security level
: Set security
; [[Manual:DIL_Manual/access|access]] : Access control
: Manage permissions
; [[Manual:DIL_Manual/reboot|reboot]] : System restart
: Restart game
; [[Manual:DIL_Manual/shell|shell]] : Execute shell command
: Run system command

== 6. DIL Program Management ==

=== 6.1 Program Structure ===

==== Program Definition ====
; [[Manual:DIL_Manual/dilbegin|dilbegin]] : Program start
: Begin DIL program
; [[Manual:DIL_Manual/dilend|dilend]] : Program end
: End DIL program

==== Variables ====
; [[Manual:DIL_Manual/var|var]] : Variable declaration
: Declare variables
; [[Manual:DIL_Manual/code|code]] : Code section
: Program code block

==== Parameters &amp; Return Values ====
: Function parameters and return value handling

=== 6.2 Program Control ===

==== Execution Control ====
; [[Manual:DIL_Manual/wait|wait]] : Wait for event
: Suspend execution
; [[Manual:DIL_Manual/interrupt|interrupt]] : Interrupt execution
: Break execution
; [[Manual:DIL_Manual/quit|quit]] : Terminate program
: End program
; [[Manual:DIL_Manual/waitnoop|waitnoop]] : Wait with no operation
: Wait without action

==== State Management ====
; [[Manual:DIL_Manual/priority|priority]] : Execution priority
: Set program priority
; [[Manual:DIL_Manual/nopriority|nopriority]] : Clear priority
: Remove priority setting

==== Event Handling ====
; [[Manual:DIL_Manual/on_activation|on_activation]] : Activation event
: Handle program activation
; [[Manual:DIL_Manual/on_goto|on_goto]] : Goto event
: Handle goto events
; [[Manual:DIL_Manual/SFB_*|SFB_*]] : State function bits
: Event wait flags
; [[Manual:DIL_Manual/sfb_cmd|sfb_cmd]] : Command activation
: Command wait flag
; [[Manual:DIL_Manual/sfb_com|sfb_com]] : Combat activation
: Combat wait flag
; [[Manual:DIL_Manual/sfb_dead|sfb_dead]] : Death activation
: Death wait flag
; [[Manual:DIL_Manual/sfb_done|sfb_done]] : Completion activation
: Completion wait flag
; [[Manual:DIL_Manual/sfb_msg|sfb_msg]] : Message activation
: Message wait flag
; [[Manual:DIL_Manual/sfb_pre|sfb_pre]] : Preparation activation
: Preparation wait flag
; [[Manual:DIL_Manual/sfb_tick|sfb_tick]] : Timer activation
: Timer wait flag

=== 6.3 Program Interaction ===

==== DIL Operations ====
; [[Manual:DIL_Manual/dilcall|dilcall]] : Call DIL program
: Execute another program
; [[Manual:DIL_Manual/dilfind|dilfind]] : Find DIL program
: Locate program instance
; [[Manual:DIL_Manual/dilcopy|dilcopy]] : Copy DIL program
: Duplicate program
; [[Manual:DIL_Manual/dildestroy|dildestroy]] : Destroy DIL program
: Remove program

==== Program Communication ====
; [[Manual:DIL_Manual/sendtoalldil|sendtoalldil]] : Message all DIL programs
: Broadcast to programs

==== Shared Data ====
; [[Manual:DIL_Manual/global_head|global_head]] : Global variables head
: Global data head
; [[Manual:DIL_Manual/store|store]] : Store data
: Save information

=== 6.4 Development Tools ===

==== Editing ====
; [[Manual:DIL_Manual/beginedit|beginedit]] : Begin editing
: Start edit mode
; [[Manual:DIL_Manual/killedit|killedit]] : End editing
: Exit edit mode
; [[Manual:DIL_Manual/editing|editing]] : Edit status
: Check edit state

==== Testing ====
; [[Manual:DIL_Manual/shell|shell]] : Execute shell command
: Run system command
; [[Manual:DIL_Manual/exec|exec]] : Execute command
: Run game command

==== Debugging ====
; [[Manual:DIL_Manual/log|log]] : Write log
: Log information
; [[Manual:DIL_Manual/hasfunc|hasfunc]] : Check function
: Test function existence

== 7. World Management ==

=== 7.1 Zone System ===

==== Zone Operations ====
; [[Manual:DIL_Manual/zone_head|zone_head]] : First zone
: Get zone list head
; [[Manual:DIL_Manual/zhead|zhead]] : Zone head
: Alternative zone reference
; [[Manual:DIL_Manual/findzone|findzone]] : Find zone
: Locate specific zone
; [[Manual:DIL_Manual/zone|zone]] : Zone operations
: General zone functions

==== Zone Properties ====
; [[Manual:DIL_Manual/zoneidx|zoneidx]] : Zone index
: Zone identifier
; [[Manual:DIL_Manual/resetmode|resetmode]] : Reset mode
: Zone reset behavior
; [[Manual:DIL_Manual/resettime|resettime]] : Reset timing
: Reset schedule

==== Zone Resets ====
; [[Manual:DIL_Manual/zonereset|zonereset]] : Zone reset
: Reset zone contents

=== 7.2 Room Management ===

==== Room Navigation ====
; [[Manual:DIL_Manual/room_head|room_head]] : First room
: Get room list head
; [[Manual:DIL_Manual/findroom|findroom]] : Find room
: Locate specific room
; [[Manual:DIL_Manual/pathto|pathto]] : Path finding
: Find path to location
; [[Manual:DIL_Manual/rooms|rooms]] : Room list
: All rooms
; [[Manual:DIL_Manual/roomcount|roomcount]] : Room count
: Number of rooms

==== Room Properties ====
; [[Manual:DIL_Manual/roomflags|roomflags]] : Room flags
: Room characteristics
; [[Manual:DIL_Manual/mapx|mapx]] : Map X coordinate
: Horizontal position
; [[Manual:DIL_Manual/mapy|mapy]] : Map Y coordinate
: Vertical position

==== Room Operations ====
; [[Manual:DIL_Manual/setroomexit|setroomexit]] : Set exit
: Define room connection

=== 7.3 NPC Management ===

==== NPC Operations ====
; [[Manual:DIL_Manual/npc_head|npc_head]] : First NPC
: Get NPC list head
; [[Manual:DIL_Manual/npcs|npcs]] : NPC list
: All NPCs
; [[Manual:DIL_Manual/npccount|npccount]] : NPC count
: Number of NPCs

==== NPC Properties ====
; [[Manual:DIL_Manual/npcflags|npcflags]] : NPC flags
: NPC characteristics
; [[Manual:DIL_Manual/hometown|hometown]] : Home location
: NPC origin
; [[Manual:DIL_Manual/profession|profession]] : Profession
: NPC job/role
; [[Manual:DIL_Manual/guild|guild]] : Guild affiliation
: NPC guild membership

==== NPC Behavior ====
; [[Manual:DIL_Manual/master|master]] : Master/leader
: NPC leader
; [[Manual:DIL_Manual/follower|follower]] : Follower
: NPC follower
; [[Manual:DIL_Manual/followercount|followercount]] : Number of followers
: Count of followers
; [[Manual:DIL_Manual/getfollower|getfollower]] : Get specific follower
: Get follower unit
; [[Manual:DIL_Manual/follow|follow]] : Follow relationship
: Following behavior

=== 7.4 Object Management ===

==== Object Operations ====
; [[Manual:DIL_Manual/obj_head|obj_head]] : First object
: Get object list head
; [[Manual:DIL_Manual/objs|objs]] : Object list
: All objects
; [[Manual:DIL_Manual/objcount|objcount]] : Object count
: Number of objects

==== Object Properties ====
; [[Manual:DIL_Manual/objectflags|objectflags]] : Object flags
: Object characteristics
; [[Manual:DIL_Manual/objecttype|objecttype]] : Object type
: Object classification

==== Equipment ====
; [[Manual:DIL_Manual/equip|equip]] : Equip item
: Wear/wield object
; [[Manual:DIL_Manual/unequip|unequip]] : Remove equipment
: Take off item
; [[Manual:DIL_Manual/equipment|equipment]] : Equipment slots
: Worn items
; [[Manual:DIL_Manual/addequip|addequip]] : Add equipment
: Add equipment item

== 8. Reference Materials ==

=== 8.1 Constants Reference ===

==== Unit Types ====
; [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] : Player character
: Player-controlled unit
; [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] : Non-player character
: Computer-controlled unit
; [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] : Object
: Item or equipment
; [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] : Room
: Location or area

==== Positions ====
; [[Manual:DIL_Manual/POSITION_STANDING|POSITION_STANDING]] : Standing
: Upright position
; [[Manual:DIL_Manual/POSITION_SITTING|POSITION_SITTING]] : Sitting
: Seated position
; [[Manual:DIL_Manual/POSITION_RESTING|POSITION_RESTING]] : Resting
: Recovering position
; [[Manual:DIL_Manual/POSITION_SLEEPING|POSITION_SLEEPING]] : Sleeping
: Unconscious position
; [[Manual:DIL_Manual/POSITION_FIGHTING|POSITION_FIGHTING]] : Fighting
: Combat position

==== Flags ====
; [[Manual:DIL_Manual/CHAR_*|CHAR_*]] : Character flags
: Character states
; [[Manual:DIL_Manual/OBJ_*|OBJ_*]] : Object flags
: Object properties
; [[Manual:DIL_Manual/ROOM_*|ROOM_*]] : Room flags
: Room characteristics

==== Find Flags ====
; [[Manual:DIL_Manual/FIND_UNIT_*|FIND_UNIT_*]] : Find unit flags
: Search parameters

==== State Function Bits ====
; [[Manual:DIL_Manual/SFB_*|SFB_*]] : State function bits
: Event wait flags

=== 8.2 Error Handling ===

==== Common Errors ====
: Typical error conditions and solutions

==== Validation Functions ====
; [[Manual:DIL_Manual/check_password|check_password]] : Password validation
: Validate user password
; [[Manual:DIL_Manual/delete_player|delete_player]] : Player deletion
: Delete player account
; [[Manual:DIL_Manual/set_password|set_password]] : Set password
: Set user password

==== Debugging Techniques ====
: Methods for finding and fixing errors

=== 8.3 Best Practices ===

==== Code Organization ====
: Structuring DIL programs effectively

==== Performance Tips ====
: Optimizing DIL code

==== Security Considerations ====
: Writing secure DIL programs

=== 8.4 Examples and Tutorials ===

==== Basic DIL Programs ====
: Simple program examples

==== Common Patterns ====
: Frequently used code patterns

==== Advanced Techniques ====
: Complex programming methods</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/abilities</title>
     <ns>0</ns>
     <id>632560</id>
     <revision>
       <id>1432298</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of abilities.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= abilities =
 field: integer &apos;&apos;&apos;.abilities&apos;&apos;&apos;[ability_index] (Read-only)

The &apos;&apos;&apos;abilities&apos;&apos;&apos; field provides access to character ability scores for both PCs and NPCs.

== Description ==
Accesses ability scores for character units using array indexing with ABIL_* constants.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| ability_index || integer || Ability index (ABIL_* constant)
|}

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| character.abilities[ability_index] || integer || The ability score for specified ability
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Ability Constants ==
The ability_index parameter accepts any of the following constants defined in values.h or vme.h:

{| class=&quot;wikitable&quot;
! Constant !! Description
|-
| ABIL_STR || Strength - Physical power and damage
|-
| ABIL_DEX || Dexterity - Agility and coordination
|-
| ABIL_CON || Constitution - Health and stamina
|-
| ABIL_CHA || Charisma - Social interaction and leadership
|-
| ABIL_BRA || Brains - Intelligence and reasoning
|-
| ABIL_MAG || Magic - Magical aptitude and power
|-
| ABIL_DIV || Divine - Divine connection and faith
|-
| ABIL_HP || Hit Points - Health and vitality
|}

== Examples ==
=== Basic Ability Check ===
 dilbegin check_strength(character : unitptr);
 code
 {
    if (character.abilities[ABIL_STR] &gt; 15) {
       send(&quot;You are very strong!&quot;);
    } else {
       send(&quot;You could use more strength training.&quot;);
    }
    quit;
 } dilend

=== Skill Check Example ===
 dilbegin skill_check(character : unitptr, difficulty : integer);
 var
    dex_check : integer;
 code
 {
    dex_check := character.abilities[ABIL_DEX];
    if (openroll(5, 100) + dex_check &gt; difficulty) {
       send(&quot;You succeed at the dexterity check!&quot;);
    } else {
       send(&quot;You fail the dexterity check.&quot;);
    }
    quit;
 } dilend

=== NPC Ability Setup ===
 dilbegin create_guard();
 code
 {
    self.abilities[ABIL_STR] := 150;
    self.abilities[ABIL_DEX] := 120;
    self.abilities[ABIL_CON] := 140;
    self.abilities[ABIL_BRA] := 100;
    position_update(self);
    quit;
 } dilend

=== Combat Skill Calculation ===
 dilbegin combat_skill(attacker : unitptr, defender : unitptr);
 var
    attack_skill, defense_skill : integer;
 code
 {
    attack_skill := (attacker.abilities[ABIL_DEX] + attacker.abilities[ABIL_STR]) / 2;
    defense_skill := (defender.abilities[ABIL_DEX] * 2) / 3;    
    if (openroll(5, 100) + attack_skill &gt; openroll(5, 100) + defense_skill) {
       send(&quot;Attack hits!&quot;);
    } else {
       send(&quot;Attack misses!&quot;);
    }
    quit;
 } dilend

== Error Handling ==
The field performs comprehensive validation:
* &apos;&apos;&apos;Character validation&apos;&apos; - Ensures the unit is a valid character type
* &apos;&apos;&apos;Index validation&apos;&apos; - Checks that ability index is between 0 and ABIL_TREE_MAX - 1
* &apos;&apos;&apos;Type validation&apos;&apos; - Returns fail if accessed on non-character units

Note: The C implementation shows different behavior for PCs vs NPCs:
* For PCs: Returns integer value or reference depending on zone access level
* For NPCs: Returns unsigned integer reference
* Uses is_in() to validate ability index range

== Usage Notes ==
* This field is read-only for reading ability scores
* Only available on character units (UNIT_ST_PC and UNIT_ST_NPC types)
* Ability scores are typically in range 0-255, with higher values being better
* The field is commonly used for skill checks, combat calculations, and character validation
* Use with position_update() after modifying abilities on NPCs
* Ability constants are defined in values.h and vme.h header files

== Related Fields ==
* [[Manual:DIL_Manual/weapons|weapons]] - Array of weapon skill values
* [[Manual:DIL_Manual/charflags|charflags]] - Character flags and affects
* [[Manual:DIL_Manual/level|level]] - Character level
* [[Manual:DIL_Manual/exp|exp]] - Character experience points

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/position_update|position_update]] - Function to update character after ability changes
* [[Manual:DIL_Manual/openroll|openroll]] - Function for dice rolls and skill checks
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/ability_costs</title>
     <ns>0</ns>
     <id>382041</id>
     <revision>
       <id>1478054</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of ability_costs.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= ability_costs =
 field: integer &apos;&apos;&apos;.ability_costs&apos;&apos;&apos;[ability_index] (Read-only)

The &apos;&apos;&apos;ability_costs&apos;&apos;&apos; field is a read-only array field available on player character units that provides access to the training costs for abilities based on the character&apos;s race.

== Description ==
This field provides access to the training costs for abilities based on the character&apos;s race. The costs are stored in an array indexed by ability constants.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| player.ability_costs[ability_index] || integer || The training cost for specified ability
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| ability_index || integer || Ability index (ABIL_* constant)
|}

== Ability Constants ==
The ability_index parameter accepts any of the ABIL_* constants defined in values.h or vme.h:

{| class=&quot;wikitable&quot;
! Constant !! Description
|-
| ABIL_STR || Strength training cost
|-
| ABIL_DEX || Dexterity training cost
|-
| ABIL_CON || Constitution training cost
|-
| ABIL_CHA || Charisma training cost
|-
| ABIL_BRA || Brains/Intelligence training cost
|-
| ABIL_MAG || Magic training cost
|-
| ABIL_DIV || Divine training cost
|-
| ABIL_HP || Hit Points training cost
|}

== Examples ==
=== Basic Cost Check ===
 dilbegin check_ability_cost(player : unitptr, ability : integer);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    if (ability &gt;= 0 and ability &lt; ABIL_TREE_MAX) {
       send(&quot;Training cost: &quot; + itoa(player.ability_costs[ability]));
    } else {
       send(&quot;Invalid ability index.&quot;);
    }
    quit;
 } dilend

=== Cost Validation ===
 dilbegin can_afford_training(player : unitptr, ability : integer);
 var
    cost : integer;
    money : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    if (ability &lt; 0 or ability &gt;= ABIL_TREE_MAX) {
       send(&quot;Invalid ability index.&quot;);
       quit;
    }
    
    cost := player.ability_costs[ability];
    money := player.money[0]; /* Gold coins */
    
    if (money &gt;= cost) {
       send(&quot;You can afford this training.&quot;);
    } else {
       send(&quot;You need &quot; + itoa(cost - money) + &quot; more gold coins.&quot;);
    }
    quit;
 } dilend

== Error Handling ==
The field performs comprehensive validation:
* &apos;&apos;&apos;Player validation&apos;&apos; - Ensures unit is a valid PC (not NPC)
* &apos;&apos;&apos;Index validation&apos;&apos; - Checks that ability index is between 0 and ABIL_TREE_MAX - 1
* &apos;&apos;&apos;Type validation&apos;&apos; - Returns fail if accessed on non-PC units

Note: The C implementation shows that this field:
* Only works on player characters (PCs), not NPCs
* Uses get_racial_ability() function to calculate costs based on race
* Has commented-out code that suggests it was originally designed to return references for certain access levels
* Uses is_in() to validate ability index range

== Usage Notes ==
* This field is read-only for reading ability training costs
* Only available on player character units (UNIT_ST_PC type)
* Costs vary based on the character&apos;s race
* The field is commonly used for training systems, guild masters, and cost validation
* Ability costs are typically used in conjunction with character&apos;s money for training validation
* Ability constants are defined in values.h and vme.h header files
* This field appears to be obsolete or rarely used based on code comments

== Related Fields ==
* [[Manual:DIL_Manual/abilities|abilities]] - Array of ability score values
* [[Manual:DIL_Manual/race|race]] - Character race field
* [[Manual:DIL_Manual/money|money]] - Character money array for cost validation

== Related Functions ==
* [[Manual:DIL_Manual/reset_race|reset_race]] - Function to reset character race and related attributes
* [[Manual:DIL_Manual/get_racial_ability|get_racial_ability]] - Internal function for racial ability calculations

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/RACE_*|RACE_*]] - Race constants
* [[Manual:DIL_Manual/ABIL_*|ABIL_*]] - Ability constants</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/ability_levels</title>
     <ns>0</ns>
     <id>1270345</id>
     <revision>
       <id>1851454</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of ability_levels.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= ability_levels =
 field: integer &apos;&apos;&apos;.ability_levels&apos;&apos;&apos;[ability_index] (Read-only)

The &apos;&apos;&apos;ability_levels&apos;&apos;&apos; field is a read-only array field available on player character units that provides access to the training level requirements for abilities.

== Description ==
This field provides access to the training level requirements for abilities. The requirements are stored in an array indexed by ability constants.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| player.ability_levels[ability_index] || integer || The training level requirement for specified ability
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| ability_index || integer || Ability index (ABIL_* constant)
|}

== Ability Constants ==
The ability_index parameter accepts any of the ABIL_* constants defined in values.h or vme.h:

{| class=&quot;wikitable&quot;
! Constant !! Description
|-
| ABIL_STR || Strength training level requirement
|-
| ABIL_DEX || Dexterity training level requirement
|-
| ABIL_CON || Constitution training level requirement
|-
| ABIL_CHA || Charisma training level requirement
|-
| ABIL_BRA || Brains/Intelligence training level requirement
|-
| ABIL_MAG || Magic training level requirement
|-
| ABIL_DIV || Divine training level requirement
|-
| ABIL_HP || Hit Points training level requirement
|}

== Examples ==
=== Basic Level Check ===
 dilbegin check_ability_level(player : unitptr, ability : integer);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    if (ability &gt;= 0 and ability &lt; ABIL_TREE_MAX) {
       send(&quot;Training level requirement: &quot; + itoa(player.ability_levels[ability]));
    } else {
       send(&quot;Invalid ability index.&quot;);
    }
    quit;
 } dilend

=== Training Eligibility Check ===
 dilbegin can_train_ability(player : unitptr, ability : integer);
 var
    required_level : integer;
    current_level : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    if (ability &lt; 0 or ability &gt;= ABIL_TREE_MAX) {
       send(&quot;Invalid ability index.&quot;);
       quit;
    }
    
    required_level := player.ability_levels[ability];
    current_level := player.level;
    
    if (current_level &gt;= required_level) {
       send(&quot;You meet the level requirement for this training.&quot;);
    } else {
       send(&quot;You need to be level &quot; + itoa(required_level) + &quot; to train this ability.&quot;);
       send(&quot;Current level: &quot; + itoa(current_level));
    }
    quit;
 } dilend

== Error Handling ==
The field performs comprehensive validation:
* &apos;&apos;&apos;Player validation&apos;&apos; - Ensures unit is a valid PC (not NPC)
* &apos;&apos;&apos;Index validation&apos;&apos; - Checks that ability index is between 0 and ABIL_TREE_MAX - 1
* &apos;&apos;&apos;Type validation&apos;&apos; - Returns fail if accessed on non-PC units

Note: The C implementation shows that this field:
* Only works on player characters (PCs), not NPCs
* Uses getAbilityLevelAtIndex() function to retrieve level requirements
* Has commented-out code that suggests it was originally designed to return references for certain access levels
* Uses is_in() to validate ability index range
* Different behavior based on zone access level (reference vs integer return)

== Usage Notes ==
* This field is read-only for reading ability training level requirements
* Only available on player character units (UNIT_ST_PC type)
* Level requirements are typically used to determine when players can train certain abilities
* The field is commonly used in training systems, guild masters, and eligibility validation
* Ability level requirements work in conjunction with character&apos;s current level for training validation
* Ability constants are defined in values.h and vme.h header files
* This field appears to be obsolete or rarely used based on code comments
* Often used together with ability_costs field for complete training validation

== Related Fields ==
* [[Manual:DIL_Manual/abilities|abilities]] - Array of current ability score values
* [[Manual:DIL_Manual/ability_costs|ability_costs]] - Array of ability training costs
* [[Manual:DIL_Manual/level|level]] - Character&apos;s current level
* [[Manual:DIL_Manual/money|money]] - Character money array for cost validation

== Related Functions ==
* [[Manual:DIL_Manual/reset_race|reset_race]] - Function to reset character race and related attributes
* [[Manual:DIL_Manual/getAbilityLevelAtIndex|getAbilityLevelAtIndex]] - Internal function for level requirement calculations

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/ABIL_*|ABIL_*]] - Ability constants
* [[Manual:DIL_Manual/ability_costs|ability_costs]] - Ability training costs field</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/ability_points</title>
     <ns>0</ns>
     <id>598399</id>
     <revision>
       <id>921049</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of ability_points.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= ability_points =
 field: integer &apos;&apos;&apos;.ability_points&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;ability_points&apos;&apos;&apos; field is a read-write integer field available on player character units that represents the number of unused ability points the player has available for training.

== Description ==
This field represents the number of unused ability points that a player has available for training abilities. Points can be awarded for leveling up, completing quests, or special events.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| player.ability_points || integer || The number of unused ability points available
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Points Check ===
 dilbegin check_ability_points(player : unitptr);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    send(&quot;You have &quot; + itoa(player.ability_points) + &quot; unused ability points.&quot;);
    quit;
 } dilend

=== Points Award ===
 dilbegin award_ability_points(player : unitptr, amount : integer);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    if (amount &gt; 0) {
       player.ability_points := player.ability_points + amount;
       send(&quot;You gain &quot; + itoa(amount) + &quot; ability points!&quot;);
    } else {
       send(&quot;Invalid amount.&quot;);
    }
    quit;
 } dilend

=== Points Spend ===
 dilbegin spend_ability_points(player : unitptr, amount : integer);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    if (amount &lt; 0) {
       send(&quot;Invalid amount.&quot;);
       quit;
    }
    
    if (player.ability_points &gt;= amount) {
       player.ability_points := player.ability_points - amount;
       send(&quot;You spend &quot; + itoa(amount) + &quot; ability points.&quot;);
       send(&quot;Remaining: &quot; + itoa(player.ability_points));
    } else {
       send(&quot;You don&apos;t have enough ability points.&quot;);
       send(&quot;You have: &quot; + itoa(player.ability_points) + &quot; available.&quot;);
    }
    quit;
 } dilend

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Player validation&apos;&apos; - Ensures unit is a valid PC (not NPC)
* &apos;&apos;&apos;Type validation&apos;&apos; - Returns fail if accessed on non-PC units
* &apos;&apos;&apos;Range validation&apos;&apos; - No explicit range validation, but practical limits apply

Note: The C implementation shows that this field:
* Only works on player characters (PCs), not NPCs
* Returns a reference (DILV_SINT4R) to the actual ability points value
* Uses getAbilityPointsPtr() function to access the underlying data
* Is a read-write field, allowing both reading and modification

== Usage Notes ==
* This field is read-write for both reading and modifying ability points
* Only available on player character units (UNIT_ST_PC type)
* Ability points are typically awarded for leveling up, completing quests, or special events
* The field is commonly used in training systems, character advancement, and point management
* Often used together with skill_points field for total practice point management
* Ability points are spent to improve base abilities through training or practice
* The field persists across saves and character logins
* Typical values range from 0 to potentially high numbers depending on character progression

== Related Fields ==
* [[Manual:DIL_Manual/skill_points|skill_points]] - Number of unused skill points available
* [[Manual:DIL_Manual/abilities|abilities]] - Array of current ability score values
* [[Manual:DIL_Manual/level|level]] - Character&apos;s current level
* [[Manual:DIL_Manual/experience|experience]] - Character&apos;s experience points

== Related Functions ==
* [[Manual:DIL_Manual/reset_race|reset_race]] - Function that may reset ability points
* [[Manual:DIL_Manual/reset_level|reset_level]] - Function that may reset ability points

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/practice|practice]] - Command for spending ability/skill points
* [[Manual:DIL_Manual/abilities|abilities]] - Ability scores array field</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/acc_balance</title>
     <ns>0</ns>
     <id>878986</id>
     <revision>
       <id>1023874</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of acc_balance.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= acc_balance =

The &apos;&apos;&apos;acc_balance&apos;&apos;&apos; field is a read-only integer field available on player character units that provides access to the player&apos;s account balance when the game is in accounting mode.

== Syntax ==
 player.acc_balance

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| player.acc_balance || integer || The player&apos;s account balance in 1/100ths of currency units
|}

== Return Value ==
Returns an integer representing the account balance:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The current account balance (in 1/100ths, so 100 = 1.00 currency units)
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If player unit is invalid, not a PC, or game not in accounting mode

== Field Properties ==
{| class=&quot;wikitable&quot;
! Property !! Type !! Description
|-
| Read/Write || Read-only (RO)
|-
| Unit Type || Only available on UNIT_ST_PC (player characters)
|-
| Accounting Mode || Only returns valid data when game is in accounting mode
|-
| Value Scale || Returns balance in 1/100ths (100 = 1.00 currency units)
|}

== Examples ==
=== Basic Balance Check ===
 dilbegin check_balance(player : unitptr);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    send(&quot;Your account balance: &quot; + itoa(player.acc_balance / 100) + &quot;.&quot; + 
          itoa(player.acc_balance % 100));
    quit;
 } dilend

=== Purchase Validation ===
 dilbegin can_afford(player : unitptr, cost : integer);
 var
    balance_cents : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    balance_cents := player.acc_balance;
    
     if (balance_cents &gt;= cost) {
        send(&quot;You can afford this purchase.&quot;);
        send(&quot;Cost: &quot; + itoa(cost / 100) + &quot;.&quot; + itoa(cost % 100));
        send(&quot;Balance: &quot; + itoa(balance_cents / 100) + &quot;.&quot; + itoa(balance_cents % 100));
     } else {
        send(&quot;You cannot afford this purchase.&quot;);
        send(&quot;Cost: &quot; + itoa(cost / 100) + &quot;.&quot; + itoa(cost % 100));
        send(&quot;Balance: &quot; + itoa(balance_cents / 100) + &quot;.&quot; + itoa(balance_cents % 100));
        send(&quot;Needed: &quot; + itoa((cost - balance_cents) / 100) + &quot;.&quot; + itoa((cost - balance_cents) % 100));
     }
    quit;
 } dilend

=== Balance Display ===
 dilbegin show_account_balance(player : unitptr);
 var
    balance_dollars : integer;
    balance_cents : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    balance_dollars := player.acc_balance / 100;
    balance_cents := player.acc_balance % 100;
    
    send(&quot;=== ACCOUNT BALANCE ===&quot;);
    send(&quot;Current Balance: $&quot; + itoa(balance_dollars) + &quot;.&quot; + 
          itoa(balance_cents));
    send(&quot;Balance in cents: &quot; + itoa(player.acc_balance));
    quit;
 } dilend

=== Transaction Processing ===
 dilbegin process_transaction(player : unitptr, amount : integer);
 var
    new_balance : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    new_balance := player.acc_balance + amount;
    
     send(&quot;Transaction processed:&quot;);
     send(&quot;  Previous balance: $&quot; + itoa(player.acc_balance / 100) + &quot;.&quot; + 
           itoa(player.acc_balance % 100));
     send(&quot;  Transaction amount: $&quot; + itoa(amount / 100) + &quot;.&quot; + 
           itoa(amount % 100));
     send(&quot;  New balance: $&quot; + itoa(new_balance / 100) + &quot;.&quot; + 
           itoa(new_balance % 100));
    
    quit;
 } dilend

=== Fountain Payment System ===
 dilbegin fountain_payment(player : unitptr, price : integer);
 var
    cost_cents : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    cost_cents := price * 100;
    
    if (player.acc_balance &gt;= cost_cents) {
       send(&quot;You pay $&quot; + itoa(price) + &quot; for the drink.&quot;);
       acc_modify(player, -cost_cents);
        send(&quot;Remaining balance: $&quot; + itoa((player.acc_balance - cost_cents) / 100) + 
              &quot;.&quot; + itoa((player.acc_balance - cost_cents) % 100));
     } else {
        send(&quot;You don&apos;t have enough money for this drink.&quot;);
        send(&quot;Cost: $&quot; + itoa(price));
        send(&quot;Your balance: $&quot; + itoa(player.acc_balance / 100) + &quot;.&quot; + 
              itoa(player.acc_balance % 100));
     }
    quit;
 } dilend

=== Account Information Display ===
 dilbegin account_info(player : unitptr);
 var
    balance_dollars : integer;
    balance_cents : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    balance_dollars := player.acc_balance / 100;
    balance_cents := player.acc_balance % 100;
    
    send(&quot;Account Information for &quot; + player.name);
    send(&quot;================================&quot;);
    send(&quot;Current Balance: $&quot; + itoa(balance_dollars) + &quot;.&quot; + itoa(balance_cents));
    send(&quot;Balance (in cents): &quot; + itoa(player.acc_balance));
    send(&quot;================================&quot;);
    quit;
 } dilend

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Player validation&apos;&apos; - Ensures unit is a valid PC (not NPC)
* &apos;&apos;&apos;Accounting mode validation&apos;&apos; - Only returns meaningful data when game is in accounting mode
* &apos;&apos;&apos;Type validation&apos;&apos; - Returns fail if accessed on non-PC units

Note: The C implementation shows that this field:
* Only works on player characters (PCs), not NPCs
* Uses getPCAccountData().getAccountBalance() to retrieve the actual balance
* Returns 0 if not in accounting mode or if account data is unavailable
* The balance is stored in 1/100ths of currency units for precise financial tracking

== Usage Notes ==
* This field is read-only for reading account balance
* Only available on player character units (UNIT_ST_PC type)
* Only returns valid data when the game server is configured in accounting mode
* The balance value is in 1/100ths (100 = 1.00 currency units) for precision
* The field is commonly used in payment systems, purchase validation, and financial transactions
* Use with acc_modify() function for modifying account balances
* The field works in conjunction with acc_total field for complete account information
* Accounting mode must be enabled in server configuration for this field to work properly

== Related Fields ==
* [[Manual:DIL_Manual/acc_total|acc_total]] - Total credit available to the player
* [[Manual:DIL_Manual/acc_modify|acc_modify]] - Function to modify account balance
* [[Manual:DIL_Manual/money|money]] - Physical currency carried by the player

== Related Functions ==
* [[Manual:DIL_Manual/acc_modify|acc_modify]] - Function to modify player account balance
* [[Manual:DIL_Manual/getPCAccountData|getPCAccountData]] - Internal function for account data access

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/accounting|accounting]] - Server accounting mode configuration
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/acc_modify</title>
     <ns>0</ns>
     <id>583608</id>
     <revision>
       <id>1026735</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of acc_modify.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= acc_modify =

The &apos;&apos;&apos;acc_modify&apos;&apos;&apos; function is a built-in DIL (DikuMUD Interactive Language) function that modifies a player&apos;s account balance by adding or subtracting funds.

== Syntax ==
 acc_modify(unitptr player, integer amount)

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| player || unitptr || The player whose account balance will be modified
|-
| amount || integer || The amount to modify (in 1/100ths, positive adds, negative subtracts)
|}

== Return Value ==
This function does not return a value (void).

== Functionality ==
The acc_modify function performs the following operations:
* &apos;&apos;&apos;Add funds&apos;&apos;&apos; - When amount is positive, adds to player&apos;s account balance
* &apos;&apos;&apos;Subtract funds&apos;&apos;&apos; - When amount is negative, subtracts from player&apos;s account balance
* &apos;&apos;&apos;Account validation&apos;&apos; - Only works when game server is in accounting mode
* &apos;&apos;&apos;Access control&apos;&apos; - Requires appropriate zone access level to use
* &apos;&apos;&apos;Transaction logging&apos;&apos; - All transactions are logged in encrypted account log file

== Examples ==
=== Basic Transaction ===
 dilbegin account_transaction(player : unitptr, amount : integer);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    acc_modify(player, amount);
    if (amount &gt; 0) {
       send(&quot;Account credited: $&quot; + itoa(amount / 100) + &quot;.&quot; + itoa(amount % 100));
    } else {
       send(&quot;Account debited: $&quot; + itoa((-amount) / 100) + &quot;.&quot; + itoa((-amount) % 100));
    }
    quit;
 } dilend

=== Purchase Processing ===
 dilbegin process_purchase(player : unitptr, cost : integer);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    if (cost &gt; 0) {
       acc_modify(player, -cost);
       send(&quot;Purchase processed: $&quot; + itoa(cost / 100) + &quot;.&quot; + itoa(cost % 100) + &quot; charged to account.&quot;);
    } else {
       send(&quot;Invalid cost amount.&quot;);
    }
    quit;
 } dilend

=== Payment System ===
 dilbegin fountain_payment(player : unitptr, price : integer);
 var
    cost_cents : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    cost_cents := price * 100;
    
    if (player.acc_balance &gt;= cost_cents) {
       acc_modify(player, -cost_cents);
       send(&quot;Payment processed: $&quot; + itoa(price) + &quot; deducted from account.&quot;);
        send(&quot;Remaining balance: $&quot; + itoa((player.acc_balance - cost_cents) / 100) + &quot;.&quot; + itoa((player.acc_balance - cost_cents) % 100));
    } else {
       send(&quot;Insufficient funds for this purchase.&quot;);
       send(&quot;Cost: $&quot; + itoa(price));
        send(&quot;Balance: $&quot; + itoa(player.acc_balance / 100) + &quot;.&quot; + itoa(player.acc_balance % 100));
    }
    quit;
 } dilend

=== Account Transfer ===
 dilbegin transfer_funds(source : unitptr, target : unitptr, amount : integer);
 code
 {
    if (source.type != UNIT_ST_PC or target.type != UNIT_ST_PC) {
       send(&quot;Both units must be players.&quot;);
       quit;
    }
    
    if (amount &gt; 0) {
       acc_modify(source, -amount);
       acc_modify(target, amount);
        send(&quot;Transfer completed: $&quot; + itoa(amount / 100) + &quot;.&quot; + itoa(amount % 100));
       send(&quot;Transferred from &quot; + source.name + &quot; to &quot; + target.name);
    } else {
       send(&quot;Amount must be positive for transfer.&quot;);
    }
    quit;
 } dilend

=== Refund Processing ===
 dilbegin process_refund(player : unitptr, refund_amount : integer);
 var
    refund_cents : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    refund_cents := refund_amount * 100;
    
    acc_modify(player, refund_cents);
     send(&quot;Refund processed: $&quot; + itoa(refund_amount / 100) + &quot;.&quot; + itoa(refund_amount % 100));
    send(&quot;Added to account balance.&quot;);
    quit;
 } dilend



== Error Handling ==
The function performs comprehensive validation:
* &apos;&apos;&apos;Player validation&apos;&apos; - Ensures unit is a valid PC (not NPC)
* &apos;&apos;&apos;Type validation&apos;&apos; - Ensures amount parameter is integer type
* &apos;&apos;&apos;Accounting mode validation&apos;&apos; - Only works when game server is in accounting mode
* &apos;&apos;&apos;Access level validation&apos;&apos; - Requires appropriate zone access (root level typically required)
* &apos;&apos;&apos;Transaction validation&apos;&apos; - Logs all transactions for audit purposes

Note: The C implementation shows that this function:
* Only works on player characters (PCs), not NPCs
* Uses account_insert() for positive amounts (credits)
* Uses account_withdraw() for negative amounts (debits)
* Requires root access level to prevent unauthorized account modifications
* All transactions are logged in a specially encrypted account log file
* Uses getPCAccountData() to access underlying account data

== Usage Notes ==
* This function only works on player character units (UNIT_ST_PC type)
* The amount parameter is in 1/100ths (100 = 1.00 currency units)
* Positive amounts add funds to the player&apos;s account balance
* Negative amounts subtract funds from the player&apos;s account balance
* Requires appropriate zone access permissions (typically root level)
* Game server must be configured in accounting mode for this function to work
* All transactions are automatically logged for security and audit purposes
* Use with caution - improper use may result in deletion of god or zone access
* Always validate parameters and access levels before using this function
* Consider using acc_balance field to check available funds before transactions

== Related Functions ==
* [[Manual:DIL_Manual/acc_balance|acc_balance]] - Field to read player&apos;s account balance
* [[Manual:DIL_Manual/acc_total|acc_total]] - Field to read player&apos;s total credit
* [[Manual:DIL_Manual/transfermoney|transfermoney]] - Function to transfer physical money between units

== Related Fields ==
* [[Manual:DIL_Manual/acc_balance|acc_balance]] - Current account balance
* [[Manual:DIL_Manual/acc_total|acc_total]] - Total credit available
* [[Manual:DIL_Manual/money|money]] - Physical currency carried by the player

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/accounting|accounting]] - Server accounting mode configuration
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/acc_total</title>
     <ns>0</ns>
     <id>422317</id>
     <revision>
       <id>1002484</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of acc_total.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= acc_total =

The &apos;&apos;&apos;acc_total&apos;&apos;&apos; field is a read-only integer field available on player character units that provides access to the player&apos;s total credit amount when the game is in accounting mode.

== Syntax ==
 player.acc_total

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| player.acc_total || integer || The player&apos;s total credit amount
|}

== Return Value ==
Returns an integer representing the total credit:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The current total credit amount
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If player unit is invalid, not a PC, or game not in accounting mode

== Field Properties ==
{| class=&quot;wikitable&quot;
! Property !! Type !! Description
|-
| Read/Write || Read-only (RO)
|-
| Unit Type || Only available on UNIT_ST_PC (player characters)
|-
| Accounting Mode || Only returns valid data when game is in accounting mode
|-
| Credit System || Represents total credit available to the player
|}

== Examples ==
=== Basic Total Credit Check ===
 dilbegin check_total_credit(player : unitptr);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    send(&quot;Your total credit: $&quot; + itoa(player.acc_total));
    quit;
 } dilend

=== Credit Analysis ===
 dilbegin analyze_credit_status(player : unitptr);
 var
    balance_dollars : integer;
    balance_cents : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    balance_dollars := player.acc_balance / 100;
    balance_cents := player.acc_balance % 100;
    
    send(&quot;=== ACCOUNT ANALYSIS ===&quot;);
    send(&quot;Total Credit: $&quot; + itoa(player.acc_total));
     send(&quot;Current Balance: $&quot; + itoa(balance_dollars) + &quot;.&quot; + itoa(balance_cents));
     send(&quot;Available Credit: $&quot; + itoa((player.acc_total - player.acc_balance) / 100) + &quot;.&quot; + itoa((player.acc_total - player.acc_balance) % 100));
    quit;
 } dilend

=== Credit Limit Check ===
 dilbegin check_credit_limit(player : unitptr, required_credit : integer);
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    if (player.acc_total &gt;= required_credit) {
       send(&quot;You have sufficient credit for this transaction.&quot;);
       send(&quot;Required: $&quot; + itoa(required_credit));
       send(&quot;Available: $&quot; + itoa(player.acc_total));
    } else {
       send(&quot;Insufficient credit for this transaction.&quot;);
       send(&quot;Required: $&quot; + itoa(required_credit));
       send(&quot;Available: $&quot; + itoa(player.acc_total));
       send(&quot;Short: $&quot; + itoa(required_credit - player.acc_total));
    }
    quit;
 } dilend

=== Credit Status Display ===
 dilbegin show_credit_status(player : unitptr);
 var
    used_credit : integer;
    available_credit : integer;
 code
 {
    if (player.type != UNIT_ST_PC) {
       send(&quot;This function only works on players.&quot;);
       quit;
    }
    
    used_credit := player.acc_total - player.acc_balance;
    available_credit := player.acc_balance;
    
    send(&quot;=== CREDIT STATUS ===&quot;);
    send(&quot;Total Credit: $&quot; + itoa(player.acc_total));
    send(&quot;Used Credit: $&quot; + itoa(used_credit));
     send(&quot;Available Balance: $&quot; + itoa(available_credit / 100) + &quot;.&quot; + itoa(available_credit % 100));
     send(&quot;Available Credit: $&quot; + itoa((player.acc_total - used_credit) / 100) + &quot;.&quot; + itoa((player.acc_total - used_credit) % 100));
    quit;
 } dilend

=== Credit Comparison ===
 dilbegin compare_credit(player1 : unitptr, player2 : unitptr);
 code
 {
    if (player1.type != UNIT_ST_PC or player2.type != UNIT_ST_PC) {
       send(&quot;Both units must be players.&quot;);
       quit;
    }
    
    send(&quot;Credit Comparison:&quot;);
    send(player1.name + &quot; total credit: $&quot; + itoa(player1.acc_total));
    send(player2.name + &quot; total credit: $&quot; + itoa(player2.acc_total));
    
    if (player1.acc_total &gt; player2.acc_total) {
       send(player1.name + &quot; has more credit available.&quot;);
    } else if (player1.acc_total &lt; player2.acc_total) {
       send(player2.name + &quot; has more credit available.&quot;);
    } else {
       send(&quot;Both players have equal credit.&quot;);
    }
    quit;
 } dilend



== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Player validation&apos;&apos; - Ensures unit is a valid PC (not NPC)
* &apos;&apos;&apos;Accounting mode validation&apos;&apos; - Only returns meaningful data when game is in accounting mode
* &apos;&apos;&apos;Type validation&apos;&apos; - Returns fail if accessed on non-PC units

Note: The C implementation shows that this field:
* Only works on player characters (PCs), not NPCs
* Uses getPCAccountData().getTotalCredit() to retrieve the actual total credit
* Returns 0 if not in accounting mode or if account data is unavailable
* The total credit represents the maximum credit the player can access
* Works in conjunction with acc_balance for complete account information

== Usage Notes ==
* This field is read-only for reading total credit amount
* Only available on player character units (UNIT_ST_PC type)
* Only returns valid data when the game server is configured in accounting mode
* The field represents the total credit limit or amount available to the player
* The field is commonly used in credit management systems, purchase validation, and financial transactions
* Use with acc_balance field to understand current vs. available credit
* Use with acc_modify() function for modifying account balances
* Accounting mode must be enabled in server configuration for this field to work properly
* The total credit typically includes both used and available credit amounts

== Related Fields ==
* [[Manual:DIL_Manual/acc_balance|acc_balance]] - Current account balance
* [[Manual:DIL_Manual/acc_modify|acc_modify]] - Function to modify account balance
* [[Manual:DIL_Manual/money|money]] - Physical currency carried by the player

== Related Functions ==
* [[Manual:DIL_Manual/getPCAccountData|getPCAccountData]] - Internal function for account data access
* [[Manual:DIL_Manual/account_insert|account_insert]] - Internal function for account transactions

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/accounting|accounting]] - Server accounting mode configuration
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/access</title>
     <ns>0</ns>
     <id>1195080</id>
     <revision>
       <id>988167</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of access.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= access =
 function: integer &apos;&apos;&apos;access&apos;&apos;&apos;(unitptr : unitptr, zone : zoneptr);

The &apos;&apos;&apos;access&apos;&apos;&apos; function is a built-in DIL (DikuMUD Interactive Language) function that checks if a player has a specific access level for a given zone.

== Description ==
This function checks if a player has sufficient access level for a specified zone. It compares the player&apos;s level against the zone&apos;s access requirements and returns the access level.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unitptr || unitptr || The player unit to check access for
|-
| zone || zoneptr || The zone to check access level for
|}

== Access Levels ==
Access levels are typically defined as follows:
{| class=&quot;wikitable&quot;
! Level !! Description !! Typical Use
|-
| 0 || No access || Basic player access
|-
| 1 || Limited access || Restricted areas
|-
| 2 || Builder access || Zone building tools
|-
| 3 || Administrator access || Full system access
|-
| 4+ || Root/Immortal access || Complete control
|}

== Examples ==
=== Basic Access Check ===
 dilbegin check_zone_access(player : unitptr, zone_name : string);
 var
    target_zone : zoneptr;
    access_level : integer;
 code
 {
    target_zone := findsymbolic(zone_name);
    if (target_zone == null) {
       send(&quot;Zone &apos;&quot; + zone_name + &quot;&apos; not found.&quot;);
       quit;
    }
    
    access_level := access(player, target_zone);
    
    if (access_level &gt; 0) {
       send(&quot;You have access to zone &apos;&quot; + zone_name + &quot;&apos; (level &quot; + itoa(access_level) + &quot;).&quot;);
    } else {
       send(&quot;You do not have access to zone &apos;&quot; + zone_name + &quot;&apos;.&quot;);
    }
    quit;
 } dilend

=== Administrative Access Check ===
 dilbegin admin_area_check(player : unitptr);
 var
    admin_zone : zoneptr;
 code
 {
    admin_zone := findsymbolic(&quot;admin_zone&quot;);
    if (admin_zone == null) {
       send(&quot;Admin zone not found.&quot;);
       quit;
    }
    
    if (access(player, admin_zone) &gt;= 3) {
       send(&quot;You have administrative access.&quot;);
    } else {
       send(&quot;You lack administrative access.&quot;);
    }
    quit;
 } dilend

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Zone validation&apos;&apos; - Ensures zone parameter is valid and not null
* &apos;&apos;&apos;Type validation&apos;&apos; - Returns fail if zone is not a valid zoneptr
* &apos;&apos;&apos;Access level retrieval&apos;&apos; - Safely gets the zone&apos;s access level

Note: The C implementation shows that this function:
* Uses getAccessLevel() method to retrieve the zone&apos;s access level
* Compares the player&apos;s level against the zone&apos;s access requirement
* Returns TRUE (1) if player level &gt;= zone access level, FALSE (0) otherwise
* The function is commonly used for zone security and access control

== Usage Notes ==
* This function is used for zone-based access control
* Access levels are typically defined in zone configuration files
* The function only checks access - it does not grant or modify access
* Use with zoneptr functions to navigate through zones
* Commonly used in zone entry points, command restrictions, and area security
* The function works with player units (PCs), not NPCs or other unit types
* Access levels are cumulative - higher levels include all lower level permissions
* Zone access is separate from character level or other security measures

== Related Functions ==
* [[Manual:DIL_Manual/findsymbolic|findsymbolic]] - Function to find zones by name
* [[Manual:DIL_Manual/zhead|zhead]] - Function to get the first zone in the list
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type and related fields

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/access|access]] - Zone access level field</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/act</title>
     <ns>0</ns>
     <id>737186</id>
     <revision>
       <id>1185772</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of act.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= act =
 function: void &apos;&apos;&apos;act&apos;&apos;&apos;(string : string, visibility : integer, char : unitptr, medium : unitptr, victim : unitptr, to_whom : integer);

The &apos;&apos;&apos;act&apos;&apos;&apos; function is a built-in DIL (DikuMUD Interactive Language) function that sends formatted messages to characters in a room or specific targets.

== Description ==
This function sends formatted messages to characters with support for dynamic content substitution through formatters. It&apos;s the primary method for sending messages to players in DikuMUD.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| string || string || The message to be sent (with formatters)
|-
| visibility || integer || Visibility flag for message delivery
|-
| char || unitptr || The character performing the action (for $1, $2, etc.)
|-
| medium || unitptr || The medium/object being used (for $m)
|-
| victim || unitptr || The target of the action (for $3, $4, etc.)
|-
| to_whom || integer || Who receives the message (target audience)
|}

== Visibility Flags ==
{| class=&quot;wikitable&quot;
! Flag !! Value !! Description
|-
| A_SOMEONE || Send to character only
|-
| A_HIDEINV || Hide action from others in room
|-
| A_ALWAYS || Send to everyone regardless of visibility
|-
| A_SOMEONE || Send to character and room (excluding character)
|-
| A_NOTVICT || Send to everyone except victim
|-
| TO_CHAR || Send to character only
|-
| TO_VICT || Send to victim only
|-
| TO_ROOM || Send to room (excluding character)
|-
| TO_REST || Send to everyone except those fighting or resting
|-
| TO_ALL || Send to everyone in room
|}

== Message Formatters ==
The message string can contain special formatters that are replaced at runtime:

{| class=&quot;wikitable&quot;
! Formatter !! Description !! Example
|-
| $1 || Replaced with character&apos;s name
|-
| $2 || Replaced with medium&apos;s name
|-
| $3 || Replaced with victim&apos;s name
|-
| $4 || Replaced with victim&apos;s title
|-
| $5 || Replaced with victim&apos;s name (gender-aware: he/she/it)
|-
| $6 || Replaced with victim&apos;s name (gender-aware: him/her/it)
|-
| $n || Replaced with victim&apos;s name (gender-aware: his/her/its)
|-
| $a || Replaced with victim&apos;s name (gender-aware: he/she/it)
|-
| $m || Replaced with victim&apos;s name (gender-aware: him/her/it)
|-
| $e || Replaced with victim&apos;s name (gender-aware: him/her/it)
|-
| $s || Replaced with victim&apos;s name (gender-aware: him/her/it)
|-
| $t || Replaced with victim&apos;s name (gender-aware: him/her/it)
|}

== Examples ==
=== Basic Action Message ===
 dilbegin simple_action(actor : unitptr, target : unitptr);
 code
 {
    act(&quot;$1n picks up $2n.&quot;, A_SOMEONE, actor, null, target, TO_CHAR);
    act(&quot;$1n picks up $2n.&quot;, A_NOTVICT, actor, null, target, TO_ROOM);
    quit;
 } dilend

=== Combat Message ===
 dilbegin combat_message(attacker : unitptr, defender : unitptr);
 code
 {
    act(&quot;$1n attacks $3n with deadly force!&quot;, A_ALWAYS, attacker, null, defender, TO_VICT);
    act(&quot;$1n attacks $3n with deadly force!&quot;, A_NOTVICT, attacker, null, defender, TO_ROOM);
    quit;
 } dilend

=== Gender-Aware Messages ===
 dilbegin gender_aware_message(actor : unitptr, victim : unitptr);
 code
 {
    act(&quot;$1n pats $5n on the head.&quot;, A_SOMEONE, actor, null, victim, TO_CHAR);
    act(&quot;$1n pats $5m on the head.&quot;, A_SOMEONE, actor, null, victim, TO_ROOM);
    quit;
 } dilend

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Message validation&apos;&apos; - Ensures message parameter is a string
* &apos;&apos;&apos;Type validation&apos;&apos; - Ensures visibility, char, medium, victim are appropriate types
* &apos;&apos;&apos;Unit validation&apos;&apos; - Ensures char, medium, and victim are valid unit pointers
* &apos;&apos;&apos;Target validation&apos;&apos; - Ensures victim is valid when using TO_VICT flag

Note: The C implementation shows that this function:
* Supports multiple parameter combinations (from 2 to 6 parameters)
* Uses formatters for dynamic message content
* Handles gender-aware name substitution
* Performs complex visibility calculations based on flags
* Returns DILV_SP (string) for the generated message

== Usage Notes ==
* This function is the primary method for sending messages to players
* The message parameter supports formatters for dynamic content
* Visibility flags control who sees the message
* The function is commonly used for combat, social interactions, and environmental descriptions
* Gender-aware formatters ($5, $6, etc.) automatically adapt to victim&apos;s gender
* The function is more efficient than multiple send() calls for complex messages
* Use appropriate visibility flags to control message flow and prevent spam
* The char parameter is required for most visibility modes except TO_ROOM and TO_ALL

== Related Functions ==
* [[Manual:DIL_Manual/send|send]] - Send message to specific character
* [[Manual:DIL_Manual/sendtext|sendtext]] - Send text to character without formatting
* [[Manual:DIL_Manual/sendto|sendto]] - Send message to specific unit
* [[Manual:DIL_Manual/sendtoall|sendtoall]] - Send message to all units in local environment

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/visibility|visibility]] - Unit visibility field
* [[Manual:DIL_Manual/position|position]] - Character position field
* [[Manual:DIL_Manual/A_*|A_*]] - Action visibility constants</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/activator</title>
     <ns>0</ns>
     <id>717659</id>
     <revision>
       <id>1896755</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of activator.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= activator =
 field: unitptr &apos;&apos;&apos;.activator&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;activator&apos;&apos;&apos; field is a read-only unit pointer field available in DIL programs that provides access to the unit which activated the current DIL program.

== Description ==
This field provides access to the unit that triggered the current DIL program. It&apos;s automatically set by the DIL runtime system when a command, spell, or event activates the program.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| activator || unitptr || The unit that activated the current DIL program
|}

== Availability ==
This field is available in all DIL programs.

== Examples ==
=== Basic Activator Check ===
 dilbegin check_activator();
 code
 {
    if (activator != null) {
       send(&quot;Program activated by: &quot; + activator.name);
    } else {
       send(&quot;No activator for this program.&quot;);
    }
    quit;
 } dilend

=== Security Check ===
 dilbegin security_check();
 code
 {
    if (activator != null) {
       if (activator.level &gt;= IMMORTAL_LEVEL) {
          send(&quot;Program activated by an immortal.&quot;);
       } else {
          send(&quot;Program activated by: &quot; + activator.name + &quot; (Level &quot; + itoa(activator.level) + &quot;)&quot;);
       }
    } else {
       send(&quot;No activator information available.&quot;);
    }
    quit;
 } dilend

=== Spell Casting Detection ===
 dilbegin spell_detection();
 code
 {
    if (activator != null) {
       if (activator.type == UNIT_ST_PC) {
          send(&quot;A player cast a spell that activated this program.&quot;);
       } else if (activator.type == UNIT_ST_NPC) {
          send(&quot;An NPC cast a spell that activated this program.&quot;);
       } else {
          send(&quot;Unknown unit type activated this program.&quot;);
       }
    } else {
       send(&quot;No activator information available.&quot;);
    }
    quit;
 } dilend

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Automatic validation&apos;&apos; - The field is automatically set by the DIL runtime
* &apos;&apos;&apos;Type validation&apos;&apos; - Always returns a unit pointer (may be null)
* &apos;&apos;&apos;Context validation&apos;&apos; - Only meaningful when accessed within an activated DIL program

Note: The field is set by the DIL runtime system when:
* A command is executed by a player/NPC
* A spell is cast that affects a DIL program
* A wait condition is triggered
* An interrupt occurs
* Any other event activates the DIL program

== Usage Notes ==
* This field is read-only and automatically managed by the DIL system
* Only meaningful when accessed within DIL code that was activated by an event
* The field is commonly used for:
** Command processing - Identifying who executed a command
** Security systems - Checking if an immortal activated a program
** Interactive objects - Determining who touched or used an item
** Trap systems - Identifying who triggered a trap
** Spell systems - Detecting magical effects on DIL programs
* The field is null when the DIL program is first created or not yet activated
* Use with wait() and SFB_CMD to create responsive programs that react to different activators

== Related Fields ==
* [[Manual:DIL_Manual/self|self]] - The current unit executing the DIL program
* [[Manual:DIL_Manual/command|command]] - The command that was executed
* [[Manual:DIL_Manual/argument|argument]] - Arguments provided with the command

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command activation wait flag
* [[Manual:DIL_Manual/wait|wait]] - Function for waiting on specific conditions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/addaff</title>
     <ns>0</ns>
     <id>516500</id>
     <revision>
       <id>1175639</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of addaff.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= addaff =
 function: void &apos;&apos;&apos;addaff&apos;&apos;&apos;(character : unitptr, affect_id : integer, duration : integer, beat : integer, data0 : integer, data1 : integer, data2 : integer, tif_first : integer, tif_last : integer, apf : integer, tif_tick : integer);

The &apos;&apos;&apos;addaff&apos;&apos;&apos; function is a built-in DIL (DikuMUD Interactive Language) function that adds a new affect to a character unit.

== Description ==
This function adds a new affect to a character with comprehensive control over duration, timing, data values, and behavior flags. It&apos;s commonly used for combat systems, magic effects, and temporary character modifications.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| character || unitptr || The character to receive the affect
|-
| affect_id || integer || The ID of the affect to add (see ID_* constants)
|-
| duration || integer || Duration in pulses (4 = 1 second)
|-
| beat || integer || How often the affect triggers (4 = 1 second)
|-
| data0 || integer || First data value for the affect
|-
| data1 || integer || Second data value for the affect
|-
| data2 || integer || Third data value for the affect
|-
| tif_first || integer || First tick modifier (TIF_XXX flags)
|-
| tif_last || integer || Last tick modifier (TIF_XXX flags)
|-
| apf || integer || Apply flags (APF_XXX flags)
|-
| tif_tick || integer || Tick interval modifier (TIF_XXX flags)
|}

== Affect ID Constants ==
The affect_id parameter accepts any of the following constants defined in values.h or vme.h:

{| class=&quot;wikitable&quot;
! Constant !! Description
|-
| ID_BLIND || Blindness affect
|-
| ID_INVISIBLE || Invisibility affect
|-
| ID_SNEAK || Sneaking affect
|-
| ID_SANCTUARY || Sanctuary affect
|-
| ID_CURSE || Curse affect
|-
| ID_POISON || Poison affect
|-
| ID_PLAGUE || Plague affect
|-
| ID_SLEEP || Sleep affect
|-
| ID_CHARM || Charm affect
|-
| ID_FLYING || Flying affect
|-
| ID_WATER_BREATH || Water breathing affect
|-
| ID_SPELL || Spell affect
|-
| ID_SKILL || Skill affect
|-
| ID_WEAPON || Weapon skill affect
|-
| ID_ARMOR || Armor skill affect
|-
| ID_DAMAGE || Damage bonus affect
|-
| ID_SPEED || Speed bonus affect
|-
| ID_MANIPULATE || Manual dexterity affect
|-
| ID_HITROLL || Hit roll bonus affect
|-
| ID_SAVING_THROW || Saving throw bonus affect
|-
| ID_SAVING_SPELL || Saving spell bonus affect
|-
| ID_RESIST_COLD || Cold resistance affect
|-
| ID_RESIST_FIRE || Fire resistance affect
|-
| ID_RESIST_ENERGY || Energy resistance affect
|-
| ID_RESIST_ACID || Acid resistance affect
|-
| ID_RESIST_ELECTRIC || Electric resistance affect
|-
| ID_RESIST_MAGIC || Magic resistance affect
|-
| ID_RESIST_DISEASE || Disease resistance affect
|-
| ID_GOOD || Good alignment affect
|-
| ID_EVIL || Evil alignment affect
|-
| ID_SUN || Sun vulnerability affect
|-
| ID_PROTECTION || Protection affect
|-
| ID_PARALYSIS || Paralysis affect
|-
| ID_FEAR || Fear affect
|-
| ID_WEAKEN || Weakness affect
|-
| ID_REGENERATION || Regeneration affect
|-
| ID_ABSORPTION || Absorption affect
|-
| ID_SPELL_DAMAGE || Spell damage affect
|-
| ID_WEAPON_DAMAGE || Weapon damage affect
|-
| ID_SKILL_DAMAGE || Skill damage affect
|-
| ID_NON_DETECTION || Non-detection affect
|-
| ID_NON_MAGIC || Non-magic affect
|}

== Apply Flags ==
The apf parameter accepts any combination of the following flags:

{| class=&quot;wikitable&quot;
! Flag !! Description
|-
| APF_NONE || No special apply behavior
|-
| APF_FIRST || Affect applies first (before other affects)
|-
| APF_LAST || Affect applies last (after other affects)
|-
| APF_TICK || Affect triggers on tick intervals
|-
| APF_FIRST_TICK || Affect triggers on first tick in interval
|-
| APF_LAST_TICK || Affect triggers on last tick in interval
|-
| APF_CUMULATIVE || Affect stacks with same type (cumulative)
|-
| APF_DURATION || Affect has duration and will expire
|-
| APF_BITE || Affect is bite-type (for vampires)
|-
| APF_WEAPON || Affect is weapon-type
|-
| APF_MAGIC || Affect is magical
|-
| APF_INVISIBLE || Affect is invisible
|-
| APF_NO_SAVE || Affect doesn&apos;t save with character
|-
| APF_TO_A || Affect transfers to attacker on hit
|-
| APF_STOP || Affect stops combat actions
|-
| APF_DEAD || Affect causes death when expires
|-
| APF_SLOW || Affect slows character
|-
| APF_HASTE || Affect causes haste
|}

== Tick Flags ==
The tif_first and tif_last parameters modify when the affect triggers:

{| class=&quot;wikitable&quot;
! Flag !! Description
|-
| TIF_NONE || No special timing
|-
| TIF_FIRST || Trigger on first tick of interval
|-
| TIF_LAST || Trigger on last tick of interval
|-
| TIF_EVERY || Trigger on every tick
|-
| TIF_ODD || Trigger on odd-numbered ticks
|-
| TIF_EVEN || Trigger on even-numbered ticks
|}

== Examples ==
=== Basic Blindness Affect ===
 dilbegin blind_target(victim : unitptr);
 code
 {
    addaff(victim, ID_BLIND, 40, 0, 0, 0, 0, 0, APF_DURATION | APF_FIRST, 0);
    send(&quot;You have been blinded!&quot;);
    quit;
 } dilend

=== Temporary Invisibility ===
 dilbegin invisibility_spell(caster : unitptr, target : unitptr);
 code
 {
    addaff(target, ID_INVISIBLE, 20, 0, 0, 0, 0, 0, APF_DURATION | APF_FIRST, 0);
    send(&quot;You fade from view.&quot;);
    quit;
 } dilend

=== Permanent Sanctuary ===
 dilbegin sanctuary_bless(player : unitptr);
 code
 {
    addaff(player, ID_SANCTUARY, -1, 0, 0, 0, 0, 0, APF_DURATION | APF_FIRST, 0);
    send(&quot;You feel protected by divine power.&quot;);
    quit;
 } dilend

=== Poison Damage Over Time ===
 dilbegin poison_damage(victim : unitptr);
 code
 {
    addaff(victim, ID_POISON, 100, 4, 0, 0, 0, 0, APF_DURATION | APF_TICK, TIF_EVERY);
    send(&quot;You feel poison coursing through your veins!&quot;);
    quit;
 } dilend

=== Complex Combat Buff ===
 dilbegin combat_enhancement(player : unitptr);
 code
 {
    addaff(player, ID_WEAPON_DAMAGE, -1, 0, 5, 0, 0, 0, APF_DURATION | APF_FIRST, 0);
    addaff(player, ID_SKILL_DAMAGE, -1, 0, 3, 0, 0, 0, APF_DURATION | APF_FIRST, 0);
    send(&quot;You feel enhanced for combat!&quot;);
    quit;
 } dilend

== Error Handling ==
The function performs comprehensive validation:
* &apos;&apos;&apos;Character validation&apos;&apos; - Ensures character is a valid unit
* &apos;&apos;&apos;Type validation&apos;&apos; - Ensures all parameters are integer types
* &apos;&apos;&apos;ID validation&apos;&apos; - Checks that affect_id is within valid range
* &apos;&apos;&apos;Flag validation&apos;&apos; - Validates apply and tick flag combinations
* &apos;&apos;&apos;Security check&apos;&apos; - Logs attempts to add affects to non-characters

Note: The C implementation shows that this function:
* Uses create_affect() to add the affect to the character
* Performs extensive parameter validation and type checking
* Logs security violations for audit purposes
* Supports complex affect combinations with multiple data values
* Handles both character and object targets appropriately

== Usage Notes ==
* This function is commonly used for:
** Combat systems - Adding blindness, poison, damage bonuses
** Magic systems - Adding spell effects, magical enhancements
** Temporary effects - Invisibility, sanctuary, haste
** Permanent effects - Alignment changes, regeneration
** Conditional effects - Effects that depend on character state
* Stacking mechanics - Multiple affects of the same type
* The function works on both players and NPCs
* Duration is measured in game pulses (typically 4 pulses = 1 second)
* Use appropriate apply flags to control affect order and behavior
* The function is more powerful than individual affect spells due to direct data manipulation

== Related Functions ==
* [[Manual:DIL_Manual/isaff|isaff]] - Check if a character has a specific affect
* [[Manual:DIL_Manual/getaffects|getaffects]] - Get all affects on a character
* [[Manual:DIL_Manual/subaff|subaff]] - Remove a specific affect from a character
* [[Manual:DIL_Manual/create_affect|create_affect]] - Internal function used by addaff

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/ID_*|ID_*]] - Affect ID constants
* [[Manual:DIL_Manual/APF_*|APF_*]] - Apply flag constants
* [[Manual:DIL_Manual/TIF_*|TIF_*]] - Tick flag constants</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/addcolor</title>
     <ns>0</ns>
     <id>1099924</id>
     <revision>
       <id>1573254</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of addcolor.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= addcolor =
function: &apos;&apos;&apos;addcolor&apos;&apos;&apos;(character : unitptr, color_key : string);

The &apos;&apos;&apos;addcolor&apos;&apos;&apos; function adds a color to a character&apos;s color palette.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| character || unitptr || The character to receive the color
|-
| color_key || string || The color key to add (e.g., &quot;&amp;red&quot;, &quot;&amp;blue&quot;)
|}

== Availability ==
This function is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Usage Notes ==
* Color keys must start with &quot;&amp;&quot; and be valid color names
* Common color keys include: &quot;&amp;red&quot;, &quot;&amp;blue&quot;, &quot;&amp;green&quot;, &quot;&amp;yellow&quot;, &quot;&amp;cyan&quot;, &quot;&amp;magenta&quot;, &quot;&amp;white&quot;, &quot;&amp;black&quot;
* Colors are persistent across character saves and logins

== Examples ==
 dilbegin add_basic_color(player : unitptr);
 code
 {
    addcolor(player, &quot;&amp;red&quot;);
    send(&quot;Red color added to your palette.&quot;);
    quit;
 } dilend

 dilbegin conditional_color(player : unitptr, color_choice : integer);
 code
 {
    if (color_choice == 1) {
       addcolor(player, &quot;&amp;red&quot;);
    } else if (color_choice == 2) {
       addcolor(player, &quot;&amp;blue&quot;);
    } else if (color_choice == 3) {
       addcolor(player, &quot;&amp;green&quot;);
    }
    quit;
 } dilend

== Error Handling ==
The function will fail if:
* The character parameter is not a valid unit
* The color_key parameter is not a string
* The color_key does not start with &quot;&amp;&quot;
* The character is not a PC or NPC

== Usage Notes ==
* Use with delcolor() for color removal
* Use with isaff() to check if a color is already available
* Color keys must start with &quot;&amp;&quot; and be valid color names
* Colors are persistent across character saves and logins

== Related Functions/Fields ==
* [[Manual:DIL_Manual/delcolor|delcolor]] - Remove a color from character&apos;s palette
* [[Manual:DIL_Manual/isaff|isaff]] - Check if character has a specific color

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/addequip</title>
     <ns>0</ns>
     <id>863086</id>
     <revision>
       <id>1190812</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of addequip.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= addequip =
function: &apos;&apos;&apos;addequip&apos;&apos;&apos;(u : unitptr, i : integer);

The &apos;&apos;&apos;addequip&apos;&apos;&apos; function equips an object unit to a specific equipment position on a character.

== Description ==
The &apos;&apos;&apos;addequip&apos;&apos;&apos; procedure equips an object unit (presumed to be in the inventory of a PC/NPC) to the specified equipment position. The object must be in the character&apos;s inventory before calling this function. The equipment position is specified using one of the WEAR_* constants defined in values.h and/or vme.h.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The object unit to be equipped
|-
| i || integer || The equipment position where the object should be equipped (WEAR_* constant)
|}

== Examples ==
=== Basic Equipment ===
dilbegin equip_item(character : unitptr, item : unitptr);
code
{
   // Check if finger slot is empty before equipping
   if (equipment(character, WEAR_FINGER_L) == null)
   {
      addequip(item, WEAR_FINGER_L);
      act(&quot;You put $2n on your left finger.&quot;, A_ALWAYS, character, item, null, TO_CHAR);
   }
   else
   {
      sendto(&quot;Your left finger is already occupied.&quot;, character);
   }
} dilend

=== Weapon Replacement ===
dilbegin equip_weapon(character : unitptr, new_weapon : unitptr);
var
   current_weapon : unitptr;
code
{
   // Remove currently wielded weapon if any
   current_weapon := equipment(character, WEAR_WIELD);
   if (current_weapon != null)
   {
      unequip(current_weapon);
   }
   
   // Equip the new weapon
   addequip(new_weapon, WEAR_WIELD);
   act(&quot;You wield $2n.&quot;, A_ALWAYS, character, new_weapon, null, TO_CHAR);
} dilend

== Usage Notes ==
* The object to be equipped must already be in the character&apos;s inventory
* The target equipment position must be empty (no item already equipped there)
* The character parameter is inferred from the object&apos;s container (the object must be inside a character)
* Common WEAR_* constants include:
** WEAR_FINGER_L, WEAR_FINGER_R (left/right finger)
** WEAR_NECK_1, WEAR_NECK_2 (neck slots)
** WEAR_BODY (body armor)
** WEAR_HEAD (helmet)
** WEAR_LEGS (leg armor)
** WEAR_FEET (boots)
** WEAR_HANDS (gloves)
** WEAR_ARMS (arm armor)
** WEAR_ABOUT (cloak)
** WEAR_WAIST (belt)
** WEAR_WRIST_L, WEAR_WRIST_R (left/right wrist)
** WEAR_WIELD (wielded weapon)
** WEAR_HOLD (held item)
** WEAR_SHIELD (shield)
** WEAR_CHEST (chest armor)
** WEAR_BACK (backpack/cloak)
** WEAR_EAR_L, WEAR_EAR_R (left/right ear)
** WEAR_ANKLE_L, WEAR_ANKLE_R (left/right ankle)

== Error Handling ==
The function will fail silently if:
* The first parameter is not a unit pointer
* The second parameter is not an integer
* The object is not in a character&apos;s inventory
* The object is not an object type (UNIT_ST_OBJ)
* The target character is not a character type (UNIT_ST_PC or UNIT_ST_NPC)
* The equipment position is already occupied

== Related Functions/Fields ==
* [[Manual:DIL_Manual/equipment|equipment]] - Returns the unit equipped at a specific position
* [[Manual:DIL_Manual/unequip|unequip]] - Removes an equipped item
* [[Manual:DIL_Manual/unit_st_obj.equip|unit_st_obj.equip]] - Field showing an object&apos;s current equipment position

== See Also ==
* [[Manual:DIL_Manual/link|link]]
* [[Manual:DIL_Manual/unit_st_obj|unit_st_obj]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/addextra</title>
     <ns>0</ns>
     <id>1068475</id>
     <revision>
       <id>1463115</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of addextra.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= addextra =
 function: &apos;&apos;&apos;addextra&apos;&apos;&apos;(unit : unitptr, index : integer, text : string);

The &apos;&apos;&apos;addextra&apos;&apos;&apos; function adds a new string to a unit&apos;s extra description list for custom descriptions and keywords.

== Description ==
Adds a new string to a unit&apos;s extra description list at the specified index position. This function is used to add custom descriptions, keywords, and other string data to units (players, NPCs, objects, rooms).

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit to add the extra description to
|-
| index || integer || The index position in the extra description list (0-based)
|-
| text || string || The string content to add to the extra description
|}

== Examples ==
=== Basic Description Addition ===
 dilbegin add_player_description();
 code
 {
    addextra(self, 0, &quot;A tall warrior with battle scars.&quot;);
    send(&quot;Description added to your character.&quot;);
    quit;
 } dilend

=== Object Keywords ===
 dilbegin add_weapon_keywords(weapon : unitptr);
 code
 {
    addextra(weapon, 1, &quot;sword blade sharp weapon&quot;);
    send(&quot;Keywords added to weapon.&quot;);
    quit;
 } dilend

=== Room Description ===
 dilbegin customize_room(room : unitptr);
 code
 {
    addextra(room, 0, &quot;A dark, damp cave with echoes of dripping water.&quot;);
    send(&quot;Room description customized.&quot;);
    quit;
 } dilend

=== Multiple Extra Descriptions ===
 dilbegin detailed_item_setup(item : unitptr);
 code
 {
    addextra(item, 0, &quot;A finely crafted longsword with intricate engravings.&quot;);
    addextra(item, 1, &quot;longsword sword blade weapon&quot;);
    addextra(item, 2, &quot;The blade gleams with an otherworldly light.&quot;);
    send(&quot;Multiple extra descriptions added to item.&quot;);
    quit;
 } dilend

== Usage Notes ==
* The index determines the position in the extra description list
* Use 0 for the main description, higher numbers for additional descriptions
* This function is commonly used for dynamic content creation
* The function handles memory allocation automatically
* Existing extra descriptions at the specified index will be replaced
* Works on all unit types: UNIT_ST_PC, UNIT_ST_NPC, UNIT_ST_OBJ, UNIT_ST_ROOM

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Index validation&apos;&apos; - Ensures index is a valid integer
* &apos;&apos;&apos;Text validation&apos;&apos; - Ensures text is a valid string
* &apos;&apos;&apos;Memory allocation&apos;&apos; - Handles memory allocation failures gracefully

== Related Functions ==
* [[Manual:DIL_Manual/delstr|delstr]] - Delete strings from extra descriptions
* [[Manual:DIL_Manual/extra|extra]] - Access extra description data
* [[Manual:DIL_Manual/addstring|addstring]] - Add strings to string lists

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/extraptr|extraptr]] - Extra description pointer type
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/addstring</title>
     <ns>0</ns>
     <id>402759</id>
     <revision>
       <id>1288818</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of addstring.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= addstring =
 function: &apos;&apos;&apos;addstring&apos;&apos;&apos;(stringlist : stringptr, text : string);

The &apos;&apos;&apos;addstring&apos;&apos;&apos; function adds a new string to a string list for building dynamic data structures.

== Description ==
Adds a new string to a string list. This function is used to build and manage dynamic string lists for various purposes like command arguments, message queues, or data collections.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| stringlist || stringptr || The string list to add string to (can be null to create a new list)
|-
| text || string || The string content to add to list
|}

== Return Value ==
Returns an updated string list pointer. If the operation fails, returns the original list unchanged.

== Examples ==
=== Basic List Creation ===
 dilbegin create_list();
 var
    mylist : stringptr;
 code
 {
    mylist := addstring(null, &quot;first item&quot;);
    mylist := addstring(mylist, &quot;second item&quot;);
    mylist := addstring(mylist, &quot;third item&quot;);
    send(&quot;List created with 3 items.&quot;);
    quit;
 } dilend

=== Command Arguments ===
 dilbegin process_arguments();
 var
    args : stringptr;
 code
 {
    args := addstring(null, argument);
    args := addstring(args, extra_argument);
    send(&quot;Arguments processed.&quot;);
    quit;
 } dilend

=== Message Queue ===
 dilbegin build_messages();
 var
    messages : stringptr;
 code
 {
    messages := addstring(messages, &quot;Welcome to the game!&quot;);
    messages := addstring(messages, &quot;Type &apos;help&apos; for commands.&quot;);
    send(&quot;Message queue built.&quot;);
    quit;
 } dilend

=== Dynamic Data Structure ===
 dilbegin dynamic_collection();
 var
    data : stringptr;
    i : integer;
 code
 {
    for (i := 1; i &lt;= 5; i := i + 1) {
       data := addstring(data, &quot;item &quot; + itoa(i));
    }
    send(&quot;Collection created with 5 items.&quot;);
    quit;
 } dilend

== Usage Notes ==
* If stringlist is null, a new string list is created
* Strings are added to the end of the list
* The function handles memory allocation automatically
* Commonly used for dynamic data structures
* Used extensively in command parsing and message handling
* Returns a string pointer that can be used with other string functions

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;String validation&apos;&apos; - Ensures text parameter is a valid string
* &apos;&apos;&apos;Memory allocation&apos;&apos; - Handles memory allocation failures gracefully
* &apos;&apos;&apos;List validation&apos;&apos; - Validates string list parameter

== Related Functions ==
* [[Manual:DIL_Manual/delstr|delstr]] - Delete strings from string lists
* [[Manual:DIL_Manual/getwords|getwords]] - Extract words from strings
* [[Manual:DIL_Manual/addextra|addextra]] - Add strings to unit extra descriptions

== See Also ==
* [[Manual:DIL_Manual/stringptr|stringptr]] - String pointer data type
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/alignment</title>
     <ns>0</ns>
     <id>561551</id>
     <revision>
       <id>1740001</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of alignment.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= alignment =
 function: integer &apos;&apos;&apos;alignment&apos;&apos;&apos;(unit : unitptr);

The &apos;&apos;&apos;alignment&apos;&apos;&apos; function returns the alignment value representing a unit&apos;s moral and ethical standing.

== Description ==
Returns the alignment value of a unit. Alignment represents the moral and ethical standing of characters in the game world, ranging from good to evil.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit whose alignment is to be retrieved
|}

== Return Value ==
Returns an integer representing the alignment value:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The alignment value, ranging from -1000 to 1000:
** 1000 = Maximum good
** 0 = Neutral
** -1000 = Maximum evil
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If unit parameter is invalid

== Examples ==
=== Basic Alignment Check ===
 dilbegin check_alignment();
 var
    align_value : integer;
 code
 {
    align_value := alignment(self);
    if (align_value &gt; 500) {
       send(&quot;You are very good!&quot;);
    } else if (align_value &lt; -500) {
       send(&quot;You are very evil!&quot;);
    } else {
       send(&quot;You are neutral.&quot;);
    }
    quit;
 } dilend

=== Target Alignment Check ===
 dilbegin check_target_alignment();
 var
    target : unitptr;
    target_align : integer;
 code
 {
    target := findunit(self, argument, FIND_UNIT_SURRO, null);
    if (target != null) {
       target_align := alignment(target);
       if (target_align &lt; 0) {
          send(target.name + &quot; is evil!&quot;);
       } else {
          send(target.name + &quot; is good.&quot;);
       }
    } else {
       send(&quot;No target found.&quot;);
    }
    quit;
 } dilend

=== Alignment-Based Reaction ===
 dilbegin alignment_reaction();
 var
    visitor : unitptr;
 code
 {
    visitor := activator;
    if (visitor != null) {
       if (alignment(visitor) &lt; -500) {
          act(&quot;$1n snarls at your evil presence.&quot;, A_ALWAYS, self, null, visitor, TO_VICT);
       } else if (alignment(visitor) &gt; 500) {
          act(&quot;$1n smiles warmly at your good nature.&quot;, A_ALWAYS, self, null, visitor, TO_VICT);
       } else {
          act(&quot;$1n nods neutrally at your presence.&quot;, A_ALWAYS, self, null, visitor, TO_VICT);
       }
    }
    quit;
 } dilend

== Usage Notes ==
* Alignment is a read-write property that can be modified using assignment
* Alignment affects various game mechanics including NPC reactions, spell effects, and equipment restrictions
* The alignment system is typically used for roleplaying purposes and to determine access to certain areas or equipment
* Players can change their alignment through their actions in the game world
* NPCs with negative alignment may attack good-aligned characters on sight
* Alignment values persist across character saves

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Type validation&apos;&apos; - Returns fail if unit is not a valid type

== Related Functions ==
* [[Manual:DIL_Manual/set|set]] - For modifying unit properties including alignment

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/argument</title>
     <ns>0</ns>
     <id>1092751</id>
     <revision>
       <id>1001730</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of argument.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= argument =
 field: string &apos;&apos;&apos;argument&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;argument&apos;&apos;&apos; field contains the text that follows the command name when a player types a command.

== Description ==
Returns the argument string of the command that triggered the DIL program. This variable contains the text that follows the command name when a player types a command.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| argument || string || The argument string provided by the player after the command name
|}

== Return Value ==
Returns a string:
* &apos;&apos;&apos;string&apos;&apos;&apos; - The argument string provided by the player after the command name
* &apos;&apos;&apos;empty string&apos;&apos;&apos; - If no argument was provided

== Examples ==
=== Basic Command Processing ===
 dilbegin hello_command();
 code
 {
    wait(SFB_CMD, command(&quot;hello&quot;));
    if (argument == &quot;&quot;) {
       send(&quot;Hello there!&quot;);
    } else {
       send(&quot;Hello &quot; + argument + &quot;!&quot;);
    }
    quit;
 } dilend

=== Target Selection ===
 dilbegin give_command();
 var
    target_name : string;
    target : unitptr;
 code
 {
    wait(SFB_CMD, command(&quot;give&quot;) and (self == target));
    target_name := argument;
    target := findunit(self.outside, target_name, FIND_UNIT_SURRO, null);
    if (target != null and target.type == UNIT_ST_PC) {
       send(&quot;You give item to &quot; + target.name + &quot;.&quot;);
    } else {
       send(&quot;No one here by that name.&quot;);
    }
    quit;
 } dilend

=== Text Validation ===
 dilbegin engrave_command();
 var
    text : string;
    maxlength : integer;
 code
 {
    wait(SFB_DONE, command(&quot;say&quot;));
    text := argument;
    maxlength := 20;
    if (length(text) &gt; maxlength) {
       exec(&quot;say That text is too long!&quot;, self);
    } else {
       exec(&quot;say Engraving: &apos;&quot; + text + &quot;&apos;&quot;, self);
    }
    quit;
 } dilend

=== Argument Parsing ===
 dilbegin parse_arguments();
 var
    words : stringptr;
    first_word : string;
 code
 {
    wait(SFB_CMD, command(&quot;tell&quot;));
    words := getwords(argument);
    first_word := getword(words, 0);
    send(&quot;First word of argument: &quot; + first_word);
    quit;
 } dilend

== Usage Notes ==
* The argument variable is only meaningful when used within DIL programs triggered by commands (SFB_CMD)
* It contains everything after the command name, including spaces
* If no argument is provided, argument returns an empty string
* Commonly used to parse player input for commands like &quot;say&quot;, &quot;tell&quot;, &quot;give&quot;, etc.
* The argument can be processed using string functions like getwords(), split(), etc.
* This field is read-only and automatically set by the DIL runtime system

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Automatic validation&apos;&apos; - The field is automatically set by the DIL runtime
* &apos;&apos;&apos;Context validation&apos;&apos; - Only meaningful when accessed within command-triggered DIL programs
* &apos;&apos;&apos;Type validation&apos;&apos; - Always returns a string (may be empty)

== Related Fields ==
* [[Manual:DIL_Manual/command|command]] - The command that was executed
* [[Manual:DIL_Manual/activator|activator]] - The unit that executed the command

== Related Functions ==
* [[Manual:DIL_Manual/getwords|getwords]] - For parsing arguments into words
* [[Manual:DIL_Manual/split|split]] - For splitting arguments by delimiter
* [[Manual:DIL_Manual/length|length]] - For checking argument length

== See Also ==
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command activation wait flag
* [[Manual:DIL_Manual/wait|wait]] - Function for waiting on specific conditions
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/asctime</title>
     <ns>0</ns>
     <id>913488</id>
     <revision>
       <id>1547005</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of asctime.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= asctime =
 function: string &apos;&apos;&apos;asctime&apos;&apos;&apos;(timestamp : integer);

The &apos;&apos;&apos;asctime&apos;&apos;&apos; function converts a Unix timestamp into a human-readable date and time string.

== Description ==
Converts a Unix timestamp (seconds since epoch) into a human-readable ASCII date and time string.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| timestamp || integer || The Unix timestamp to convert, representing seconds since January 1, 1970 (epoch)
|}

== Return Value ==
Returns a string:
* &apos;&apos;&apos;string&apos;&apos;&apos; - A formatted date and time string in the format &quot;Mon Nov 18 18:49:08 1996&quot;
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If timestamp parameter is invalid

== Examples ==
=== Current Time Display ===
 dilbegin show_time();
 var
    current_time : integer;
    time_string : string;
 code
 {
    current_time := realtime;
    time_string := asctime(current_time);
    send(&quot;Current time: &quot; + time_string);
    quit;
 } dilend

=== Character Birth Information ===
 dilbegin birth_command();
 var
    pc : unitptr;
    birth_time : string;
 code
 {
    wait(SFB_CMD, command(&quot;birth&quot;) and (activator.type == UNIT_ST_PC));
    pc := activator;
    birth_time := asctime(pc.birth);
    send(&quot;Your character was created &quot; + birth_time + &quot;.&quot;);
    quit;
 } dilend

=== System Logging ===
 dilbegin system_check();
 var
    log_entry : string;
 code
 {
    log_entry := &quot;System check at &quot; + asctime(realtime);
    log(log_entry);
    send(&quot;System check logged.&quot;);
    quit;
 } dilend

=== Event Timestamping ===
 dilbegin event_log(event_name : string);
 var
    timestamp : integer;
    time_str : string;
 code
 {
    timestamp := realtime;
    time_str := asctime(timestamp);
    log(&quot;Event &apos;&quot; + event_name + &quot;&apos; occurred at &quot; + time_str);
    send(&quot;Event logged with timestamp.&quot;);
    quit;
 } dilend

== Usage Notes ==
* The function uses the standard C library ctime() function internally
* The returned string format is always: &quot;Day Month Date HH:MM:SS Year&quot;
* Commonly used with realtime() to get current time
* Useful for logging, displaying creation times, or timestamping events
* The input parameter must be an integer representing Unix timestamp
* The format is consistent and predictable for all timestamps

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Parameter validation&apos;&apos; - Ensures timestamp is a valid integer
* &apos;&apos;&apos;Range validation&apos;&apos; - Validates timestamp is within reasonable bounds
* &apos;&apos;&apos;Format validation&apos;&apos; - Ensures proper string format is returned

== Related Functions ==
* [[Manual:DIL_Manual/realtime|realtime]] - For getting the current Unix timestamp
* [[Manual:DIL_Manual/log|log]] - For logging timestamped messages
* [[Manual:DIL_Manual/mud|mud]] - For game-specific time functions

== See Also ==
* [[Manual:DIL_Manual/Unix timestamp|Unix timestamp]] - Unix epoch time system
* [[Manual:DIL_Manual/ctime|ctime]] - C library function reference
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/atoi</title>
     <ns>0</ns>
     <id>977690</id>
     <revision>
       <id>1622517</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of atoi.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= atoi =
 function: integer &apos;&apos;&apos;atoi&apos;&apos;&apos;(text : string);

The &apos;&apos;&apos;atoi&apos;&apos;&apos; function converts a string containing a numeric value into an integer.

== Description ==
Converts a string containing a numeric value into an integer. This function parses the beginning of a string to extract and return the integer value it contains.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| text || string || The string to convert to an integer. The string should contain numeric characters.
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The integer value extracted from the string
* &apos;&apos;&apos;0&apos;&apos;&apos; - If the string does not begin with a valid number

== Examples ==
=== Basic Conversion ===
 dilbegin convert_number();
 var
    text : string;
    number : integer;
 code
 {
    text := &quot;42&quot;;
    number := atoi(text);
    send(&quot;The number is: &quot; + itoa(number));
    quit;
 } dilend

=== User Input Processing ===
 dilbegin process_amount();
 var
    amount_str : string;
    amount : integer;
 code
 {
    amount_str := argument;
    amount := atoi(amount_str);
    if (amount &gt; 0) {
       send(&quot;Processing amount: &quot; + itoa(amount));
    } else {
       send(&quot;Invalid amount specified.&quot;);
    }
    quit;
 } dilend

=== Reward System ===
 dilbegin reward_check();
 var
    reward_str : string;
    reward_amount : integer;
 code
 {
    reward_str := &quot;1000&quot;;
    reward_amount := atoi(reward_str);
    if (reward_amount &gt; 500) {
       send(&quot;That&apos;s a high reward!&quot;);
    } else {
       send(&quot;Standard reward amount.&quot;);
    }
    quit;
 } dilend

=== Time Parsing ===
 dilbegin parse_time();
 var
    time_str : string;
    hours : integer;
 code
 {
    time_str := &quot;24 hours remaining&quot;;
    hours := atoi(time_str);
    send(&quot;Jail time: &quot; + itoa(hours) + &quot; hours remaining.&quot;);
    quit;
 } dilend

=== Negative Numbers ===
 dilbegin negative_conversion();
 var
    debt_str : string;
    debt : integer;
 code
 {
    debt_str := &quot;-150&quot;;
    debt := atoi(debt_str);
    send(&quot;Debt amount: &quot; + itoa(debt));
    quit;
 } dilend

== Usage Notes ==
* The function stops parsing when it encounters a non-numeric character
* If the string begins with non-numeric characters, the function returns 0
* Leading whitespace is ignored
* The function handles both positive and negative numbers
* Commonly used to convert user input or stored string values to integers
* This is the inverse of the itoa() function
* Useful for parsing command arguments, configuration values, and user input

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;String validation&apos;&apos; - Ensures text parameter is a valid string
* &apos;&apos;&apos;Numeric parsing&apos;&apos; - Stops at first non-numeric character
* &apos;&apos;&apos;Range validation&apos;&apos; - Handles integer overflow gracefully
* &apos;&apos;&apos;Sign handling&apos;&apos; - Properly processes positive and negative numbers

== Related Functions ==
* [[Manual:DIL_Manual/itoa|itoa]] - For converting integers to strings
* [[Manual:DIL_Manual/getwords|getwords]] - For parsing strings into components
* [[Manual:DIL_Manual/strcmp|strcmp]] - For string comparison

== See Also ==
* [[Manual:DIL_Manual/string|string]] - String data type
* [[Manual:DIL_Manual/integer|integer]] - Integer data type
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/attack_spell</title>
     <ns>0</ns>
     <id>636819</id>
     <revision>
       <id>1495949</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of attack_spell.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= attack_spell =
 function: integer &apos;&apos;&apos;attack_spell&apos;&apos;&apos;(spell_index : integer, caster : unitptr, medium : unitptr, target : unitptr, bonus : integer, effect : string);

The &apos;&apos;&apos;attack_spell&apos;&apos;&apos; function casts an offensive spell from a caster to a target.

== Description ==
Casts an offensive spell from a caster to a target. This is a low-level function used for spell development and should only be used by developers who understand the spell system internals.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| spell_index || integer || The spell index to cast (SPL_XXX constants)
|-
| caster || unitptr || The unit casting the spell
|-
| medium || unitptr || The medium through which the spell is cast (may be same as caster)
|-
| target || unitptr || The target of the spell
|-
| bonus || integer || Bonus or penalty to apply to the spell (positive for advantage, negative for penalty)
|-
| effect || string || Optional effect string for the spell (can be null or empty)
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The amount of damage dealt by the spell
* &apos;&apos;&apos;0&apos;&apos;&apos; - If the spell fails or deals no damage
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If parameters are invalid

== Examples ==
=== Basic Spell Attack ===
 dilbegin lava_attack();
 var
    caster : unitptr;
    target : unitptr;
    damage : integer;
 code
 {
    caster := self;
    target := activator;
    damage := attack_spell(SPL_LAVA_1, caster, caster, target, 0, &quot;&quot;);
    send(&quot;The lava spell deals &quot; + itoa(damage) + &quot; damage!&quot;);
    quit;
 } dilend

=== Enhanced Spell Attack ===
 dilbegin enhanced_fireball();
 var
    spell_damage : integer;
 code
 {
    spell_damage := attack_spell(SPL_FIREBALL, self, self, opponent, 5, &quot;burning&quot;);
    if (spell_damage &gt; 0) {
       send(&quot;Your enhanced fireball deals &quot; + itoa(spell_damage) + &quot; damage!&quot;);
    } else {
       send(&quot;Your fireball fails to hit.&quot;);
    }
    quit;
 } dilend

=== Conditional Spell Casting ===
 dilbegin conditional_spell(target : unitptr);
 var
    damage : integer;
 code
 {
    if (target != null and target.type == UNIT_ST_PC) {
       damage := attack_spell(SPL_MAGIC_MISSILE, self, self, target, 0, &quot;magical&quot;);
       send(&quot;Magic missile strikes &quot; + target.name + &quot; for &quot; + itoa(damage) + &quot; damage!&quot;);
    } else {
       send(&quot;No valid target for spell.&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* This is an advanced function for spell development
* Should only be used by developers who understand the spell system
* Requires proper spell index constants (SPL_XXX)
* The medium parameter allows for spell casting through objects or other units
* Bonus parameter can modify spell effectiveness
* Effect parameter is optional and can be null or empty string
* Returns the actual damage dealt by the spell
* Use with caution - improper use can cause game balance issues

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Parameter validation&apos;&apos; - Ensures all parameters are valid types
* &apos;&apos;&apos;Spell validation&apos;&apos; - Checks that spell_index is within valid range
* &apos;&apos;&apos;Target validation&apos;&apos; - Ensures target is a valid unit
* &apos;&apos;&apos;Caster validation&apos;&apos; - Ensures caster is a valid unit

== Related Functions ==
* [[Manual:DIL_Manual/cast_spell|cast_spell]] - For standard spell casting
* [[Manual:DIL_Manual/spellinfo|spellinfo]] - For getting spell information
* [[Manual:DIL_Manual/spellindex|spellindex]] - For spell index constants

== See Also ==
* [[Manual:DIL_Manual/SPL_*|SPL_*]] - Spell index constants
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/attack_type</title>
     <ns>0</ns>
     <id>795716</id>
     <revision>
       <id>1805863</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of attack_type.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= attack_type =
 field: integer &apos;&apos;&apos;attack_type&apos;&apos;&apos; (Read-write)

The &apos;&apos;&apos;attack_type&apos;&apos;&apos; field determines the non-weapon attack type of a character unit.

== Description ==
Returns or sets the non-weapon attack type of a character unit. This property determines what type of unarmed combat the character uses.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.attack_type || integer || The current attack type of the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
=== Check Current Attack Type ===
 dilbegin check_attack_type();
 var
    current_attack : integer;
 code
 {
    current_attack := self.attack_type;
    send(&quot;Your current attack type is &quot; + weapon_name(current_attack) + &quot;.&quot;);
    quit;
 } dilend

=== Set Attack Type ===
 dilbegin set_attack_type(new_type : integer);
 code
 {
    if (new_type &gt;= WPN_FIST and new_type &lt;= WPN_ELBOW) {
       self.attack_type := new_type;
       send(&quot;Attack type set to &quot; + weapon_name(new_type) + &quot;.&quot;);
    } else {
       send(&quot;Invalid attack type.&quot;);
    }
    quit;
 } dilend

=== Attack Type Menu ===
 dilbegin attack_menu();
 var
    choice : string;
 code
 {
    send(&quot;Available attack types:&quot;);
    send(&quot;1. Fist&quot;);
    send(&quot;2. Kick&quot;);
    send(&quot;3. Knee&quot;);
    send(&quot;4. Elbow&quot;);
    
    pause;
    choice := argument;
    
    if (choice == &quot;1&quot;) {
       self.attack_type := WPN_FIST;
       send(&quot;Attack type set to fist.&quot;);
    } else if (choice == &quot;2&quot;) {
       self.attack_type := WPN_KICK;
       send(&quot;Attack type set to kick.&quot;);
    } else if (choice == &quot;3&quot;) {
       self.attack_type := WPN_KNEE;
       send(&quot;Attack type set to knee.&quot;);
    } else if (choice == &quot;4&quot;) {
       self.attack_type := WPN_ELBOW;
       send(&quot;Attack type set to elbow.&quot;);
    } else {
       send(&quot;Invalid choice.&quot;);
    }
    quit;
 } dilend

=== Combat Style Change ===
 dilbegin combat_style(style : string);
 code
 {
    if (style == &quot;martial&quot;) {
       self.attack_type := WPN_KICK;
       send(&quot;You adopt a martial arts stance.&quot;);
    } else if (style == &quot;brawler&quot;) {
       self.attack_type := WPN_FIST;
       send(&quot;You adopt a brawler&apos;s stance.&quot;);
    } else {
       send(&quot;Unknown combat style.&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* This is a read-write property that can be modified
* Attack types correspond to weapon type constants (WPN_FIST, WPN_KICK, etc.)
* Only applies to character units (PCs and NPCs)
* Used for unarmed combat when no weapon is equipped
* The attack_type affects combat animations and damage calculations
* Common attack types include: fist, kick, knee, elbow
* Changes to attack type take effect immediately in combat

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos; - Ensures unit is a character type
* &apos;&apos;&apos;Range validation&apos;&apos; - Validates attack type is within valid range
* &apos;&apos;&apos;Type validation&apos;&apos; - Ensures value is an integer

== Related Fields ==
* [[Manual:DIL_Manual/weapon_name|weapon_name]] - For getting the name of an attack type
* [[Manual:DIL_Manual/weapon_info|weapon_info]] - For detailed weapon/attack type information
* [[Manual:DIL_Manual/position|position]] - For character combat position

== See Also ==
* [[Manual:DIL_Manual/WPN_*|WPN_*]] - Weapon type constants
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/baseweight</title>
     <ns>0</ns>
     <id>694842</id>
     <revision>
       <id>1069500</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of baseweight.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= baseweight =
 function: integer &apos;&apos;&apos;baseweight&apos;&apos;&apos;(unit : unitptr);

The &apos;&apos;&apos;baseweight&apos;&apos;&apos; function returns the base weight of a unit without contents.

== Description ==
Returns the base weight of a unit. This represents the empty weight of a unit without any contents or additional weight.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit whose base weight is being retrieved
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The base weight of the unit in grams
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If unit parameter is invalid

== Examples ==
=== Weight Comparison ===
 dilbegin compare_weights();
 var
    base_wt : integer;
    current_wt : integer;
 code
 {
    base_wt := baseweight(self);
    current_wt := weight(self);
    send(&quot;Base weight: &quot; + itoa(base_wt) + &quot;g&quot;);
    send(&quot;Current weight: &quot; + itoa(current_wt) + &quot;g&quot;);
    send(&quot;Contents weight: &quot; + itoa(current_wt - base_wt) + &quot;g&quot;);
    quit;
 } dilend

=== Item Creation ===
 dilbegin create_item_weight();
 var
    new_item : unitptr;
    target_weight : integer;
 code
 {
    target_weight := atoi(argument);
    if (target_weight &gt; 0) {
       new_item := load(&quot;generic_item&quot;);
       set_weight_base(new_item, target_weight);
       send(&quot;Item created with base weight: &quot; + itoa(target_weight) + &quot;g&quot;);
    } else {
       send(&quot;Invalid weight specified.&quot;);
    }
    quit;
 } dilend

=== Corpse Processing ===
 dilbegin decapitation_example();
 var
    corpse : unitptr;
    head : unitptr;
    head_weight : integer;
 code
 {
    corpse := medium;
    if (corpse != null and corpse.type == UNIT_ST_OBJ) {
       head := load(&quot;head@death&quot;);
       head_weight := baseweight(corpse) / 70;
       set_weight_base(head, head_weight);
       
       if (head.baseweight &gt; 100) {
          set_weight_base(head, 100);
       }
       if (head.baseweight &lt; 1) {
          set_weight_base(head, 1);
       }
       send(&quot;Head created with appropriate weight.&quot;);
    } else {
       send(&quot;No valid corpse found.&quot;);
    }
    quit;
 } dilend

=== Weight Validation ===
 dilbegin check_weight_limits(item : unitptr);
 var
    item_base : integer;
 code
 {
    if (item != null) {
       item_base := baseweight(item);
       if (item_base &gt; 50000) {
          send(&quot;Item is extremely heavy (&quot; + itoa(item_base) + &quot;g)&quot;);
       } else if (item_base &gt; 10000) {
          send(&quot;Item is very heavy (&quot; + itoa(item_base) + &quot;g)&quot;);
       } else if (item_base &gt; 5000) {
          send(&quot;Item is heavy (&quot; + itoa(item_base) + &quot;g)&quot;);
       } else {
          send(&quot;Item weight is reasonable (&quot; + itoa(item_base) + &quot;g)&quot;);
       }
    } else {
       send(&quot;No item specified.&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* This is a read-only property that returns the empty weight of a unit
* Base weight is different from current weight (which includes contents)
* Used in calculations for item creation, weight limits, and encumbrance
* Base weight is typically used with set_weight_base() function
* Weight values are in grams
* Commonly used in corpse processing, item creation, and equipment systems
* Base weight remains constant throughout the unit&apos;s lifetime

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid type
* &apos;&apos;&apos;Range validation&apos;&apos;&apos; - Validates weight is within reasonable bounds

== Related Functions ==
* [[Manual:DIL_Manual/weight|weight]] - For getting the current weight including contents
* [[Manual:DIL_Manual/set_weight_base|set_weight_base]] - For setting the base weight of a unit
* [[Manual:DIL_Manual/capacity|capacity]] - For checking the weight capacity of containers

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/grams|grams]] - Weight unit system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/beginedit</title>
     <ns>0</ns>
     <id>1130739</id>
     <revision>
       <id>1754964</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of beginedit.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= beginedit =
 function: &apos;&apos;&apos;beginedit&apos;&apos;&apos;(unit : unitptr);

The &apos;&apos;&apos;beginedit&apos;&apos;&apos; function puts a player character into editing mode.

== Description ==
Puts a player character into editing mode. This function enables the player to use text editing commands and sets up the editing state.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The player character to put into editing mode
|}

== Return Value ==
This function does not return a value. When the player finishes editing, an SFB_EDIT message is sent to continue the DIL program.

== Examples ==
=== Description Editing ===
 dilbegin edit_description();
 var
    formatted_text : string;
 code
 {
    beginedit(self);
    wait(SFB_EDIT, self == activator);
    formatted_text := textformat(argument);
    addextra(self, &quot;general&quot;, formatted_text);
    send(&quot;Description updated.&quot;);
    quit;
 } dilend

=== Board Message Editing ===
 dilbegin board_edit();
 var
    board : unitptr;
    message : string;
 code
 {
    board := findunit(self.outside, &quot;board&quot;, FIND_UNIT_SURRO, null);
    if (board != null and board.type == UNIT_ST_OBJ and board.objecttype == ITEM_BOARD) {
       beginedit(self);
       wait(SFB_EDIT, self == activator);
       message := argument;
       // Add message to board logic here
       send(&quot;Message posted to board.&quot;);
    } else {
       send(&quot;No board found here.&quot;);
    }
    quit;
 } dilend

=== Mail Composition ===
 dilbegin compose_mail();
 var
    recipient : unitptr;
    mail_text : string;
 code
 {
    recipient := findunit(self.outside, argument, FIND_UNIT_SURRO, null);
    if (recipient != null and recipient.type == UNIT_ST_PC) {
       beginedit(self);
       wait(SFB_EDIT, self == activator);
       mail_text := argument;
       // Send mail logic here
       send(&quot;Mail sent to &quot; + recipient.name + &quot;.&quot;);
    } else {
       send(&quot;No recipient found.&quot;);
    }
    quit;
 } dilend

=== Document Creation ===
 dilbegin create_document();
 var
    doc_title : string;
 code
 {
    send(&quot;Enter document title:&quot;);
    pause;
    doc_title := argument;
    
    beginedit(self);
    wait(SFB_EDIT, self == activator);
    // Create document with title and content
    send(&quot;Document &apos;&quot; + doc_title + &quot;&apos; created.&quot;);
    quit;
 } dilend

== Usage Notes ==
* Only works on player characters (PC units)
* Player must have a descriptor to enter editing mode
* While in editing mode, the player&apos;s &apos;editing&apos; flag is set to true
* When editing is complete, an SFB_EDIT trigger is sent
* Use killedit() to force exit from editing mode if needed
* Commonly used for board editing, description editing, and text input
* The player can use standard editor commands while in edit mode
* The edited text is available in the argument variable after editing completes

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a valid player character
* &apos;&apos;&apos;Descriptor validation&apos;&apos;&apos; - Checks that player has an active descriptor
* &apos;&apos;&apos;State validation&apos;&apos;&apos; - Ensures player is not already in editing mode

== Related Functions ==
* [[Manual:DIL_Manual/killedit|killedit]] - For forcing exit from edit mode
* [[Manual:DIL_Manual/textformat|textformat]] - For formatting text input
* [[Manual:DIL_Manual/SFB_EDIT|SFB_EDIT]] - For editing trigger flag

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/descriptor|descriptor]] - Player connection descriptor
* [[Manual:DIL_Manual/argument|argument]] - Edited text content
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/birth</title>
     <ns>0</ns>
     <id>428183</id>
     <revision>
       <id>1666837</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of birth.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= birth =
 function: integer &apos;&apos;&apos;birth&apos;&apos;&apos;(unit : unitptr);

The &apos;&apos;&apos;birth&apos;&apos;&apos; function returns the birth time of a player character.

== Description ==
Returns the birth time of a player character. This represents when the character was created in the game.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The player character whose birth time is being retrieved
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The Unix timestamp when the character was created
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If unit parameter is invalid or not a player

== Examples ==
=== Character Age ===
 dilbegin check_age();
 var
    birth_time : integer;
    age_days : integer;
 code
 {
    birth_time := birth(self);
    age_days := (realtime - birth_time) / (60 * 60 * 24);
    send(&quot;You are &quot; + itoa(age_days) + &quot; days old.&quot;);
    quit;
 } dilend

=== Character Information ===
 dilbegin character_info();
 var
    creation_time : integer;
    creation_date : string;
 code
 {
    creation_time := birth(activator);
    creation_date := asctime(creation_time);
    send(&quot;Character created: &quot; + creation_date);
    quit;
 } dilend

=== Birthday Check ===
 dilbegin birthday_check();
 var
    char_birth : integer;
    current_time : integer;
    years_old : integer;
 code
 {
    char_birth := birth(self);
    current_time := realtime;
    years_old := (current_time - char_birth) / (60 * 60 * 24 * 365);
    send(&quot;You are &quot; + itoa(years_old) + &quot; years old.&quot;);
    quit;
 } dilend

=== Account Age Verification ===
 dilbegin verify_account_age(minimum_days : integer);
 var
    player_birth : integer;
    account_age : integer;
 code
 {
    player_birth := birth(activator);
    account_age := (realtime - player_birth) / (60 * 60 * 24);
    
    if (account_age &gt;= minimum_days) {
       send(&quot;Account is old enough: &quot; + itoa(account_age) + &quot; days.&quot;);
    } else {
       send(&quot;Account is too young: &quot; + itoa(account_age) + &quot; days (minimum: &quot; + itoa(minimum_days) + &quot;)&quot;);
    }
    quit;
 } dilend

=== Veteran Status ===
 dilbegin check_veteran_status();
 var
    char_birth : integer;
    days_old : integer;
 code
 {
    char_birth := birth(self);
    days_old := (realtime - char_birth) / (60 * 60 * 24);
    
    if (days_old &gt;= 365) {
       send(&quot;You are a veteran player (&quot; + itoa(days_old) + &quot; days old)!&quot;);
    } else if (days_old &gt;= 30) {
       send(&quot;You are an experienced player (&quot; + itoa(days_old) + &quot; days old).&quot;);
    } else {
       send(&quot;You are a new player (&quot; + itoa(days_old) + &quot; days old).&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* This is a read-only property that returns the character creation time
* The value is a Unix timestamp (seconds since epoch)
* Commonly used with asctime() to convert to readable format
* Used for age calculations, character history, and account management
* Birth time is set when a character is first created and never changes
* The timestamp can be used for various time-based calculations
* Only works on player characters (UNIT_ST_PC), not NPCs

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a player character
* &apos;&apos;&apos;Range validation&apos;&apos;&apos; - Validates timestamp is within reasonable bounds

== Related Functions ==
* [[Manual:DIL_Manual/asctime|asctime]] - For converting timestamp to readable date format
* [[Manual:DIL_Manual/realtime|realtime]] - For getting the current time
* [[Manual:DIL_Manual/age calculations|age calculations]] - For determining character age from birth time

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/Unix timestamp|Unix timestamp]] - Unix epoch time system
* [[Manual:DIL_Manual/account management|account management]] - Player account systems
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/block</title>
     <ns>0</ns>
     <id>727653</id>
     <revision>
       <id>1701188</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of block.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= block =
 function: &apos;&apos;&apos;block&apos;&apos;&apos;();

The &apos;&apos;&apos;block&apos;&apos;&apos; function prevents commands from being processed by the interpreter.

== Description ==
Blocks commands issued by a player or mobile. This function prevents commands from being processed by the interpreter and is useful for creating special command handlers.

== Parameters ==
This function takes no parameters.

== Return Value ==
This function does not return a value.

== Examples ==
=== Basic Command Blocking ===
 dilbegin command_interceptor();
 code
 {
    wait(SFB_CMD, command(&quot;test&quot;));
    block;
    send(&quot;The &apos;test&apos; command has been blocked.&quot;);
    quit;
 } dilend

=== Special Command Handler ===
 dilbegin special_handler();
 var
    cmd : string;
 code
 {
    wait(SFB_CMD, TRUE);
    cmd := argument;
    
    if (cmd == &quot;special&quot;) {
       block;
       // Handle special command logic here
       send(&quot;Special command processed.&quot;);
    } else {
       // Let normal command processing continue
       send(&quot;Normal command: &quot; + cmd);
    }
    quit;
 } dilend

=== Command Restriction ===
 dilbegin block_example();
 var
    blocked_cmd : string;
 code
 {
    wait(SFB_CMD, TRUE);
    blocked_cmd := argument;
    
    if (blocked_cmd != &quot;&quot;) {
       block;
       exec(&quot;say I&apos;m not allowed to use that command.&quot;, self);
       exec(&quot;emote looks confused.&quot;, self);
    } else {
       send(&quot;No command to block.&quot;);
    }
    quit;
 } dilend

=== Command Validation ===
 dilbegin validate_command();
 var
    player_input : string;
 code
 {
    wait(SFB_CMD, TRUE);
    player_input := argument;
    
    if (player_input == &quot;forbidden&quot;) {
       block;
       send(&quot;That command is forbidden.&quot;);
    } else if (player_input == &quot;restricted&quot;) {
       block;
       send(&quot;That command is restricted.&quot;);
    } else {
       send(&quot;Command accepted: &quot; + player_input);
    }
    quit;
 } dilend

== Usage Notes ==
* The block function prevents the current command from being processed
* When blocked, the command is intercepted and not passed to the normal interpreter
* Useful for creating custom command handlers or restricting certain commands
* Can be used to intercept commands for special processing
* Often used with SFB_CMD triggers to handle commands before normal processing
* The blocking is temporary - subsequent commands will process normally unless blocked again
* Commonly used for command validation, special effects, or command restrictions

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Context validation&apos;&apos;&apos; - Only works within command-triggered DIL programs
* &apos;&apos;&apos;State validation&apos;&apos;&apos; - Ensures proper command context
* &apos;&apos;&apos;Runtime validation&apos;&apos;&apos; - Validates command processing state

== Related Functions ==
* [[Manual:DIL_Manual/exec|exec]] - For executing alternative commands
* [[Manual:DIL_Manual/command|command]] - For checking what command was issued
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - For triggering on commands

== See Also ==
* [[Manual:DIL_Manual/command|command]] - Command field
* [[Manual:DIL_Manual/argument|argument]] - Command argument field
* [[Manual:DIL_Manual/interpreter|interpreter]] - Command processing system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/break</title>
     <ns>0</ns>
     <id>1220412</id>
     <revision>
       <id>972381</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of break.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= break =
 statement: &apos;&apos;&apos;break&apos;&apos;&apos;;

The break statement terminates execution of the innermost loop and transfers control to the statement immediately following the loop.

== Description ==
The &apos;&apos;&apos;break&apos;&apos;&apos; statement is used to exit prematurely from any loop construct in DIL, including &apos;&apos;&apos;while&apos;&apos;&apos; loops and &apos;&apos;&apos;foreach&apos;&apos;&apos; loops. When executed, it immediately terminates the current loop iteration and transfers program flow to the first statement following the loop body.

== Usage Notes ==
* The &apos;&apos;&apos;break&apos;&apos;&apos; statement can only be used within loop constructs
* Using &apos;&apos;&apos;break&apos;&apos;&apos; outside of a loop will result in a compilation error: &quot;Using break outside loop&quot;
* When multiple loops are nested, &apos;&apos;&apos;break&apos;&apos;&apos; only exits the innermost loop
* The statement is particularly useful for conditional loop termination based on runtime conditions

== Error Handling ==
If the &apos;&apos;&apos;break&apos;&apos;&apos; statement is used outside of any loop construct, the DIL compiler will generate an error and the script will fail to compile.

== Examples ==
 dilbegin check_position();
 code
 {
   while (self.inside) {
     if (self.position &amp; POSITION_SLEEPING)
       break;
     exec(&quot;say I am awake and active&quot;, self);
     pause;
   }
 } dilend

 dilbegin find_injured_player();
 code
 {
   foreach (UNIT_ST_PC, target) {
     if (target.hp &lt; target.max_hp / 2) {
       act(&quot;You found an injured player!&quot;, A_ALWAYS, self, null, target, TO_CHAR);
       break;
     }
   }
 } dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/continue|continue]] - Skip to next iteration of a loop
* [[Manual:DIL_Manual/while|while]] - Loop construct that can be controlled with break
* [[Manual:DIL_Manual/foreach|foreach]] - Loop construct that can be controlled with break

== See Also ==
* [[Manual:DIL_Manual/continue|continue]]
* [[Manual:DIL_Manual/while|while]]
* [[Manual:DIL_Manual/foreach|foreach]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/bright</title>
     <ns>0</ns>
     <id>314479</id>
     <revision>
       <id>1315688</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of bright.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= bright =
 function: integer &apos;&apos;&apos;bright&apos;&apos;&apos;(unit : unitptr);

The &apos;&apos;&apos;bright&apos;&apos;&apos; function returns the light output value of a unit.

== Description ==
Returns the light output value of a unit. This function gets the brightness level for light-producing units like torches or lanterns.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit whose brightness value is being retrieved
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The light output value of the unit
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If unit parameter is invalid

== Examples ==
=== Check Torch Brightness ===
 dilbegin check_torch();
 var
    torch_brightness : integer;
 code
 {
    torch_brightness := bright(self);
    send(&quot;Torch brightness: &quot; + itoa(torch_brightness));
    quit;
 } dilend

=== Adjust Light Source ===
 dilbegin adjust_light();
 var
    light_obj : unitptr;
 code
 {
    light_obj := findunit(self.outside, &quot;torch&quot;, FIND_UNIT_SURRO, null);
    if (light_obj != null and light_obj.type == UNIT_ST_OBJ and light_obj.objecttype == ITEM_LIGHT) {
       setbright(light_obj, 5);
       send(&quot;You adjust the torch to brightness 5.&quot;);
    } else {
       send(&quot;No torch found here.&quot;);
    }
    quit;
 } dilend

=== Light Level Check ===
 dilbegin check_room_light();
 var
    current_bright : integer;
 code
 {
    current_bright := bright(self);
    if (current_bright &gt; 0) {
       send(&quot;The room is illuminated by your light.&quot;);
    } else {
       send(&quot;The light source is not providing illumination.&quot;);
    }
    quit;
 } dilend

=== Multiple Light Sources ===
 dilbegin count_lights();
 var
    total_brightness : integer;
    item : unitptr;
 code
 {
    total_brightness := 0;
    
    // Check all light sources in inventory
    foreach (item in self.inside) {
       if (item.type == UNIT_ST_OBJ and item.objecttype == ITEM_LIGHT) {
          total_brightness := total_brightness + bright(item);
       }
    }
    
    send(&quot;Total light output: &quot; + itoa(total_brightness));
    quit;
 } dilend

=== Magical Light ===
 dilbegin magical_light();
 var
    light_level : integer;
 code
 {
    light_level := bright(self);
    if (light_level &gt;= 10) {
       send(&quot;Your light source shines brilliantly!&quot;);
    } else if (light_level &gt;= 5) {
       send(&quot;Your light source glows brightly.&quot;);
    } else if (light_level &gt; 0) {
       send(&quot;Your light source glows dimly.&quot;);
    } else {
       send(&quot;Your light source is not providing illumination.&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* This is a read-only property that returns light output value
* Only applies to units that can produce light (lights, torches, etc.)
* The brightness value affects how much light the unit provides to its surroundings
* Higher brightness values provide more illumination
* Commonly used with light-producing objects and room lighting calculations
* The function is read-only - use setbright() to modify brightness
* Brightness values are typically in range 0-20 for most light sources

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid type
* &apos;&apos;&apos;Property validation&apos;&apos;&apos; - Validates that unit has brightness property

== Related Functions ==
* [[Manual:DIL_Manual/setbright|setbright]] - For setting the brightness of a unit
* [[Manual:DIL_Manual/islight|islight]] - For checking if a unit produces light
* [[Manual:DIL_Manual/light|light]] - For getting current light level of a room

== See Also ==
* [[Manual:DIL_Manual/ITEM_LIGHT|ITEM_LIGHT]] - Light object type constant
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/illumination|illumination]] - Room lighting system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/can_carry</title>
     <ns>0</ns>
     <id>735419</id>
     <revision>
       <id>1807811</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of can_carry.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= can_carry =
function: [integer] &apos;&apos;&apos;can_carry&apos;&apos;&apos;(ch : unitptr, u : unitptr, n : integer);

Checks if a character can carry a specific number of items, testing both inventory count limits and weight constraints.

== Description ==
The &apos;&apos;&apos;can_carry&apos;&apos;&apos; function determines whether a character can carry a specified quantity of a particular item. It performs two separate checks: first testing if the character has enough inventory slots available, then checking if the additional weight would exceed the character&apos;s maximum carrying capacity. This function is commonly used for item pickup validation and inventory management before actually transferring items to a character.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| ch || unitptr || The character to check carrying capacity for (must be a character unit)
|-
| u || unitptr || The item to check if the character can carry (any unit type)
|-
| n || integer || The number of copies of the item to check (must be 1 or greater)
|}

== Return Value ==
: integer
: Returns a status code indicating the result of the carry check:
:* 0 - Character can carry the specified quantity of items
:* 1 - Cannot carry due to inventory count limit (hands are full)
:* 2 - Cannot carry due to weight limit (too heavy)

== Examples ==
 dilbegin item_pickup_validation();
 var
  sword : unitptr;
  result : integer;
 code
 {
 :start:
 sword := findunit(self.outside, &quot;sword&quot;, FIND_UNIT_SURRO, null);
 if (sword == null)
 {
   sendtext(&quot;No sword found here.&lt;br/&gt;&quot;, self);
   goto done;
 }
 
 result := can_carry(activator, sword, 1);
 
 if (result == 1)
   exec(&quot;say Your hands are full!&quot;, self);
 else if (result == 2)
   exec(&quot;say You can&apos;t carry that much weight.&quot;, self);
 else
   exec(&quot;give &quot; + sword.name + &quot; to &quot; + activator.name, self);
 
 :done:
 } dilend

== Usage Notes ==
* The function checks count limits first, then weight limits
* Count limit is calculated as: 10 + (character dexterity / 10) items
* Weight limit is calculated as: 50 + MAX(50, base weight / 2) + strength * 2
* Only non-equipped items are counted toward the inventory limit
* Money items are excluded from the count calculation

== Error Handling ==
The function will fail with DILV_FAIL if:
* The first parameter (ch) is not a character unit or is null
* The second parameter (u) is null
* The third parameter (n) is less than 1

Type errors will occur if:
* Parameter 1 or 2 are not unitptr types
* Parameter 3 is not an integer type

== Related Functions/Fields ==
* [[Manual:DIL_Manual/capacity|capacity]] - Gets the maximum weight a unit can carry
* [[Manual:DIL_Manual/weight|weight]] - Gets the current weight of a unit
* [[Manual:DIL_Manual/fits|fits]] - Checks if an item fits in a specific equipment slot
* [[Manual:DIL_Manual/manipulate|manipulate]] - Field that controls item interaction permissions

== See Also ==
* [[Manual:DIL_Manual/char_can_carry_n|char_can_carry_n]] - Internal count limit function
* [[Manual:DIL_Manual/char_can_carry_w|char_can_carry_w]] - Internal weight limit function
* [[Manual:DIL_Manual/findunit|findunit]] - For locating items to check
* [[Manual:DIL_Manual/load|load]] - For creating new items to test carrying capacity</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/capacity</title>
     <ns>0</ns>
     <id>1172815</id>
     <revision>
       <id>1089785</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of capacity.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= capacity =
 function: integer &apos;&apos;&apos;capacity&apos;&apos;&apos;(unit : unitptr);

The &apos;&apos;&apos;capacity&apos;&apos;&apos; function returns the maximum weight capacity of a unit.

== Description ==
Returns the maximum weight capacity of a unit. This function determines how much weight a unit can hold (e.g. a chest) or carry (e.g. a character - based on its attributes).

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit whose capacity is being retrieved
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The maximum weight capacity of the unit
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If unit parameter is invalid

== Examples ==
=== Basic Capacity Check ===
 dilbegin check_capacity();
 var
    max_capacity : integer;
 code
 {
    max_capacity := capacity(self);
    send(&quot;Your maximum capacity is &quot; + itoa(max_capacity) + &quot; units.&quot;);
    quit;
 } dilend

=== Container Capacity ===
 dilbegin check_chest();
 var
    chest : unitptr;
    chest_capacity : integer;
 code
 {
    chest := findunit(self.outside, &quot;chest&quot;, FIND_UNIT_SURRO, null);
    if (chest != null and chest.type == UNIT_ST_OBJ) {
       chest_capacity := capacity(chest);
       send(&quot;Chest capacity: &quot; + itoa(chest_capacity) + &quot; units.&quot;);
    } else {
       send(&quot;No chest found here.&quot;);
    }
    quit;
 } dilend

=== Weight Comparison ===
 dilbegin weight_vs_capacity();
 var
    current_weight : integer;
    max_capacity : integer;
 code
 {
    current_weight := weight(self);
    max_capacity := capacity(self);
    
    send(&quot;Current weight: &quot; + itoa(current_weight) + &quot;/&quot; + itoa(max_capacity));
    if (current_weight &gt;= max_capacity) {
       send(&quot;You are carrying your maximum weight!&quot;);
    } else {
       send(&quot;You have &quot; + itoa(max_capacity - current_weight) + &quot; units of capacity remaining.&quot;);
    }
    quit;
 } dilend

=== Encumbrance Check ===
 dilbegin check_encumbrance();
 var
    carry_capacity : integer;
    current_load : integer;
    percentage : integer;
 code
 {
    carry_capacity := capacity(self);
    current_load := weight(self);
    percentage := (current_load * 100) / carry_capacity;
    
    if (percentage &gt;= 100) {
       send(&quot;You are completely overloaded!&quot;);
    } else if (percentage &gt;= 75) {
       send(&quot;You are heavily encumbered.&quot;);
    } else if (percentage &gt;= 50) {
       send(&quot;You are moderately encumbered.&quot;);
    } else {
       send(&quot;You are lightly encumbered.&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* This is a read-write property that can be modified
* For characters, capacity is based on the character&apos;s strength and other attributes
* The value represents the maximum weight a unit can contain
* Commonly used for chests, inventory management, encumbrance checks, and weight calculations
* Higher capacity values allow units to contain more and heavier items
* The function is read-only - use set() to modify capacity if needed
* Capacity is typically measured in the same units as weight (grams)

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid type
* &apos;&apos;&apos;Range validation&apos;&apos;&apos; - Validates capacity is within reasonable bounds

== Related Functions ==
* [[Manual:DIL_Manual/weight|weight]] - For getting the current weight of a unit
* [[Manual:DIL_Manual/can_carry|can_carry]] - For checking if a character can carry specific items
* [[Manual:DIL_Manual/baseweight|baseweight]] - For getting the base weight of a unit

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/encumbrance|encumbrance]] - Weight and carrying system
* [[Manual:DIL_Manual/strength|strength]] - Character attribute affecting capacity
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/cast_spell</title>
     <ns>0</ns>
     <id>1080639</id>
     <revision>
       <id>1193267</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of cast_spell.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= cast_spell =
 function: integer &apos;&apos;&apos;cast_spell&apos;&apos;&apos;(spell_index : integer, caster : unitptr, medium : unitptr, target : unitptr, bonus : integer, effect : string);

The &apos;&apos;&apos;cast_spell&apos;&apos;&apos; function casts a spell at a target unit.

== Description ==
Casts a spell at a target unit. This is a low-level function for spell development and should only be used by developers who understand the spell system.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| spell_index || integer || The spell index to cast (SPL_XXX constants)
|-
| caster || unitptr || The unit casting the spell
|-
| medium || unitptr || The medium through which the spell is cast (may be same as caster)
|-
| target || unitptr || The target of the spell
|-
| bonus || integer || Bonus or penalty to apply to the spell (positive for advantage, negative for penalty)
|-
| effect || string || Optional effect string for the spell (can be null or empty)
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - The amount of damage dealt by the spell
* &apos;&apos;&apos;0&apos;&apos;&apos; - If the spell fails or deals no damage
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If parameters are invalid

== Examples ==
=== Basic Spell Casting ===
 dilbegin fireball_example();
 var
    damage : integer;
 code
 {
    damage := cast_spell(SPL_FIREBALL, self, self, 0, &quot;&quot;);
    send(&quot;Your fireball deals &quot; + itoa(damage) + &quot; damage.&quot;);
    quit;
 } dilend

=== Enhanced Spell ===
 dilbegin enhanced_spell();
 var
    spell_damage : integer;
 code
 {
    spell_damage := cast_spell(SPL_LIGHTNING, self, self, 5, &quot;enhanced effect&quot;);
    send(&quot;Your enhanced lightning deals &quot; + itoa(spell_damage) + &quot; damage.&quot;);
    quit;
 } dilend

=== Targeted Spell ===
 dilbegin targeted_spell(target : unitptr);
 var
    spell_damage : integer;
 code
 {
    if (target != null) {
       spell_damage := cast_spell(SPL_MAGIC_MISSILE, self, self, target, 0, &quot;magical&quot;);
       send(&quot;Magic missile strikes &quot; + target.name + &quot; for &quot; + itoa(spell_damage) + &quot; damage!&quot;);
    } else {
       send(&quot;No valid target for spell.&quot;);
    }
    quit;
 } dilend

=== Conditional Spell Casting ===
 dilbegin conditional_cast();
 var
    spell_power : integer;
 code
 {
    spell_power := cast_spell(SPL_HEAL, self, self, activator, 0, &quot;&quot;);
    
    if (spell_power &gt; 0) {
       send(&quot;Your heal spell was effective!&quot;);
    } else {
       send(&quot;Your heal spell failed.&quot;);
    }
    quit;
 } dilend

=== Spell with Medium ===
 dilbegin spell_through_wand();
 var
    wand : unitptr;
    damage : integer;
 code
 {
    wand := findunit(self.inside, &quot;wand&quot;, FIND_UNIT_INVEN, null);
    if (wand != null) {
       damage := cast_spell(SPL_FIREBALL, self, wand, activator, 0, &quot;&quot;);
       send(&quot;Your wand casts fireball for &quot; + itoa(damage) + &quot; damage!&quot;);
    } else {
       send(&quot;No wand found.&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* This is an advanced function for spell development
* Should only be used by developers who understand the spell system
* Requires proper spell index constants (SPL_XXX)
* The bonus parameter can modify spell effectiveness
* Effect parameter is optional and can be null or empty string
* Returns the actual damage dealt by the spell
* Commonly used for creating custom spells or spell modifications
* The function handles spell casting mechanics including damage calculation

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Parameter validation&apos;&apos;&apos; - Ensures all parameters are valid types
* &apos;&apos;&apos;Spell validation&apos;&apos;&apos; - Checks that spell_index is within valid range
* &apos;&apos;&apos;Target validation&apos;&apos;&apos; - Ensures target is a valid unit
* &apos;&apos;&apos;Caster validation&apos;&apos;&apos; - Ensures caster is a valid unit

== Related Functions ==
* [[Manual:DIL_Manual/spellinfo|spellinfo]] - For getting detailed information about spells
* [[Manual:DIL_Manual/SPL_*|SPL_*]] - Spell index constants
* [[Manual:DIL_Manual/attack_spell|attack_spell]] - For offensive spell casting (higher-level function)

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/spell system|spell system]] - Magic and spell casting system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/change_speed</title>
     <ns>0</ns>
     <id>317890</id>
     <revision>
       <id>1711234</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of change_speed.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= change_speed =
function: &apos;&apos;&apos;change_speed&apos;&apos;&apos;(u : unitptr, i : integer);

The &apos;&apos;&apos;change_speed&apos;&apos;&apos; function modifies the combat speed of a character.

== Description ==
The &apos;&apos;&apos;change_speed&apos;&apos;&apos; function modifies the combat speed of a character. This is not the same as the character&apos;s base speed field, but rather the calculated speed used during combat rounds. This function is primarily used to temporarily delay or accelerate a character&apos;s next combat action.

The function only has an effect if the target unit is currently engaged in combat.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit on which to alter the current combat speed
|-
| i || integer || The amount to add to the speed
|}

== Examples ==
 dilbegin stun_effect(target : unitptr);
 code
 {
    change_speed(target, 12);
    quit;
 } dilend

 dilbegin potion_quaff_delay();
 code
 {
    if (self.position == POSITION_FIGHTING) 
        change_speed(self, PULSE_VIOLENCE*2);
    quit;
 } dilend

== Usage Notes ==
* This function only works on units that are currently in combat
* The speed modification is temporary and affects the timing of combat actions
* Commonly used for spells like &apos;stun&apos; that effectively put a character out of combat for one or more rounds

== Error Handling ==
The function will have no effect if:
* The target unit is not currently in combat
* The parameters are of incorrect types

== Related Functions/Fields ==
* [[Manual:DIL_Manual/set_fighting|set_fighting]] - To initiate combat between units
* [[Manual:DIL_Manual/stop_fighting|stop_fighting]] - To cancel combat

== See Also ==
* [[Manual:DIL_Manual/PULSE_VIOLENCE|PULSE_VIOLENCE]] - Combat timing constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/changecolor</title>
     <ns>0</ns>
     <id>828857</id>
     <revision>
       <id>981788</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of changecolor.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= changecolor =
function: [integer] &apos;&apos;&apos;changecolor&apos;&apos;&apos;(ch : unitptr, ks : string, cstr : string);

The &apos;&apos;&apos;changecolor&apos;&apos;&apos; function modifies an existing color entry in a player&apos;s personal color list.

== Description ==
The &apos;&apos;&apos;changecolor&apos;&apos;&apos; function modifies an existing color entry in a player&apos;s personal color list. This function only works on player characters and will fail if used on NPCs or other unit types.

The function first checks if the specified color key exists in the player&apos;s color list. If the key exists, it updates the color value with the new color string provided. If the key does not exist, the function returns FALSE without making any changes.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| ch || unitptr || Character to change the color on (must be a player character)
|-
| ks || string || Key string for the color (maximum 20 characters, alphanumeric and underscore only)
|-
| cstr || string || Color string to assign to the key
|}

== Return Value ==
Returns 1 (TRUE) if the color was successfully changed, 0 (FALSE) if the color key was not found.

== Availability ==
This function is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
 dilbegin update_clan_color();
 code
 {
    if (changecolor(activator, &quot;clan_who&quot;, &quot;&amp;c+w&amp;bn&quot;))
        act(&quot;Your clan color has been updated.&quot;, A_ALWAYS, activator, null, null, TO_CHAR);
    else
        act(&quot;Color key &apos;clan_who&apos; not found.&quot;, A_ALWAYS, activator, null, null, TO_CHAR);
    quit;
 } dilend

== Usage Notes ==
* Only works on player characters (PCs)
* The key string must be 20 characters or less
* The key string can only contain alphanumeric characters and underscores
* The function only modifies existing color entries - it does not create new ones

== Error Handling ==
The function will fail and return FALSE if:
* The target unit is not a player character
* The key string is longer than 20 characters
* The key string contains invalid characters
* The specified color key does not exist in the player&apos;s color list

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addcolor|addcolor]] - Add new color entries to a player&apos;s color list
* [[Manual:DIL_Manual/delcolor|delcolor]] - Remove color entries from a player&apos;s color list

== See Also ==
* [[Manual:DIL_Manual/getcolor|getcolor]] - Retrieve color values from a player&apos;s color list</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/charflags</title>
     <ns>0</ns>
     <id>373704</id>
     <revision>
       <id>1739128</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of charflags.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= charflags =
 field: integer &apos;&apos;&apos;charflags&apos;&apos;&apos; (Read-write)

The &apos;&apos;&apos;charflags&apos;&apos;&apos; field contains character flags specifying spell affects, character states, and other attributes.

== Description ==
The charflags field is a bitfield that contains various character flags specifying spell affects, character states, and other attributes for player characters (PCs) and non-player characters (NPCs). This field is accessible as a property of unit objects of type UNIT_ST_PC or UNIT_ST_NPC.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.charflags || integer || The character flags bitfield
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
=== Check Outlaw Status ===
 dilbegin check_outlaw();
 code
 {
    if (activator.charflags &amp; CHAR_OUTLAW) {
       act(&quot;$1n is an outlaw!&quot;, A_ALWAYS, self, null, activator, TO_ROOM);
    } else {
       act(&quot;$1n is a law-abiding citizen.&quot;, A_ALWAYS, self, null, activator, TO_ROOM);
    }
    quit;
 } dilend

=== Protection Status ===
 dilbegin check_protection();
 code
 {
    if (isset(activator.charflags, CHAR_PROTECTED)) {
       send(&quot;This character is protected.&quot;);
    } else {
       send(&quot;This character is not protected.&quot;);
    }
    quit;
 } dilend

=== Set Self Defence ===
 dilbegin set_self_defence();
 code
 {
    set(activator.charflags, CHAR_SELF_DEFENCE);
    send(&quot;You are now in self-defence mode.&quot;);
    quit;
 } dilend

=== Remove Outlaw Flag ===
 dilbegin remove_outlaw();
 code
 {
    unset(activator.charflags, CHAR_OUTLAW);
    send(&quot;You are no longer marked as an outlaw.&quot;);
    quit;
 } dilend

=== Multiple Flag Operations ===
 dilbegin manage_flags();
 code
 {
    // Set multiple flags at once
    set(activator.charflags, CHAR_OUTLAW | CHAR_PROTECTED);
    send(&quot;You are now a protected outlaw.&quot;);
    
    pause;
    
    // Check specific flags
    if (isset(activator.charflags, CHAR_OUTLAW)) {
       send(&quot;Still marked as outlaw.&quot;);
    }
    if (isset(activator.charflags, CHAR_PROTECTED)) {
       send(&quot;Still protected.&quot;);
    }
    
    // Clear all flags
    set(activator.charflags, 0);
    send(&quot;All character flags cleared.&quot;);
    quit;
 } dilend

=== Flag Combination Check ===
 dilbegin check_combination();
 code
 {
    if ((activator.charflags &amp; CHAR_OUTLAW) and (activator.charflags &amp; CHAR_PROTECTED)) {
       send(&quot;You are a protected outlaw.&quot;);
    } else if (activator.charflags &amp; CHAR_OUTLAW) {
       send(&quot;You are an outlaw.&quot;);
    } else if (activator.charflags &amp; CHAR_PROTECTED) {
       send(&quot;You are protected.&quot;);
    } else {
       send(&quot;You have no special flags.&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* This field is read/write - you can both read and modify character flags
* Only available on character units (PCs and NPCs)
* Use bit manipulation functions like set(), unset(), and isset() to work with individual flags
* Common flags include CHAR_OUTLAW, CHAR_PROTECTED, and CHAR_SELF_DEFENCE among others
* Flags are combined using bitwise OR operations

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a character type
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid type
* &apos;&apos;&apos;Range validation&apos;&apos;&apos; - Validates flag values are within valid range

== Related Functions ==
* [[Manual:DIL_Manual/set|set]] - Set specific bits in an integer
* [[Manual:DIL_Manual/unset|unset]] - Clear specific bits in an integer
* [[Manual:DIL_Manual/isset|isset]] - Check if specific bits are set in an integer

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type
* [[Manual:DIL_Manual/CHAR_*|CHAR_*]] - Character flag constants
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/chead</title>
     <ns>0</ns>
     <id>490133</id>
     <revision>
       <id>1068662</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of chead.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= chead =
 function: &apos;&apos;&apos;chead&apos;&apos;&apos;() : cmdptr;

The &apos;&apos;&apos;chead&apos;&apos;&apos; function returns a pointer to the first command in the global command list.

== Description ==
The chead function returns a pointer to the first command in the global command list. This function provides access to the complete command registry of the MUD, allowing DIL programs to iterate through all available commands, examine their properties, and perform command-related operations.

== Return Value ==
Returns a cmdptr:
* &apos;&apos;&apos;cmdptr&apos;&apos;&apos; - Pointer to the first command in the global command list
* &apos;&apos;&apos;null&apos;&apos;&apos; - If no commands are available

== Examples ==
=== List All Commands ===
 dilbegin list_commands();
 var
    cmd : cmdptr;
    info : string;
 code
 {
    cmd := chead();
    
    while (cmd) {
       info := cmd.name + &quot; (level &quot; + itoa(cmd.level) + &quot;)&quot;;
       act(&quot;Command: $2t&quot;, A_ALWAYS, self, info, null, TO_CHAR);
       cmd := cmd.next;
    }
    quit;
 } dilend

=== Find Specific Command ===
 dilbegin find_wiz_command();
 var
    cmd : cmdptr;
 code
 {
    cmd := chead();
    
    while ((cmd) and (cmd.name != &quot;wiz&quot;)) {
       cmd := cmd.next;
    }
    
    if (cmd) {
       act(&quot;Found wiz command, level: $2d&quot;, A_ALWAYS, self, cmd.level, null, TO_CHAR);
    } else {
       act(&quot;Wiz command not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Information Display ===
 dilbegin command_info();
 var
    cmd : cmdptr;
    details : string;
 code
 {
    cmd := chead();
    
    while (cmd) {
       details := cmd.name + &quot; &quot; + itoa(cmd.level) + &quot; &quot; + itoa(cmd.type) + 
                 &quot; &quot; + itoa(cmd.loglevel) + &quot; &quot; + itoa(cmd.position);
       act(&quot;CMD: $2t&quot;, A_ALWAYS, self, details, null, TO_CHAR);
       cmd := cmd.next;
    }
    quit;
 } dilend

=== Command Count ===
 dilbegin count_commands();
 var
    cmd : cmdptr;
    count : integer;
 code
 {
    cmd := chead();
    count := 0;
    
    while (cmd) {
       count := count + 1;
       cmd := cmd.next;
    }
    
    send(&quot;Total commands available: &quot; + itoa(count));
    quit;
 } dilend

== Usage Notes ==
* The returned cmdptr points to the first command in the global command list
* Use the next field to iterate through subsequent commands
* The command list includes all available commands in the system
* Each command has properties like name, level, type, loglevel, and position requirements
* Commonly used for command help systems, command validation, and administrative tools

== cmdptr Fields ==
The cmdptr returned by chead() has the following accessible fields:
* &apos;&apos;&apos;name&apos;&apos;&apos; : string - Command name
* &apos;&apos;&apos;type&apos;&apos;&apos; : integer - Command type (social, skill, or regular command)
* &apos;&apos;&apos;level&apos;&apos;&apos; : integer - Minimum level required to use the command
* &apos;&apos;&apos;loglevel&apos;&apos;&apos; : integer - Level of character that can see the log (0 for no logs)
* &apos;&apos;&apos;position&apos;&apos;&apos; : integer - Minimum position required to use the command
* &apos;&apos;&apos;next&apos;&apos;&apos; : cmdptr - Pointer to the next command in the list
* &apos;&apos;&apos;previous&apos;&apos;&apos; : cmdptr - Pointer to the previous command in the list

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;List validation&apos;&apos;&apos; - Ensures global command list is available
* &apos;&apos;&apos;Pointer validation&apos;&apos;&apos; - Returns null if no commands exist
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Always returns a valid cmdptr or null

== Related Functions ==
* [[Manual:DIL_Manual/getcommand|getcommand]] - Get a specific command by name
* [[Manual:DIL_Manual/ghead|ghead]] - Get the first unit in the global unit list
* [[Manual:DIL_Manual/cmdptr|cmdptr]] - Command pointer type and field documentation

== See Also ==
* [[Manual:DIL_Manual/command|command]] - Command field for checking current command
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command activation wait flag
* [[Manual:DIL_Manual/global command list|global command list]] - System command registry</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/check_password</title>
     <ns>0</ns>
     <id>1225110</id>
     <revision>
       <id>1246193</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of check_password.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= check_password =
 function: &apos;&apos;&apos;check_password&apos;&apos;&apos;(unit : unitptr, password : string) : integer;

The &apos;&apos;&apos;check_password&apos;&apos;&apos; function verifies whether a given password matches a player&apos;s stored password.

== Description ==
The check_password function verifies whether a given password string matches the stored password of a player character. This function only works on player characters (PCs) and will fail if used on NPCs or other unit types.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The player character unit whose password you want to check
|-
| password || string || The password string to verify against the player&apos;s password
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;1&apos;&apos;&apos; (TRUE) - If the password matches the player&apos;s password
* &apos;&apos;&apos;0&apos;&apos;&apos; (FALSE) - If it does not match
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If unit parameter is invalid or not a player

== Examples ==
=== Basic Password Verification ===
 dilbegin verify_password();
 code
 {
    if (not check_password(pc, argument)) {
       send(argument + &quot; is not &quot; + pc.name + &quot;&apos;s password.&quot;);
    } else {
       send(&quot;Password verified successfully.&quot;);
    }
    quit;
 } dilend

=== Authentication System ===
 dilbegin authenticate_player(target : unitptr, password : string);
 var
    authenticated : integer;
 code
 {
    authenticated := check_password(target, password);
    
    if (authenticated) {
       act(&quot;Authentication successful for $1n.&quot;, A_ALWAYS, target, null, null, TO_ROOM);
    } else {
       act(&quot;Authentication failed for $1n.&quot;, A_ALWAYS, target, null, null, TO_ROOM);
    }
    quit;
 } dilend

=== Password Change Verification ===
 dilbegin verify_old_password(new_pwd : string);
 var
    old_pwd : string;
 code
 {
    send(&quot;Enter your current password:&quot;);
    pause;
    old_pwd := excmdstr;
    
    if (not check_password(self, old_pwd)) {
       send(&quot;Incorrect password. Password change cancelled.&quot;);
    } else {
       send(&quot;Password verified. Proceeding with password change.&quot;);
    }
    quit;
 } dilend

=== Security Check ===
 dilbegin security_check();
 code
 {
    if (check_password(self, &quot;admin123&quot;)) {
       send(&quot;Access granted to administrative functions.&quot;);
    } else {
       send(&quot;Access denied. Invalid password.&quot;);
    }
    quit;
 } dilend

=== Multiple Attempts ===
 dilbegin password_attempts();
 var
    attempts : integer;
    input_pwd : string;
 code
 {
    attempts := 0;
    
    while (attempts &lt; 3) {
       send(&quot;Enter password (attempt &quot; + itoa(attempts + 1) + &quot;):&quot;);
       pause;
       input_pwd := excmdstr;
       
       if (check_password(self, input_pwd)) {
          send(&quot;Access granted!&quot;);
          break;
       } else {
          send(&quot;Invalid password. Try again.&quot;);
       }
       attempts := attempts + 1;
    }
    
    if (attempts &gt;= 3) {
       send(&quot;Too many failed attempts. Access denied.&quot;);
    }
    quit;
 } dilend

== Usage Notes ==
* Only works on player characters (PCs) - will fail and log an error if used on NPCs
* The password comparison is secure and uses proper cryptographic hashing
* This function is commonly used for authentication and password verification systems
* The function returns a boolean result as an integer (TRUE/FALSE)
* Always use this function rather than trying to compare passwords directly

== Error Handling ==
The function will fail and return an error if:
* The target unit is not a player character
* The password string is null or invalid
* The unit pointer is null or invalid

== Security Considerations ==
* Passwords are stored using secure cryptographic hashing
* The function does not expose the actual stored password
* Password comparison is done securely using the system&apos;s pwdcompare function
* Always use this function rather than trying to compare passwords directly

== Related Functions ==
* [[Manual:DIL_Manual/set_password|set_password]] - Set or change a player&apos;s password
* [[Manual:DIL_Manual/isplayer|isplayer]] - Check if a unit is a player character

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/cryptographic hashing|cryptographic hashing]] - Security system
* [[Manual:DIL_Manual/authentication|authentication]] - Player authentication system</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/clear</title>
     <ns>0</ns>
     <id>1082581</id>
     <revision>
       <id>1003360</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of clear.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= clear =
 function: &apos;&apos;&apos;clear&apos;&apos;&apos;(interrupt_index : integer);

The &apos;&apos;&apos;clear&apos;&apos;&apos; function removes a previously set interrupt from the current DIL program.

== Description ==
The clear function removes a previously set interrupt from the current DIL program. This is used to cancel interrupt handlers that are no longer needed, preventing them from triggering when their conditions are met.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| interrupt_index || integer || The interrupt index to clear, as returned by a previous interrupt() call
|}

== Return Value ==
This function does not return a value.

== Examples ==
=== Basic Interrupt Clearing ===
 dilbegin simple_interrupt();
 var
    intridx : integer;
 code
 {
    // Set up an interrupt
    intridx := interrupt(SFB_CMD, command(&quot;quit&quot;), handle_quit);
    
    // Some code here...
    
    // Clear the interrupt when no longer needed
    clear(intridx);
    quit;
    
    :handle_quit:
    act(&quot;Quit command intercepted!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== One-time Interrupt ===
 dilbegin one_time_interrupt();
 var
    intridx : integer;
 code
 {
    // Set up interrupt that will only trigger once
    intridx := interrupt(SFB_MSG, argument == &quot;hello&quot;, say_hi);
    
    :loop:
    pause;
    goto loop;
    
    :say_hi:
    act(&quot;Hello to you too!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    clear(intridx);  // Remove interrupt after it triggers
    goto loop;
 } dilend

=== Multiple Interrupt Management ===
 dilbegin manage_interrupts();
 var
    intr1, intr2, intr3 : integer;
 code
 {
    // Set up multiple interrupts
    intr1 := interrupt(SFB_CMD, command(&quot;stop&quot;), stop_handler);
    intr2 := interrupt(SFB_MSG, argument == &quot;pause&quot;, pause_handler);
    intr3 := interrupt(SFB_CMD, command(&quot;quit&quot;), quit_handler);
    
    heartbeat := PULSE_SEC * 15;
    
    act(&quot;The nightshade berries have a bitter taste.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    pause;
    act(&quot;Your stomach starts to rumble...&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    pause;
    act(&quot;You feel psychotic!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    pause;
    
    // Clear specific interrupts
    clear(intr1);  // Remove stop interrupt
    clear(intr2);  // Remove pause interrupt
    act(&quot;All interrupts cleared except quit.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
    
    :stop_handler:
    clear(intr1);
    clear(intr2);
    clear(intr3);
    act(&quot;All interrupts cleared, quitting.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
    
    :pause_handler:
    act(&quot;Pausing for a moment...&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    goto main_loop;
    
    :quit_handler:
    clear(intr1);
    clear(intr2);
    clear(intr3);
    act(&quot;All interrupts cleared, quitting.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Dynamic Interrupt Management ===
 dilbegin dynamic_interrupts();
 var
    msg_intr : integer;
    cmd_intr : integer;
 code
 {
    // Set up dynamic interrupts based on conditions
    msg_intr := interrupt(SFB_MSG, TRUE, message_handler);
    cmd_intr := interrupt(SFB_CMD, TRUE, command_handler);
    
    // Main loop
    pause;
    goto main_loop;
    
    :message_handler:
    // Handle message interrupt
    clear(msg_intr);  // Remove after handling
    goto main_loop;
    
    :command_handler:
    // Handle command interrupt
    clear(cmd_intr);  // Remove after handling
    goto main_loop;
    
    :main_loop:
    pause;
    goto main_loop;
 } dilend

== Usage Notes ==
* The interrupt index must be a valid value returned by a previous interrupt() call
* If the interrupt index is invalid, the function may clear the wrong interrupt or do nothing
* Clearing an interrupt that has already been cleared is safe but has no effect
* This function is commonly used with interrupt() to manage dynamic interrupt handling
* The clearing is immediate and affects the current execution cycle

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Index validation&apos;&apos;&apos; - Ensures interrupt index is valid
* &apos;&apos;&apos;State validation&apos;&apos;&apos; - Ensures proper interrupt context
* &apos;&apos;&apos;Runtime validation&apos;&apos;&apos; - Validates interrupt management state

== Related Functions ==
* [[Manual:DIL_Manual/interrupt|interrupt]] - Set up interrupt handlers
* [[Manual:DIL_Manual/SFB_*|SFB_*]] - Interrupt trigger flags
* [[Manual:DIL_Manual/pause|pause]] - Pause program execution

== See Also ==
* [[Manual:DIL_Manual/interrupt|interrupt]] - Interrupt management system
* [[Manual:DIL_Manual/execution control|execution control]] - DIL program flow control</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/clone</title>
     <ns>0</ns>
     <id>426138</id>
     <revision>
       <id>1662167</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of clone.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= clone =
 function: &apos;&apos;&apos;clone&apos;&apos;&apos;(unit : unitptr) : unitptr;

The &apos;&apos;&apos;clone&apos;&apos;&apos; function creates an exact copy of an existing unit.

== Description ==
The clone function creates an exact copy of an existing unit and places it in the same location as the unit that initiated the cloning process. The cloned unit is a complete duplicate with all properties, attributes, and DIL programs of the original unit.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit to clone/copy
|}

== Return Value ==
Returns a unit pointer:
* &apos;&apos;&apos;unitptr&apos;&apos;&apos; - Pointer to the cloned copy of the original unit
* &apos;&apos;&apos;null&apos;&apos;&apos; - If cloning failed

== Examples ==
=== Basic Item Cloning ===
 dilbegin clone_item();
 var
    original_item, cloned_item : unitptr;
 code
 {
    original_item := findunit(self, &quot;sword&quot;, FIND_UNIT_IN_ME, null);
    
    if (original_item) {
       cloned_item := clone(original_item);
       
       if (cloned_item) {
          act(&quot;You successfully clone $2t.&quot;, A_ALWAYS, self, cloned_item.title, null, TO_CHAR);
       } else {
          act(&quot;Failed to clone the item.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;You don&apos;t have that item.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== NPC Cloning ===
 dilbegin create_guard();
 var
    template_guard, new_guard : unitptr;
 code
 {
    template_guard := findunit(self, &quot;guard_template&quot;, FIND_UNIT_WORLD, null);
    
    if (template_guard) {
       new_guard := clone(template_guard);
       
       if (new_guard) {
          link(new_guard, self);
          act(&quot;$1n appears suddenly!&quot;, A_ALWAYS, new_guard, null, null, TO_ROOM);
       }
    } else {
       act(&quot;Guard template not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Mass Cloning ===
 dilbegin clone_multiple();
 var
    source_item, cloned_copy : unitptr;
    i : integer;
 code
 {
    source_item := findunit(self, &quot;potion&quot;, FIND_UNIT_IN_ME, null);
    
    if (source_item) {
       for (i := 0; i &lt; 5; i := i + 1) {
          cloned_copy := clone(source_item);
          
          if (not cloned_copy) {
             act(&quot;Cloning failed after &quot; + itoa(i) + &quot; copies.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
             break;
          }
       }
       
       if (i &gt;= 4) {
          act(&quot;You create multiple copies of the potion.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;No potion found to clone.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Conditional Cloning ===
 dilbegin smart_clone();
 var
    target_unit, cloned_unit : unitptr;
 code
 {
    target_unit := findunit(self, &quot;magic_orb&quot;, FIND_UNIT_WORLD, null);
    
    if (target_unit) {
       if (target_unit.type == UNIT_ST_OBJ) {
          cloned_unit := clone(target_unit);
          
          if (cloned_unit) {
             act(&quot;The magic orb duplicates itself!&quot;, A_ALWAYS, cloned_unit, null, null, TO_ROOM);
             set(cloned_unit.extra, EXTRA_NOSAVE);  // Make temporary
          }
       } else {
          act(&quot;Only objects can be cloned here.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;No target found for cloning.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Temporary Clone ===
 dilbegin create_temp_copy();
 var
    original, temp_copy : unitptr;
 code
 {
    original := findunit(self, &quot;scroll&quot;, FIND_UNIT_IN_ME, null);
    
    if (original) {
       temp_copy := clone(original);
       
       if (temp_copy) {
          set(temp_copy.extra, EXTRA_NOSAVE);
          act(&quot;You create a temporary copy of the scroll.&quot;, A_ALWAYS, self, temp_copy.title, null, TO_CHAR);
       }
    } else {
       act(&quot;Failed to create temporary copy.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* The cloned unit is automatically placed inside the unit that performed the clone operation
* All DIL programs on the cloned unit are activated after cloning
* The cloned unit is a complete duplicate with all original properties
* This function is useful for creating copies of items, NPCs, or other units
* The original unit remains unchanged
* Use EXTRA_NOSAVE flag to make cloned units temporary

== Error Handling ==
The function will return null if:
* The source unit pointer is null or invalid
* The cloning process fails due to system limitations
* Memory allocation fails for the new unit

== Related Functions ==
* [[Manual:DIL_Manual/load|load]] - Load a unit from database by name
* [[Manual:DIL_Manual/destroy|destroy]] - Remove a unit from the game
* [[Manual:DIL_Manual/link|link]] - Move a unit to a different location

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/EXTRA_NOSAVE|EXTRA_NOSAVE]] - Extra description flag for temporary units</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/cmdptr</title>
     <ns>0</ns>
     <id>933265</id>
     <revision>
       <id>1310490</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of cmdptr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= cmdptr =
 type: &apos;&apos;&apos;cmdptr&apos;&apos;&apos;

The &apos;&apos;&apos;cmdptr&apos;&apos;&apos; type represents a command pointer that provides access to command information in the DikuMUD command system.

== Description ==
A &apos;&apos;&apos;cmdptr&apos;&apos;&apos; is a pointer type that references individual commands in the global command table. Each command contains information such as its name, required level, position requirements, command type, and logging level. Command pointers are commonly used for command validation, permission checking, and creating command help systems.

The cmdptr type supports traversal through linked lists using the next and previous fields, allowing iteration through all available commands in the system.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| name || string || Read-only || The command name string
|-
| type || integer || Read-only || Command type identifier (social, skill, or regular command)
|-
| level || integer || Read-only || Minimum character level required to use the command
|-
| loglevel || integer || Read-only || Minimum character level that can see log entries (0 = no logging)
|-
| position || integer || Read-only || Minimum position required to use the command
|-
| next || cmdptr || Read-only || Pointer to the next command in the list
|-
| previous || cmdptr || Read-only || Pointer to the previous command in the list
|}

== Availability ==
The cmdptr type is used with the following functions and operations:
* &apos;&apos;&apos;chead()&apos;&apos;&apos; - Returns the first command in the global command list
* &apos;&apos;&apos;getcommand(s : string)&apos;&apos;&apos; - Returns a specific command by name
* &apos;&apos;&apos;getcmd(s : string)&apos;&apos;&apos; - Alternative function to get a command by name

== Examples ==
=== List All Commands ===
 dilbegin list_all_commands();
 var
    cmd : cmdptr;
    info : string;
    count : integer;
 code
 {
    cmd := chead();
    count := 0;
    
    while (cmd) {
       info := cmd.name + &quot; (lvl:&quot; + itoa(cmd.level) + 
                 &quot; pos:&quot; + itoa(cmd.position) + 
                 &quot; type:&quot; + itoa(cmd.type) + &quot;)&quot;;
       act(&quot;CMD: $2t&quot;, A_ALWAYS, self, info, null, TO_CHAR);
       cmd := cmd.next;
       count := count + 1;
    }
    
    act(&quot;Total commands: &quot; + itoa(count), A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Check Command Access ===
 dilbegin check_command_access(cmd_name : string);
 var
    cmd : cmdptr;
 code
 {
    cmd := getcommand(cmd_name);
    
    if (not cmd) {
       act(&quot;Command &apos;&quot; + cmd_name + &quot;&apos; does not exist.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Command: &quot; + cmd.name, A_ALWAYS, self, cmd.level, null, TO_CHAR);
       act(&quot;Required level: &quot; + itoa(cmd.level), A_ALWAYS, self, cmd.position, null, TO_CHAR);
       act(&quot;Required position: &quot; + itoa(cmd.position), A_ALWAYS, self, cmd.type, null, TO_CHAR);
    act(&quot;Command type: &quot; + itoa(cmd.type), A_ALWAYS, self, cmd.loglevel, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Analysis ===
 dilbegin analyze_commands();
 var
    cmd : cmdptr;
    total, socials, skills : integer;
 code
 {
    total := 0;
    socials := 0;
    skills := 0;
    
    cmd := chead();
    
    while (cmd) {
       total := total + 1;
       
       if (cmd.type == 1)  // Assuming type 1 = social
          socials := socials + 1;
       else if (cmd.type == 2)  // Assuming type 2 = skill
          skills := skills + 1;
       
       cmd := cmd.next;
    }
    
    act(&quot;Command analysis:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Total commands: &quot; + itoa(total), A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Social commands: &quot; + itoa(socials), A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Skill commands: &quot; + itoa(skills), A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

== Usage Notes ==
* Command pointers are read-only; you cannot modify command properties through cmdptr
* The command list is a doubly-linked list, allowing both forward and backward traversal
* Command types are typically defined as constants in the system (social, skill, regular command)
* Position requirements use standard position constants (standing, sitting, fighting, etc.)
* A loglevel of 0 indicates that the command does not generate log entries
* Use &apos;&apos;&apos;chead()&apos;&apos;&apos; to get the first command and traverse with &apos;&apos;&apos;next&apos;&apos;&apos; to iterate through all commands

== Error Handling ==
* Accessing fields on a null cmdptr will result in a DILV_FAIL condition
* &apos;&apos;&apos;getcommand()&apos;&apos;&apos; and &apos;&apos;&apos;getcmd()&apos;&apos;&apos; return null if the command is not found
* Always check if a cmdptr is valid before accessing its fields

== Related Functions ==
* [[Manual:DIL_Manual/chead|chead]] - Get the first command in the global command list
* [[Manual:DIL_Manual/getcommand|getcommand]] - Get a specific command by name
* [[Manual:DIL_Manual/getcmd|getcmd]] - Alternative function to get a command by name

== See Also ==
* [[Manual:DIL_Manual/command|command]] - Command field for checking current command
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command activation wait flag
* [[Manual:DIL_Manual/global command list|global command list]] - System command registry</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/cmdstr</title>
     <ns>0</ns>
     <id>907217</id>
     <revision>
       <id>1659873</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of cmdstr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= cmdstr =
 field: string &apos;&apos;&apos;cmdstr&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;cmdstr&apos;&apos;&apos; field contains the full command string as entered by a player.

== Description ==
The cmdstr variable contains the full command string as entered by a player, but with command expansion applied by the interpreter. This variable is available within DIL programs that are activated by player commands (SFB_CMD).

The cmdstr represents the command portion of what the player typed, after the interpreter has expanded any abbreviations or aliases. For example, if a player types &quot;s&quot; (abbreviation for &quot;south&quot;), cmdstr will contain &quot;south&quot;.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| cmdstr || string || The expanded command string as entered by the player
|}

== Examples ==
=== Basic Command Processing ===
 dilbegin command_handler();
 code
 {
    if (cmdstr == &quot;north&quot;) {
       act(&quot;You go north.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if (cmdstr == &quot;south&quot;) {
       act(&quot;You go south.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Unknown command: &quot; + cmdstr, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Validation ===
 dilbegin validate_command();
 code
 {
    if ((cmdstr == &quot;remove&quot;) and (cmdstr != &quot;remove&quot;)) {
       act(&quot;Command expansion detected: &quot; + cmdstr, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Command accepted: &quot; + cmdstr, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Logging ===
 dilbegin log_commands();
 code
 {
    log(&quot;Player &quot; + activator.name + &quot; used command: &quot; + cmdstr + &quot; with args: &quot; + argument);
    
    // Process based on expanded command
    if (cmdstr == &quot;look&quot;) {
       act(&quot;You look around.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if (cmdstr == &quot;say&quot;) {
       act(&quot;You say &apos;&quot; + argument + &quot;&apos;&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Comparison ===
 dilbegin compare_commands();
 var
    full_command : string;
 code
 {
    full_command := cmdstr + &quot; &quot; + argument;
    act(&quot;Full command: &quot; + full_command, A_ALWAYS, self, null, null, TO_CHAR);
    
    // Show individual parts
    act(&quot;Command: &quot; + cmdstr, A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Argument: &quot; + argument, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Abbreviation Detection ===
 dilbegin detect_abbreviation();
 code
 {
    if ((cmdstr == &quot;n&quot;) and (cmdstr != &quot;north&quot;)) {
       act(&quot;Abbreviation detected: &apos;n&apos; expanded to &apos;north&apos;&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if ((cmdstr == &quot;s&quot;) and (cmdstr != &quot;south&quot;)) {
       act(&quot;Abbreviation detected: &apos;s&apos; expanded to &apos;south&apos;&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Command: &quot; + cmdstr, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* This is a read-only variable that contains the expanded command
* cmdstr + &quot; &quot; + argument gives the complete command string as entered by the player
* The command is expanded by the interpreter (abbreviations become full commands)
* Only available in DIL programs activated by SFB_CMD (command triggers)
* Useful for parsing and processing player commands
* The command expansion is done before the DIL program receives control

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Automatic validation&apos;&apos;&apos; - The field is automatically set by the DIL runtime
* &apos;&apos;&apos;Context validation&apos;&apos;&apos; - Only meaningful when accessed within command-triggered DIL programs
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Always returns a string (may be empty)

== Related Fields ==
* [[Manual:DIL_Manual/excmdstr|excmdstr]] - Original command as typed (lowercase)
* [[Manual:DIL_Manual/excmdstr_case|excmdstr_case]] - Original command as typed (preserves case)
* [[Manual:DIL_Manual/argument|argument]] - Command arguments

== Related Functions ==
* [[Manual:DIL_Manual/command|command]] - Check if a specific command was used
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command activation wait flag

== See Also ==
* [[Manual:DIL_Manual/command interpreter|command interpreter]] - Command processing system
* [[Manual:DIL_Manual/command expansion|command expansion]] - Abbreviation and alias system</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/command</title>
     <ns>0</ns>
     <id>1142362</id>
     <revision>
       <id>1307785</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of command.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= command =
 function: &apos;&apos;&apos;command&apos;&apos;&apos;(cmd_name : string) : integer
 function: &apos;&apos;&apos;command&apos;&apos;&apos;(cmd_num : integer) : integer

The &apos;&apos;&apos;command&apos;&apos;&apos; function checks whether the current command matches a specific command name or number.

== Description ==
The command function checks whether the current command that activated the DIL program matches a specific command name or command number. This is useful for DIL programs that handle multiple commands and need to determine which specific command triggered the activation.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| cmd_name || string || The command name to check
|-
| cmd_num || integer || The command number to check
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;1&apos;&apos;&apos; (TRUE) - If the specified command matches the current command
* &apos;&apos;&apos;0&apos;&apos;&apos; (FALSE) - If the command does not match

== Examples ==
=== Basic Command Handling ===
 dilbegin multi_command_handler();
 code
 {
    if (command(&quot;north&quot;)) {
       act(&quot;You go north.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if (command(&quot;south&quot;)) {
       act(&quot;You go south.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if (command(&quot;look&quot;)) {
       act(&quot;You look around.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Unknown command.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Number Handling ===
 dilbegin numbered_commands();
 code
 {
    if (command(1)) {
       act(&quot;Command 1 activated.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if (command(2)) {
       act(&quot;Command 2 activated.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if (command(3)) {
       act(&quot;Command 3 activated.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Unknown command number.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Router ===
 dilbegin command_router();
 var
    cmd_found : integer;
 code
 {
    cmd_found := 0;
    
    // Check various command categories
    if (command(&quot;get&quot;) or command(&quot;take&quot;) or command(&quot;drop&quot;)) {
       cmd_found := 1;
       act(&quot;Object command detected.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if (command(&quot;say&quot;) or command(&quot;tell&quot;) or command(&quot;shout&quot;)) {
       cmd_found := 1;
       act(&quot;Communication command detected.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else if (command(&quot;north&quot;) or command(&quot;south&quot;) or command(&quot;east&quot;) or command(&quot;west&quot;)) {
       cmd_found := 1;
       act(&quot;Movement command detected.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    
    if (cmd_found) {
       act(&quot;Command recognized and processed.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Unknown command type.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Permission Check ===
 dilbegin check_command_permission();
 code
 {
    if (command(&quot;admin&quot;)) {
       if (activator.level &gt;= 255) {
          act(&quot;Admin command authorized.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
          // Process admin command...
       } else {
          act(&quot;Admin command denied - insufficient level.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;Non-admin command detected.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Complex Command Processing ===
 dilbegin advanced_handler();
 var
    cmd_type : integer;
 code
 {
    // Determine command type
    if (command(&quot;north&quot;) or command(&quot;south&quot;) or command(&quot;east&quot;) or command(&quot;west&quot;)) {
       cmd_type := 1;  // Movement
    } else if (command(&quot;get&quot;) or command(&quot;take&quot;) or command(&quot;drop&quot;)) {
       cmd_type := 2;  // Object manipulation
    } else if (command(&quot;say&quot;) or command(&quot;tell&quot;) or command(&quot;shout&quot;)) {
       cmd_type := 3;  // Communication
    } else if (command(&quot;attack&quot;) or command(&quot;kill&quot;) or command(&quot;cast&quot;)) {
       cmd_type := 4;  // Combat
    } else {
       cmd_type := 0;  // Unknown
    }
    
    act(&quot;Command type &quot; + itoa(cmd_type) + &quot; detected.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

== Usage Notes ==
* Only available in DIL programs activated by SFB_CMD (command triggers)
* Returns TRUE if the current command matches the specified command
* Can work with both string command names and integer command numbers
* The command check is case-sensitive when using string comparison
* Useful for creating multi-command DIL programs that handle different behaviors
* The function compares against the current command that triggered the DIL program

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Parameter validation&apos;&apos;&apos; - Ensures cmd_name is a string or cmd_num is an integer
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if parameters are invalid
* &apos;&apos;&apos;Command validation&apos;&apos;&apos; - Always returns a valid boolean result

== Related Functions ==
* [[Manual:DIL_Manual/cmdstr|cmdstr]] - Get the expanded command string
* [[Manual:DIL_Manual/excmdstr|excmdstr]] - Get the original command as typed
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command activation wait flag

== See Also ==
* [[Manual:DIL_Manual/command interpreter|command interpreter]] - Command processing system
* [[Manual:DIL_Manual/command registry|command registry]] - System command database</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/command_head</title>
     <ns>0</ns>
     <id>947517</id>
     <revision>
       <id>1061673</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of command_head.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= command_head =
 function: &apos;&apos;&apos;command_head&apos;&apos;&apos;() : cmdptr;

The &apos;&apos;&apos;command_head&apos;&apos;&apos; function returns a pointer to the first command in the global command list.

== Description ==
The command_head function returns a pointer to the first command in the global command registry. This provides access to the complete command system, allowing DIL programs to iterate through all available commands, examine their properties, and perform command-related operations.

== Return Value ==
Returns a cmdptr:
* &apos;&apos;&apos;cmdptr&apos;&apos;&apos; - Pointer to the first command in the global command list
* &apos;&apos;&apos;null&apos;&apos;&apos; - If no commands are available

== Examples ==
=== List All Commands ===
 dilbegin list_all_commands();
 var
    cmd : cmdptr;
    info : string;
    count : integer;
 code
 {
    cmd := command_head();
    count := 0;
    
    while (cmd) {
       info := cmd.name + &quot; (level &quot; + itoa(cmd.level) + &quot;)&quot;;
       act(&quot;Command: $2t&quot;, A_ALWAYS, self, info, null, TO_CHAR);
       cmd := cmd.next;
       count := count + 1;
    }
    
    act(&quot;Total commands: &quot; + itoa(count), A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Command Analysis ===
 dilbegin analyze_commands();
 var
    cmd : cmdptr;
    total, socials, skills : integer;
 code
 {
    total := 0;
    socials := 0;
    skills := 0;
    
    cmd := command_head();
    
    while (cmd) {
       total := total + 1;
       
       if (cmd.type == 1)  // Assuming type 1 = social
          socials := socials + 1;
       else if (cmd.type == 2)  // Assuming type 2 = skill
          skills := skills + 1;
       
       cmd := cmd.next;
    }
    
    act(&quot;Command analysis:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Total commands: &quot; + itoa(total), A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Social commands: &quot; + itoa(socials), A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Skill commands: &quot; + itoa(skills), A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Command Lookup ===
 dilbegin find_command_info(cmd_name : string);
 var
    cmd : cmdptr;
 code
 {
    cmd := command_head();
    
    while ((cmd) and (cmd.name != cmd_name)) {
       cmd := cmd.next;
    }
    
    if (cmd) {
       act(&quot;Command: &quot; + cmd.name, A_ALWAYS, self, cmd.level, null, TO_CHAR);
       act(&quot;Required level: &quot; + itoa(cmd.level), A_ALWAYS, self, cmd.position, null, TO_CHAR);
       act(&quot;Required position: &quot; + itoa(cmd.position), A_ALWAYS, self, cmd.type, null, TO_CHAR);
    } else {
       act(&quot;Command &apos;&quot; + cmd_name + &quot;&apos; not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Command Filtering ===
 dilbegin list_commands_by_level(min_level : integer);
 var
    cmd : cmdptr;
    count : integer;
 code
 {
    count := 0;
    cmd := command_head();
    
    while (cmd) {
       if (cmd.level &lt;= min_level) {
          act(cmd.name + &quot; (level &quot; + itoa(cmd.level) + &quot;)&quot;, A_ALWAYS, self, null, null, TO_CHAR);
          count := count + 1;
       }
       cmd := cmd.next;
    }
    
    act(&quot;Found &quot; + itoa(count) + &quot; commands you can use.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

== Usage Notes ==
* The returned cmdptr points to the first command in the global command list
* Use the next field to iterate through subsequent commands
* The command list contains all registered commands in the system
* Each command has properties like name, level, type, loglevel, and position requirements
* This function is identical to chead() - both return the same result
* Commonly used for command help systems, command validation, and administrative tools

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;List validation&apos;&apos;&apos; - Ensures global command list is available
* &apos;&apos;&apos;Pointer validation&apos;&apos;&apos; - Returns null if no commands exist
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Always returns a valid cmdptr or null

== Related Functions ==
* [[Manual:DIL_Manual/getcommand|getcommand]] - Get a specific command by name
* [[Manual:DIL_Manual/cmdptr|cmdptr]] - Command pointer type and field documentation

== See Also ==
* [[Manual:DIL_Manual/command|command]] - Command field for checking current command
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command activation wait flag
* [[Manual:DIL_Manual/global command list|global command list]] - System command registry</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/continue</title>
     <ns>0</ns>
     <id>1089036</id>
     <revision>
       <id>1142237</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of continue.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= continue =
 statement: &apos;&apos;&apos;continue&apos;&apos;&apos;;

The continue statement skips the remaining code in the current loop iteration and jumps to the next iteration of the loop.

== Description ==
The &apos;&apos;&apos;continue&apos;&apos;&apos; statement is used within loop constructs to immediately terminate the current iteration and proceed to the next iteration of the loop. When executed, any remaining statements in the loop body are skipped, and the loop condition is re-evaluated to determine if another iteration should occur.

This statement is particularly useful for filtering out unwanted iterations in loops, allowing the program to skip processing of items that don&apos;t meet certain criteria without exiting the entire loop.

== Usage Notes ==
* The &apos;&apos;&apos;continue&apos;&apos;&apos; statement can only be used within loop constructs (while loops, foreach loops)
* Using &apos;&apos;&apos;continue&apos;&apos;&apos; outside of a loop will result in a compilation error: &quot;Using continue outside loop&quot;
* When multiple loops are nested, &apos;&apos;&apos;continue&apos;&apos;&apos; only affects the innermost loop
* The statement is commonly used for conditional filtering within loops
* &apos;&apos;&apos;continue&apos;&apos;&apos; differs from &apos;&apos;&apos;break&apos;&apos;&apos; in that it doesn&apos;t exit the loop, just the current iteration

== Error Handling ==
If the &apos;&apos;&apos;continue&apos;&apos;&apos; statement is used outside of any loop construct, the DIL compiler will generate an error and the script will fail to compile.

== Examples ==
dilbegin check_health_status();
code
{
  while (self.inside) {
    if (self.position &amp; POSITION_SLEEPING)
      break;
    pause;
    if (self.hp &lt; 0) 
      continue;
    exec(&quot;say I am healthy and ready&quot;, self);
    pause;
  }
} dilend

dilbegin collect_valuable_items();
var
    item : unitptr;
    count : integer;
code
{
    count := 0;
    foreach (UNIT_ST_OBJ, item) {
        if (not isset(item.manipulate, MANIPULATE_TAKE))
            continue;
        
        if (item.flags &amp; UNIT_FL_BURIED)
            continue;
        
        if (not visible(self, item))
            continue;
        
        act(&quot;$1n picks up $2n.&quot;, A_ALWAYS, self, item, null, TO_ALL);
        exec(&quot;get &quot; + item.name, self);
        count := count + 1;
    }
    
    act(&quot;Collected $2d items.&quot;, A_ALWAYS, self, itoa(count), null, TO_CHAR);
} dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/break|break]] - Exit from a loop entirely
* [[Manual:DIL_Manual/while|while]] - Loop construct that can be controlled with continue
* [[Manual:DIL_Manual/foreach|foreach]] - Loop construct that can be controlled with continue

== See Also ==
* [[Manual:DIL_Manual/break|break]]
* [[Manual:DIL_Manual/while|while]]
* [[Manual:DIL_Manual/foreach|foreach]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/cost</title>
     <ns>0</ns>
     <id>1236406</id>
     <revision>
       <id>1158653</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of cost.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= cost =
 field: integer &apos;&apos;&apos;cost&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;cost&apos;&apos;&apos; field returns the price of an object in gold pieces.

== Description ==
The cost field is a read-only property of object units that returns the price of the item in gold pieces. This field provides access to the monetary value that would be charged to players when purchasing the item from shops.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.cost || integer || The price of the object in gold pieces
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_OBJ (Object)

== Examples ==
=== Basic Cost Display ===
 dilbegin show_item_cost();
 var
    item : unitptr;
 code
 {
    item := findunit(self, &quot;sword&quot;, FIND_UNIT_IN_ME, null);
    
    if (item) {
       act(&quot;The &quot; + item.title + &quot; costs &quot; + itoa(item.cost) + &quot; gold pieces.&quot;, 
           A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;No item found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Shop Pricing ===
 dilbegin shopkeeper();
 var
    customer_item : unitptr;
    shop_item : unitptr;
 code
 {
    customer_item := medium;  // Item customer wants to sell
    shop_item := findunit(self, &quot;potion&quot;, FIND_UNIT_IN_ME, null);
    
    if (customer_item and shop_item) {
       act(&quot;The &quot; + customer_item.title + &quot; is worth &quot; + itoa(customer_item.cost) + 
          &quot; gold pieces. I can offer you &quot; + itoa(shop_item.cost) + &quot; for it.&quot;, 
          A_ALWAYS, self, customer_item, null, TO_CHAR);
    } else {
       act(&quot;Cannot complete transaction - missing items.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Cost Comparison ===
 dilbegin compare_costs();
 var
    item1, item2 : unitptr;
 code
 {
    item1 := findunit(self, &quot;sword&quot;, FIND_UNIT_IN_ME, null);
    item2 := findunit(self, &quot;dagger&quot;, FIND_UNIT_IN_ME, null);
    
    if (item1 and item2) {
       if (item1.cost &gt; item2.cost) {
          act(&quot;The &quot; + item1.title + &quot; is more expensive than the &quot; + item2.title + &quot;.&quot;, 
             A_ALWAYS, self, null, null, TO_CHAR);
       } else if (item1.cost &lt; item2.cost) {
          act(&quot;The &quot; + item2.title + &quot; is more expensive than the &quot; + item1.title + &quot;.&quot;, 
             A_ALWAYS, self, null, null, TO_CHAR);
       } else {
          act(&quot;Both items have the same value.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;Cannot compare - missing items.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Affordability Check ===
 dilbegin can_afford(item_cost : integer);
 var
    player_money : integer;
 code
 {
    player_money := self.money[0];  // Gold pieces
    
    if (player_money &gt;= item_cost) {
       act(&quot;You can afford this item.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;You cannot afford this item. You need &quot; + itoa(item_cost - player_money) + 
          &quot; more gold pieces.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Value Analysis ===
 dilbegin analyze_item_value();
 var
    item : unitptr;
    value_per_weight : integer;
 code
 {
    item := findunit(self, &quot;armor&quot;, FIND_UNIT_IN_ME, null);
    
    if (item and item.weight &gt; 0) {
       value_per_weight := item.cost / item.weight;
       act(&quot;Item: &quot; + item.title, A_ALWAYS, self, null, null, TO_CHAR);
       act(&quot;Cost: &quot; + itoa(item.cost) + &quot; gold&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       act(&quot;Weight: &quot; + itoa(item.weight) + &quot; lbs&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       act(&quot;Value per pound: &quot; + itoa(value_per_weight) + &quot; gold&quot;, 
             A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;No item found or invalid weight.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* Only available on object units (UNIT_ST_OBJ)
* Returns the price in gold pieces as an integer
* The cost is read-only and cannot be modified directly
* Used by shop systems, trading mechanics, and economic calculations
* The cost may be affected by item condition, magical properties, and other factors
* Cost values are typically positive integers representing gold pieces

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is an object type
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid type
* &apos;&apos;&apos;Range validation&apos;&apos;&apos; - Validates cost is within reasonable bounds

== Related Functions ==
* [[Manual:DIL_Manual/value|value]] - Get the base value of an item
* [[Manual:DIL_Manual/moneystring|moneystring]] - Format money amounts for display
* [[Manual:DIL_Manual/transfermoney|transfermoney]] - Transfer money between units

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object unit type
* [[Manual:DIL_Manual/shop systems|shop systems]] - Economic and trading systems
* [[Manual:DIL_Manual/gold pieces|gold pieces]] - Currency system</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/creators</title>
     <ns>0</ns>
     <id>1265997</id>
     <revision>
       <id>1041432</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of creators.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= creators =
 field: stringlist &apos;&apos;&apos;creators&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;creators&apos;&apos;&apos; field contains names of creators who contributed to a zone.

== Description ==
The creators field is a read-only property of zone units that returns a stringlist containing the names of creators who contributed to that zone. This provides information about the authors or builders responsible for the zone&apos;s content and design.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| zone.creators || stringlist || The list of creator names
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room with zone properties)

== Examples ==
=== Basic Creator Display ===
 dilbegin show_creators();
 var
    zone : unitptr;
    creator_list : stringlist;
 code
 {
    zone := self.outside;
    
    if (zone and zone.creators) {
       act(&quot;Zone creators:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       
       // Display each creator
       foreach (creator_name in zone.creators) {
          act(&quot;  &quot; + creator_name, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;No creator information available for this zone.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Zone Information Command ===
 dilbegin zone_info();
 var
    current_zone : unitptr;
    creator_count : integer;
 code
 {
    current_zone := self.outside;
    
    if (current_zone and current_zone.creators) {
       creator_count := length(current_zone.creators);
       act(&quot;Zone: &quot; + current_zone.zoneidx, A_ALWAYS, self, null, null, TO_CHAR);
       act(&quot;Total creators: &quot; + itoa(creator_count), A_ALWAYS, self, null, null, TO_CHAR);
       
       // Display each creator
       foreach (creator_name in current_zone.creators) {
          act(&quot;  Creator: &quot; + creator_name, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;No creator information available.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Creator Search ===
 dilbegin find_zone_creators(zone_name : string);
 var
    zone_ptr : zoneptr;
    found_creators : stringlist;
 code
 {
    zone_ptr := zhead();
    
    while (zone_ptr) {
       if (zone_ptr.name == zone_name) {
          found_creators := zone_ptr.creators;
          break;
       }
       zone_ptr := zone_ptr.next;
    }
    
    if (found_creators) {
       act(&quot;Creators of zone &apos;&quot; + zone_name + &quot;&apos;:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       foreach (creator_name in found_creators) {
          act(&quot;  &quot; + creator_name, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;Zone &apos;&quot; + zone_name + &quot;&apos; not found or has no creator information.&quot;, 
          A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Help System Integration ===
 dilbegin help_creators();
 var
    zone : unitptr;
    help_text : string;
 code
 {
    zone := self.outside;
    
    if (zone and zone.creators) {
       help_text := &quot;This zone was created by: &quot;;
       
       // Format creator list nicely
       if (length(zone.creators) == 1) {
          help_text := help_text + zone.creators.[0];
       } else {
          help_text := help_text + zone.creators.[0];
          foreach (i := 1; i &lt; length(zone.creators); i := i + 1) {
             if (i == length(zone.creators)) {
                help_text := help_text + &quot; and &quot; + zone.creators.[i];
             } else {
                help_text := help_text + &quot;, &quot; + zone.creators.[i];
             }
          }
       }
       
       sendtext(help_text, self);
    } else {
       sendtext(&quot;No creator information available for this zone.&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* Only available on zone units (UNIT_ST_ROOM with zone properties)
* Returns a stringlist containing creator names
* The field is read-only and cannot be modified through DIL
* Used for help systems, zone information displays, and credit attribution
* Creator information is typically stored in zone data and loaded when zone is initialized
* Useful for tracking zone authorship and building contributions

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Zone validation&apos;&apos;&apos; - Ensures unit is a zone with properties
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid zone type
* &apos;&apos;&apos;List validation&apos;&apos;&apos; - Ensures stringlist is properly formatted

== Related Functions ==
* [[Manual:DIL_Manual/zhead|zhead]] - Get first zone in the list
* [[Manual:DIL_Manual/stringlist|stringlist]] - String list data type
* [[Manual:DIL_Manual/pagestring|pagestring]] - Display string lists to players

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room unit type
* [[Manual:DIL_Manual/zone|zone]] - Zone pointer and navigation
* [[Manual:DIL_Manual/zone properties|zone properties]] - Zone-specific fields</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/crimes</title>
     <ns>0</ns>
     <id>1063442</id>
     <revision>
       <id>1341511</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of crimes.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= crimes =
 field: integer &apos;&apos;&apos;crimes&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;crimes&apos;&apos;&apos; field returns the number of crimes a character has committed.

== Description ==
The crimes field is a read-only property of player character units that returns the number of crimes the character has committed. This field tracks the character&apos;s criminal history and is used by justice systems, law enforcement mechanics, and various gameplay systems that need to monitor player behavior.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.crimes || integer || The number of crimes committed
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Crime Check ===
 dilbegin check_criminal();
 code
 {
    if (activator.crimes &gt; 0) {
       act(&quot;You have committed &quot; + itoa(activator.crimes) + &quot; crimes.&quot;, 
          A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;You have a clean record.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Crime Status Display ===
 dilbegin crime_status();
 var
    status : string;
 code
 {
    if (activator.crimes &gt; 10) {
       status := &quot;Habitual Criminal&quot;;
    } else if (activator.crimes &gt; 5) {
       status := &quot;Known Criminal&quot;;
    } else if (activator.crimes &gt; 0) {
       status := &quot;Minor Offender&quot;;
    } else {
       status := &quot;Clean Record&quot;;
    }
    
    act(&quot;Crime Status: &quot; + status, A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Total Crimes: &quot; + itoa(activator.crimes), A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Justice System ===
 dilbegin justice_system();
 var
    suspect : unitptr;
 code
 {
    suspect := activator;
    
    if (suspect.crimes &gt; 3) {
       act(&quot;Guards! This person is a known criminal with &quot; + itoa(suspect.crimes) + 
          &quot; offenses!&quot;, A_ALWAYS, self, suspect, null, TO_ROOM);
       act(&quot;You&apos;re under arrest!&quot;, A_ALWAYS, suspect, null, null, TO_CHAR);
    } else if (suspect.crimes &gt; 0) {
       act(&quot;This person has a minor criminal record.&quot;, A_ALWAYS, self, suspect, null, TO_ROOM);
    } else {
       act(&quot;This person has a clean record.&quot;, A_ALWAYS, self, suspect, null, TO_ROOM);
    }
    quit;
 } dilend

=== Crime Tracking ===
 dilbegin track_crimes();
 var
    criminal : unitptr;
 code
 {
    criminal := activator;
    
    // Log criminal activity
    log(&quot;Criminal &quot; + criminal.name + &quot; detected with &quot; + 
          itoa(criminal.crimes) + &quot; prior offenses.&quot;);
    
    if (criminal.crimes &gt;= 10) {
       act(&quot;WANTED: &quot; + criminal.name, A_ALWAYS, criminal, null, null, TO_ROOM);
       set(criminal.charflags, CHAR_OUTLAW);
    } else {
       unset(criminal.charflags, CHAR_OUTLAW);
    }
    quit;
 } dilend

=== Entry Restriction ===
 dilbegin city_gates();
 var
    traveler : unitptr;
 code
 {
    traveler := activator;
    
    if (traveler.crimes &gt; 3) {
       act(&quot;Guards block your path. \&quot;Your criminal record prevents entry.\&quot;&quot;,
          A_ALWAYS, self, traveler, null, TO_CHAR);
       act(&quot;The guards turn away &quot; + traveler.name + &quot; at the city gates.&quot;, 
          A_ALWAYS, self, traveler, null, TO_ROOM);
    } else {
       act(&quot;You pass through the city gates unmolested.&quot;, 
          A_ALWAYS, self, traveler, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* Only available on player character units (UNIT_ST_PC)
* Returns an integer representing the number of crimes committed
* The field is read-only and cannot be modified directly through DIL
* Used by justice systems, guard NPCs, and law enforcement mechanics
* Often checked alongside other character flags like CHAR_OUTLAW
* The value persists across character sessions and is saved with the player
* Higher values indicate more serious criminal history

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a player character
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid type
* &apos;&apos;&apos;Range validation&apos;&apos;&apos; - Validates crime count is within reasonable bounds

== Related Functions ==
* [[Manual:DIL_Manual/charflags|charflags]] - Character flags including CHAR_OUTLAW
* [[Manual:DIL_Manual/isplayer|isplayer]] - Check if a unit is a player character

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/justice system|justice system]] - Law enforcement and crime tracking
* [[Manual:DIL_Manual/CHAR_OUTLAW|CHAR_OUTLAW]] - Outlaw character flag</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/defaultpos</title>
     <ns>0</ns>
     <id>1202400</id>
     <revision>
       <id>1708635</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of defaultpos.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= defaultpos =
field: [integer] &apos;&apos;&apos;.defaultpos&apos;&apos;&apos; (read-only)

The &apos;&apos;&apos;defaultpos&apos;&apos;&apos; field returns the default position a character will assume when not otherwise specified.

== Description ==
The &apos;&apos;&apos;defaultpos&apos;&apos;&apos; field is a read-only property of character units that returns the default position the character will assume when not otherwise specified. This field determines the character&apos;s default stance or posture when no explicit position is set.

The default position is used when characters are created, loaded, or when their position needs to be reset to a baseline state.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| defaultpos || integer || Read-only || Default position constant for the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
dilbegin show_default_position();
var
   target : unitptr;
code
{
   target := activator;
   
   if (target.type == UNIT_ST_PC or target.type == UNIT_ST_NPC)
   {
       act(&quot;Default position: &quot; + itoa(target.defaultpos), 
               A_ALWAYS, target, null, null, TO_CHAR);
   }
   else
   {
       act(&quot;This unit has no default position.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
   }
   
   quit;
} dilend

dilbegin reset_to_default();
var
   character : unitptr;
code
{
   character := activator;
   
   if (character.type == UNIT_ST_PC or character.type == UNIT_ST_NPC)
   {
       character.position := character.defaultpos;
       act(&quot;You are now in position &quot; + itoa(character.position), 
               A_ALWAYS, character, null, null, TO_CHAR);
   }
   
   quit;
} dilend

== Usage Notes ==
* Returns an integer representing the default position constant
* The field is read-only and cannot be modified directly through DIL
* Position constants are typically defined as POSITION_* constants

== Related Functions/Fields ==
* [[Manual:DIL_Manual/position|position]] - Current position of a character

== See Also ==
* [[Manual:DIL_Manual/POSITION_STANDING|POSITION_STANDING]] - Standing position constant
* [[Manual:DIL_Manual/POSITION_SLEEPING|POSITION_SLEEPING]] - Sleeping position constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/defensive</title>
     <ns>0</ns>
     <id>448850</id>
     <revision>
       <id>1362054</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of defensive.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= defensive =
 field: integer &apos;&apos;&apos;defensive&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;defensive&apos;&apos;&apos; field returns the character&apos;s defensive bonus value.

== Description ==
The defensive field is a read-only property of character units that returns the character&apos;s defensive bonus value. This field represents the character&apos;s defensive capabilities and is used in combat calculations to determine damage mitigation and defensive effectiveness.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.defensive || integer || The character&apos;s defensive bonus value
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
=== Basic Defense Display ===
 dilbegin show_defense();
 code
 {
    act(&quot;Defensive bonus: &quot; + itoa(activator.defensive), 
          A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Defense Comparison ===
 dilbegin compare_defense();
 var
    char1, char2 : unitptr;
 code
 {
    char1 := activator;
    char2 := medium;  // Assuming medium is another character
    
    if ((char1.type == UNIT_ST_PC or char1.type == UNIT_ST_NPC) and
        (char2.type == UNIT_ST_PC or char2.type == UNIT_ST_NPC)) {
       
       if (char1.defensive &gt; char2.defensive) {
          act(char1.name + &quot; is more defensive than &quot; + char2.name + &quot;.&quot;, 
             A_ALWAYS, char1, null, char2, null, TO_CHAR);
       } else if (char1.defensive &lt; char2.defensive) {
          act(char1.name + &quot; is less defensive than &quot; + char2.name + &quot;.&quot;, 
             A_ALWAYS, char1, null, char2, null, TO_CHAR);
       } else {
          act(char1.name + &quot; and &quot; + char2.name + &quot; have equal defensive capabilities.&quot;, 
             A_ALWAYS, char1, null, char2, null, TO_CHAR);
       }
    } else {
       act(&quot;Cannot compare - invalid unit types.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Defense Tier Analysis ===
 dilbegin analyze_defense();
 var
    character : unitptr;
    tier : string;
 code
 {
    character := activator;
    
    if (character.defensive &gt;= 80) {
       tier := &quot;Elite&quot;;
    } else if (character.defensive &gt;= 60) {
       tier := &quot;Expert&quot;;
    } else if (character.defensive &gt;= 40) {
       tier := &quot;Advanced&quot;;
    } else if (character.defensive &gt;= 20) {
       tier := &quot;Skilled&quot;;
    } else if (character.defensive &gt;= 0) {
       tier := &quot;Novice&quot;;
    } else {
       tier := &quot;None&quot;;
    }
    
    act(&quot;Defensive Tier: &quot; + tier, A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;Defensive Value: &quot; + itoa(character.defensive), 
          A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Combat Effectiveness ===
 dilbegin combat_effectiveness();
 var
    attacker, defender : unitptr;
 code
 {
    attacker := activator;
    defender := medium;
    
    if ((attacker.type == UNIT_ST_PC or attacker.type == UNIT_ST_NPC) and
        (defender.type == UNIT_ST_PC or defender.type == UNIT_ST_NPC)) {
       
       defense_bonus := defender.defensive - attacker.defensive;
       
       if (defense_bonus &gt; 50) {
          act(defender.name + &quot;&apos;s superior defense provides significant protection!&quot;, 
             A_ALWAYS, attacker, null, defender, null, TO_VICT);
       } else if (defense_bonus &gt; 20) {
          act(defender.name + &quot;&apos;s defense provides good protection!&quot;, 
             A_ALWAYS, attacker, null, defender, null, TO_VICT);
       } else if (defense_bonus &gt; 0) {
          act(defender.name + &quot;&apos;s defense provides some protection.&quot;, 
             A_ALWAYS, attacker, null, defender, null, TO_VICT);
       } else {
          act(defender.name + &quot; has no defensive bonus.&quot;, 
             A_ALWAYS, attacker, null, defender, null, TO_VICT);
       }
    } else {
       act(&quot;Cannot compare - invalid unit types.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* Only available on character units (UNIT_ST_PC and UNIT_ST_NPC)
* Returns an integer representing the defensive bonus
* The field is read-only and cannot be modified directly through DIL
* Used by combat systems, damage calculations, and defensive mechanics
* Higher values generally indicate better defensive capabilities
* The value is typically calculated based on equipment, skills, and other factors

== Error Handling ==
The field performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a character type
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid type
* &apos;&apos;&apos;Range validation&apos;&apos;&apos; - Validates defensive value is within reasonable bounds

== Related Functions ==
* [[Manual:DIL_Manual/charflags|charflags]] - Character flags and status
* [[Manual:DIL_Manual/combat|combat]] - Combat systems and damage calculations
* [[Manual:DIL_Manual/equipment|equipment]] - Equipment that affects defensive capabilities

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type
* [[Manual:DIL_Manual/combat mechanics|combat mechanics]] - Defensive and offensive systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/delcolor</title>
     <ns>0</ns>
     <id>886838</id>
     <revision>
       <id>943728</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of delcolor.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= delcolor =
 function: &apos;&apos;&apos;delcolor&apos;&apos;&apos;(unit : unitptr, color_name : string) : integer;

The &apos;&apos;&apos;delcolor&apos;&apos;&apos; function removes a color from a player character&apos;s color list.

== Description ==
The delcolor function removes a color from a player character&apos;s personal color list. This function allows players to manage their custom color settings by removing colors they no longer want to use.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The player character from which to delete the color
|-
| color_name || string || The name of the color to delete
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;1&apos;&apos;&apos; (TRUE) - If the color was successfully deleted
* &apos;&apos;&apos;0&apos;&apos;&apos; (FALSE) - If the color was not found or deletion failed

== Examples ==
=== Basic Color Removal ===
 dilbegin remove_color();
 code
 {
    if (delcolor(self, &quot;old_red&quot;)) {
       act(&quot;Color &apos;old_red&apos; has been removed from your list.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Color &apos;old_red&apos; was not found in your color list.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Conditional Color Removal ===
 dilbegin cleanup_colors();
 var
    colors_to_remove : stringlist;
 code
 {
    colors_to_remove := {&quot;old_red&quot;, &quot;bright_blue&quot;, &quot;dark_green&quot;};
    
    foreach (color_name in colors_to_remove) {
       if (delcolor(self, color_name)) {
          act(&quot;Color &apos;&quot; + color_name + &quot;&apos; has been removed.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    }
    
    act(&quot;Color cleanup completed. Removed &quot; + itoa(length(colors_to_remove)) + &quot; colors.&quot;, 
          A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Color Management System ===
 dilbegin color_manager();
 var
    command : string;
    color_name : string;
 code
 {
    wait(SFB_CMD, TRUE);
    command := argument;
    
    if (command == &quot;removecolor&quot;) {
       color_name := getword(argument, 1);
       
       if (color_name != &quot;&quot;) {
          if (delcolor(self, color_name)) {
             act(&quot;Color &apos;&quot; + color_name + &quot;&apos; removed successfully.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
          } else {
             act(&quot;Color &apos;&quot; + color_name + &quot;&apos; not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
          }
       } else {
          act(&quot;Usage: removecolor &lt;color_name&gt;&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else if (command == &quot;listcolors&quot;) {
       act(&quot;Your available colors:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       // Implementation would list all available colors
    } else {
       act(&quot;Unknown command. Available: removecolor, listcolors&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Color Validation ===
 dilbegin safe_remove_color();
 var
    color_name : string;
 code
 {
    color_name := argument;
    
    // Validate color name
    if (length(color_name) &gt; 20) {
       act(&quot;Color names must be 20 characters or less.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }
    
    if (delcolor(self, color_name)) {
       act(&quot;Color &apos;&quot; + color_name + &quot;&apos; removed successfully.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Color &apos;&quot; + color_name + &quot;&apos; not found or invalid.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* Only works on player characters (UNIT_ST_PC)
* The color name must be 20 characters or less and contain only alphanumeric characters and underscores
* Color names are case-sensitive
* Returns TRUE if color was found and deleted, FALSE if not found or failed
* Used to clean up unwanted or obsolete color entries
* The function performs security checks to prevent unauthorized color modifications

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a player character
* &apos;&apos;&apos;Color name validation&apos;&apos;&apos; - Checks color name length and valid characters
* &apos;&apos;&apos;Security check&apos;&apos;&apos; - Only allows color deletion on player&apos;s own color list

== Related Functions ==
* [[Manual:DIL_Manual/addcolor|addcolor]] - Add a color to a player&apos;s color list
* [[Manual:DIL_Manual/getcolor|getcolor]] - Get a color from a player&apos;s color list

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/color system|color system]] - Player color management</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/delete_player</title>
     <ns>0</ns>
     <id>905183</id>
     <revision>
       <id>933744</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of delete_player.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= delete_player =
function: &apos;&apos;&apos;delete_player&apos;&apos;&apos;(s : string);

The &apos;&apos;&apos;delete_player&apos;&apos;&apos; function permanently deletes a player character from the game world.

== Description ==
The &apos;&apos;&apos;delete_player&apos;&apos;&apos; function deletes a player character from the game. The deletion process includes:
* Removing the player from the global unit list if they are currently loaded
* Closing their descriptor if they are currently online
* Deleting their player file from disk

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The player name to delete
|}

== Examples ==
dilbegin delete_character(pname : string);
code
{
   if (isplayer(pname))
   {
      delete_player(pname);
      act(&quot;Player &quot; + pname + &quot; has been deleted.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
   }
   else
   {
      act(&quot;Player &quot; + pname + &quot; does not exist.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
   }
   quit;
} dilend

== Usage Notes ==
* The function does not verify if the player existed or was successfully deleted
* Use the isplayer() function to check if a player exists before attempting deletion
* The deletion is permanent and cannot be undone
* Only DIL programs running in zones with access level 0 can use this function

== Error Handling ==
The function includes security checks to prevent unauthorized use:
* Only DIL programs running in zones with access level 0 can use this function
* Attempts to use it from higher access level zones will be logged and the DIL program will terminate

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isplayer|isplayer]] - Check if a player exists

== See Also ==
* [[Manual:DIL_Manual/delete|delete]] - Delete non-player units</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/delstr</title>
     <ns>0</ns>
     <id>757355</id>
     <revision>
       <id>928696</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of delstr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= delstr =
 function: &apos;&apos;&apos;delstr&apos;&apos;&apos;(filename : string) : integer;

The &apos;&apos;&apos;delstr&apos;&apos;&apos; function deletes a string file from the game&apos;s file system.

== Description ==
The delstr function is used to delete files that are managed by the game&apos;s string file system (used with loadstr() and savestr() functions). This function operates with security restrictions to prevent unauthorized file deletion.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| filename || string || The name of the file to be deleted
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;1&apos;&apos;&apos; (TRUE) - If the file was successfully deleted
* &apos;&apos;&apos;0&apos;&apos;&apos; (FALSE) - If the file was not deleted or deletion failed

== Examples ==
=== Basic File Deletion ===
 dilbegin delete_news();
 code
 {
    if (delstr(&quot;news.txt&quot;)) {
       act(&quot;News file deleted successfully.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to delete news file.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Conditional File Management ===
 dilbegin manage_files();
 var
    command : string;
    filename : string;
 code
 {
    wait(SFB_CMD, TRUE);
    command := argument;
    
    if (command == &quot;deletefile&quot;) {
       filename := getword(argument, 1);
       
       if (filename != &quot;&quot;) {
          if (delstr(filename)) {
             act(&quot;File &apos;&quot; + filename + &quot;&apos; deleted successfully.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
          } else {
             act(&quot;File &apos;&quot; + filename + &quot;&apos; not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
          }
       } else {
          act(&quot;Usage: deletefile &lt;filename&gt;&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else if (command == &quot;listfiles&quot;) {
       act(&quot;File management commands: deletefile, listfiles&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Unknown command.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Secure File Deletion ===
 dilbegin secure_delete();
 var
    filename : string;
 code
 {
    filename := argument;
    
    // Validate filename
    if (filename == &quot;&quot; or length(filename) &gt; 50) {
       act(&quot;Invalid filename. Must be 1-50 characters.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }
    
    if (delstr(filename)) {
       act(&quot;File &apos;&quot; + filename + &quot;&apos; deleted securely.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to delete file or file not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* Only deletes files within the zone&apos;s designated string file directory
* Requires zone access level 10 or higher
* Filenames are validated for security (length limits, character restrictions)
* The deletion is permanent and cannot be undone
* Used for managing board messages, temporary data, or other string-based content
* The function performs security logging of all deletion attempts

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Zone validation&apos;&apos;&apos; - Ensures caller has sufficient zone access
* &apos;&apos;&apos;Filename validation&apos;&apos;&apos; - Checks filename length and valid characters
* &apos;&apos;&apos;Security check&apos;&apos;&apos; - Logs unauthorized deletion attempts
* &apos;&apos;&apos;File existence check&apos;&apos;&apos; - Returns FALSE if file doesn&apos;t exist

== Related Functions ==
* [[Manual:DIL_Manual/loadstr|loadstr]] - Load string files
* [[Manual:DIL_Manual/savestr|savestr]] - Save string files
* [[Manual:DIL_Manual/log|log]] - Log system messages

== See Also ==
* [[Manual:DIL_Manual/zone|zone]] - Zone pointer and access control
* [[Manual:DIL_Manual/string file system|string file system]] - Game file management</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/delunit</title>
     <ns>0</ns>
     <id>543493</id>
     <revision>
       <id>1281447</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of delunit.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= delunit =
 function: &apos;&apos;&apos;delunit&apos;&apos;&apos;(filename : string) : integer;

The &apos;&apos;&apos;delunit&apos;&apos;&apos; function deletes a unit file from the game&apos;s file system.

== Description ==
The delunit function is used to delete unit files that are managed by the game&apos;s unit file system (used with store() and restore() functions). This function operates with security restrictions to prevent unauthorized unit deletion.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| filename || string || The name of the unit file to be deleted
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;1&apos;&apos;&apos; (TRUE) - If the file was successfully deleted
* &apos;&apos;&apos;0&apos;&apos;&apos; (FALSE) - If the file was not deleted or deletion failed

== Examples ==
=== Basic Unit Deletion ===
 dilbegin delete_temp_unit();
 code
 {
    if (delunit(&quot;temp_guardian.unit&quot;)) {
       act(&quot;Temporary unit file deleted successfully.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to delete temporary unit file.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Unit File Management ===
 dilbegin manage_unit_files();
 var
    command : string;
    filename : string;
 code
 {
    wait(SFB_CMD, TRUE);
    command := argument;
    
    if (command == &quot;deleteunit&quot;) {
       filename := getword(argument, 1);
       
       if (filename != &quot;&quot;) {
          if (delunit(filename)) {
             act(&quot;Unit file &apos;&quot; + filename + &quot;&apos; deleted successfully.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
          } else {
             act(&quot;Unit file &apos;&quot; + filename + &quot;&apos; not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
          }
       } else {
          act(&quot;Usage: deleteunit &lt;filename&gt;&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else if (command == &quot;listunits&quot;) {
       act(&quot;Unit file management commands: deleteunit, listunits&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Unknown command.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Secure Unit Deletion ===
 dilbegin secure_unit_delete();
 var
    filename : string;
 code
 {
    filename := argument;
    
    // Validate filename
    if (filename == &quot;&quot; or length(filename) &gt; 50) {
       act(&quot;Invalid filename. Must be 1-50 characters.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }
    
    if (delunit(filename)) {
       act(&quot;Unit file &apos;&quot; + filename + &quot;&apos; deleted securely.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to delete unit file or file not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* Only deletes unit files within the zone&apos;s designated unit file directory
* Requires zone access level 10 or higher
* Filenames are validated for security (length limits, character restrictions)
* The deletion is permanent and cannot be undone
* Used for managing temporary NPCs, custom creatures, or other unit-based content
* The function performs security logging of all deletion attempts

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Zone validation&apos;&apos;&apos; - Ensures caller has sufficient zone access
* &apos;&apos;&apos;Filename validation&apos;&apos;&apos; - Checks filename length and valid characters
* &apos;&apos;&apos;Security check&apos;&apos;&apos; - Logs unauthorized deletion attempts
* &apos;&apos;&apos;File existence check&apos;&apos;&apos; - Returns FALSE if file doesn&apos;t exist

== Related Functions ==
* [[Manual:DIL_Manual/store|store]] - Store units to unit files
* [[Manual:DIL_Manual/restore|restore]] - Restore units from unit files
* [[Manual:DIL_Manual/log|log]] - Log system messages

== See Also ==
* [[Manual:DIL_Manual/zone|zone]] - Zone pointer and access control
* [[Manual:DIL_Manual/unit file system|unit file system]] - Game unit management</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/descr</title>
     <ns>0</ns>
     <id>595218</id>
     <revision>
       <id>1859201</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of descr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= descr =
field: [string] &apos;&apos;&apos;.descr&apos;&apos;&apos; (read-write)

The &apos;&apos;&apos;descr&apos;&apos;&apos; field accesses the description text from an extra description pointer.

== Description ==
The &apos;&apos;&apos;descr&apos;&apos;&apos; field is used to access the description text stored in an extra description structure. Extra descriptions are used throughout the game to provide additional descriptive text for objects, rooms, and characters that can be accessed through commands like &quot;look at&quot;, &quot;examine&quot;, or &quot;read&quot;.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| descr || string || Read-write || Description text of the extra description
|}

== Availability ==
This field is available on the following unit types:
* extraptr (Extra description pointer)

== Examples ==
dilbegin modify_extra_description(ed : extraptr);
code
{
   if (ed != null)
   {
      act(&quot;Current description: &quot; + ed.descr, A_ALWAYS, self, null, null, TO_CHAR);
      ed.descr := &quot;This is a new description.&quot;;
      act(&quot;Description updated.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
   }
   quit;
} dilend

== Usage Notes ==
* This field is read-write - you can both read and modify the description text
* The field is accessed through an extraptr variable
* Extra descriptions are commonly used for object descriptions, room details, and character descriptions

== Related Functions/Fields ==
* [[Manual:DIL_Manual/extraptr|extraptr]] - Extra description pointer type
* [[Manual:DIL_Manual/addextra|addextra]] - Add extra descriptions
* [[Manual:DIL_Manual/subextra|subextra]] - Remove extra descriptions

== See Also ==
* [[Manual:DIL_Manual/in|in]] - Search extra descriptions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/destroy</title>
     <ns>0</ns>
     <id>527271</id>
     <revision>
       <id>1446304</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of destroy.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= destroy =
 function: &apos;&apos;&apos;destroy&apos;&apos;&apos;(unit : unitptr);

The &apos;&apos;&apos;destroy&apos;&apos;&apos; function permanently removes a unit from the game world.

== Description ==
The destroy function permanently removes a unit from the game world. The behavior depends on the type of unit being destroyed:

=== For Player Characters (PCs) ===
* The player is saved and ejected from the game
* The player&apos;s descriptor is closed
* All references to the unit are cleaned up
* The player&apos;s equipment is unequipped and dropped to the ground
* The player is removed from all containing units

=== For NPCs and Objects ===
* The unit is immediately removed from the game
* All references to the unit are cleaned up
* The unit is removed from memory
* The unit&apos;s equipment is dropped to the ground
* The unit is removed from all containing units

=== For Rooms ===
* The function will have no effect on room units
* Rooms cannot be destroyed using this function

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit to remove from the game
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;1&apos;&apos;&apos; (TRUE) - If the unit was successfully destroyed
* &apos;&apos;&apos;0&apos;&apos;&apos; (FALSE) - If the unit was not found or destruction failed

== Examples ==
=== Basic Unit Destruction ===
 dilbegin destroy_item();
 var
    item : unitptr;
 code
 {
    item := findunit(self, &quot;sword&quot;, FIND_UNIT_IN_ME, null);
    
    if (item) {
       destroy(item);
       act(&quot;You destroy the &quot; + item.title + &quot;.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;No item found to destroy.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== NPC Removal ===
 dilbegin remove_npc();
 var
    npc : unitptr;
 code
 {
    npc := findunit(self, &quot;guard&quot;, FIND_UNIT_SURRO, null);
    
    if (npc and npc.type == UNIT_ST_NPC) {
       destroy(npc);
       act(&quot;The guard disappears in a puff of smoke.&quot;, A_ALWAYS, self, null, null, TO_ROOM);
    } else {
       act(&quot;No guard found to remove.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Player Logout ===
 dilbegin force_logout();
 var
    player : unitptr;
 code
 {
    player := activator;
    
    if (player and player.type == UNIT_ST_PC) {
       act(&quot;You are forcibly logged out.&quot;, A_ALWAYS, player, null, null, TO_CHAR);
       destroy(player);
    } else {
       act(&quot;No player found to logout.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Conditional Destruction ===
 dilbegin conditional_destroy();
 var
    target : unitptr;
 code
 {
    target := findunit(self, argument, FIND_UNIT_SURRO, null);
    
    if (target) {
       if (target.type == UNIT_ST_OBJ) {
          destroy(target);
          act(&quot;You destroy the &quot; + target.title + &quot;.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       } else if (target.type == UNIT_ST_NPC) {
          act(&quot;You cannot destroy living beings.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       } else {
          act(&quot;You can only destroy objects and NPCs.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;No target found to destroy.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* The destruction is permanent and cannot be undone
* For player characters, this is equivalent to force logout
* The function handles cleanup of all references to the destroyed unit
* Equipment is dropped to the ground before destruction
* The function performs security checks to prevent unauthorized destruction
* Use with caution - especially with player characters

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Security check&apos;&apos;&apos; - Prevents destruction of protected units
* &apos;&apos;&apos;Type validation&apos;&apos;&apos; - Returns fail if unit is not a valid type
* &apos;&apos;&apos;Permission check&apos;&apos;&apos; - Ensures caller has authority to destroy target

== Related Functions ==
* [[Manual:DIL_Manual/remove|remove]] - Remove units from rooms
* [[Manual:DIL_Manual/unequip|unequip]] - Remove equipment from characters
* [[Manual:DIL_Manual/logout|logout]] - Force player logout (safer alternative)

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object unit type
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room unit type</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/dilcall</title>
     <ns>0</ns>
     <id>600133</id>
     <revision>
       <id>1453385</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of dilcall.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= dilcall =
 function: &apos;&apos;&apos;dilcall&apos;&apos;&apos;(template_name : string, unit : unitptr, priority : integer, argument : string) : integer;

The &apos;&apos;&apos;dilcall&apos;&apos;&apos; function dynamically calls a DIL template by name.

== Description ==
The dilcall function allows dynamic invocation of DIL templates by name at runtime. This enables flexible program flow and modular DIL design where specific DIL programs can be called based on conditions or user input.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| template_name || string || The name of the DIL template to call
|-
| unit || unitptr || The unit that will be the &quot;self&quot; context in the called DIL
|-
| priority || integer || Priority level for the called DIL program
|-
| argument || string || String argument to pass to the called DIL program
|}

== Return Value ==
Returns an integer:
* &apos;&apos;&apos;1&apos;&apos;&apos; (TRUE) - If the template was found and call was initiated
* &apos;&apos;&apos;0&apos;&apos;&apos; (FALSE) - If the template was not found or call failed
* &apos;&apos;&apos;Error value&apos;&apos;&apos; - If parameters are invalid

== Examples ==
=== Basic Template Call ===
 dilbegin call_template();
 var
    result : integer;
 code
 {
    result := dilcall(&quot;healing_spell&quot;, self, 0, &quot;minor&quot;);
    
    if (result == 1) {
       act(&quot;Healing spell template called successfully.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to call healing spell template.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Priority-Based Call ===
 dilbegin priority_call();
 var
    result : integer;
 code
 {
    result := dilcall(&quot;combat_action&quot;, self, 5, &quot;attack&quot;);
    
    if (result == 1) {
       act(&quot;High priority combat action template called.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to call combat action template.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Argument Passing ===
 dilbegin argument_call();
 var
    result : integer;
 code
 {
    result := dilcall(&quot;message_handler&quot;, self, 0, &quot;Hello &quot; + activator.name);
    
    if (result == 1) {
       act(&quot;Message handler template called with argument.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to call message handler template.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Dynamic Quest System ===
 dilbegin quest_router();
 var
    quest_type : string;
    result : integer;
 code
 {
    quest_type := argument;
    
    if (quest_type == &quot;delivery&quot;) {
       result := dilcall(&quot;delivery_quest&quot;, self, 0, &quot;&quot;);
    } else if (quest_type == &quot;rescue&quot;) {
       result := dilcall(&quot;rescue_quest&quot;, self, 0, &quot;&quot;);
    } else if (quest_type == &quot;exploration&quot;) {
       result := dilcall(&quot;exploration_quest&quot;, self, 0, &quot;&quot;);
    } else {
       result := dilcall(&quot;default_quest&quot;, self, 0, &quot;&quot;);
    }
    
    if (result == 1) {
       act(&quot;Quest template &apos;&quot; + quest_type + &quot;&apos; activated.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Unknown quest type: &quot; + quest_type, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Error Handling ===
 dilbegin template_error();
 var
    result : integer;
 code
 {
    result := dilcall(&quot;nonexistent&quot;, self, 0, &quot;&quot;);
    
    if (result == 0) {
       act(&quot;Template not found error handled correctly.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Unexpected error in template call.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* The template name must be a valid DIL template that exists in the zone
* The called DIL program runs with the specified unit as its &quot;self&quot; context
* Priority levels control execution order for multiple pending calls
* Arguments are passed as strings to the called DIL program
* The function enables modular and dynamic DIL programming
* Commonly used for quest systems, event handling, and plugin architectures

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Template validation&apos;&apos;&apos; - Ensures template name exists in zone
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Parameter validation&apos;&apos;&apos; - Validates all parameter types
* &apos;&apos;&apos;Security check&apos;&apos;&apos; - Prevents unauthorized template invocation
* &apos;&apos;&apos;Priority validation&apos;&apos;&apos; - Ensures priority is within valid range

== Related Functions ==
* [[Manual:DIL_Manual/dilcopy|dilcopy]] - Create a copy of a DIL template
* [[Manual:DIL_Manual/dilfind|dilfind]] - Find DIL programs on units
* [[Manual:DIL_Manual/dildestroy|dildestroy]] - Destroy DIL programs

== See Also ==
* [[Manual:DIL_Manual/DIL templates|DIL templates]] - Template system and modular programming
* [[Manual:DIL_Manual/dynamic programming|dynamic programming]] - Runtime code generation and execution
* [[Manual:DIL_Manual/quest system|quest system]] - Dynamic quest and event handling</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/dilcopy</title>
     <ns>0</ns>
     <id>1158290</id>
     <revision>
       <id>1812408</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of dilcopy.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= dilcopy =
 function: &apos;&apos;&apos;dilcopy&apos;&apos;&apos;(template_name : string, unit : unitptr) : unitptr;

The &apos;&apos;&apos;dilcopy&apos;&apos;&apos; function creates and attaches a new DIL program instance to a unit using a specified template.

== Description ==
The dilcopy function creates and attaches a new DIL program instance to a unit using a specified template. This enables modular DIL programming where multiple instances of the same DIL program can be attached to different units, each running independently with its own context and variables.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| template_name || string || The name of the DIL template to copy
|-
| unit || unitptr || The unit to attach the new DIL program to
|}

== Return Value ==
Returns a unit pointer:
* &apos;&apos;&apos;unitptr&apos;&apos;&apos; - Pointer to the newly created DIL program instance
* &apos;&apos;&apos;null&apos;&apos;&apos; - If the template was not found or copy failed

== Examples ==
=== Basic Program Copy ===
 dilbegin copy_guard();
 var
    new_guard : unitptr;
 code
 {
    new_guard := dilcopy(&quot;guard_template&quot;, self);
    
    if (new_guard) {
       link(new_guard, self);
       act(&quot;New guard created and linked to you.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to create guard.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Multiple Program Instances ===
 dilbegin create_patrol();
 var
    i : integer;
    new_guard : unitptr;
 code
 {
    for (i := 0; i &lt; 3; i := i + 1) {
       new_guard := dilcopy(&quot;guard_template&quot;, self);
       
       if (new_guard) {
          link(new_guard, self);
          act(&quot;Guard &quot; + itoa(i + 1) + &quot; created.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       } else {
          act(&quot;Failed to create guard &quot; + itoa(i + 1) + &quot;.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    }
    
    act(&quot;Patrol created with &quot; + itoa(i) + &quot; guards.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

=== Program with Arguments ===
 dilbegin custom_guard();
 var
    new_guard : unitptr;
    guard_name : string;
 code
 {
    guard_name := argument;
    
    if (guard_name != &quot;&quot;) {
       new_guard := dilcopy(&quot;guard_template&quot;, self);
       
       if (new_guard) {
          // Set custom name
          new_guard.title := &quot;Guard &quot; + guard_name;
          link(new_guard, self);
          act(&quot;Custom guard &apos;&quot; + guard_name + &quot;&apos; created.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       } else {
          act(&quot;Failed to create custom guard.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    } else {
       act(&quot;No guard name specified.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

=== Independent Program ===
 dilbegin independent_program();
 var
    new_program : unitptr;
 code
 {
    new_program := dilcopy(&quot;independent_npc&quot;, self);
    
    if (new_program) {
       link(new_program, self.outside);
       act(&quot;Independent NPC program created.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    } else {
       act(&quot;Failed to create independent program.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    quit;
 } dilend

== Usage Notes ==
* The template name must be a valid DIL template that exists in the zone
* The new DIL program runs independently with its own execution context
* Multiple instances of the same template can be attached to different units
* The copied program inherits all properties and DIL code from the template
* Each instance has its own variable space and execution state
* Commonly used for creating multiple NPCs with similar behavior
* The function enables modular and reusable DIL programming

== Error Handling ==
The function performs validation:
* &apos;&apos;&apos;Template validation&apos;&apos;&apos; - Ensures template name exists in zone
* &apos;&apos;&apos;Unit validation&apos;&apos;&apos; - Ensures unit is a valid unit pointer
* &apos;&apos;&apos;Copy validation&apos;&apos;&apos; - Validates that the copy operation succeeds
* &apos;&apos;&apos;Security check&apos;&apos;&apos; - Prevents unauthorized template copying

== Related Functions ==
* [[Manual:DIL_Manual/dilcall|dilcall]] - Call DIL templates dynamically
* [[Manual:DIL_Manual/dilfind|dilfind]] - Find DIL programs on units
* [[Manual:DIL_Manual/dildestroy|dildestroy]] - Destroy DIL programs
* [[Manual:DIL_Manual/link|link]] - Move units between locations

== See Also ==
* [[Manual:DIL_Manual/DIL templates|DIL templates]] - Template system and modular programming
* [[Manual:DIL_Manual/dynamic programming|dynamic programming]] - Runtime code generation and execution
* [[Manual:DIL_Manual/modular design|modular design]] - Reusable program components</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/dildestroy</title>
     <ns>0</ns>
     <id>933794</id>
     <revision>
       <id>1097350</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of dildestroy.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= dildestroy =
 function: integer &apos;&apos;&apos;dildestroy&apos;&apos;&apos;(s : string, u : unitptr);

&apos;&apos;&apos;dildestroy&apos;&apos;&apos; is a DIL function that removes DIL programs from units based on template name.

== Description ==
The dildestroy function searches for and removes DIL programs attached to a specified unit that match the given template name. This allows for precise removal of specific DIL instances without affecting other programs running on the same unit.

The function:
* Searches all DIL programs attached to the target unit
* Matches programs by template name (exact string match)
* Removes all matching programs from the unit
* Returns count of programs successfully destroyed

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || Name of DIL template to delete from unit
|-
| u || unitptr || Unit to remove DIL program from
|}

== Error Handling ==
The function performs error checking:
* Returns error value if parameters are invalid
* Returns 0 if no matching DIL programs are found
* Returns count of programs successfully destroyed

== Usage Notes ==
* Only removes programs matching the exact template name specified
* Multiple instances of the same template can be destroyed with one call
* The function is commonly used for:
** Cleaning up temporary effect programs
** Removing quest triggers when completed
** Stopping recurring behaviors
** Managing state-based DIL attachments

== Example ==
 dilbegin item_charge(base_charge:integer);
 external
   string accept_dil@function (pc:unitptr,s:string);

 var
    thing   : unitptr;
    pc      : unitptr;
    answer  : string;

 code
 {
 :start:
    wait (SFB_DONE,( (command(&quot;give&quot;)) and (self==target) ));

    pc:=activator;
    thing:=medium;
    secure(pc,lost_pc);
    secure(thing,lost_pc);

    dilcopy (&quot;busy@function(Please wait I am busy with other work right now.&quot;, self);

    // ... processing logic ...

 :give_back:
    act( self.name + &quot; returns your &quot; + thing.name + &quot; to you.&quot;,
        A_ALWAYS,pc,null,null,TO_CHAR);
    act(self.name + &quot; returns $1n&apos;s &quot; + thing.name + &quot; to $1m.&quot;,
        A_SOMEONE,pc,null,null,TO_REST);
    link(thing,pc);

 :lost_pc:
    // Remove the busy message DIL program
    die := dildestroy (&quot;busy@function&quot;,self);
    unsecure(pc);
    unsecure(thing);
    goto start;
 } dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/dilcopy|dilcopy]] - Attach DIL programs to units
* [[Manual:DIL_Manual/dilfind|dilfind]] - Find DIL programs on units
* [[Manual:DIL_Manual/dilcall|dilcall]] - Call DIL templates dynamically

== See Also ==</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/dilfind</title>
     <ns>0</ns>
     <id>975471</id>
     <revision>
       <id>1222768</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of dilfind.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= dilfind =
 function: integer &apos;&apos;&apos;dilfind&apos;&apos;&apos;(s : string, u : unitptr);

&apos;&apos;&apos;dilfind&apos;&apos;&apos; is a DIL function that checks if a DIL program with a specific template name is attached to a unit.

== Description ==
The dilfind function searches for DIL programs attached to a specified unit and checks if any of them match the given template name. This allows for conditional logic based on whether specific DIL programs are currently active on a unit.

The function:
* Searches all DIL programs attached to the target unit
* Matches programs by template name (exact string match)
* Returns TRUE if at least one matching program is found
* Returns FALSE if no matching programs are found

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || Name of DIL template to find
|-
| u || unitptr || Unit to search for DIL program on
|}

== Error Handling ==
The function performs error checking:
* Returns TRUE (1) if a DIL program with the specified template name is found on the unit
* Returns FALSE (0) if no matching DIL program is found
* Returns error value if parameters were invalid
* Template name matching is case-sensitive

== Usage Notes ==
* Only checks for existence of programs, doesn&apos;t provide access to them
* The function is commonly used for:
** Checking if temporary effects are active
** Preventing duplicate program attachments
** Verifying quest states
** Managing conditional behaviors

== Example ==
 dilbegin look_signature();
 var
   pc:unitptr;
 code
 {
   heartbeat:=PULSE_SEC*3;
 :start:
   wait (SFB_CMD,(
   (command (&quot;look&quot;)) and
   ((&quot;signature&quot;==argument ) or (&quot;signatures&quot; == argument))
   ));
   block;
   pc:=ghead();
   sendtext (&quot;The following book signers are on line.&lt;br/&gt;&lt;br/&gt;&quot;,activator);

      while (pc.type==UNIT_ST_PC)
       {
       if (((isset (pc.pcflags,PC_PK_RELAXED)) or
		(dilfind (&quot;no_kill@function&quot;,pc))) and
       (pc.level&lt;200) and
       (visible (activator,pc)))
      sendtext(pc.name+&quot; &quot;+pc.title+&quot;&lt;br/&gt;&quot;,activator);
       pc:=pc.gnext;
       }

 goto start;
 } dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/dilcopy|dilcopy]] - Attach DIL programs to units
* [[Manual:DIL_Manual/dildestroy|dildestroy]] - Remove DIL programs from units
* [[Manual:DIL_Manual/dilcall|dilcall]] - Call DIL templates dynamically

== See Also ==</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/dispatch</title>
     <ns>0</ns>
     <id>352752</id>
     <revision>
       <id>1731703</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of dispatch.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= dispatch =
 function: &apos;&apos;&apos;dispatch&apos;&apos;&apos;(s : string);

&apos;&apos;&apos;dispatch&apos;&apos;&apos; is a DIL function that sends a message to the MUD&apos;s dispatcher system for external processing.

== Description ==
The dispatch function sends a string message to the MUD&apos;s external dispatcher system. This allows DIL programs to communicate with external processes and services that are monitoring or managing the game world.

The dispatcher system typically handles:
* External service communication
* Cross-system messaging
* Administrative notifications
* Integration with external tools and services

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || String message to send to the dispatcher system
|}

== Error Handling ==
The function performs basic error checking:
* Returns fail if the dispatcher system is unavailable
* Returns fail if the message parameter is invalid

== Usage Notes ==
* Messages are sent to the system&apos;s pipe dispatcher
* The function is commonly used for:
** Bug reporting systems
** External logging services
** Integration with Discord/IRC bots
** Administrative notifications
** Cross-server communication

== Example ==
 dilbegin aware cmd_bugs(st : string);
 var
    t : string;
    z : unitptr;
    i : integer;
 code
 {
    if (self.type!=UNIT_ST_PC)
       return;
    sendtext(&quot;Enter your bug reports. You have approximately 4000 &quot;+
             &quot;characters to work with. Note that if you input only a &quot;+
             &quot;single word or nothing at all, it will abort.&lt;br/&gt;&quot;, self);
    beginedit(self);
    wait(SFB_EDIT, self == activator);
    t := argument;
    if (length(getwords(t)) &lt; 2)
    {
       sendtext(&quot;Insufficient report. Exiting.&lt;br/&gt;&quot;, self);
       quit;
    }
    z := self.outside;
    while (z.type != UNIT_ST_ROOM)
       z := z.outside;
    t := z.symname + &quot; [&quot;+self.name+&quot;] &quot; + asctime(realtime)+ argument;
    t := textformat(t);
    i := flog(&quot;bugs&quot;, t, &quot;a&quot;);
    sendtext(&quot;Thank you. They will be corrected.&lt;br/&gt;&quot;, self);
    dispatch(&quot;discord msg #bugs @&quot; + self.name + &quot; bug report: &quot; + t); // Send to dispatcher.py via pipeDispatcher

    quit;
 } dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/flog|flog]] - Write to log files
* [[Manual:DIL_Manual/log|log]] - Log messages to system
* [[Manual:DIL_Manual/sendtext|sendtext]] - Send text to players

== See Also ==</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/drunk</title>
     <ns>0</ns>
     <id>493411</id>
     <revision>
       <id>1519195</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of drunk.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= drunk =
 field: integer &apos;&apos;&apos;.drunk&apos;&apos;&apos; (Read-only)

&apos;&apos;&apos;drunk&apos;&apos;&apos; is a field accessor that retrieves the drunkenness level of a player character.

== Description ==
The drunk field provides access to a player character&apos;s current intoxication level. This value affects various game mechanics and can be used to determine if a character is under the influence of alcohol.

The drunkenness level typically ranges from:
* 0: Sober
* 1-10: Slightly intoxicated
* 10+: Drunk (visible in score display)

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unitptr.drunk || integer || Current drunkenness level of the character (Read-only)
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Usage Notes ==
* The value is modified by consuming alcoholic beverages
* Higher drunkenness levels may affect:
** Combat abilities and penalties
** Movement and coordination
** Speech and communication
** Visual perception
* The field is commonly used in:
** Bar and tavern systems
** Alcohol-related quests
** Combat calculations
** Score displays

== Example ==
 dilbegin do_score(arg:string);
 var
    stat : string;
 code
 {
    // am i drunk hungry thirsty?
    if (self.drunk &gt; 10 )
       stat :=&quot;&lt;div class=&apos;score&apos;&gt;You are drunk!&lt;/div&gt;&quot;;
    else
       stat := &quot;&quot;;

    // Display in score output
    act(&quot;Your status: &quot;+stat, A_ALWAYS, self, null, null, TO_CHAR);
 } dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/thirst|thirst]] - Character thirst level
* [[Manual:DIL_Manual/full|full]] - Character hunger level

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc|unit_st_pc]] - Player character fields</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/editing</title>
     <ns>0</ns>
     <id>873718</id>
     <revision>
       <id>1712347</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of editing.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= editing =
 field: integer &apos;&apos;&apos;.editing&apos;&apos;&apos; (Read-only)

&apos;&apos;&apos;editing&apos;&apos;&apos; is a field accessor that checks if a player character is currently in text editing mode.

== Description ==
The editing field indicates whether a player character is currently in text editing mode. This typically occurs when players are writing messages, notes, board posts, or other text content using the game&apos;s built-in editor.

The editing mode is activated by:
* Using the &apos;&apos;&apos;beginedit&apos;&apos;&apos; function
* Writing on message boards
* Creating notes or letters
* Other text input scenarios

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unitptr.editing || integer || TRUE (1) if editing, FALSE (0) if not editing (Read-only)
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Usage Notes ==
* The value is automatically managed by the game system
* The field is commonly used to:
** Prevent multiple simultaneous editing sessions
** Handle interruptions during editing
** Manage board and note systems
** Control text input flows

== Example ==
 dilbegin aware do_write (arg:string);
 var
    u:unitptr;
 code
 {
    if (self.type!=UNIT_ST_PC)
       quit;

    // Check if player is already editing
    if (self.editing)
    {
       act(&quot;You are already editing something.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Start editing session
    beginedit(self);
    wait(SFB_EDIT, self==activator);
    
    // Player is now done editing
    act(&quot;Done editing&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 } dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/beginedit|beginedit]] - Put a player into editing mode
* [[Manual:DIL_Manual/killedit|killedit]] - Stop editing before completion

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc|unit_st_pc]] - Player character fields</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/endurance</title>
     <ns>0</ns>
     <id>1230770</id>
     <revision>
       <id>1556291</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of endurance.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= endurance =
 field: integer &apos;&apos;&apos;.endurance&apos;&apos;&apos; (Read/Write)

&apos;&apos;&apos;endurance&apos;&apos;&apos; is a field accessor that retrieves the current endurance points of a character.

== Description ==
The endurance field provides access to a character&apos;s current endurance (stamina) points. Endurance represents physical stamina and is consumed by various activities such as:

* Fighting and combat actions
* Physical exertion and movement
* Special abilities and skills
* Extended activities

Endurance works alongside:
* &apos;&apos;&apos;max_endurance&apos;&apos;&apos; - The maximum endurance a character can have
* &apos;&apos;&apos;hp&apos;&apos;&apos; - Health points
* &apos;&apos;&apos;mana&apos;&apos;&apos; - Magic points

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unitptr.endurance || integer || Current endurance points of the character (Read/Write)
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Usage Notes ==
* Endurance naturally regenerates over time
* When endurance reaches 0, characters may become exhausted or incapacitated
* The field is commonly used in:
** Combat systems
** Fatigue mechanics
** Physical skill systems
** Movement and travel systems

== Example ==
 dilbegin nokill();
 var
    pc : unitptr;
 code
 {
    heartbeat := 3 * PULSE_SEC;
 :start:
    wait(SFB_COM, self.position == POSITION_FIGHTING);
    pc := self.fighting;
    if (pc.level &gt; 200) goto start;
    secure(pc,gone);
    if (command(&quot;flee&quot;))
       block;

    // Check opponent&apos;s endurance before attacking
    if (pc.endurance &lt; 2)
       act(&quot;Your opponent looks exhausted.&quot;, A_ALWAYS, self, null, pc, TO_CHAR);
    else
    {
       self.hp:= self.max_hp;
       act(&quot;$1n grabs a large oak staff from behind $1m.&quot;, A_ALWAYS, self, null, pc, TO_VICT);
       act(&quot;With a surprisingly swift move he swings, connecting with your head and knocking you unconscious!&quot;, A_ALWAYS, self, null, pc, TO_VICT);
       
       pc.hp:= 0;
       pc.endurance:= 0;
       position_update(pc);
    }
 :gone:
    unsecure(pc);
    goto start;
 } dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/max_endurance|max_endurance]] - Maximum endurance points
* [[Manual:DIL_Manual/hp|hp]] - Health points
* [[Manual:DIL_Manual/mana|mana]] - Magic points

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc|unit_st_pc]] - Player character fields</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/equip</title>
     <ns>0</ns>
     <id>1132142</id>
     <revision>
       <id>1286376</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of equip.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= equip =
 function: unitptr &apos;&apos;&apos;equip&apos;&apos;&apos;(u : unitptr, i : integer);

&apos;&apos;&apos;equip&apos;&apos;&apos; is a function that retrieves the unit currently equipped in a specific equipment position.

== Description ==
The equip function searches a character&apos;s equipment slots and returns the item currently equipped in the specified position. This allows DIL programs to examine, manipulate, or check specific equipped items.

Common equipment positions include:
* WEAR_WRIST_R, WEAR_WRIST_L - Wrist slots
* WEAR_FINGER_R, WEAR_FINGER_L - Finger slots  
* WEAR_NECK - Neck slot
* WEAR_BODY - Body slot
* WEAR_HEAD - Head slot
* WEAR_FEET - Feet slot
* WEAR_HANDS - Hand slot
* WEAR_ARMS - Arm slot
* WEAR_ABOUT - About body (cloaks)
* WEAR_WAIST - Waist slot
* WEAR_SHIELD - Shield slot
* WEAR_BACK - Back slot

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The character to search for equipment
|-
| i || integer || The equipment position to check (any of the WEAR_* constants)
|}

== Error Handling ==
The function performs error checking:
* Returns null if no item is equipped in the specified position
* Returns fail if the character parameter is invalid or not a character unit
* Returns fail if the equipment position is invalid

== Usage Notes ==
* The function only works on character units (PCs and NPCs)
* Equipment positions are defined by WEAR_* constants in values.h
* The function is commonly used for:
** Equipment checking and validation
** Item manipulation and replacement
** Combat calculations based on gear
** Special effect processing

== Example ==
 dilbegin fnpri(FN_PRI_RESCUE-1) aware unique cuffed(depname : string);
 var
    cuffs  : unitptr;
    deputy : unitptr;
 code
 {
    cuffs := equipment(self, WEAR_WRIST_R);
    secure(cuffs, broken);
    
    deputy := self.master;
    secure(deputy, broken);
    
    if ((deputy == null) or (cuffs == null))
    {
       log(&quot;Cuffed lost either deputy or cuffs&quot;);
       goto broken;
    }
    
    heartbeat := PULSE_SEC * 1;
    
 :loop:
    if (cuffs.equip != WEAR_WRIST_R)
       goto broken;
    priority;
    wait(SFB_TICK|SFB_CMD, activator == self);
    goto loop;
    
 :broken:
    i := dildestroy(&quot;cuffed2@midgaard&quot;, self);
    quit;
 } dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addequip|addequip]] - Equip items to characters
* [[Manual:DIL_Manual/unequip|unequip]] - Remove items from characters
* [[Manual:DIL_Manual/equipment|equipment]] - Equipment field (different function)

== See Also ==</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/equipment</title>
     <ns>0</ns>
     <id>1205318</id>
     <revision>
       <id>1059635</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of equipment.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= equipment =

The &apos;&apos;&apos;equipment&apos;&apos;&apos; function is a built-in DIL (DikuMUD Interactive Language) function that retrieves the unit (object) currently equipped in a specific wear position on a character.

== Syntax ==
 unitptr equipment(unitptr character, integer wear_position)

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| character || unitptr || The character (PC or NPC) to search for equipped items
|-
| wear_position || integer || The equipment position to check (WEAR_* constant)
|}

== Return Value ==
Returns a unit pointer to the equipped item:
* &apos;&apos;&apos;unitptr&apos;&apos;&apos; - The item equipped in the specified position
* &apos;&apos;&apos;null&apos;&apos;&apos; - If no item is equipped in that position
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If the character parameter is invalid or not a character unit

== WEAR_* Constants ==
The wear_position parameter accepts any of the following constants defined in values.h or vme.h:

{| class=&quot;wikitable&quot;
! Constant !! Description
|-
| WEAR_FINGER_L || Left finger
|-
| WEAR_FINGER_R || Right finger
|-
| WEAR_NECK_1 || First neck slot
|-
| WEAR_NECK_2 || Second neck slot
|-
| WEAR_BODY || Body/armor slot
|-
| WEAR_HEAD || Head slot
|-
| WEAR_LEGS || Legs slot
|-
| WEAR_FEET || Feet slot
|-
| WEAR_HANDS || Hands slot
|-
| WEAR_ARMS || Arms slot
|-
| WEAR_ABOUT || About body (cloaks)
|-
| WEAR_WAIST || Waist slot
|-
| WEAR_WRIST_L || Left wrist
|-
| WEAR_WRIST_R || Right wrist
|-
| WEAR_WIELD || Weapon wield slot
|-
| WEAR_HOLD || Held item slot
|-
| WEAR_SHIELD || Shield slot
|-
| WEAR_CHEST || Chest slot
|-
| WEAR_BACK || Back slot
|-
| WEAR_EAR_L || Left ear
|-
| WEAR_EAR_R || Right ear
|-
| WEAR_ANKLE_L || Left ankle
|-
| WEAR_ANKLE_R || Right ankle
|}

== Examples ==
=== Basic Equipment Check ===
 dilbegin check_weapon(player : unitptr);
 var
    weapon : unitptr;
 code
 {
    weapon := equipment(player, WEAR_WIELD);
    if (weapon != null) {
       send(&quot;You are wielding &quot; + weapon.name + &quot;.&quot;, player);
    } else {
       send(&quot;You are not wielding anything.&quot;, player);
    }
    return;
 } dilend

=== Equipment Removal ===
 dilbegin cuff_target(deputy : unitptr, targ : unitptr, cuffs : unitptr);
 var
    depname : string;
 code
 {
    act(&quot;You cuff $3n.&quot;, A_SOMEONE, deputy, null, targ, TO_CHAR);
    act(&quot;$1n surprises you and put $2n around your wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_VICT);
    act(&quot;$1n puts $2n around $3N&apos;s wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_NOTVICT);

    follow(targ, deputy);
    depname := deputy.name;
    link(cuffs, targ);
    unequip(equipment(targ, WEAR_WRIST_R));
    addequip(cuffs, WEAR_WRIST_R);
    dilcopy(&quot;cuffed@midgaard(&quot;+depname+&quot;)&quot;, targ);
    dilcopy(&quot;cuffed2@midgaard(&quot;+depname+&quot;)&quot;, targ);

    exec(&quot;sigh&quot;, targ); /* Do this to activate the DILs */
    return;
 } dilend

=== Multiple Equipment Check ===
 dilbegin check_armor(character : unitptr);
 var
    armor, helmet, boots : unitptr;
 code
 {
    armor := equipment(character, WEAR_BODY);
    helmet := equipment(character, WEAR_HEAD);
    boots := equipment(character, WEAR_FEET);
    
    if ((armor != null) and (helmet != null) and (boots != null)) {
       send(&quot;You are fully equipped with armor.&quot;, character);
    } else {
       send(&quot;You are missing some armor pieces.&quot;, character);
    }
    return;
 } dilend

== Error Handling ==
The function performs comprehensive error checking:
* &apos;&apos;&apos;Type validation&apos;&apos; - Ensures first parameter is unitptr, second is integer
* &apos;&apos;&apos;Unit validation&apos;&apos; - Checks that the character unit is valid and is actually a character
* &apos;&apos;&apos;Null handling&apos;&apos; - Returns null if no item is equipped in the position
* &apos;&apos;&apos;Fail handling&apos;&apos; - Returns fail if parameters are invalid

Note: The C implementation shows that the function validates the character unit using the isChar() method to ensure it&apos;s a valid character before proceeding with the equipment lookup.

== Related Functions ==
* [[Manual:DIL_Manual/addequip|addequip]] - Equips an item in a specific position
* [[Manual:DIL_Manual/unequip|unequip]] - Removes an equipped item
* [[Manual:DIL_Manual/fits|fits]] - Checks if an item can be equipped in a position

== Usage Notes ==
* The function only works on character units (PCs and NPCs), not on rooms or objects
* Always check for null return values before using the returned unit pointer
* The function is read-only - it does not modify equipment state
* Use with addequip() and unequip() for complete equipment management
* WEAR_* constants are defined in values.h and vme.h header files
* The function is commonly used in equipment management, combat checks, and item validation

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type
* [[Manual:DIL_Manual/WEAR_* constants|WEAR_* constants]] - Equipment position constants
* [[Manual:DIL_Manual/manipulate|manipulate]] - Object manipulation flags for equipment validation </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/excmdstr</title>
     <ns>0</ns>
     <id>901744</id>
     <revision>
       <id>1341473</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of excmdstr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= excmdstr =
 variable: string &apos;&apos;&apos;excmdstr&apos;&apos;&apos;

&apos;&apos;&apos;excmdstr&apos;&apos;&apos; is a built-in DIL variable that returns the first word/command string entered by a player as a string value.

== Description ==

The excmdstr variable contains the &quot;first string&quot; which was entered by a player. This represents the actual command word that triggered the DIL program. The variable is automatically converted to lowercase by the interpreter.

When combined with the &apos;&apos;&apos;argument&apos;&apos;&apos; variable, you can reconstruct the complete command as entered by the player:

 excmdstr + &quot; &quot; + argument

== Examples ==
The following example shows excmdstr being used to validate a quit command:

 dilbegin aware do_quit(arg : string);
 external
    on_connect@basis();

 var
    quit_str:string;

 code
 {
    if (quit_str==&quot;logging on&quot;)
       quit;

    // Check if the actual command was &quot;quit&quot;
    if (excmdstr != &quot;quit&quot;)
    {
       // Check if it starts with &apos;q&apos; but isn&apos;t exactly &quot;quit&quot;
       if (excmdstr.[0] != &quot;q&quot;)
          quit;

       sendtext (&quot;You can&apos;t just type [&quot;+excmdstr+&quot;] you must type &apos;quit&apos; no less to quit!&lt;br/&gt;&quot;,self);
       quit;
    }

    // Continue with quit processing...
 } dilend

== Usage Notes ==
* The command string is converted to lowercase automatically
* For case-sensitive command checking, use &apos;&apos;&apos;excmdstr_case&apos;&apos;&apos; instead
* Commonly used in command validation and processing
* Essential for determining which command triggered a DIL program
* Returns NULL if no extended command is available

== Related Functions/Fields ==
* [[Manual:DIL_Manual/excmdstr_case|excmdstr_case]] - Case-sensitive version of excmdstr
* [[Manual:DIL_Manual/argument|argument]] - The argument portion of a command
* [[Manual:DIL_Manual/cmdstr|cmdstr]] - Alternative command string variable

== See Also ==</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/excmdstr_case</title>
     <ns>0</ns>
     <id>307173</id>
     <revision>
       <id>1357385</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of excmdstr_case.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= excmdstr_case =
 variable: string &apos;&apos;&apos;excmdstr_case&apos;&apos;&apos;

&apos;&apos;&apos;excmdstr_case&apos;&apos;&apos; is a DIL variable that contains the player&apos;s command input with original case preserved.

== Description ==
The excmdstr_case variable provides access to the exact text that a player typed as a command, preserving the original letter case. This is different from &apos;&apos;&apos;excmdstr&apos;&apos;&apos; which converts the input to lowercase.

The variable contains:
* The command word exactly as typed by the player
* Original capitalization and letter case
* Any arguments following the command
* The complete command line as entered

== Examples ==
 dilbegin aware do_password(arg:string);
 var
    prmt:string;
    firstpwd:string;
    i:integer;
    tlist:stringlist;
 code
 {
    if (self.type != UNIT_ST_PC)
       quit;
    
    // Get the command with original case
    tlist := getwords(excmdstr_case);
    
    if (length(tlist) &gt; 1)
    {
       sendtext(&quot;Password must be only one word. Try again.&lt;br/&gt;&quot;,self);
       quit;
    }
    
    if (length(excmdstr_case) &lt; 5)
    {
       sendtext(&quot;Password too short. Password must be 5 characters or longer. Try again.&lt;br/&gt;&quot;,self);
       quit;
    }
    
    if (length(excmdstr_case) &gt; 16)
    {
       sendtext(&quot;Password too long. Try again.&lt;br/&gt;&quot;,self);
       quit;
    }
    
    firstpwd:=excmdstr_case;
    self.prompt:=&quot;Enter password again:  &quot;;
    
    wait(SFB_CMD, self==activator);
    block;
    
    if (strcmp(excmdstr_case, firstpwd) != 0)
    {
       sendtext(&quot;Passwords do not match try again.&lt;br/&gt;&quot;,self);
       quit;
    }
    
    set_password(self, excmdstr_case);
    sendtext(&quot;Password Changed.&lt;br/&gt;&quot;,self);
 } dilend

== Usage Notes ==
* This variable is read-only
* It&apos;s automatically set by the game system when players enter commands
* The variable is commonly used for:
** Password validation systems
** Case-sensitive command processing
** Text input validation
** Command logging and analysis

== Related Functions/Fields ==
* [[Manual:DIL_Manual/excmdstr|excmdstr]] - Command input (lowercase)
* [[Manual:DIL_Manual/argument|argument]] - Command arguments
* [[Manual:DIL_Manual/set_password|set_password]] - Set player password

== See Also ==</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/exec</title>
     <ns>0</ns>
     <id>1236086</id>
     <revision>
       <id>1201523</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of exec.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= exec =
 function: void &apos;&apos;&apos;exec&apos;&apos;&apos;(command_string : string, target_unit : unitptr);

The exec function forces a unit to execute a command as if they had typed it at the command prompt.

== Description ==
The &apos;&apos;&apos;exec&apos;&apos;&apos; function forces a unit (PC or NPC) to execute a command as if they had typed it at the command prompt. The command is processed through the normal command interpreter, giving the same results and feedback as if the player had entered it manually.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| command_string || string || Command and arguments to perform
|-
| target_unit || unitptr || Unit to perform command
|}

== Examples ==
 dilbegin force_movement(pc : unitptr);
 code
 {
    exec(&quot;north&quot;, pc);
    exec(&quot;say I&apos;m moving!&quot;, pc);
 } dilend

== Usage Notes ==
* Commands longer than MAX_INPUT_LENGTH are truncated and logged
* Immortal-level commands cannot be executed on immortal characters
* The function tracks nested exec() calls for security purposes
* If the target unit is secured using secure(), the exec() call will test for secure violations

== Error Handling ==
* It is not directly possible to detect whether the command was successful or failed
* The target unit receives normal feedback messages for the command
* If the command fails, the target is notified normally

== Related Functions/Fields ==
* [[Manual:DIL_Manual/secure|secure]] - For securing units against destruction/movement
* [[Manual:DIL_Manual/command|command]] - For checking what command was entered
* [[Manual:DIL_Manual/send|send]] - For sending messages to units

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/exit_diff</title>
     <ns>0</ns>
     <id>476105</id>
     <revision>
       <id>1210101</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of exit_diff.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= exit_diff =
 field: integer &apos;&apos;&apos;.exit_diff&apos;&apos;&apos;[direction] (Read-only)

The exit_diff field returns the skill difficulty value for a specific exit in a room.

== Description ==
The &apos;&apos;&apos;exit_diff&apos;&apos;&apos; field returns the skill difficulty value for a specific exit in a room. This difficulty value is used in skill checks to determine whether a character can successfully traverse the exit, particularly for exits that require special skills like climbing.

The difficulty is an integer that represents how challenging it is to use the exit. Higher values indicate greater difficulty.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| room.exit_diff[direction] || integer || The difficulty level of the specified exit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin check_climb_difficulty(room : unitptr, dir : integer);
 var
    difficulty : integer;
 code
 {
    if (room.exit_info[dir] &amp; EX_CLIMB)
    {
       difficulty := room.exit_diff[dir];
       if (skillcheck(SKI_CLIMB, ABIL_DEX, difficulty) &gt; 0)
          act(&quot;You successfully climb.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       else
          act(&quot;You fail to climb.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
 } dilend

== Usage Notes ==
* The direction parameter must be one of the predefined direction constants (NORTH, EAST, SOUTH, WEST, UP, DOWN)
* This field is read-only - difficulty values are typically set through the building/editor system
* Common difficulty values range from 0 (easy) to 100+ (very difficult)

== Error Handling ==
* Returns DILV_FAIL if the exit doesn&apos;t exist or the parameters are invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/exit_to|exit_to]] - Gets the room unit an exit leads to
* [[Manual:DIL_Manual/exit_info|exit_info]] - Gets the flags/properties of an exit
* [[Manual:DIL_Manual/exit_names|exit_names]] - Gets the names of an exit
* [[Manual:DIL_Manual/skillcheck|skillcheck]] - For performing skill checks against difficulty

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room unit type constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/exit_info</title>
     <ns>0</ns>
     <id>1037638</id>
     <revision>
       <id>1814880</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of exit_info.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= exit_info =
 field: integer &apos;&apos;&apos;.exit_info&apos;&apos;&apos;[direction] (Read/Write)

The exit_info field provides access to the flag bits for room exits.

== Description ==
The &apos;&apos;&apos;exit_info&apos;&apos;&apos; field provides access to the condition flags that control how an exit behaves. These flags determine whether an exit is closed, locked, hidden, etc. The field returns a reference to the actual exit flags, allowing both reading and writing.

Common exit flags include:
; EX_CLOSED : The exit is closed and cannot be passed
; EX_LOCKED : The exit is locked and requires a key
; EX_HIDDEN : The exit is hidden from players
; EX_PICKPROOF : The exit cannot be picked
; EX_NOPASS : The exit cannot be passed even when open
; EX_NOFLEE : Players cannot flee through this exit
; EX_CLIMB : The exit requires climbing
; EX_WIZARD : Only wizards can use this exit

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| room.exit_info[direction] || integer || The flag bits for the specified exit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin toggle_door(room : unitptr);
 code
 {
    if (isset(room.exit_info[NORTH], EX_CLOSED))
    {
       unset(room.exit_info[NORTH], EX_CLOSED);
       act(&quot;The door swings open.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    }
    else
    {
       set(room.exit_info[NORTH], EX_CLOSED);
       act(&quot;The door swings shut.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    }
 } dilend

== Usage Notes ==
* The direction parameter must be one of the directional constants (NORTH, EAST, SOUTH, WEST, UP, DOWN)
* The exit must exist for the specified direction, otherwise the operation will fail
* Modifying exit flags affects the actual game world immediately

== Error Handling ==
* Returns fail if accessed on non-room units
* Operation fails if the direction index is out of range

== Related Functions/Fields ==
* [[Manual:DIL_Manual/exit_names|exit_names]] - Get the names of exits
* [[Manual:DIL_Manual/exit_to|exit_to]] - Get the destination room of an exit
* [[Manual:DIL_Manual/isset|isset]] - Test if a flag bit is set
* [[Manual:DIL_Manual/set|set]] - Set a flag bit
* [[Manual:DIL_Manual/unset|unset]] - Clear a flag bit

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room unit type constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/exit_key</title>
     <ns>0</ns>
     <id>698708</id>
     <revision>
       <id>1012339</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of exit_key.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= exit_key =
 field: string &apos;&apos;&apos;.exit_key&apos;&apos;&apos;[direction] (Read-only)

The exit_key field provides access to the key identifier for room exits.

== Description ==
The &apos;&apos;&apos;exit_key&apos;&apos;&apos; field provides access to the key identifier associated with a room exit. This identifier is the symbolic name of the key object that can be used to lock or unlock the exit. The key can be located using the findsymbolic() function.

The key string format follows the standard DikuMUD symbolic naming convention: &quot;key_name@zone_name&quot;

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| room.exit_key[direction] || string || The symbolic name of the key required for the exit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin check_exit_key(room : unitptr, dir : integer);
 var
    key_name : string;
    key_obj : unitptr;
 code
 {
    key_name := room.exit_key[dir];
    if (key_name != &quot;&quot;)
    {
       key_obj := findsymbolic(self, key_name, FIND_UNIT_IN_ME);
       if (key_obj != null)
          act(&quot;You have the proper key.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       else
          act(&quot;You don&apos;t have the key.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
 } dilend

== Usage Notes ==
* The direction parameter must be one of the directional constants (NORTH, EAST, SOUTH, WEST, UP, DOWN)
* An empty string indicates that no key is required for the exit
* This field is read-only - keys cannot be changed through DIL programs

== Error Handling ==
* Returns empty string if the exit doesn&apos;t exist or no key is required
* Returns fail if accessed on non-room units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/exit_info|exit_info]] - Get/set exit flags (locked, closed, etc.)
* [[Manual:DIL_Manual/exit_names|exit_names]] - Get the names of exits
* [[Manual:DIL_Manual/exit_to|exit_to]] - Get the destination room of an exit
* [[Manual:DIL_Manual/findsymbolic|findsymbolic]] - Find a unit by its symbolic name

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room unit type constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/exit_names</title>
     <ns>0</ns>
     <id>949768</id>
     <revision>
       <id>1136272</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of exit_names.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= exit_names =
 field: stringlist &apos;&apos;&apos;.exit_names&apos;&apos;&apos;[direction] (Read/Write)

The exit_names field provides access to the name list for room exits.

== Description ==
The &apos;&apos;&apos;exit_names&apos;&apos;&apos; field provides access to the list of names associated with a room exit. These names are what players type to use the exit (e.g., &quot;door&quot;, &quot;gate&quot;, &quot;north&quot;, &quot;open grate&quot;). The field returns a reference to the actual name list, allowing both reading and writing.

Each exit can have multiple names, allowing for multiple ways to reference the same exit.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| room.exit_names[direction] || stringlist || The list of names for the specified exit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin show_exit_name(room : unitptr, dir : integer);
 var
    names : stringlist;
 code
 {
    names := room.exit_names[dir];
    if (length(names) &gt; 0)
       act(&quot;The exit is called: $2t&quot;, A_ALWAYS, self, names.[0], null, TO_CHAR);
 } dilend

 dilbegin dynamic_exit_names(room : unitptr);
 code
 {
    if (isset(room.exit_info[NORTH], EX_CLOSED))
       room.exit_names[NORTH] := {&quot;closed door&quot;, &quot;barrier&quot;};
    else
       room.exit_names[NORTH] := {&quot;open door&quot;, &quot;entrance&quot;};
 } dilend

== Usage Notes ==
* The direction parameter must be one of the directional constants (NORTH, EAST, SOUTH, WEST, UP, DOWN)
* The first name ([0]) is typically used for display purposes
* Players can use any name in the list to reference the exit
* Modifying exit names affects how players interact with the exit immediately

== Error Handling ==
* Returns empty stringlist if the exit doesn&apos;t exist
* Returns fail if accessed on non-room units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/exit_info|exit_info]] - Get/set exit flags (closed, locked, etc.)
* [[Manual:DIL_Manual/exit_to|exit_to]] - Get the destination room of an exit
* [[Manual:DIL_Manual/exit_key|exit_key]] - Get the key required for an exit
* [[Manual:DIL_Manual/stringlist|stringlist]] - Working with string lists

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room unit type constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/exit_to</title>
     <ns>0</ns>
     <id>526487</id>
     <revision>
       <id>1554677</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of exit_to.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= exit_to =
 field: unitptr &apos;&apos;&apos;.exit_to&apos;&apos;&apos;[direction] (Read-only)

The exit_to field provides access to the destination rooms for each direction exit.

== Description ==
The &apos;&apos;&apos;exit_to&apos;&apos;&apos; field is a read-only array field available on room units that provides access to the destination rooms for each direction exit.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| room.exit_to[direction] || unitptr || The destination room for the specified direction
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin check_exits(room : unitptr);
 code
 {
    if (room.exit_to[NORTH] != null)
       send(&quot;There is an exit to the north.&quot;);
    if (room.exit_to[SOUTH] == null)
       send(&quot;There is no exit to the south.&quot;);
 } dilend

 dilbegin teleport_random(room : unitptr);
 var
    exits : integer[6];
    count : integer;
    dir : integer;
 code
 {
    count := 0;
    for (dir := 0; dir &lt; 6; dir := dir + 1)
    {
       if (room.exit_to[dir] != null)
       {
          exits[count] := dir;
          count := count + 1;
       }
    }
    
    if (count &gt; 0)
    {
       dir := exits[rand(count)];
       link(self, room.exit_to[dir]);
    }
 } dilend

== Usage Notes ==
* The direction parameter must be one of the directional constants (NORTH, EAST, SOUTH, WEST, UP, DOWN)
* This field is read-only - you cannot change exit destinations through DIL
* Always check for null return values before using the destination room

== Error Handling ==
* Returns null if no exit exists in the specified direction
* Returns fail if accessed on non-room units
* Returns fail if the direction index is out of range

== Related Functions/Fields ==
* [[Manual:DIL_Manual/exit_names|exit_names]] - Array of exit name strings for each direction
* [[Manual:DIL_Manual/exit_info|exit_info]] - Array of exit flag bits for each direction
* [[Manual:DIL_Manual/link|link]] - Function to move units between rooms

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room unit type constant
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer data type</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/exp</title>
     <ns>0</ns>
     <id>823547</id>
     <revision>
       <id>1736488</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of exp.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= exp =
 field: integer &apos;&apos;&apos;.exp&apos;&apos;&apos; (Read-only)

The exp field provides access to a unit&apos;s experience points.

== Description ==
The &apos;&apos;&apos;exp&apos;&apos;&apos; field is a read-only integer field available on both player characters (PC) and non-player characters (NPC). For PCs, it represents the total number of experience points the character has accumulated. For NPCs, it represents the experience quality or value of the monster.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.exp || integer || The experience points of the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
 dilbegin show_experience(pc : unitptr);
 code
 {
    if (pc.type == UNIT_ST_PC)
       sendtext(&quot;You have &quot; + itoa(pc.exp) + &quot; experience points.&lt;br/&gt;&quot;, pc);
 } dilend

== Usage Notes ==
* The field is read-only - use the experience() function to modify values
* For PCs, this value affects leveling when compared against the exptol field
* For NPCs, this value typically determines the experience reward when killed

== Error Handling ==
* Returns fail if accessed on invalid unit types

== Related Functions/Fields ==
* [[Manual:DIL_Manual/experience|experience]] - Function to modify experience values
* [[Manual:DIL_Manual/exptol|exptol]] - Experience needed for next level (PC only)
* [[Manual:DIL_Manual/level|level]] - Current level of the unit

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/experience</title>
     <ns>0</ns>
     <id>1289678</id>
     <revision>
       <id>1721548</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of experience.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= experience =
 function: void &apos;&apos;&apos;experience&apos;&apos;&apos;(amount : integer, target : unitptr);

The experience function adds or subtracts experience points from a player character&apos;s total experience.

== Description ==
The &apos;&apos;&apos;experience&apos;&apos;&apos; function adds or subtracts experience points from a player character&apos;s total experience. This function directly modifies a player&apos;s experience pool and can affect leveling progression.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| amount || integer || The number of experience points to add (positive) or subtract (negative)
|-
| target || unitptr || The player character to receive the experience change
|}

== Examples ==
 dilbegin reward_quest_completion(pc : unitptr);
 code
 {
    if (pc.type == UNIT_ST_PC)
    {
       experience(1000, pc);
       sendtext(&quot;You gain 1000 experience points for completing the quest!&lt;br/&gt;&quot;, pc);
    }
 } dilend

== Usage Notes ==
* This function only works on player characters (UNIT_ST_PC)
* Use with extreme care as it directly affects player progression
* It is recommended to use integer constants for the amount parameter to avoid errors
* The function logs experience gains to the system log
* Negative values will subtract experience from the player

== Error Handling ==
* The function will silently fail if called on non-player units
* Always validate that the target is a player character before calling

== Related Functions/Fields ==
* [[Manual:DIL_Manual/exp|exp]] - Read-only field to check current experience
* [[Manual:DIL_Manual/exptol|exptol]] - Experience needed for next level
* [[Manual:DIL_Manual/level|level]] - Current player level

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/exptol</title>
     <ns>0</ns>
     <id>443684</id>
     <revision>
       <id>1222137</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of exptol.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= exptol =
 field: integer &apos;&apos;&apos;.exptol&apos;&apos;&apos; (Read/Write)

The exptol field represents the experience points needed to reach the next level.

== Description ==
The &apos;&apos;&apos;exptol&apos;&apos;&apos; field is a read-write integer field available on player characters (PC). It represents the amount of experience points the player needs to reach the next level. This value is dynamically calculated based on the player&apos;s current virtual level and total experience.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.exptol || integer || The experience points needed to reach the next level
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
 dilbegin check_level_progress(pc : unitptr);
 code
 {
    if (pc.type == UNIT_ST_PC)
    {
       if (pc.exptol &lt;= 0)
          sendtext(&quot;You can level up now! Use the &apos;level&apos; command.&lt;br/&gt;&quot;, pc);
       else
          sendtext(&quot;You need &quot; + itoa(pc.exptol) + &quot; more experience to level.&lt;br/&gt;&quot;, pc);
    }
 } dilend

== Usage Notes ==
* The field is typically dynamically calculated as: required_xp(PC_VIRTUAL_LEVEL(unit) + 1) - CHAR_EXP(unit)
* Modifying this value directly can affect player progression balance
* The value automatically updates as the player gains experience
* When exptol reaches 0 or less, the player can use the &apos;level&apos; command to advance

== Error Handling ==
* Returns fail if accessed on non-player character units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/exp|exp]] - Current experience points
* [[Manual:DIL_Manual/level|level]] - Current player level
* [[Manual:DIL_Manual/experience|experience]] - Function to modify experience values

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/extra</title>
     <ns>0</ns>
     <id>507627</id>
     <revision>
       <id>1225455</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of extra.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= extra =
 field: extraptr &apos;&apos;&apos;.extra&apos;&apos;&apos; (Read-only)

The extra field provides access to a unit&apos;s extra description list.

== Description ==
The &apos;&apos;&apos;extra&apos;&apos;&apos; field provides access to a unit&apos;s extra description list. Extra descriptions are additional data structures that can contain names, values, and descriptive text attached to units. This field returns an extraptr that points to the linked list of extra descriptions.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.extra || extraptr || Pointer to the unit&apos;s extra description list
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin check_quest_flag(pc : unitptr);
 code
 {
    if (&quot;completed_quest&quot; in pc.extra)
       sendtext(&quot;You have already completed this quest.&lt;br/&gt;&quot;, pc);
    else
       sendtext(&quot;You can start this quest.&lt;br/&gt;&quot;, pc);
 } dilend

== Usage Notes ==
* Use the &apos;&apos;&apos;in&apos;&apos;&apos; operator to check if a name exists in the extra list
* Use [[Manual:DIL_Manual/addextra|addextra]] to add new extra descriptions
* Use [[Manual:DIL_Manual/subextra|subextra]] to remove extra descriptions
* Navigate through the list using the &apos;&apos;&apos;next&apos;&apos;&apos; member
* Extraptr variables are volatile and may be cleared when rendered unusable

== Error Handling ==
* Returns null if the unit has no extra descriptions
* Returns fail if accessed on invalid unit types

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addextra|addextra]] - Add extra descriptions to a unit
* [[Manual:DIL_Manual/subextra|subextra]] - Remove extra descriptions from a unit
* [[Manual:DIL_Manual/extraptr|extraptr]] - Extra description pointer type

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object unit type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room unit type constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/extraptr</title>
     <ns>0</ns>
     <id>300042</id>
     <revision>
       <id>1640114</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of extraptr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= extraptr =

 type: &apos;&apos;&apos;extraptr&apos;&apos;&apos;

The &apos;&apos;&apos;extraptr&apos;&apos;&apos; type represents a pointer to an extra description structure that can contain names, values, and descriptive text. Extra descriptions are used throughout the game to store additional data for units, quests, and various game systems.

== Description ==
An extraptr is a pointer type that references extra description structures attached to units or used independently for data storage. Each extra description contains parallel arrays of names (stringlist), values (integerlist), and a description text (string). These structures are commonly used for quests, special descriptions, unit flags, and structured data storage.

Extra descriptions are organized as linked lists, allowing multiple extra descriptions to be attached to a single unit. The extraptr type provides access to navigate and manipulate these structures.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| next || extraptr || Read-only || Pointer to the next extra description in the linked list (null if none)
|-
| names || stringlist || Read/Write || Array of names/keywords for the extra description (null if none)
|-
| vals || integerlist || Read/Write || Array of integer values corresponding to names (null if none)
|-
| descr || string || Read/Write || Description text stored in the extra description
|}

== Availability ==
The extraptr type is used with the following operations:
* &apos;&apos;&apos;unit.extra&apos;&apos;&apos; - Access to a unit&apos;s extra description list
* &apos;&apos;&apos;unit.quests&apos;&apos;&apos; - Access to a player&apos;s quest extra descriptions
* &apos;&apos;&apos;unit.info&apos;&apos;&apos; - Access to a player&apos;s information structure
* &apos;&apos;&apos;addextra()&apos;&apos;&apos; - Function to add new extra descriptions
* &apos;&apos;&apos;subextra()&apos;&apos;&apos; - Function to remove extra descriptions
* &apos;&apos;&apos;in&apos;&apos;&apos; operator - Search for names in extra description lists

== Examples ==
=== Basic Extra Description Access ===
dilbegin examine_extra_descriptions(target : unitptr);
var
    ex_list : extraptr;
    count : integer;
code
{
    ex_list := target.extra;
    count := 0;
    
    while (ex_list) {
        act(&quot;Extra $2d: $3t&quot;, A_ALWAYS, self, itoa(count), ex_list.descr, null, TO_CHAR);
        
        // Show names if any exist
        if (ex_list.names) {
            act(&quot;  Names: $2t&quot;, A_ALWAYS, self, ex_list.names.[0], null, TO_CHAR);
        }
        
        ex_list := ex_list.next;
        count := count + 1;
    }
    
    if (count == 0) {
        act(&quot;No extra descriptions found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
} dilend

=== Working with Names and Values ===
dilbegin process_quest_data();
var
    quest_extra : extraptr;
    i : integer;
    total_points : integer;
code
{
    // Get or create a quest extra description
    quest_extra := self.extra.[&quot;$quest_data&quot;];
    
    if (not quest_extra) {
        act(&quot;No quest data found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
        quit;
    }
    
    total_points := 0;
    
    // Process parallel name-value pairs
    i := 0;
    while (i &lt; length(quest_extra.names) and i &lt; length(quest_extra.vals)) {
        act(&quot;Task: $2t, Points: $3d&quot;, A_ALWAYS, self, 
            quest_extra.names.[i], itoa(quest_extra.vals.[i]), null, TO_CHAR);
        total_points := total_points + quest_extra.vals.[i];
        i := i + 1;
    }
    
    act(&quot;Total quest points: $2d&quot;, A_ALWAYS, self, itoa(total_points), null, TO_CHAR);
} dilend

=== Adding and Modifying Extra Descriptions ===
dilbegin add_player_note(note_text : string);
var
    note_extra : extraptr;
    timestamp : string;
code
{
    // Create a timestamp
    timestamp := asctime() + &quot; - &quot; + self.name;
    
    // Add to existing notes or create new
    note_extra := self.extra.[&quot;$notes&quot;];
    
    if (not note_extra) {
        // Create new note extra description
        addextra(self, &quot;$notes&quot;, note_text);
        note_extra := self.extra.[&quot;$notes&quot;];
    } else {
        // Add to existing description
        note_extra.descr := note_extra.descr + &quot;&amp;n&quot; + timestamp + &quot;: &quot; + note_text;
    }
    
    act(&quot;Note added: $2t&quot;, A_ALWAYS, self, note_text, null, TO_CHAR);
} dilend

=== Searching Extra Descriptions ===
dilbegin check_special_flags(target : unitptr);
var
    ex_list : extraptr;
code
{
    ex_list := target.extra;
    
    // Check for specific flags using the &apos;in&apos; operator
    if (&quot;$magical&quot; in ex_list) {
        act(&quot;$2n has magical properties.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    }
    
    if (&quot;$cursed&quot; in ex_list) {
        act(&quot;$2n appears to be cursed.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    }
    
    if (&quot;$blessed&quot; in ex_list) {
        act(&quot;$2n has been blessed.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    }
    
    // Search through all extra descriptions
    while (ex_list) {
        if (&quot;$special&quot; in ex_list.names) {
            act(&quot;Found special extra: $2t&quot;, A_ALWAYS, self, ex_list.descr, null, TO_CHAR);
        }
        ex_list := ex_list.next;
    }
} dilend

=== Quest Management Example ===
dilbegin manage_quest_progress(quest_name : string, progress : integer);
var
    quest_extra : extraptr;
    i : integer;
    found : integer;
code
{
    quest_extra := self.quests;
    found := 0;
    
    // Search for existing quest
    while (quest_extra) {
        i := 0;
        while (i &lt; length(quest_extra.names)) {
            if (quest_extra.names.[i] == quest_name) {
                // Update existing quest progress
                quest_extra.vals.[i] := progress;
                act(&quot;Updated quest &apos;$2t&apos; progress to $3d.&quot;, A_ALWAYS, self, 
                    quest_name, itoa(progress), null, TO_CHAR);
                found := 1;
                break;
            }
            i := i + 1;
        }
        
        if (found) break;
        quest_extra := quest_extra.next;
    }
    
    if (not found) {
        act(&quot;Quest &apos;$2t&apos; not found.&quot;, A_ALWAYS, self, quest_name, null, TO_CHAR);
    }
} dilend

== Usage Notes ==
* Extraptr variables are volatile and may be cleared when rendered unusable
* Cannot declare static extraptr structures in DIL programs
* Extra descriptions are commonly used for quests, special descriptions, and unit flags
* The &apos;&apos;&apos;names&apos;&apos;&apos; and &apos;&apos;&apos;vals&apos;&apos;&apos; fields are parallel arrays - corresponding indices should match
* Use the &apos;&apos;&apos;in&apos;&apos;&apos; operator to efficiently search for names in extra description lists
* Extra descriptions are automatically saved with the unit if the unit is savable
* The linked list structure allows multiple extra descriptions per unit

== Error Handling ==
* Accessing fields on a null extraptr will result in a runtime error
* Out-of-bounds access to names or vals arrays will return null
* Always check if an extraptr is valid before accessing its fields
* The system automatically handles memory management for extra description structures

== Related Functions/Fields ==
* [[Manual:DIL_Manual/extra|extra]] - Field to access a unit&apos;s extra description list
* [[Manual:DIL_Manual/quests|quests]] - Field to access player quest extra descriptions
* [[Manual:DIL_Manual/info|info]] - Field to access player information structure
* [[Manual:DIL_Manual/addextra|addextra]] - Function to add new extra descriptions
* [[Manual:DIL_Manual/subextra|subextra]] - Function to remove extra descriptions
* [[Manual:DIL_Manual/names|names]] - Field for accessing extra description names
* [[Manual:DIL_Manual/vals|vals]] - Field for accessing extra description values
* [[Manual:DIL_Manual/descr|descr]] - Field for accessing extra description text
* [[Manual:DIL_Manual/next|next]] - Field for traversing extra description lists

== See Also ==
* Extra description functions and operations
* Quest system documentation
* Unit data structures
* Stringlist and integerlist types
* Pointer types (unitptr, cmdptr, zoneptr) </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/fighting</title>
     <ns>0</ns>
     <id>707352</id>
     <revision>
       <id>983880</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of fighting.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= fighting =
 field: unitptr &apos;&apos;&apos;fighting&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;fighting&apos;&apos;&apos; field returns a pointer to the unit that the character is currently fighting. If the character is not in combat, this field returns null.

== Description ==
The &apos;&apos;&apos;fighting&apos;&apos;&apos; field is a read-only unitptr field available on both player characters (PC) and non-player characters (NPC). It provides access to the current combat opponent.

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| fighting || unitptr || Read-only || Pointer to the unit the character is currently fighting (null if not in combat)
|}

== Examples ==
dilbegin check_combat_status(ch : unitptr);
var
   opponent : unitptr;
code
{
   heartbeat := 3;
   if (ch.type != UNIT_ST_PC and ch.type != UNIT_ST_NPC)
      return;

   opponent := ch.fighting;
   
   if (opponent == null)
      sendtext(ch.name + &quot; is not in combat.&lt;br/&gt;&quot;, self);
   else
      sendtext(ch.name + &quot; is fighting &quot; + opponent.name + &quot;.&lt;br/&gt;&quot;, self);
} dilend

== Usage Notes ==
* The field is read-only and cannot be directly assigned
* Returns null when the character is not in combat
* Only works on character units (PC and NPC)
* Can be used to detect when combat starts or ends
* Useful for triggering events based on combat outcomes

== Error Handling ==
* Accessing &apos;&apos;&apos;fighting&apos;&apos;&apos; on non-character units will return null
* Always check if the returned unitptr is valid before use

== Related Functions/Fields ==
* [[Manual:DIL_Manual/set_fighting()|set_fighting()]] - Function to initiate combat between units
* [[Manual:DIL_Manual/stop_fighting()|stop_fighting()]] - Function to end combat
* [[Manual:DIL_Manual/opponentcount|opponentcount]] - Number of opponents being fought
* [[Manual:DIL_Manual/position|position]] - Current position of the character

== See Also ==
* Combat system documentation
* Unit pointer operations</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/findrndunit</title>
     <ns>0</ns>
     <id>1292931</id>
     <revision>
       <id>1531863</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of findrndunit.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= findrndunit =
 function: unitptr &apos;&apos;&apos;findrndunit&apos;&apos;&apos;(u : unitptr, sv : integer, uf : integer);

The &apos;&apos;&apos;findrndunit&apos;&apos;&apos; function returns a random unit that matches the specified criteria within a defined search environment.

== Description ==
This routine returns a random unit that matches the specified criteria. The function searches within the defined environment and returns a unit of the specified type(s).

The &apos;&apos;&apos;uf&apos;&apos;&apos; parameter lets you specify exactly what unit types to look for using the UNIT_ST_* flags. You can combine multiple unit types using the bitwise OR operator.

The &apos;&apos;&apos;sv&apos;&apos;&apos; parameter is not a bit vector, although FIND_UNIT_XXX is usually used as such. If you need to search multiple environments, then call the routine once for each.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit pointer which the search is relative to
|-
| sv || integer || The search-location, a value (not bit vector) of FIND_UNIT_XXX
|-
| uf || integer || Bit vector. The unit flags which can match of UNIT_ST_XXX
|}

== Examples ==
u := findrndunit(self, FIND_UNIT_ZONE, UNIT_ST_PC|UNIT_ST_NPC);

== Usage Notes ==
* The &apos;&apos;&apos;sv&apos;&apos;&apos; parameter is a single value, not a bit vector
* The &apos;&apos;&apos;uf&apos;&apos;&apos; parameter is a bit vector that can combine multiple UNIT_ST_* flags
* Using FIND_UNIT_PAY or FIND_UNIT_NOPAY will filter by player payment status
* For rooms, payment status affects accessibility
* For objects, payment status filtering returns null

== Error Handling ==
* Returns null if no matching unit is found
* Invalid search location values may cause unexpected behavior

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findunit()|findunit()]] - Find a specific unit by name
* [[Manual:DIL_Manual/findsymbolic()|findsymbolic()]] - Find a unit by symbolic name
* [[Manual:DIL_Manual/foreach()|foreach()]] - Iterate through units of specific types

== See Also ==
* FIND_UNIT_* constants documentation
* UNIT_ST_* constants documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/findroom</title>
     <ns>0</ns>
     <id>883324</id>
     <revision>
       <id>1625601</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of findroom.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= findroom =
 function: unitptr &apos;&apos;&apos;findroom&apos;&apos;&apos;(s : string);

The &apos;&apos;&apos;findroom&apos;&apos;&apos; function finds and returns a room unitptr based on its symbolic name.

== Description ==
This function finds and returns a room unitptr based on its symbolic name. The symbolic name should be in the format &quot;room_name@zone_name&quot;.

If the symbolic name exists but is not a room (e.g., it&apos;s an object, NPC, or player), the function will return null.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || Symbolic name of room in the format &quot;room_name@zone_name&quot;
|}

== Examples ==
room := findroom(&quot;inn@udgaard&quot;);

== Usage Notes ==
* This function is primarily provided for historical reasons
* Using &apos;&apos;&apos;findsymbolic()&apos;&apos;&apos; is equally efficient and provides the same functionality
* &apos;&apos;&apos;findsymbolic()&apos;&apos;&apos; can return any type of unit, not just rooms

== Error Handling ==
* Returns null if the room is not found
* Returns null if the symbolic name exists but is not a room

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findsymbolic()|findsymbolic()]] - Find any unit by symbolic name
* [[Manual:DIL_Manual/findunit()|findunit()]] - Find a unit by name within a specific environment

== See Also ==
* Room system documentation
* Symbolic name conventions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/findsymbolic</title>
     <ns>0</ns>
     <id>429289</id>
     <revision>
       <id>1028557</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of findsymbolic.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= findsymbolic =
 function: unitptr &apos;&apos;&apos;findsymbolic&apos;&apos;&apos;(s : string)
 function: unitptr &apos;&apos;&apos;findsymbolic&apos;&apos;&apos;(s : string, idx : integer)
 function: unitptr &apos;&apos;&apos;findsymbolic&apos;&apos;&apos;(u : unitptr, s : string, i : integer)

The &apos;&apos;&apos;findsymbolic&apos;&apos;&apos; function finds units by their symbolic name, supporting three different forms for various search scenarios.

== Description ==
This routine supplements &apos;&apos;&apos;findunit()&apos;&apos;&apos; and &apos;&apos;&apos;findroom()&apos;&apos;&apos;. It comes in handy if it is important to get a unitptr to a unit in the world. This is super fast and a great routine if it doesn&apos;t matter where in the world the unit is.

=== Single Parameter Form ===
This form finds any unit (player, room, object, NPC) by its symbolic name. If there are multiple instances of the same symbolic name, it will return a random one of them.

=== Two Parameter Form ===
This form helps you find a precise unique unit in the world. The idx parameter allows you to match a specific instance when there are multiple units with the same symbolic name. For players it will find the online player regardless of the idx.

=== Three Parameter Form ===
This form searches for a unit relative to a specific unit within defined environments. It will return the first unit matching the symbolic name in the specified search locations.

== PARAMETERS ==
=== Single Parameter Form ===
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || Symbolic name of the unit to find (player, room, object, NPC) in the format &quot;name@zone&quot;
|}

=== Two Parameter Form ===
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || Symbolic name of the unit to find (player, room, object, NPC) in the format &quot;name@zone&quot;
|-
| idx || integer || The index to match for finding a precise unique unit, see unitptr.idx
|}

=== Three Parameter Form ===
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || Search is relative to this unit
|-
| s || string || Symbolic name of the NPC or Object to find in the format &quot;name@zone&quot;
|-
| i || integer || FIND_UNIT_XXX bit vector of places to search
|}

== Examples ==
bread := findsymbolic(&quot;bread@midgaard&quot;);

// Presume target is pointing to a particular cityguard
s := target.symname; // Save the symbolic name
i := target.idx;
// Do stuff. Wake up 9 hours later. Find the target again like this:
target := findsymbolic(s, i);
// and if the guard is still alive you&apos;ll get your pointer back.

// Mary needs to check if she has her own cooking pot
pot := findsymbolic(self, &quot;pot@haon_dor&quot;, FIND_UNIT_IN_ME);

== Usage Notes ==
* Use &apos;&apos;&apos;findsymbolic()&apos;&apos;&apos; when you need to find a specific unit regardless of location
* Use &apos;&apos;&apos;findsymbolic(s, idx)&apos;&apos;&apos; when you need to find a precise instance among duplicates
* Use &apos;&apos;&apos;findsymbolic(u, s, i)&apos;&apos;&apos; when you need to search relative to a specific unit
* For players, the two-parameter form will find the online player regardless of idx

== Error Handling ==
* Returns null if no matching unit is found
* Invalid symbolic names will return null
* Invalid FIND_UNIT_* values may cause unexpected behavior

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findunit()|findunit()]] - Find a unit by name within a specific environment
* [[Manual:DIL_Manual/findroom()|findroom()]] - Find a room by symbolic name
* [[Manual:DIL_Manual/unitptr.idx|unitptr.idx]] - Unique identifier for unit instances

== See Also ==
* FIND_UNIT_* constants documentation
* Symbolic name conventions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/findunit</title>
     <ns>0</ns>
     <id>1210550</id>
     <revision>
       <id>995350</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of findunit.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= findunit =
 function: unitptr &apos;&apos;&apos;findunit&apos;&apos;&apos;(u : unitptr, s : string, i : integer, l : unitptr);

The &apos;&apos;&apos;findunit&apos;&apos;&apos; function searches for a unit by name within a specific environment or container list.

== Description ==
The first argument is typically the char that&apos;s looking for something, i.e. if Mary needs a spoon to stir the pot, she&apos;ll be the first argument.

The second argument is what you&apos;re looking for, represented by a string. In the above mentioned example, that&apos;d be &quot;spoon&quot;.

For the third or fourth argument, you have a choice, as you&apos;ll only need to use one of them, and let the other be 0 or null. For instance, if you have a pointer to Mary&apos;s kitchen utensil pot, you can use the line:

 findunit(mary, &quot;spoon&quot;, 0, pot);

Or you can just let her look around for it with:

 findunit(mary, &quot;spoon&quot;, FIND_UNIT_INVEN or FIND_UNIT_SURRO, null);

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit the local environment is relative to
|-
| s || string || A string with name of the unit to find
|-
| i || integer || The environment, where to look for it, see FIND_UNIT_* in values.h and/or vme.h
|-
| l || unitptr || An optional list of units to search
|}

== Examples ==
spoon := findunit(mary, &quot;spoon&quot;, 0, pot);

spoon := findunit(mary, &quot;spoon&quot;, FIND_UNIT_INVEN or FIND_UNIT_SURRO, null);

safe := findunit(self, &quot;safe&quot;, FIND_UNIT_SURRO, self);

== Usage Notes ==
* Use either the environment parameter (i) or the list parameter (l), not both
* Set the unused parameter to 0 or null
* FIND_UNIT_PAY and FIND_UNIT_NOPAY are ignored in this function
* The search is case-insensitive for unit names

== Error Handling ==
* Returns null if no matching unit is found
* Invalid FIND_UNIT_* values may cause unexpected behavior
* Always check the returned unitptr before use

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findsymbolic()|findsymbolic()]] - Find a unit by symbolic name
* [[Manual:DIL_Manual/findroom()|findroom()]] - Find a room by symbolic name
* [[Manual:DIL_Manual/foreach()|foreach()]] - Iterate through units of specific types

== See Also ==
* FIND_UNIT_* constants documentation
* Container and inventory operations</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/findzone</title>
     <ns>0</ns>
     <id>562341</id>
     <revision>
       <id>927573</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of findzone.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= findzone =
 function: zoneptr &apos;&apos;&apos;findzone&apos;&apos;&apos;(s : string);

The &apos;&apos;&apos;findzone&apos;&apos;&apos; function finds and returns a zone pointer based on the zone name.

== Description ==
This function finds and returns a zone pointer based on the zone name. The zone name should be the name of the zone without any file extension or path.

If the zone is not found, the function returns null.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The name of the zone to find
|}

== Examples ==
z := findzone(&quot;midgaard&quot;);

// Get the current room&apos;s zone
u := self.outside;
while (u.type != UNIT_ST_ROOM)
    u := u.outside;
z := findzone(u.zone);

dilbegin cmd_reset(arg : string);
var
   z : zoneptr;
   u : unitptr;
code
{
   if (arg == &quot;&quot;)
   {
      u := self.outside;
      while (u.type != UNIT_ST_ROOM)
          u := u.outside;
      z := findzone(u.zone);
   }
   else
   {
      z := findzone(arg);
   }

   if (z == null)
   {
       sendtext(&quot;Could not find a zone named &quot;+ arg + &quot;&lt;br/&gt;&quot;, self);
       quit;
   }

   sendtext(&quot;Resetting zone &quot;+ z.name + &quot;&lt;br/&gt;&quot;, self);
   zonereset(z);
} dilend

== Usage Notes ==
* Zone name should not include file extensions or paths
* Zone names are case-sensitive
* The function searches the global zone list

== Error Handling ==
* Returns null if the zone is not found
* Always check the returned zoneptr before use

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type and fields
* [[Manual:DIL_Manual/zhead()|zhead()]] - Get the first zone in the global list
* [[Manual:DIL_Manual/zonereset()|zonereset()]] - Reset a zone

== See Also ==
* Zone system documentation
* Zone management operations</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/fits</title>
     <ns>0</ns>
     <id>432321</id>
     <revision>
       <id>1436685</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of fits.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= fits =
 function: string &apos;&apos;&apos;fits&apos;&apos;&apos;(char : unitptr, obj : unitptr, pos : integer);

The &apos;&apos;&apos;fits&apos;&apos;&apos; function tests if an object can be worn by a character in a specific position.

== Description ==
This function tests if &quot;obj&quot; can be worn by &quot;char&quot; in position &quot;pos&quot;. If pos is -1, then fits automatically figures out the default worn position for &quot;obj&quot;.

The function is useful for checking whether an armor or clothing item will fit a character before attempting to equip it or sell it to them.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| char || unitptr || Character which we want to test if obj can be fitted upon
|-
| obj || unitptr || The object we want to see if fits char
|-
| pos || integer || -1 or WEAR_XXX position where object would be worn
|}

== Examples ==
s := fits(self, obj, -1);
if (s != &quot;&quot;)
  exec(&quot;say Don&apos;t buy it, its &quot;+s, self);

// Check if helmet fits
result := fits(player, helmet, WEAR_HEAD);
if (result == &quot;&quot;)
{
   // Helmet fits, can proceed
}
else
{
   // Helmet doesn&apos;t fit, explain why
   exec(&quot;say This helmet won&apos;t fit you: &quot; + result, self);
}

== Usage Notes ==
* Returns empty string (&quot;&quot;) if the object fits the character
* Returns textual description of why it doesn&apos;t fit (e.g., &quot;too small&quot;, &quot;too large&quot;)
* Use -1 for pos to let the function determine the default position
* Useful for shopkeepers and equipment validation

== Error Handling ==
* Returns error description if object doesn&apos;t fit
* Invalid WEAR_* positions may cause unexpected behavior
* Always check the returned string for fit status

== Related Functions/Fields ==
* [[Manual:DIL_Manual/equipment()|equipment()]] - Get equipment in specific position
* [[Manual:DIL_Manual/addequip()|addequip()]] - Add equipment to character
* [[Manual:DIL_Manual/unequip()|unequip()]] - Remove equipment from character

== See Also ==
* WEAR_* constants documentation
* Equipment system documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/flags</title>
     <ns>0</ns>
     <id>800372</id>
     <revision>
       <id>1139129</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of flags.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= flags =
 field: integer &apos;&apos;&apos;flags&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;flags&apos;&apos;&apos; field contains bits that specify different properties of a unit.

== Description ==
This field contains bits that specify different properties of a unit. The flags are defined as UNIT_FL_* constants in values.h and/or vme.h.

The flags field is a bit vector where each bit represents a specific property or state of the unit. You can use the isset() and unset() functions to test and modify individual flags.

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| flags || integer || Read/Write || Bit vector of UNIT_FL_* flags specifying unit properties
|}

== Examples ==
if (isset(unit.flags, UNIT_FL_BURIED))
{
   // Unit is buried
}

unit.flags := unit.flags | UNIT_FL_SOME_FLAG;

unit.flags := unit.flags &amp; ~UNIT_FL_SOME_FLAG;

if (not isset(self.flags, UNIT_FL_BURIED))
{
   act(&quot;A &quot;+self.name+&quot; rots away.&quot;, A_SOMEONE, self, null, null, TO_ROOM);
   destroy(self);
}

// Make unit invisible
unit.flags := unit.flags | UNIT_FL_INVISIBLE;

// Make unit visible again  
unit.flags := unit.flags &amp; ~UNIT_FL_INVISIBLE;

== Usage Notes ==
* Use &apos;&apos;&apos;isset()&apos;&apos;&apos; to test if a flag is set
* Use bitwise OR to set flags
* Use bitwise AND with complement to clear flags
* The specific flag constants (UNIT_FL_*) are defined in values.h and/or vme.h

== Error Handling ==
* Invalid flag constants may cause unexpected behavior
* Some flags may be read-only depending on unit type

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isset()|isset()]] - Test if a flag is set
* [[Manual:DIL_Manual/unset()|unset()]] - Clear a flag
* [[Manual:DIL_Manual/charflags|charflags]] - Character-specific flags
* [[Manual:DIL_Manual/roomflags|roomflags]] - Room-specific flags
* [[Manual:DIL_Manual/objectflags|objectflags]] - Object-specific flags

== See Also ==
* UNIT_FL_* constants documentation
* Bit manipulation operations</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/flog</title>
     <ns>0</ns>
     <id>727236</id>
     <revision>
       <id>1462876</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of flog.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= flog =
 function: integer &apos;&apos;&apos;flog&apos;&apos;&apos;(filename : string, s : string, wa : string);

The &apos;&apos;&apos;flog&apos;&apos;&apos; function allows you to split up your logs in the log directory so that you don&apos;t end up with everything in the main vme.log.

== Description ==
The flog function allows you to split up your logs in the log directory so that you don&apos;t end up with everything in the main vme.log.

The append/write argument must be in lower case and can only be a &apos;w&apos; or a &apos;a&apos; surrounded by quotes. If the argument is a &apos;w&apos; it will overwrite any log file by that name. If the argument is an &apos;a&apos; it will append to the file by that name.

&apos;&apos;&apos;Note:&apos;&apos;&apos; This function requires zone access level &gt; 1 to use.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| filename || string || The Filename of the file to appear in the log directory
|-
| s || string || The string to be logged
|-
| wa || string || Write or Append mode - must be &quot;w&quot; or &quot;a&quot; (lowercase, surrounded by quotes)
|}

== Examples ==
dilbegin zonelog(s : string);
code
{
   flog(self.zonidx+&quot;.log&quot;, s, &quot;a&quot;);
} dilend

t := z.symname + &quot; [&quot;+self.name+&quot;] &quot; + asctime(realtime)+ argument;
t := textformat(t);
i := flog(&quot;bugs&quot;, t, &quot;a&quot;);

// Create a fresh daily log
flog(&quot;daily.log&quot;, &quot;Daily log started: &quot; + asctime(realtime), &quot;w&quot;);

== Usage Notes ==
* The wa parameter must be exactly &quot;w&quot; or &quot;a&quot; (lowercase, with quotes)
* &quot;w&quot; mode creates new file or overwrites existing file
* &quot;a&quot; mode adds to end of existing file or creates new file
* Requires zone access level &gt; 1 to use

== Error Handling ==
* Returns 0 on success, non-zero on error
* Insufficient access level will cause function to fail
* File system errors may occur (disk full, permissions, etc.)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/log()|log()]] - Write to main game log
* [[Manual:DIL_Manual/logcrime()|logcrime()]] - Log criminal activities
* [[Manual:DIL_Manual/asctime()|asctime()]] - Format timestamp for log entries

== See Also ==
* File system operations
* Zone access and security documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/fname</title>
     <ns>0</ns>
     <id>777771</id>
     <revision>
       <id>1348845</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of fname.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= fname =
 field: string &apos;&apos;&apos;.fname&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;fname&apos;&apos;&apos; field is used to access the filename of a zone from a zone pointer (zoneptr).

== Description ==
The &apos;&apos;&apos;fname&apos;&apos;&apos; field returns the actual filename used to store the zone data on disk.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| fname || string || Read-only || The filename of the zone
|}

== Availability ==
This field is available on the following unit types:
* zoneptr (Zone pointer)

== Examples ==
 dilbegin show_zone_filename();
 var
    z : zoneptr;
 code
 {
    z := zhead();
    
    if (length(z.fname) &lt; 1)
        goto failure;
    
    send(&quot;Zone filename: &quot; + z.fname, self);
    goto cleanup;

:failure:
    send(&quot;No filename available for this zone&quot;, self);
    
:cleanup:
    return;
 } dilend

== Usage Notes ==
* The field returns an empty string if no filename is available
* This is typically used for zone management and debugging purposes

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]]
* [[Manual:DIL_Manual/zhead|zhead]]
* [[Manual:DIL_Manual/name|name]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/follow</title>
     <ns>0</ns>
     <id>1016683</id>
     <revision>
       <id>1039833</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of follow.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= follow =
 function: void &apos;&apos;&apos;follow&apos;&apos;&apos;({follower : unitptr, leader : unitptr});

The &apos;&apos;&apos;follow&apos;&apos;&apos; function makes the follower character follow the leader character.

== Description ==
The &apos;&apos;&apos;follow&apos;&apos;&apos; function makes the follower character follow the leader character. This function works unconditionally, meaning it will make the follower follow even if they are mortally wounded, sleeping, fighting, or in any other state.

If the leader parameter is null, the function will stop the follower from following anyone.

When called, the function will first stop any existing following relationship for the follower, then establish the new following relationship if both the follower and leader are valid characters.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| follower || unitptr || The character that will follow the leader
|-
| leader || unitptr || The character to be followed. Can be null to stop following
|}

== Examples ==
 dilbegin cuff_target(deputy : unitptr, targ : unitptr, cuffs : unitptr);
 var
    depname: string;

 code
 {
    act(&quot;You cuff $3n.&quot;, A_SOMEONE, deputy, null, targ, TO_CHAR);
    act(&quot;$1n surprises you and put $2n around your wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_VICT);
    act(&quot;$1n puts $2n around $3N&apos;s wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_NOTVICT);

    follow(targ, deputy);
    depname := deputy.name;
    link(cuffs, targ);
    unequip(equipment(targ, WEAR_WRIST_R));
    addequip(cuffs, WEAR_WRIST_R);
    dilcopy(&quot;cuffed@midgaard(&quot;+depname+&quot;)&quot;, targ);
    dilcopy(&quot;cuffed2@midgaard(&quot;+depname+&quot;)&quot;, targ);

    exec(&quot;sigh&quot;, targ); /* Do this to activate the DILs */
    return;
 } dilend

== Usage Notes ==
* Both the follower and leader must be valid character units (unitptr)
* The function will automatically stop any existing following relationship before establishing a new one
* Use null as the leader parameter to stop a character from following anyone
* This function is commonly used in situations like arrests, escorts, or prisoner scenarios

== Error Handling ==
* If either parameter is invalid, the function will fail gracefully
* The function handles null leader parameter to stop following relationships

== Related Functions/Fields ==
* [[Manual:DIL_Manual/follower|follower]]
* [[Manual:DIL_Manual/master|master]]
* [[Manual:DIL_Manual/followercount|followercount]]

== See Also ==
* [[Manual:DIL_Manual/stop_fighting|stop_fighting]]
* [[Manual:DIL_Manual/unitptr|unitptr]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/follower</title>
     <ns>0</ns>
     <id>309858</id>
     <revision>
       <id>1516999</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of follower.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= follower =
 field: unitptr &apos;&apos;&apos;.follower&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;follower&apos;&apos;&apos; field returns the first follower of a PC or NPC character.

== Description ==
The &apos;&apos;&apos;follower&apos;&apos;&apos; field provides access to the character that is following the specified unit. If the character has no followers, this field returns null.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| follower || unitptr || Read-only || The first follower of the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
 dilbegin check_followers();
 var
    first_follower : unitptr;
    
 code
 {
    if (self.follower)
    {
        act(&quot;You have at least one follower: $3n&quot;, A_ALWAYS, self, null, self.follower, TO_CHAR);
    }
    else
    {
        act(&quot;You have no followers.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    return;
 } dilend

== Usage Notes ==
* This field is read-only and cannot be modified directly
* Only returns the first follower in the chain
* To access all followers, use a foreach loop in the local environment
* The field returns null if the character has no followers

== Related Functions/Fields ==
* [[Manual:DIL_Manual/follow|follow]]
* [[Manual:DIL_Manual/master|master]]
* [[Manual:DIL_Manual/followercount|followercount]]
* [[Manual:DIL_Manual/getfollower|getfollower]]

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/followercount</title>
     <ns>0</ns>
     <id>1107896</id>
     <revision>
       <id>1318651</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of followercount.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= followercount =
 field: integer &apos;&apos;&apos;.followercount&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;followercount&apos;&apos;&apos; field returns the number of followers that a PC or NPC character has.

== Description ==
The &apos;&apos;&apos;followercount&apos;&apos;&apos; field provides a count of all characters that are following the specified unit. If the character has no followers, this field returns 0.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| followercount || integer || Read-only || The number of followers the character has
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
 dilbegin check_follower_count();
 var
    count : integer;
    
 code
 {
    count := self.followercount;
    
    if (count &gt; 0)
    {
        act(&quot;You have &quot; + itoa(count) + &quot; follower(s).&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    else
    {
        act(&quot;You have no followers.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    return;
 } dilend

 dilbegin list_followers();
 var
    i : integer;
    fol : unitptr;
    
 code
 {
    if (self.followercount == 0)
    {
        act(&quot;You have no followers.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
        return;
    }
    
    act(&quot;Your followers:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    
    i := 0;
    while (i &lt; self.followercount)
    {
        fol := getfollower(self, i);
        if (fol)
        {
            act(&quot;  &quot; + itoa(i+1) + &quot;. &quot; + fol.name, A_ALWAYS, self, null, null, TO_CHAR);
        }
        i := i + 1;
    }
    return;
 } dilend

== Usage Notes ==
* This field is read-only and cannot be modified directly
* Returns 0 if the character has no followers
* Often used in conjunction with the getfollower() function to iterate through all followers
* Useful for group management and follower tracking systems

== Related Functions/Fields ==
* [[Manual:DIL_Manual/follower|follower]]
* [[Manual:DIL_Manual/follow|follow]]
* [[Manual:DIL_Manual/master|master]]
* [[Manual:DIL_Manual/getfollower|getfollower]]

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/foreach</title>
     <ns>0</ns>
     <id>823843</id>
     <revision>
       <id>1668164</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of foreach.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= foreach =

The &apos;&apos;&apos;foreach&apos;&apos;&apos; statement provides an easy way to process all units in the local environment.

== Description ==
The &apos;&apos;&apos;foreach&apos;&apos;&apos; statement provides an easy way to process all units in the local environment relative to the &apos;self&apos; unit executing the foreach. The function automatically creates a list of local units and secures them during iteration.

The local environment includes:
* If &apos;self&apos; is in a room: all units in that room
* If &apos;self&apos; is inside another unit: all units inside that container
* The &apos;self&apos; unit itself is always included in the iteration

The foreach statement supports both break and continue statements for controlling the loop flow.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit_type_flags || integer || Bitwise combination of unit type flags (e.g., UNIT_ST_PC, UNIT_ST_NPC, UNIT_ST_OBJ)
|-
| variable || unitptr || Variable name that will hold each unit in the iteration
|}

== Examples ==
 dilbegin heal_all();
 var
    u : unitptr;
    
 code
 {
    foreach (UNIT_ST_PC|UNIT_ST_NPC, u)
    {
       if (u.hp &lt; u.max_hp)
       {
          act(&quot;Warm raindrops fall upon you, cleaning your wounds.&quot;,
              A_ALWAYS, u, null, null, TO_CHAR);
          u.hp := u.hp + 6;
          if (u.hp &gt; u.max_hp)
            u.hp := u.max_hp;
       }
       else
          act(&quot;Warm raindrops fall upon you.&quot;,
              A_ALWAYS, u, null, null, TO_CHAR);
       pause;
    }
    return;
 } dilend

 dilbegin collect_items();
 var
    item : unitptr;
    
 code
 {
    foreach (UNIT_ST_OBJ, item)
    {
       if (item.objecttype == ITEM_FOOD)
       {
          act(&quot;$1n picks up $2n.&quot;, A_ALWAYS, self, item, null, TO_ALL);
          exec(&quot;get &quot; + item.name, self);
          continue;
       }
       
       if (item.objecttype == ITEM_WEAPON)
       {
          act(&quot;$1n examines $2n carefully.&quot;, A_ALWAYS, self, item, null, TO_ALL);
          break;
       }
    }
    return;
 } dilend

== Usage Notes ==
* Foreach cannot be nested - attempting to nest foreach statements will result in a fatal error
* The units processed are relative to the &apos;self&apos; unit executing the foreach
* All units in the iteration are automatically secured to prevent modification conflicts
* The &apos;self&apos; unit is always included in the iteration if it matches the specified unit type flags
* Common unit type flags include:
** UNIT_ST_PC - Player characters
** UNIT_ST_NPC - Non-player characters  
** UNIT_ST_OBJ - Objects
** UNIT_ST_ROOM - Rooms
* Multiple flags can be combined using bitwise OR (|)

== Error Handling ==
* Nested foreach statements will cause a fatal error
* Invalid unit type flags may result in unexpected behavior

== Related Functions/Fields ==
* [[Manual:DIL_Manual/secure|secure]]
* [[Manual:DIL_Manual/unsecure|unsecure]]
* [[Manual:DIL_Manual/break|break]]
* [[Manual:DIL_Manual/continue|continue]]

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/full</title>
     <ns>0</ns>
     <id>445283</id>
     <revision>
       <id>1469446</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of full.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= full =
 field: integer &apos;&apos;&apos;.full&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;full&apos;&apos;&apos; field represents how hungry a player character (PC) is.

== Description ==
The &apos;&apos;&apos;full&apos;&apos;&apos; field tracks the character&apos;s hunger level and is used to determine when a character needs to eat. Higher values indicate more hunger, while lower values indicate less hunger (more full).

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| full || integer || Read/Write || The hunger level of the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
 dilbegin check_hunger();
 var
    hunger_level : integer;
    
 code
 {
    hunger_level := self.full;
    
    if (hunger_level &gt; 20)
    {
        act(&quot;You are very hungry.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    else if (hunger_level &gt; 10)
    {
        act(&quot;You are hungry.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    else if (hunger_level &lt; 5)
    {
        act(&quot;You feel quite full.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    else
    {
        act(&quot;You are not particularly hungry.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    return;
 } dilend

 dilbegin eat_food(food : unitptr);
 var
    hunger_reduction : integer;
    
 code
 {
    if (food.objecttype != ITEM_FOOD)
    {
        act(&quot;That&apos;s not food!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
        return;
    }
    
    hunger_reduction := food.value[0]; // Food value
    self.full := self.full - hunger_reduction;
    
    if (self.full &lt; 0)
        self.full := 0;
    
    act(&quot;You eat $2n and feel less hungry.&quot;, A_ALWAYS, self, food, null, TO_CHAR);
    act(&quot;$1n eats $2n.&quot;, A_ALWAYS, self, food, null, TO_REST);
    
    destroy(food);
    return;
 } dilend

== Usage Notes ==
* Only available for player characters (UNIT_ST_PC), not NPCs
* Often used in conjunction with thirst and drunk fields for character condition tracking
* The field is typically modified by eating food items or by natural hunger progression over time
* Setting the value too low may cause the character to be unable to eat more
* Setting the value too high may cause hunger-related messages or effects
* The exact scale and thresholds are game-specific

== Related Functions/Fields ==
* [[Manual:DIL_Manual/thirst|thirst]]
* [[Manual:DIL_Manual/drunk|drunk]]

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]]
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/gamestate</title>
     <ns>0</ns>
     <id>347647</id>
     <revision>
       <id>1800110</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of gamestate.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= gamestate =
 function: void &apos;&apos;&apos;gamestate&apos;&apos;&apos;({unit : unitptr, state : integer});

The &apos;&apos;&apos;gamestate&apos;&apos;&apos; function changes the game state of a player character.

== Description ==
The &apos;&apos;&apos;gamestate&apos;&apos;&apos; function changes the game state of a player character. This function is primarily used for managing player connections and menu navigation in VME 2.0. When used, it removes the character from normal gameplay and transitions them to a different state.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The player character whose game state will be changed
|-
| state || integer || The new game state using GS_ defines from vme.h
|}

== Examples ==
 dilbegin quit_command();
 var
    err : integer;
    goodbye : string;
    
 code
 {
    if (self.position == POSITION_FIGHTING)
    {
       sendtext(&quot;Not while fighting!&lt;br/&gt;&quot;, self);
       quit;
    }
    
    foreach(UNIT_ST_PC, u)
    {
       if (u != self)
       {
          if (visible(u, self))
             sendtext(self.name + &quot; has left the game.&lt;br/&gt;&quot;, u);
       }
    }
    
    if (self.level &lt; 200)
    {
       err := loadstr(&quot;goodbye&quot;, goodbye);
       
       if (err &gt; 0)
       {
          goodbye := textformat(goodbye);
          sendtext(&quot;&lt;br/&gt;&lt;br/&gt;&quot; + goodbye, self);
       }
       
       sendtext(&quot;Goodbye, friend.. Come back soon!&lt;br/&gt;&quot;, self);
       gamestate(self, GS_QUIT);
    }
    else
    {
       gamestate(self, GS_MENU);
    }
    quit;
 } dilend

 dilbegin immortal_menu();
 var
    choice : string;
    
 code
 {
    sendtext(&quot;Immortal Menu:&lt;br/&gt;&quot;, self);
    sendtext(&quot;1) Enter game&lt;br/&gt;&quot;, self);
    sendtext(&quot;0) Disconnect&lt;br/&gt;&quot;, self);
    sendtext(&quot;Choice: &quot;, self);
    
    wait(SFB_CMD, TRUE);
    
    if (command(&quot;1&quot;))
    {
       gamestate(self, GS_PLAY);
       exec(&quot;look&quot;, self);
    }
    else if (command(&quot;0&quot;))
    {
       gamestate(self, GS_QUIT);
    }
    else
    {
       sendtext(&quot;Invalid choice.&lt;br/&gt;&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* This function only works on player characters (UNIT_ST_PC), not NPCs
* Using GS_QUIT will extract the unit from the game completely
* Using GS_MENU removes the player from normal gameplay and puts them in menu mode
* Using GS_LINK_DEAD closes the player&apos;s network descriptor
* Using GS_PLAY returns the player to normal gameplay
* Be aware that players could potentially use this function to hide if not properly secured
* This function is commonly used in login/logout sequences and immortal menu systems

The state parameter should use one of the following GS_ defines:
* GS_PLAY - Returns the player to normal gameplay mode
* GS_QUIT - Extracts the player from the game (disconnects them)
* GS_MENU - Transitions the player to menu mode (typically for immortal/admin menus)
* GS_LINK_DEAD - Closes the player&apos;s descriptor, making them link-dead

== Error Handling ==
* Function will fail if the unit parameter is not a player character
* Invalid state values may cause unexpected behavior

== Related Functions/Fields ==
* [[Manual:DIL_Manual/extract_unit|extract_unit]]
* [[Manual:DIL_Manual/descriptor_close|descriptor_close]]

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/getaffects</title>
     <ns>0</ns>
     <id>1016699</id>
     <revision>
       <id>913310</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of getaffects.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= getaffects =
 function: stringlist &apos;&apos;&apos;getaffects&apos;&apos;&apos;({unit : unitptr});

The &apos;&apos;&apos;getaffects&apos;&apos;&apos; function retrieves all magical and special affects currently applied to a unit.

== Description ==
The &apos;&apos;&apos;getaffects&apos;&apos;&apos; function retrieves all magical and special affects currently applied to a unit. This is useful for identifying what spells, enchantments, or special properties are affecting a character or object.

Each affect entry in the returned stringlist follows the format:
{&quot;Description&quot;, &quot;data0,data1,data2,duration&quot;}

The data values and their meanings depend on the type of affect:
* Ability adjustments: &quot;ability_index,modifier,0,duration&quot;
* Spell adjustments: &quot;spell_index,modifier,0,duration&quot;  
* Light modifications: &quot;skill_index,modifier,0,duration&quot;
* Character flag modifications: &quot;skill_index,modifier,0,duration&quot;
* Unit flag modifications: &quot;skill_index,modifier,0,duration&quot;
* Object flag modifications: &quot;skill_index,modifier,0,duration&quot;
* Skill adjustments: &quot;skill_index,modifier,0,duration&quot;
* Weapon adjustments: &quot;weapon_index,modifier,0,duration&quot;
* Natural armor modifications: &quot;skill_index,modifier,0,duration&quot;
* Speed modifications: &quot;0,speed_modifier,0,duration&quot;

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit to scan for affects
|}

== Examples ==
 dilbegin check_affects();
 var
    affects : stringlist;
    affect_data : stringlist;
    i : integer;
    n : integer;
    
 code
 {
    affects := getaffects(self);
    n := length(affects);
    
    if (n == 0)
    {
        act(&quot;You have no special affects.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
        return;
    }
    
    act(&quot;You have the following affects:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    
    i := 0;
    while (i &lt; n)
    {
        affect_data := split(affects.[i], &quot;,&quot;);
        
        if (affect_data.[0] == &quot;Ability Adjustment&quot;)
        {
            act(&quot;  &quot; + affects.[i] + &quot; (Ability bonus)&quot;, A_ALWAYS, self, null, null, TO_CHAR);
        }
        else if (affect_data.[0] == &quot;Weapon adjustment&quot;)
        {
            act(&quot;  &quot; + affects.[i] + &quot; (Weapon bonus)&quot;, A_ALWAYS, self, null, null, TO_CHAR);
        }
        else
        {
            act(&quot;  &quot; + affects.[i], A_ALWAYS, self, null, null, TO_CHAR);
        }
        
        i := i + 1;
    }
    return;
 } dilend

 dilbegin identify_item(item : unitptr);
 var
    affects : stringlist;
    affect_data : stringlist;
    i : integer;
    n : integer;
    
 code
 {
    affects := getaffects(item);
    n := length(affects);
    
    if (n &gt; 0)
    {
        act(&quot;This item has the following magical properties:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
        
        i := 0;
        while (i &lt; n)
        {
            affect_data := split(affects.[i], &quot;,&quot;);
            
            if (affect_data.[0] == &quot;Ability Adjustment&quot;)
            {
                act(&quot;  Ability bonus: &quot; + affect_data.[2] + &quot; &quot; + affect_data.[3], A_ALWAYS, self, null, null, TO_CHAR);
            }
            else if (affect_data.[0] == &quot;Weapon adjustment&quot;)
            {
                act(&quot;  Weapon bonus: &quot; + affect_data.[2] + &quot; &quot; + affect_data.[3], A_ALWAYS, self, null, null, TO_CHAR);
            }
            
            i := i + 1;
        }
    }
    return;
 } dilend

== Usage Notes ==
* Use the split() function to separate the numerical values in the data string
* Duration of -1 typically indicates a permanent affect
* The function returns an empty stringlist if the unit has no affects
* This function is commonly used in identify spells and item inspection commands
* The specific meaning of data values depends on the affect type

== Error Handling ==
* Returns an empty stringlist if the unit parameter is invalid
* Returns fail if the input unit is null or an unsupported type

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isaff|isaff]]
* [[Manual:DIL_Manual/addaff|addaff]]
* [[Manual:DIL_Manual/subaff|subaff]]
* [[Manual:DIL_Manual/split|split]]

== See Also ==
* [[Manual:DIL_Manual/stringlist|stringlist]]</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/getcmd</title>
     <ns>0</ns>
     <id>620688</id>
     <revision>
       <id>1854384</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of getcmd.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= getcmd =
 function: cmdptr &apos;&apos;&apos;getcmd&apos;&apos;&apos;({command_name : string});

The &apos;&apos;&apos;getcmd&apos;&apos;&apos; function searches the internal command trie for a command matching the specified name.

== Description ==
The &apos;&apos;&apos;getcmd&apos;&apos;&apos; function searches the internal command trie for a command matching the specified name. This function provides direct access to the command information structure, allowing DIL programs to examine command properties such as required level, position, and command type.

The function is useful for:
* Checking if a command exists in the system
* Retrieving detailed information about a command
* Validating command availability for players

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| command_name || string || The name of the command to search for in the command table
|}

== Examples ==
 dilbegin check_command(cmd_name : string);
 var
    cmd_ptr : cmdptr;
 code
 {
    cmd_ptr := getcmd(cmd_name);
    
    if (cmd_ptr) {
       act(&quot;Command &apos;$2t&apos; found. Level: $3d, Position: $4d&quot;, A_ALWAYS, self, 
           cmd_name, itoa(cmd_ptr.level), itoa(cmd_ptr.position), null, TO_CHAR);
    } else {
       act(&quot;Command &apos;$2t&apos; not found.&quot;, A_ALWAYS, self, cmd_name, null, TO_CHAR);
    }
    
    quit;
 } dilend

== Usage Notes ==
* Returns a command pointer (cmdptr) to the command if found, or null if the command does not exist
* The command pointer can be used to access command properties like level, position, and type
* This function is commonly used for command validation and permission checking

== Error Handling ==
* Returns null if the command does not exist
* Returns fail if the input string is null

== Related Functions/Fields ==
* [[Manual:DIL_Manual/cmdptr|cmdptr]] - Command pointer type and fields
* [[Manual:DIL_Manual/command|command]] - Command matching function
* [[Manual:DIL_Manual/chead|chead]] - Get first command in list

== See Also ==</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/getcolor</title>
     <ns>0</ns>
     <id>1251805</id>
     <revision>
       <id>1431011</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of getcolor.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= getcolor =
 function: string &apos;&apos;&apos;getcolor&apos;&apos;&apos;({color_string : string});

The &apos;&apos;&apos;getcolor&apos;&apos;&apos; function processes color strings by calling the internal divcolor() function.

== Description ==
The &apos;&apos;&apos;getcolor&apos;&apos;&apos; function processes color strings by calling the internal divcolor() function. This function appears to convert or divide color codes within the input string.

Note: This function is different from the player-specific color functions (addcolor, delcolor, changecolor) which work with individual player color settings. The getcolor() function works with color code processing and conversion.

The function is currently marked as unused in the codebase, suggesting it may be obsolete or awaiting testing and implementation.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| color_string || string || A string containing color codes to be converted/divided
|}

== Examples ==
 dilbegin process_colors(input : string);
 var
    processed : string;
 code
 {
    processed := getcolor(&quot;&amp;brThis is bold red text&amp;n&quot;);
    
    if (processed) {
       sendtext(&quot;Processed: &quot; + processed + &quot;&amp;n&quot;, self);
    } else {
       sendtext(&quot;Failed to process colors.&amp;n&quot;, self);
    }
    
    quit;
 } dilend

== Usage Notes ==
* This function works with color code processing and conversion
* Different from player-specific color functions which work with individual player color settings
* Currently marked as unused in the codebase

== Error Handling ==
* Returns fail if the input is null, fail, or an unsupported type
* Returns the processed color string on success

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addcolor|addcolor]] - Add color to player&apos;s personal color list
* [[Manual:DIL_Manual/delcolor|delcolor]] - Delete color from player&apos;s personal color list  
* [[Manual:DIL_Manual/changecolor|changecolor]] - Change color in player&apos;s personal color list

== See Also ==</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/getfollower</title>
     <ns>0</ns>
     <id>764934</id>
     <revision>
       <id>1252177</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of getfollower.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= getfollower =
 function: unitptr &apos;&apos;&apos;getfollower&apos;&apos;&apos;(master_unit : unitptr, index : integer);

The getfollower() function retrieves a specific follower from a character&apos;s follower list by index.

== Description ==
 The &apos;&apos;&apos;getfollower&apos;&apos;&apos;() function retrieves a specific follower from a character&apos;s follower list by index. This is commonly used in group management systems to iterate through all followers of a group leader.

 The function works with the internal follower chain where each character can have multiple followers arranged in a linked list. The index parameter allows direct access to followers without needing to traverse the entire chain.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| master_unit || unitptr || The character whose follower list should be searched. Must be a character unit (PC or NPC).
|-
| index || integer || The zero-based index of the follower to retrieve. Must be &gt;= 0.
|}

== Examples ==
 dilbegin list_followers(leader_name : string);
 var
    leader : unitptr;
    follower : unitptr;
    count : integer;
    buffer : string;
 code
 {
    leader := findunit(self, leader_name, FIND_UNIT_SURRO, null);
    
    if (leader == null) {
       sendtext(&quot;Leader not found.&amp;n&quot;, self);
       quit;
    }
    
    buffer := &quot;Followers of &quot; + leader.name + &quot;:&amp;n&quot;;
    count := 0;
    
    while (count &lt; leader.followercount) {
       follower := getfollower(leader, count);
       
       if (follower) {
          buffer := buffer + &quot;  &quot; + itoa(count) + &quot;: &quot; + follower.name + &quot;&amp;n&quot;;
       }
       
       count := count + 1;
    }
    
    sendtext(buffer, self);
    quit;
 } dilend

== Usage Notes ==
* The index is zero-based, so index 0 retrieves the first follower
* Use &apos;&apos;&apos;followercount&apos;&apos;&apos; field to determine the valid range of indices
* Returns null for invalid indices, allowing safe iteration

== Error Handling ==
* Returns fail if master_unit is null or not a character unit
* Returns null if index is negative or exceeds follower count
* Always check return value before using the returned unit

== Related Functions/Fields ==
* [[Manual:DIL_Manual/follow|follow]] - Make a character follow another
* [[Manual:DIL_Manual/followercount|followercount]] - Number of followers a character has
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character fields including follower and master

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type and fields</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/getinteger</title>
     <ns>0</ns>
     <id>623344</id>
     <revision>
       <id>1093049</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of getinteger.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= getinteger =
 function: integer &apos;&apos;&apos;getinteger&apos;&apos;&apos;(index : integer, unit : unitptr, value : integer);

The getinteger() function is a versatile utility that retrieves various game system values based on the index parameter.

== Description ==
 The &apos;&apos;&apos;getinteger&apos;&apos;&apos;() function is a versatile utility that retrieves various game system values based on the index parameter. It can calculate character statistics, experience requirements, check player status, and access real-world time information.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| index || integer || The type of value to retrieve. See the table below for valid indices.
|-
| unit || unitptr || The unit to operate on (required for some indices, can be null for others).
|-
| value || integer || An integer value used by some index types (e.g., level for XP calculations).
|}

=== Supported Indices ===

{| class=&quot;wikitable&quot;
! Index Constant !! Description !! Unit Required !! Value Parameter
|-
| DIL_GINT_MANAREG || Mana regeneration rate || Yes (character) || Ignored
|-
| DIL_GINT_HITREG || Hit point regeneration rate || Yes (character) || Ignored
|-
| DIL_GINT_MOVEREG || Movement point regeneration rate || Yes (character) || Ignored
|-
| DIL_GINT_EFFDEX || Effective dexterity value || Yes (character) || Ignored
|-
| DIL_GINT_REQXP || Experience required for specified level || No || Level number
|-
| DIL_GINT_LEVELXP || Experience at specified level || No || Level number
|-
| DIL_GINT_DESCRIPTOR || Check if player has active descriptor || Yes (player) || Ignored
|-
| DIL_GINT_CRIMENO || Generate new crime serial number || No || Ignored
|-
| DIL_GINT_BONUS_A || Get bonus map A value || No || Index
|-
| DIL_GINT_BONUS_B || Get bonus map B value || No || Index
|-
| DIL_GINT_REALYEAR || Current real-world year || No || Ignored
|-
| DIL_GINT_REALMONTH || Current real-world month (1-12) || No || Ignored
|-
| DIL_GINT_REALDAY || Current real-world day of month || No || Ignored
|}

== Examples ==
 dilbegin check_character_stats(pc_name : string);
 var
    pc : unitptr;
    mana_reg : integer;
    hp_reg : integer;
    move_reg : integer;
    eff_dex : integer;
 code
 {
    pc := findunit(self, pc_name, FIND_UNIT_SURRO, null);
    
    if (pc == null) {
       sendtext(&quot;Player not found.&amp;n&quot;, self);
       quit;
    }
    
    if (pc.type != UNIT_ST_PC) {
       sendtext(&quot;Target is not a player.&amp;n&quot;, self);
       quit;
    }
    
    mana_reg := getinteger(DIL_GINT_MANAREG, pc, 0);
    hp_reg := getinteger(DIL_GINT_HITREG, pc, 0);
    move_reg := getinteger(DIL_GINT_MOVEREG, pc, 0);
    eff_dex := getinteger(DIL_GINT_EFFDEX, pc, 0);
    
    sendtext(&quot;Regeneration rates for &quot; + pc.name + &quot;:&amp;n&quot;, self);
    sendtext(&quot;  Mana: &quot; + itoa(mana_reg) + &quot;&amp;n&quot;, self);
    sendtext(&quot;  HP: &quot; + itoa(hp_reg) + &quot;&amp;n&quot;, self);
    sendtext(&quot;  Move: &quot; + itoa(move_reg) + &quot;&amp;n&quot;, self);
    sendtext(&quot;  Effective DEX: &quot; + itoa(eff_dex) + &quot;&amp;n&quot;, self);
    
    quit;
 } dilend

== Usage Notes ==
* Some indices require a valid unit parameter, others ignore it
* The value parameter is only used by specific index types
* Real-world time indices return actual system time values

== Error Handling ==
* Returns fail if index is unsupported or parameters are invalid
* Returns fail if unit is required but not provided or invalid
* Always check return value before using in calculations

== Related Functions/Fields ==
* [[Manual:DIL_Manual/experience|experience]] - Modify player experience
* [[Manual:DIL_Manual/realtime|realtime]] - Get current Unix timestamp
* [[Manual:DIL_Manual/mud(day,month,..)|mud(day,month,..)]] - MUD time variables

== See Also ==
* Character statistics and regeneration systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/getopponent</title>
     <ns>0</ns>
     <id>752428</id>
     <revision>
       <id>1898108</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of getopponent.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= getopponent =
 function: unitptr &apos;&apos;&apos;getopponent&apos;&apos;&apos;(character : unitptr, index : integer);

The getopponent() function retrieves a specific opponent from a character&apos;s opponent list by index.

== Description ==
 The &apos;&apos;&apos;getopponent&apos;&apos;&apos;() function retrieves a specific opponent from a character&apos;s opponent list by index. In the DikuMUD combat system, a character can be fighting multiple opponents simultaneously, with one primary opponent (accessible via the .fighting field) and additional opponents in the opponent list.

 This function is commonly used to:
 * Iterate through all opponents of a character
 * Check specific opponents in multi-opponent combat situations
 * Display combat information involving multiple attackers

 The index is zero-based, so index 0 retrieves the first opponent in the list.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| character || unitptr || The character whose opponent list should be searched. Must be a character unit (PC or NPC) that is currently in combat.
|-
| index || integer || The zero-based index of the opponent to retrieve. Must be &gt;= 0.
|}

== Examples ==
 dilbegin list_opponents(target_name : string);
 var
    target : unitptr;
    opponent : unitptr;
    count : integer;
    buffer : string;
 code
 {
    target := findunit(self, target_name, FIND_UNIT_SURRO, null);
    
    if (target == null) {
       sendtext(&quot;Target not found.&amp;n&quot;, self);
       quit;
    }
    
    if (target.opponentcount == 0) {
       sendtext(target.name + &quot; is not fighting anyone.&amp;n&quot;, self);
       quit;
    }
    
    buffer := target.name + &quot; is fighting:&amp;n&quot;;
    count := 0;
    
    while (count &lt; target.opponentcount) {
       opponent := getopponent(target, count);
       
       if (opponent) {
          buffer := buffer + &quot;  &quot; + itoa(count) + &quot;: &quot; + opponent.name + &quot;&amp;n&quot;;
       }
       
       count := count + 1;
    }
    
    sendtext(buffer, self);
    quit;
 } dilend

== Usage Notes ==
* The index is zero-based, so index 0 retrieves the first opponent
* Use &apos;&apos;&apos;opponentcount&apos;&apos;&apos; field to determine the valid range of indices
* Returns null for invalid indices, allowing safe iteration
* The primary opponent is also accessible via the &apos;&apos;&apos;fighting&apos;&apos;&apos; field

== Error Handling ==
* Returns fail if character parameter is null or not a character unit
* Returns null if index is negative or exceeds opponent count
* Returns null if character is not in combat (opponentcount is 0)
* Always check return value before using the returned unit

== Related Functions/Fields ==
* [[Manual:DIL_Manual/opponent|opponent]] - Check if two units are opponents
* [[Manual:DIL_Manual/set_fighting|set_fighting]] - Set two characters fighting
* [[Manual:DIL_Manual/stop_fighting|stop_fighting]] - Stop combat between characters
* [[Manual:DIL_Manual/fighting|fighting]] - Primary opponent field
* [[Manual:DIL_Manual/opponentcount|opponentcount]] - Number of opponents a character is fighting

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character fields including fighting and opponentcount</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/getword</title>
     <ns>0</ns>
     <id>1012414</id>
     <revision>
       <id>1325220</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of getword.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= getword =
 function: string &apos;&apos;&apos;getword&apos;&apos;&apos;(var input_string : string);

The getword() function extracts the first word from a string and removes it from the original string.

== Description ==
 The &apos;&apos;&apos;getword&apos;&apos;&apos;() function extracts the first word from a string and removes it from the original string. The function treats spaces as word separators and skips any leading spaces before finding the first word.

 Important: The input_string parameter is modified by this function - the returned word is removed from the original string. This makes getword() useful for parsing command arguments sequentially.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| input_string || string || A string containing one or more words separated by spaces. This parameter is passed by reference and will be modified.
|}

== Examples ==
 dilbegin parse_command(cmd_line : string);
 var
    first_word : string;
    remaining : string;
 code
 {
    first_word := getword(cmd_line);
    remaining := cmd_line; // cmd_line now has the first word removed
    
    sendtext(&quot;First word: &quot; + first_word + &quot;&amp;n&quot;, self);
    sendtext(&quot;Remaining: &quot; + remaining + &quot;&amp;n&quot;, self);
    
    // Example with &quot;cast fireball monster&quot;
    // first_word becomes &quot;cast&quot;
    // remaining becomes &quot;fireball monster&quot;
    
    quit;
 } dilend

 dilbegin process_spell_args();
 var
    spell_name : string;
    target_name : string;
 code
 {
    spell_name := getword(argument);
    target_name := getword(argument);
    
    if (spell_name == &quot;&quot;) {
       sendtext(&quot;Cast what?&amp;n&quot;, self);
       quit;
    }
    
    if (target_name == &quot;&quot;) {
       sendtext(&quot;Cast &quot; + spell_name + &quot; on whom?&amp;n&quot;, self);
       quit;
    }
    
    sendtext(&quot;Casting &quot; + spell_name + &quot; on &quot; + target_name + &quot;&amp;n&quot;, self);
    quit;
 } dilend

== Usage Notes ==
* The input_string parameter is modified by reference
* Leading spaces are skipped before finding the first word
* Multiple consecutive spaces are treated as single separators
* Returns empty string if no words are found
* Commonly used for parsing command arguments sequentially

== Error Handling ==
* Returns fail if input_string is null or invalid
* Returns empty string if input_string contains no words
* Always check return value before using in string operations

== Related Functions/Fields ==
* [[Manual:DIL_Manual/getwords|getwords]] - Get all words as a stringlist
* [[Manual:DIL_Manual/argument|argument]] - Command argument string
* [[Manual:DIL_Manual/left|left]] - Get left portion of string
* [[Manual:DIL_Manual/right|right]] - Get right portion of string

== See Also ==
* String parsing and manipulation functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/getwords</title>
     <ns>0</ns>
     <id>473606</id>
     <revision>
       <id>996993</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of getwords.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= getwords =
 function: stringlist &apos;&apos;&apos;getwords&apos;&apos;&apos;(input_string : string);

The getwords() function splits a string into individual words using spaces as delimiters and returns them as a stringlist.

== Description ==
 The &apos;&apos;&apos;getwords&apos;&apos;&apos;() function splits a string into individual words using spaces as delimiters and returns them as a stringlist. Each word becomes a separate element in the resulting stringlist.

 Unlike getword() which extracts one word and modifies the original string, getwords() returns all words at once without modifying the original string.

 The function handles multiple consecutive spaces by treating them as single delimiters (empty strings are not added to the result).

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| input_string || string || A string containing zero or more words separated by spaces.
|}

== Examples ==
 dilbegin parse_sentence(sentence : string);
 var
    words : stringlist;
    i : integer;
 code
 {
    words := getwords(sentence);
    
    sendtext(&quot;Sentence has &quot; + itoa(length(words)) + &quot; words:&amp;n&quot;, self);
    
    i := 0;
    while (i &lt; length(words)) {
       sendtext(&quot;  Word &quot; + itoa(i) + &quot;: &quot; + words.[i] + &quot;&amp;n&quot;, self);
       i := i + 1;
    }
    
    quit;
 } dilend

 dilbegin check_keywords(input : string);
 var
    words : stringlist;
    keywords : stringlist;
 code
 {
    words := getwords(input);
    keywords := {&quot;sword&quot;, &quot;shield&quot;, &quot;armor&quot;, &quot;potion&quot;};
    
    if (words.[0] in keywords) {
       sendtext(&quot;First word is a keyword: &quot; + words.[0] + &quot;&amp;n&quot;, self);
    }
    
    if (words.[1] in keywords) {
       sendtext(&quot;Second word is a keyword: &quot; + words.[1] + &quot;&amp;n&quot;, self);
    }
    
    quit;
 } dilend

== Usage Notes ==
* The original input_string is not modified
* Multiple consecutive spaces are treated as single delimiters
* Leading and trailing spaces are ignored
* Empty string input returns an empty stringlist
* Use &apos;&apos;&apos;length&apos;&apos;&apos;() to get the number of words returned

== Error Handling ==
* Returns fail if input_string is null or invalid
* Returns empty stringlist if input_string contains no words
* Always check return value before accessing array elements

== Related Functions/Fields ==
* [[Manual:DIL_Manual/getword|getword]] - Get first word and remove from string
* [[Manual:DIL_Manual/stringlist|stringlist]] - String list type and operations
* [[Manual:DIL_Manual/length|length]] - Get length of string or stringlist
* [[Manual:DIL_Manual/addstring|addstring]] - Add string to stringlist

== See Also ==
* String parsing and manipulation functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/ghead</title>
     <ns>0</ns>
     <id>834258</id>
     <revision>
       <id>1547947</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of ghead.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= ghead =
 function: unitptr &apos;&apos;&apos;ghead&apos;&apos;&apos;();

The ghead() function returns the first unit in the global unit list, providing access to all units currently active in the game.

== Description ==
 The &apos;&apos;&apos;ghead&apos;&apos;&apos;() function returns the first unit in the global unit list, providing access to all units currently active in the game. The global list contains all units (players, NPCs, objects, rooms) in the order they were created or logged in.

 This function is commonly used to iterate through all units in the game, particularly for:
 * Finding all online players
 * Performing global operations on all units
 * Checking who is currently logged in
 * Global cleanup or maintenance tasks

 The returned unit can be used with the .gnext field to traverse through the entire global list.

== Examples ==
 dilbegin list_online_players();
 var
    unit : unitptr;
    count : integer;
 code
 {
    sendtext(&quot;Currently online players:&amp;n&quot;, self);
    
    unit := ghead();
    count := 0;
    
    while (unit != null) {
       if (unit.type == UNIT_ST_PC) {
          if (visible(self, unit)) {
             sendtext(&quot;  &quot; + unit.name + &quot; (&quot; + unit.title + &quot;)&amp;n&quot;, self);
             count := count + 1;
          }
       }
       unit := unit.gnext;
    }
    
    sendtext(&quot;&amp;nTotal visible players: &quot; + itoa(count) + &quot;&amp;n&quot;, self);
    quit;
 } dilend

 dilbegin global_cleanup();
 var
    unit : unitptr;
 code
 {
    unit := ghead();
    
    while (unit != null) {
       // Perform cleanup operations on all units
       if (unit.type == UNIT_ST_OBJ) {
          // Clean up objects if needed
       }
       
       unit := unit.gnext;
    }
    
    quit;
 } dilend

== Usage Notes ==
* Returns the last character to have logged on as the first unit
* Use with &apos;&apos;&apos;gnext&apos;&apos;&apos; field to iterate through the entire global list
* The global list contains all unit types: players, NPCs, objects, and rooms
* Returns null if no units exist in the game

== Error Handling ==
* Returns null if the global list is empty
* Always check return value before using the returned unit
* The function itself does not fail under normal circumstances

== Related Functions/Fields ==
* [[Manual:DIL_Manual/gnext|gnext]] - Next unit in global list
* [[Manual:DIL_Manual/gprevious|gprevious]] - Previous unit in global list
* [[Manual:DIL_Manual/visible|visible]] - Check if unit is visible to another

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type and fields</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/global_head</title>
     <ns>0</ns>
     <id>1040783</id>
     <revision>
       <id>932777</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of global_head.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= global_head =
 function: unitptr &apos;&apos;&apos;global_head&apos;&apos;&apos;();

Returns the first unit in the global unit list, which will be the last character to have logged on.

== Description ==
Returns the first unit in the global unit list, which will be the last character to have logged on.

== Usage Notes ==
This function is currently marked as obsolete and not used anywhere in the existing DIL codebase. It was part of a set of head-related functions that were considered obsolete until needed and tested.

== Examples ==
 dilbegin example();
 code
    // This function is not used in any current DIL programs
    // head := global_head();  -- NOT USED ANYWHERE
 quit;
 dilend

== Error Handling ==
* Returns null if the global list is empty
* Function is obsolete - use &apos;&apos;&apos;ghead&apos;&apos;&apos;() instead

== Related Functions/Fields ==
* [[Manual:DIL_Manual/ghead|ghead]] - Similar function for global head
* [[Manual:DIL_Manual/obj_head|obj_head]] - Object head function
* [[Manual:DIL_Manual/npc_head|npc_head]] - NPC head function
* [[Manual:DIL_Manual/room_head|room_head]] - Room head function
* [[Manual:DIL_Manual/zone_head|zone_head]] - Zone head function
* [[Manual:DIL_Manual/command_head|command_head]] - Command head function

== See Also ==
* Obsolete functions and their modern equivalents</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/gnext</title>
     <ns>0</ns>
     <id>886864</id>
     <revision>
       <id>1787156</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of gnext.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= gnext =
 field: unitptr &apos;&apos;&apos;.gnext&apos;&apos;&apos; (Read-only)

Returns the next unit in the global list of units.

== Description ==
Returns the next unit in the global list of units. This is a read-only field of a unitptr.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access
|-
| gnext || unitptr || Read-only
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin look_signature();
 var
   pc:unitptr;
 code
 {
   heartbeat:=PULSE_SEC*3;
 :start:
   wait (SFB_CMD,(
   (command (&quot;look&quot;)) and
   ((&quot;signature&quot;==argument ) or (&quot;signatures&quot; == argument))
   ));
   block;
   pc:=ghead();
   sendtext (&quot;The following book signers are on line.&lt;br/&gt;&lt;br/&gt;&quot;,activator);

   while (pc.type==UNIT_ST_PC)
   {
     if (((isset (pc.pcflags,PC_PK_RELAXED)) or
           (dilfind (&quot;no_kill@function&quot;,pc))) and
         (pc.level&lt;200) and
         (visible (activator,pc)))
       sendtext(pc.name+&quot; &quot;+pc.title+&quot;&lt;br/&gt;&quot;,activator);
     pc:=pc.gnext;
   }

   goto start;
 } dilend

== Usage Notes ==
* The global list contains all units in the game
* This field is read-only (RO)
* Returns null when called on the last unit in the global list
* Commonly used for iterating through all units in the game
* Use with &apos;&apos;&apos;ghead&apos;&apos;&apos;() to start iteration from the beginning

== Error Handling ==
* Returns null when called on the last unit in the global list
* Always check return value before using the returned unit
* No error occurs when accessing on null units (returns null)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/ghead|ghead]] - Get the first unit in the global list
* [[Manual:DIL_Manual/gprevious|gprevious]] - Get the previous unit in the global list
* [[Manual:DIL_Manual/next|next]] - Get the next unit in the local list

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/goto</title>
     <ns>0</ns>
     <id>755065</id>
     <revision>
       <id>970674</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of goto.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= goto =
 statement: &apos;&apos;&apos;goto&apos;&apos;&apos;;

The goto statement performs an unconditional jump to a specified label within the same DIL program.

== Description ==
The &apos;&apos;&apos;goto&apos;&apos;&apos; statement is used to transfer program control unconditionally to a labeled location within the same DIL program. Labels are defined using a colon prefix (&apos;:labelname:&apos;) and serve as targets for goto statements. This provides a way to create loops, implement error handling, or structure program flow when other control structures are not suitable.

Goto statements are particularly useful in DIL for creating infinite loops with pause statements, implementing state machines, handling error conditions, and creating menu systems where traditional loop structures might be cumbersome.

== Usage Notes ==
* Labels are defined using the format &apos;:labelname:&apos; at the beginning of a line
* The goto statement jumps to the label without the colon prefix: &apos;goto labelname&apos;
* Labels must be unique within a DIL program
* Goto can jump both forward and backward in the code
* The statement is commonly used with &apos;&apos;&apos;pause&apos;&apos;&apos; to create continuous loops
* Labels are also used with &apos;&apos;&apos;on&apos;&apos;&apos; statements for interrupt handlers
* Goto cannot jump between different DIL programs or functions

== Error Handling ==
* Attempting to goto a non-existent label will result in a compilation error
* Labels must be defined before they can be used as goto targets
* The DIL compiler will validate all goto statements during compilation

== Examples ==
=== Basic Infinite Loop ===
dilbegin hello_world();
code
{
  :mylabel:
  exec(&quot;say Hello world&quot;, self);
  pause;
  goto mylabel;
} dilend

=== Error Handling ===
dilbegin safe_operation();
var
    target : unitptr;
code
{
    :start:
    target := self.fighting;
    
    if (not target)
        goto no_target;
    
    if (target.hp &lt;= 0)
        goto target_dead;
    
    exec(&quot;say Fighting &quot; + target.name, self);
    pause;
    goto start;
    
    :no_target:
    exec(&quot;say You are not fighting anyone&quot;, self);
    quit;
    
    :target_dead:
    exec(&quot;say Your target is dead&quot;, self);
    quit;
} dilend

=== Menu System ===
dilbegin menu_loop();
var
    choice : integer;
code
{
    :menu_start:
    act(&quot;1. Look around&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;2. Check inventory&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;3. Quit&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    
    // Simulate player choice (in real usage, this would come from player input)
    choice := rnd(1, 3);
    
    if (choice == 1) goto look_choice;
    if (choice == 2) goto inventory_choice;
    if (choice == 3) goto quit_choice;
    goto menu_start; // Invalid choice, show menu again
    
    :look_choice:
    exec(&quot;look&quot;, self);
    goto menu_start;
    
    :inventory_choice:
    exec(&quot;inventory&quot;, self);
    goto menu_start;
    
    :quit_choice:
    exec(&quot;say Goodbye!&quot;, self);
    quit;
} dilend

=== Time-Based Behavior ===
dilbegin time_based_greeting();
code
{
    :check_time:
    if (mudhour &gt;= 6 and mudhour &lt; 12)
        goto morning;
    
    if (mudhour &gt;= 12 and mudhour &lt; 18)
        goto afternoon;
    
    if (mudhour &gt;= 18 and mudhour &lt; 24)
        goto evening;
    
    goto night; // 0-5 hours
    
    :morning:
    exec(&quot;say Good morning!&quot;, self);
    goto wait_and_check;
    
    :afternoon:
    exec(&quot;say Good afternoon!&quot;, self);
    goto wait_and_check;
    
    :evening:
    exec(&quot;say Good evening!&quot;, self);
    goto wait_and_check;
    
    :night:
    exec(&quot;say Good night!&quot;, self);
    goto wait_and_check;
    
    :wait_and_check:
    heartbeat := PULSE_SEC * 300; // Check every 5 minutes
    pause;
    goto check_time;
} dilend

=== Resource Management ===
dilbegin resource_monitor();
var
    resource_level : integer;
code
{
    :monitor_loop:
    resource_level := self.mana; // Monitor mana as example
    
    if (resource_level &lt; 10)
        goto low_resource;
    
    if (resource_level &lt; 50)
        goto medium_resource;
    
    goto high_resource;
    
    :low_resource:
    exec(&quot;say Resources are critically low!&quot;, self);
    heartbeat := PULSE_SEC * 30; // Check every 30 seconds
    pause;
    goto monitor_loop;
    
    :medium_resource:
    exec(&quot;say Resources are moderate&quot;, self);
    heartbeat := PULSE_SEC * 60; // Check every minute
    pause;
    goto monitor_loop;
    
    :high_resource:
    exec(&quot;say Resources are plentiful&quot;, self);
    heartbeat := PULSE_SEC * 120; // Check every 2 minutes
    pause;
    goto monitor_loop;
} dilend

== Related Functions/Fields ==
* [[Manual:DIL_Manual/on n goto (...)|on n goto (...)]] - On integer goto with list of labels
* [[Manual:DIL_Manual/pause|pause]] - Often used with goto to create loops
* [[Manual:DIL_Manual/if|if]] - Conditional control structure
* [[Manual:DIL_Manual/while|while]] - Loop construct (alternative to goto-based loops)
* [[Manual:DIL_Manual/heartbeat|heartbeat]] - Timing control often used with goto loops

== See Also ==
* [[Manual:DIL_Manual/pause|pause]] - Program timing and loop control
* [[Manual:DIL_Manual/if|if]] - Conditional branching
* Control flow structures
* State machine patterns </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/gprevious</title>
     <ns>0</ns>
     <id>985508</id>
     <revision>
       <id>1119032</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of gprevious.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= gprevious =
 field: unitptr &apos;&apos;&apos;.gprevious&apos;&apos;&apos; (Read-only)

Returns the previous unit in the global list of units.

== Description ==
Returns the previous unit in the global list of units. This is a read-only field of a unitptr.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access
|-
| gprevious || unitptr || Read-only
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin color_bc();
 var
   pc     :unitptr;
   newarg :string;
 code
 {
   heartbeat := PULSE_SEC;
 
 :start:
   wait(SFB_CMD,((command(&quot;cb&quot;)) and (activator.level&gt;=242) and (activator==self.outside)));
   block;
   pc:=activator;
   if ((&quot;\\&quot; in argument) and (activator.level&lt;253))
   {
     act(&quot;You may not use newline characters!&quot;,A_ALWAYS,pc,null,null,TO_CHAR);
     log(pc.name + &quot; attempted to use newline characters in a &quot;
         +&quot;broadcast below level 253!&quot;);
     goto start;
   }
   if (&quot;\\&quot; in argument)
   {
     act(&quot;You may not change the background color, sorry.&quot;,A_ALWAYS,pc,null,null,TO_CHAR);
     goto start;
   }
   newarg := argument;
   newarg := replace(&quot;&amp;lt;&quot;,&quot;&lt;&quot;,newarg);
   newarg := replace(&quot;&amp;gt;&quot;,&quot;&gt;&quot;,newarg);

   while (pc.gprevious.type==UNIT_ST_PC)
     pc := pc.gprevious;

   while (pc.type==UNIT_ST_PC)
   {
     sendtext(newarg,pc);
     pc:=pc.gnext;
   }
   goto start;
 } dilend

== Usage Notes ==
* The global list contains all units in the game
* This field is read-only (RO)
* Returns null when called on the first unit in the global list
* Commonly used for iterating backwards through all units in the game
* Often used to find the first unit in a specific category before iterating forward

== Error Handling ==
* Returns null when called on the first unit in the global list
* Always check return value before using the returned unit
* No error occurs when accessing on null units (returns null)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/ghead|ghead]] - Get the first unit in the global list
* [[Manual:DIL_Manual/gnext|gnext]] - Get the next unit in the global list
* [[Manual:DIL_Manual/previous|previous]] - Get the previous unit in the local list

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/guild</title>
     <ns>0</ns>
     <id>410137</id>
     <revision>
       <id>1551690</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of guild.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= guild =

 field: string &apos;&apos;&apos;guild&apos;&apos;&apos; (Read/Write)

== Description ==
Returns the guild that a player character (PC) belongs to. This is a read-write field available only for player characters.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.guild || string || The guild name of the player character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
 dilbegin check_guild(pc : unitptr);
 var
     guild_name : string;
 code
 {
     guild_name := pc.guild;
     
     if (guild_name == &quot;thief&quot;)
     {
         exec(&quot;say Welcome, brother of the shadows!&quot;, self);
     }
     else if (guild_name == &quot;warrior&quot;)
     {
         exec(&quot;say A warrior&apos;s strength is respected here.&quot;, self);
     }
     else if (guild_name == &quot;&quot;)
     {
         exec(&quot;say You have not yet joined any guild.&quot;, self);
     }
     else
     {
         exec(&quot;say Welcome, member of the &quot; + guild_name + &quot; guild!&quot;, self);
     }
 } dilend

== Usage Notes ==
* This field is only available for player characters (UNIT_ST_PC)
* The field is read-write (RW), meaning it can be both read and modified
* Returns an empty string if the player is not in any guild
* Commonly used for guild-specific pricing, abilities, or restrictions

== Error Handling ==
* Accessing &apos;&apos;&apos;guild&apos;&apos;&apos; on non-player units will result in errors
* Always verify the unit is a player character before accessing this field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/skills|skills]] - Player skills array
* [[Manual:DIL_Manual/ability_points|ability_points]] - Player ability points
* [[Manual:DIL_Manual/skill_points|skill_points]] - Player skill points

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc|unit_st_pc]] - Player character specific fields</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/hasfunc</title>
     <ns>0</ns>
     <id>805569</id>
     <revision>
       <id>1238149</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of hasfunc.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= hasfunc =

 field: integer &apos;&apos;&apos;hasfunc&apos;&apos;&apos; (Read-only)

== Description ==
Returns TRUE if the unit has special functions attached to it. This is a read-only field of a unitptr.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.hasfunc || integer || 1 if unit has special functions, 0 otherwise
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin check_dil_presence(target : unitptr);
 var
     has_dil : integer;
 code
 {
     has_dil := target.hasfunc;
     
     if (has_dil == 1)
     {
         act(&quot;$1n has special functions attached.&quot;, 
             A_ALWAYS, target, null, null, TO_ROOM);
     }
     else
     {
         act(&quot;$1n has no special functions.&quot;, 
             A_ALWAYS, target, null, null, TO_ROOM);
     }
 } dilend

== Usage Notes ==
* This field is read-only (RO)
* Special functions refer to DIL programs or other function pointers attached to the unit
* This function is currently marked as obsolete and not used anywhere in the existing DIL codebase
* It was part of a set of functions considered obsolete until needed and tested
* Can be used to check if a unit has DIL programs attached before attempting to interact with them

== Error Handling ==
* Always check if the unit pointer is valid before accessing &apos;&apos;&apos;hasfunc&apos;&apos;&apos;
* The field will return 0 for null or invalid unit pointers

== Related Functions/Fields ==
* [[Manual:DIL_Manual/dilfind|dilfind]] - Find DIL programs attached to units
* [[Manual:DIL_Manual/dilcopy|dilcopy]] - Copy DIL programs to units
* [[Manual:DIL_Manual/dildestroy|dildestroy]] - Destroy DIL programs on units

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/heartbeat</title>
     <ns>0</ns>
     <id>1030163</id>
     <revision>
       <id>1386768</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of heartbeat.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= heartbeat =

 variable: &apos;&apos;&apos;heartbeat&apos;&apos;&apos;

== Description ==
Controls the heartbeat rate of a DIL program. This determines how frequently the SFB_TICK (tick) event is activated for the program.

== Usage Notes ==
The heartbeat can be assigned at runtime to change the rate with which SFB_TICK is activated. The value is specified in 1/4th of a second units.

 heartbeat := PULSE_SEC * 25; // Tick every 25 seconds

Use the PULSE_SEC constant to multiply your wanted delay:
* PULSE_SEC = 4 (represents 1 second)
* PULSE_SEC * 5 = 20 (represents 5 seconds)
* PULSE_SEC * 60 = 240 (represents 1 minute)

== Examples ==
 dilbegin simple_timer();
 var
     counter : integer;
 code
 {
     counter := 0;
     heartbeat := PULSE_SEC * 10; // Tick every 10 seconds
     
:start:
     wait(SFB_TICK, TRUE);
     counter := counter + 1;
     act(&quot;Timer tick #&quot; + itoa(counter), A_ALWAYS, self, null, null, TO_CHAR);
     
     if (counter &lt; 5)
         goto start;
     else
         exec(&quot;say Timer finished!&quot;, self);
 } dilend

== Usage Notes ==
* Do not set the heartbeat too low as it can impact server performance
* The heartbeat value is in 1/4 second increments (4 = 1 second)
* Use PULSE_SEC constant for readability and proper timing
* Common values:
** PULSE_SEC * 1 = 4 (1 second)
** PULSE_SEC * 5 = 20 (5 seconds)
** PULSE_SEC * 60 = 240 (1 minute)
** WAIT_SEC * 5 = commonly used for 5-second intervals

== Error Handling ==
* Setting heartbeat to 0 or negative values may cause unexpected behavior
* Very low heartbeat values (less than PULSE_SEC) can impact server performance

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Wait for specific events
* [[Manual:DIL_Manual/pause|pause]] - Pause execution
* [[Manual:DIL_Manual/SFB_TICK|SFB_TICK]] - Tick event trigger
* [[Manual:DIL_Manual/realtime|realtime]] - Get current game time

== See Also ==
* [[Manual:DIL_Manual/PULSE_SEC|PULSE_SEC]] - Time constant</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/height</title>
     <ns>0</ns>
     <id>1260104</id>
     <revision>
       <id>1067939</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of height.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= height =

 field: integer &apos;&apos;&apos;height&apos;&apos;&apos; (Read/Write)

== Description ==
The height of a PC/NPC, the length of a rope, or the size of weapons, armours, and shields. This is a read-write field of a unitptr.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.height || integer || The height/size of the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)

== Examples ==
 dilbegin check_height_fit(pc : unitptr, armor : unitptr);
 var
     height_diff : integer;
     percent_diff : integer;
 code
 {
     if (armor.type != UNIT_ST_OBJ)
     {
         exec(&quot;say This is not an object.&quot;, self);
         quit;
     }
     
     height_diff := pc.height - armor.height;
     percent_diff := (height_diff * 100) / pc.height;
     
     if (percent_diff &lt; -10)
     {
         exec(&quot;say This armor is much too large for you.&quot;, self);
     }
     else if (percent_diff &gt; 10)
     {
         exec(&quot;say This armor is much too small for you.&quot;, self);
     }
     else
     {
         exec(&quot;say This armor should fit you reasonably well.&quot;, self);
     }
 } dilend

== Usage Notes ==
* This field is read-write (RW)
* For PCs and NPCs: represents character height
* For objects like ropes: represents length
* For weapons, armor, and shields: represents size
* Commonly used in resizing calculations and equipment fitting checks
* Height values are typically in centimeters or similar units

== Error Handling ==
* Setting height to 0 or negative values may cause unexpected behavior
* When modifying height, consider the impact on gameplay balance
* Always validate height ranges are appropriate for the unit type

== Related Functions/Fields ==
* [[Manual:DIL_Manual/weight|weight]] - Unit weight field
* [[Manual:DIL_Manual/baseweight|baseweight]] - Base weight field
* [[Manual:DIL_Manual/objecttype|objecttype]] - Object type field
* [[Manual:DIL_Manual/value|value]] - Object values array

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/help</title>
     <ns>0</ns>
     <id>835556</id>
     <revision>
       <id>1082986</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of help.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= help =

 field: string &apos;&apos;&apos;help&apos;&apos;&apos; (Read-only)

== Description ==
Returns the help text associated with a zone. This is a read-only field of a zoneptr.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| zone.help || string || The help text for the zone
|}

== Availability ==
This field is available on the following pointer types:
* zoneptr (Zone pointer)

== Examples ==
 dilbegin display_zone_help(zone_name : string);
 var
     target_zone : zoneptr;
     help_text : string;
 code
 {
     target_zone := findzone(zone_name);
     
     if (target_zone)
     {
         help_text := target_zone.help;
         if (help_text != &quot;&quot;)
         {
             act(&quot;Zone help for &quot; + zone_name + &quot;:&quot;, 
                 A_ALWAYS, self, null, null, TO_CHAR);
             act(help_text, A_ALWAYS, self, null, null, TO_CHAR);
         }
         else
         {
             act(&quot;No help text available for zone &quot; + zone_name + &quot;.&quot;, 
                 A_ALWAYS, self, null, null, TO_CHAR);
         }
     }
     else
     {
         act(&quot;Zone &quot; + zone_name + &quot; not found.&quot;, 
             A_ALWAYS, self, null, null, TO_CHAR);
     }
 } dilend

== Usage Notes ==
* This field is read-only (RO)
* Only available on zoneptr variables
* Contains help text that describes the zone or provides information about it
* Can be used to display zone information to players
* The help text is typically set in the zone definition files

== Error Handling ==
* Always verify the zoneptr is valid before accessing the &apos;&apos;&apos;help&apos;&apos;&apos; field
* The help field may return an empty string if no help text is defined

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zhead|zhead]] - Get first zone in global list
* [[Manual:DIL_Manual/notes|notes]] - Zone notes field
* [[Manual:DIL_Manual/zone|zone]] - Zone name field of units
* [[Manual:DIL_Manual/findzone|findzone]] - Find a zone by name

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/hometown</title>
     <ns>0</ns>
     <id>445020</id>
     <revision>
       <id>1796171</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of hometown.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= hometown

== Syntax

  stringptr .hometown

== Description

The &apos;&apos;&apos;hometown&apos;&apos;&apos; field returns a string pointer to the hometown of a player character (PC). This field is read-only and can only be accessed on player character units.

== Return Value

Returns a string pointer containing the symbolic name of the player&apos;s hometown room. This can be used directly with functions like findroom() to locate the actual room unit.

== Usage Notes

* This field is only applicable to player characters (UNIT_ST_PC)
* The field is read-only (RO) - it cannot be modified
* The returned value is a string pointer that can be used with room-finding functions
* Each player is assigned a hometown during character creation

== Example

 dilbegin recall home();
 var
    hour : integer;
    i : integer;

 code
 {
    hour := -24;

    :start:
    wait(SFB_CMD, (activator == self.outside) and command(&quot;home&quot;));
    block;
    if (self.outside.position == POSITION_FIGHTING)
    {
       act(&quot;The $2N does not work in combat.&quot;,
          A_ALWAYS, self.outside, self, null, TO_CHAR);
       goto start;
    }

    if (self.equip == 0)
    {
       act(&quot;The $2N must be worn for it to work.&quot;,
          A_ALWAYS, self.outside, self, null, TO_CHAR);
       goto start;
    }

    if (activator.level &gt; 3)
    {
       act(&quot;As you attempt to use $2n it suddenly dissolves.&quot;,
          A_ALWAYS, self.outside, self, null, TO_CHAR);
       act(&quot;$1n&apos;s $2n suddenly dissolves as $1e attempts to use it,&quot;,
          A_ALWAYS, self.outside, self, null, TO_REST);
       destroy(self);
    }
    i := hour - (mudhour + mudday * MUD_DAY);
    if (i &lt; 0)
      i := -i;
    if (i &lt; 6)
    {
       act(&quot;The $2N has not charged enough power yet.&quot;,
          A_ALWAYS, self.outside, self, null, TO_CHAR);
       goto start;
    }
    hour := mudhour + mudday * MUD_DAY;
    act(&quot;Your $2N glows and you feel transported to another place!&quot;,
         A_ALWAYS, self.outside, self, null, TO_CHAR);
    act(&quot;The $2N on $1n&apos;s finger glows brightly as $1e vanishes in a &quot;+
        &quot;flash of light!&quot;, A_ALWAYS, self.outside, self, null, TO_REST);
    link(self.outside, findroom(self.outside.hometown));
    exec(&quot;look&quot;, self.outside);
    act(&quot;$1n appears in a flash of light!&quot;,
        A_ALWAYS, self.outside, self, null, TO_REST);
    goto start;
 } dilend

== See Also

* [[Manual:DIL_Manual/findroom|findroom]] - Find a room by symbolic name
* [[Manual:DIL_Manual/unit_st_pc|unit_st_pc]] - Player character unit fields </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/hp</title>
     <ns>0</ns>
     <id>342459</id>
     <revision>
       <id>1124431</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of hp.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= hp =

 field: integer &apos;&apos;&apos;hp&apos;&apos;&apos; (Read/Write)

== Description ==
The &apos;&apos;&apos;hp&apos;&apos;&apos; field represents the current hitpoints of a unit. This field is read-write (RW) and can be accessed on any unit type including characters, mobiles, and objects.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.hp || integer || The current hitpoints of the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Usage Notes

* For characters and mobiles, this represents their current health
* For objects, this represents the object&apos;s durability/condition
* Setting hp to low values can render objects &apos;broken&apos;
* If a unit has -1 hitpoints, it is considered unbreakable
* The field is read-write (RW) and can be modified
* Should typically be used in conjunction with max_hp to ensure values stay within valid ranges

== Examples

=== Basic Health Check

 if (self.hp &gt; 10)
 {
    act(&quot;You are in good health.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

=== Healing Example

 dilbegin heal_target(target : unitptr);
 var
 code
 {
    if (target.hp &lt; target.max_hp)
    {
       target.hp := target.hp + 6;
       if (target.hp &gt; target.max_hp)
         target.hp := target.max_hp;
       act(&quot;You feel better!&quot;, A_ALWAYS, target, null, null, TO_CHAR);
    }
 } dilend

=== Cloning Attributes

 dilbegin clone_attr(original : unitptr, tgt : unitptr);
 var
    i : integer;
 code
 {
    /* Copy abilities */
    while (i &lt; ABIL_TREE_MAX)
    {
       tgt.abilities[i] := original.abilities[i];
       i := i + 1;
    }

    /* Copy current hitpoints */
    tgt.hp := original.hp;

    quit;
 } dilend

=== Damage Example

 pc.hp := pc.hp - 100;

== See Also

* [[Manual:DIL_Manual/max_hp|max_hp]] - Maximum hitpoints field
* [[Manual:DIL_Manual/position_update|position_update]] - Useful when modifying hp field
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer fields </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/idx</title>
     <ns>0</ns>
     <id>1186207</id>
     <revision>
       <id>1325717</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of idx.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= idx =

 field: integer &apos;&apos;&apos;idx&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;idx&apos;&apos;&apos; field returns a constant integer ID for a unit. For players, this ID is persistent across reboots. For non-player characters (NPCs) and objects, this is the memory pointer converted to an integer.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.idx || integer || Unique identifier for the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Usage Notes

* For players: Returns a persistent ID that remains the same across reboots
* For NPCs and objects: Returns the memory pointer converted to integer (changes between reboots)
* This field is read-only (RO)
* Useful for distinguishing between multiple instances of the same unit type
* Commonly used with findsymbolic() to locate specific units later
* Do not rely on idx for persistence across reboots for non-player units

== Examples

=== Identifying Specific Units

 dilbegin track_guard();
 var
    guard_symname : string;
    guard_idx : integer;
    target : unitptr;
 code
 {
    // Get reference to a specific guard
    target := findsymbolic(&quot;cityguard@midgaard&quot;);
    if (target)
    {
       guard_symname := target.symname;
       guard_idx := target.idx;
       
       // Later, find the exact same guard
       target := findsymbolic(guard_symname, guard_idx);
       if (target)
       {
          act(&quot;Found the same guard again!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       }
    }
 } dilend

=== Justice System Example

 id := &quot;$reward &quot;+ self.symname + &quot; &quot; + itoa(self.idx) + &quot; &quot;+ juris;

=== Bounty Hunter Pattern

 // Presume target is pointing to a particular cityguard
 s := target.symname; // Save the symbolic name
 i := target.idx;
 // Do stuff. Wake up 9 hours later. Find the target again like this:
 target := findsymbolic(s, i);
 // and if the guard is still alive you&apos;ll get your pointer back.

== See Also

* [[Manual:DIL_Manual/findsymbolic|findsymbolic]] - Find units by symbolic name and optional idx
* [[Manual:DIL_Manual/symname|symname]] - Get the symbolic name of a unit
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer fields </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/if</title>
     <ns>0</ns>
     <id>615258</id>
     <revision>
       <id>1876389</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of if.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= if =

== Description ==
The &apos;&apos;&apos;if&apos;&apos;&apos; statement is a conditional control structure similar to C. It evaluates a condition and executes different code blocks based on whether the condition is true or false.

== Syntax ==
 if (condition)
 {
    // code to execute if condition is true
 }
 else
 {
    // code to execute if condition is false
 }

== Condition Evaluation

* Integers: Considered TRUE if non-zero, FALSE if zero
* Non-integer types: Considered TRUE if not null, FALSE if null
* Any valid expression can be used as the condition

== Usage Notes

* The else clause is optional
* Multiple if-else statements can be nested
* Curly braces are required for code blocks
* The condition can be any valid DIL expression

== Examples

=== Basic Health Check

 dilbegin foo();
 code
 {
   if (self.hp&gt;10)
   {
     exec(&quot;say Hehe!&quot;,self);
   }
   else
   {
     exec(&quot;say ouch!&quot;, self);
   }
 } dilend

=== Simple Condition Without Else

 dilbegin foo();
 code
 {
   if (self.loaded&gt;10)
   {
     exec(&quot;say its getting crowded!&quot;,self);
   }
 } dilend

=== Single Line Without Braces

 dilbegin foo();
 code
 {
   if (self.loaded&lt;10)
     exec(&quot;say plenty of room!&quot;,self);
 } dilend

=== Guard Routine with Multiple Conditions

 dilbegin guardroutine(guardloc : string, dayguard : integer);
 external
    DailyRoutine@quests(sl : stringlist, arg2 : string);
 var
    i  : integer;
    sch : intlist;
 code
 {
    if (dayguard)
       sch := {5, 18};  // Wake up at 5, go back at 6pm
    else
       sch := {17,6};   // Wake up at 17, go home at 6

 :start:
    heartbeat := WAIT_SEC*5;
    pause;
    if (mudhour == sch.[0])
    {
       DailyRoutine@quests({
          &quot;wake&quot;, 
          &quot;::descr::A $1N is here heading to work.&quot;,
          &quot;yawn&quot;,
          &quot;say Time to get going guys!&quot;, 
          &quot;::walkto::$2t&quot;,
          &quot;::descr::A $1N is here guarding the gate.&quot;
       }, guardloc);
    }

    if(mudhour == sch.[1])
    {
       i := rnd(1,3);
       if (i == 1) goto bar1;
       if (i == 2) goto bar2;
       if (i == 3) goto bar3;
       else goto start;
    }
 } dilend

== See Also

* [[Manual:DIL_Manual/else|else]] - Optional else clause for if statements
* [[Manual:DIL_Manual/goto|goto]] - Unconditional jump statement </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/illum</title>
     <ns>0</ns>
     <id>843763</id>
     <revision>
       <id>1357999</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of illum.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= illum =

 field: integer &apos;&apos;&apos;illum&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;illum&apos;&apos;&apos; field returns the amount of light that units inside a transparent unit create. This field is read-only (RO) and represents the combined light output from all light sources contained within a transparent container.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.illum || integer || Light created by units inside transparent unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Usage Notes

* This field is read-only (RO) and cannot be modified directly
* Only applies to transparent units that can contain other units
* Represents the cumulative light from all light sources inside the container
* Different from the &apos;&apos;&apos;bright&apos;&apos;&apos; field which is how much the unit itself lights up
* Different from the &apos;&apos;&apos;light&apos;&apos;&apos; field which is how much light is inside the unit

== Light Field Comparison

{| class=&quot;wikitable&quot;
! Field !! Description !! Read/Write !! Purpose
|-
| &apos;&apos;&apos;light&apos;&apos;&apos; || How much light is inside the unit || RO || Internal light level
|-
| &apos;&apos;&apos;bright&apos;&apos;&apos; || How much the unit lights up surroundings || RO || External light output
|-
| &apos;&apos;&apos;illum&apos;&apos;&apos; || Light created by units inside transparent unit || RO || Contained light sources
|}

== Examples

=== Checking Container Illumination

 dilbegin check_lamp(lamp : unitptr);
 var
    container : unitptr;
 code
 {
    if (lamp.outside)
    {
       container := lamp.outside;
       if (container.illum &gt; 0)
       {
          act(&quot;The container glows with light from within.&quot;, 
              A_ALWAYS, container, null, null, TO_ALL);
       }
    }
 } dilend

=== Light Level Analysis

 dilbegin analyze_light();
 var
    total_light : integer;
 code
 {
    total_light := self.light + self.illum;
    
    if (total_light &gt; 10)
    {
       act(&quot;This area is very well lit.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    else if (total_light &gt; 0)
    {
       act(&quot;This area is dimly lit.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
    else
    {
       act(&quot;This area is dark.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
 } dilend

== See Also

* [[Manual:DIL_Manual/light|light]] - How much light is inside a unit
* [[Manual:DIL_Manual/bright|bright]] - How much a unit lights up its surroundings
* [[Manual:DIL_Manual/setbright|setbright]] - Procedure to change a unit&apos;s brightness
* [[Manual:DIL_Manual/islight|islight]] - Check if a unit is a light source
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer fields </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/in</title>
     <ns>0</ns>
     <id>763944</id>
     <revision>
       <id>1369525</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of in.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= in =
 operator: &apos;&apos;&apos;in&apos;&apos;&apos;

The &apos;in&apos; operator is a multipurpose search operator used to check for the existence of elements within various data structures in DIL.

== Description ==
The &apos;&apos;&apos;in&apos;&apos;&apos; operator provides a convenient way to search for elements within different data types. It can be used to check if a string exists within another string (substring search), if a name exists in an extra description list, if a quest exists in a player&apos;s quest list, or if an element exists in a stringlist. This operator returns a boolean value (true/false) indicating whether the search was successful.

The operator is particularly useful for filtering operations, conditional checks, and data validation without requiring explicit loops or complex search functions.

== Usage ==
The &apos;in&apos; operator has different behaviors depending on the data types involved:

=== String Substring Search ===
; search_term : string
: Checks if search_term exists as a substring within another string

=== Extra Description Search ===
; name : string
: Checks if an extra description with the specified name exists in an extra description list (or for PC .quests or PC .info - any extraptr data structure)

=== Stringlist Search ===
; element : string
: Checks if an element exists in a stringlist

== Return Value ==
Returns integer:
* &apos;&apos;&apos;1&apos;&apos;&apos; (true) - The element was found
* &apos;&apos;&apos;0&apos;&apos;&apos; (false) - The element was not found

== Examples ==
=== String Substring Search ===
dilbegin search_text();
var
    text : string;
    search_term : string;
code
{
    text := &quot;The quick brown fox jumps over the lazy dog&quot;;
    search_term := &quot;fox&quot;;
    
    if (search_term in text)
        sendtext(&quot;Found &apos;&quot; + search_term + &quot;&apos; in the text.&lt;br/&gt;&quot;, self);
    else
        sendtext(&quot;Could not find &apos;&quot; + search_term + &quot;&apos; in the text.&lt;br/&gt;&quot;, self);
} dilend

=== Extra Description Search ===
dilbegin check_special_flags(target : unitptr);
var
    ex_list : extraptr;
code
{
    ex_list := target.extra;
    
    // Check for special flags
    if (&quot;$magical&quot; in ex_list) {
        act(&quot;$2n has magical properties.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    }
    
    if (&quot;$cursed&quot; in ex_list) {
        act(&quot;$2n appears to be cursed.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    }
} dilend

=== Quest Status Check ===
dilbegin check_quest_status();
code
{
    // Check if player has specific quests
    if (LIB_COMPLETE in self.quests) {
        sendtext(&quot;You have completed the library quest.&lt;br/&gt;&quot;, self);
    }
    
    if (not LIB_ONGOING in self.quests) {
        sendtext(&quot;You don&apos;t have any ongoing library quests.&lt;br/&gt;&quot;, self);
    }
} dilend

=== Stringlist Operations ===
dilbegin check_inventory_items();
var
    item_names : stringlist;
code
{
    item_names := {&quot;sword&quot;, &quot;shield&quot;, &quot;potion&quot;, &quot;key&quot;};
    
    // Check for specific items
    if (&quot;sword&quot; in item_names) {
        sendtext(&quot;You have a sword in your inventory.&lt;br/&gt;&quot;, self);
    }
    
    if (&quot;wand&quot; in item_names) {
        sendtext(&quot;You don&apos;t have a wand in your inventory.&lt;br/&gt;&quot;, self);
    }
} dilend

== Usage Notes ==
* The &apos;in&apos; operator is case-sensitive for string searches
* For extra descriptions and quests, the search is performed on the names field
* The operator returns boolean values (1 for true, 0 for false)
* String searches look for exact substring matches
* The operator is more efficient than manual loop-based searches
* Can be used in conditional statements (if, while) for filtering logic
* Particularly useful in quest systems and inventory management

== Error Handling ==
* Using &apos;in&apos; operator on null or undefined variables will result in runtime errors
* Ensure both operands are of compatible types before using the operator
* For string searches, very long search strings may impact performance
* Invalid data types will cause compilation errors

== Related Functions/Fields ==
* [[Manual:DIL_Manual/extra|extra]] - Access to unit&apos;s extra description list
* [[Manual:DIL_Manual/quests|quests]] - Access to player&apos;s quest list
* [[Manual:DIL_Manual/stringlist|stringlist]] - String list type that supports &apos;in&apos; operator
* [[Manual:DIL_Manual/extraptr|extraptr]] - Extra description pointer type
* [[Manual:DIL_Manual/names|names]] - Field for accessing names in extra descriptions
* [[Manual:DIL_Manual/substring|substring]] - Function for extracting substrings

== See Also ==
* String operations and searching functions
* Extra description management
* Quest system documentation
* List and array operations
* Conditional operators and control structures</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/info</title>
     <ns>0</ns>
     <id>668754</id>
     <revision>
       <id>1333186</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of info.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= info =
 field: extraptr &apos;&apos;&apos;info&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;info&apos;&apos;&apos; field provides access to a player character&apos;s personal information storage, which can contain custom data fields such as email addresses, maiden names, and other player-specific information.

== Description ==

The &apos;&apos;&apos;info&apos;&apos;&apos; field is accessed on player character units and returns an extraptr to the player&apos;s information structure. This structure is used to store persistent player data that is not part of the core character statistics but is needed for game management and player identification.

The info structure is implemented as a linked list of extra descriptions, where each entry can have:
* An array of names (stringlist)
* An array of values (integerlist) 
* A description string

== Field Access ==

{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.info || extraptr || Returns pointer to player&apos;s info structure
|}

== Availability ==

This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==

=== Basic Access ===
dilbegin example();
var
   pc : unitptr;
   info_ptr : extraptr;
code
{
   pc := activator;
   if (pc.type != UNIT_ST_PC) goto lost_pc;
   
   info_ptr := pc.info;
   if (info_ptr != null)
   {
      // Access player info
   }
:lost_pc:
} dilend

=== Searching for Specific Fields ===
dilbegin get_email();
var
   pc : unitptr;
   email_expd : extraptr;
   email_str : string;
code
{
   pc := activator;
   email_expd := &quot;$email&quot; in pc.info;
   if (email_expd != null)
   {
      email_str := email_expd.descr;
      act(&quot;Email: &quot; + email_str, A_ALWAYS, pc, null, null, TO_CHAR);
   }
   else
   {
      act(&quot;No email address set.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
   }
} dilend

=== Adding/Modifying Info Fields ===
dilbegin set_email();
var
   pc : unitptr;
   new_email : string;
code
{
   pc := activator;
   new_email := argument;
   
   // Remove existing email entry
   subextra(pc.info, &quot;$email&quot;);
   
   // Add new email entry
   addextra(pc.info, {&quot;$email&quot;}, new_email);
   
   act(&quot;Email address updated.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

== Usage Notes ==

* The info field can only be accessed on player characters (PCs)
* Common fields include &apos;&apos;&apos;$email&apos;&apos;&apos; and &apos;&apos;&apos;$maiden&apos;&apos;&apos;
* Custom field names should be prefixed with a special character (like $) to avoid conflicts
* The structure is persistent and saved with the player data
* Use the &apos;&apos;&apos;in&apos;&apos;&apos; operator to search for specific fields in the info structure

== Error Handling ==

* Attempting to access info on NPCs or other unit types will result in failure
* Always check if the returned extraptr is null before accessing its fields
* Ensure proper error handling when working with player data

== Related Functions/Fields ==

* [[Manual:DIL_Manual/extraptr|extraptr]] - Information about the extraptr data structure
* [[Manual:DIL_Manual/addextra|addextra]] - Function to add entries to extra descriptions
* [[Manual:DIL_Manual/subextra|subextra]] - Function to remove entries from extra descriptions
* [[Manual:DIL_Manual/in|in]] - Operator for searching within extra descriptions

== See Also ==

* Player character management
* Extra description system
* Data persistence and player information</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/insert</title>
     <ns>0</ns>
     <id>950662</id>
     <revision>
       <id>1367897</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of insert.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= insert =
 function: void &apos;&apos;&apos;insert&apos;&apos;&apos;(sl : stringlist or intlist, i : integer, s : string or integer);

The &apos;&apos;&apos;insert&apos;&apos;&apos; function inserts a value into a stringlist or intlist at the specified index position.

== Description ==

The &apos;&apos;&apos;insert&apos;&apos;&apos; function allows you to insert a value into a stringlist or intlist at a specific position without having to rebuild the entire list. This is more efficient than manually recreating the list when you need to insert elements in the middle of an existing list.

The function automatically handles both stringlist and intlist types based on the first parameter&apos;s type.

== PARAMETERS ==

{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| sl || stringlist or intlist || The list to insert into (must be a variable reference)
|-
| i || integer || The index position where the value will be inserted
|-
| s || string or integer || The value to insert (type must match list type)
|}

== Examples ==

=== Inserting into Stringlist ===
dilbegin insert_string_example();
var
   names : stringlist;
code
{
   names := {&quot;Alice&quot;, &quot;Charlie&quot;, &quot;David&quot;};
   
   // Insert &quot;Bob&quot; at position 1 (0-based indexing)
   insert(names, 1, &quot;Bob&quot;);
   
   // Result: {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;}
} dilend

=== Inserting into Intlist ===
dilbegin insert_int_example();
var
   numbers : intlist;
code
{
   numbers := {10, 30, 40};
   
   // Insert 20 at position 1
   insert(numbers, 1, 20);
   
   // Result: {10, 20, 30, 40}
} dilend

=== Inserting at End ===
dilbegin insert_at_end();
var
   items : stringlist;
code
{
   items := {&quot;first&quot;, &quot;second&quot;};
   
   // Insert at the end using length()
   insert(items, length(items), &quot;third&quot;);
   
   // Result: {&quot;first&quot;, &quot;second&quot;, &quot;third&quot;}
} dilend

== Usage Notes ==

* The function uses 0-based indexing
* Position 0 inserts at the beginning of the list
* Position equal to current length appends to the end
* Positions beyond current length expand the list with empty values
* For &apos;&apos;&apos;stringlist&apos;&apos;&apos;: the third parameter should be a string
* For &apos;&apos;&apos;intlist&apos;&apos;&apos;: the third parameter can be an integer or convertible string
* The function modifies the list in-place and does not return a value

== Error Handling ==

* The first parameter must be a variable reference to a stringlist or intlist
* The second parameter must be an integer
* The third parameter must be compatible with the list type
* Type mismatch errors will occur at compile time if parameters are incorrect

== Related Functions/Fields ==

* [[Manual:DIL_Manual/stringlist|stringlist]] - Information about stringlist data structure
* [[Manual:DIL_Manual/integerlist|integerlist]] - Information about intlist data structure  
* [[Manual:DIL_Manual/addstring|addstring]] - Function to add strings to the end of a stringlist
* [[Manual:DIL_Manual/remove|remove]] - Function to remove elements from a list
* [[Manual:DIL_Manual/length|length]] - Function to get the length of a list

== See Also ==

* List and array operations
* Data structure manipulation
* Type conversion functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/inside</title>
     <ns>0</ns>
     <id>670289</id>
     <revision>
       <id>1011737</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of inside.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= inside =
 field: unitptr &apos;&apos;&apos;inside&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;inside&apos;&apos;&apos; field points to the first unit contained within this unit, or null if the unit is empty.

== Description ==

The &apos;&apos;&apos;inside&apos;&apos;&apos; field provides access to the first unit in a unit&apos;s contents. This creates a linked list structure where you can navigate through all units contained within another unit using the &apos;&apos;&apos;next&apos;&apos;&apos; field.

This field is read-only (RO) and represents the &quot;contains&quot; relationship in the unit hierarchy. For example, a room&apos;s inside field points to the first player/object in that room, and a player&apos;s inside field points to the first item in their inventory.

== Field Access ==

{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.inside || unitptr || Returns pointer to first contained unit or null
|}

== Availability ==

This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==

=== Checking if Unit is Empty ===
dilbegin check_contents();
var
   container : unitptr;
code
{
   container := self;
   
   if (container.inside == null)
   {
      act(&quot;The container is empty.&quot;, A_ALWAYS, activator, null, null, TO_CHAR);
   }
   else
   {
      act(&quot;The container contains something.&quot;, A_ALWAYS, activator, null, null, TO_CHAR);
   }
} dilend

=== Iterating Through Contents ===
dilbegin list_inventory();
var
   pc : unitptr;
   item : unitptr;
   count : integer;
code
{
   pc := activator;
   count := 0;
   
   item := pc.inside;
   while (item != null)
   {
      act(&quot;Item &quot; + itoa(count + 1) + &quot;: &quot; + item.name, 
          A_ALWAYS, pc, null, null, TO_CHAR);
      item := item.next;
      count := count + 1;
   }
   
   if (count == 0)
   {
      act(&quot;You are not carrying anything.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
   }
   else
   {
      act(&quot;Total items: &quot; + itoa(count), A_ALWAYS, pc, null, null, TO_CHAR);
   }
} dilend

=== Corpse Processing ===
dilbegin process_corpse();
var
   corpse : unitptr;
code
{
   corpse := self;
   
   // Check if corpse has contents
   if (corpse.inside != null)
   {
      act(&quot;The corpse still contains items.&quot;, A_ALWAYS, activator, null, null, TO_CHAR);
      exec(&quot;get all from corpse&quot;, activator);
   }
   else
   {
      act(&quot;The corpse is empty.&quot;, A_ALWAYS, activator, null, null, TO_CHAR);
      exec(&quot;bury corpse&quot;, activator);
   }
} dilend

== Usage Notes ==

* The field is read-only (RO)
* Returns null if the unit contains no other units
* Creates a linked list structure when combined with the &apos;&apos;&apos;next&apos;&apos;&apos; field
* Commonly used with while loops to iterate through contents
* Essential for inventory management and container operations
* The typical navigation pattern is: unit := container.inside; while (unit != null) { /* process */ unit := unit.next; }

== Error Handling ==

* Always check if the returned unitptr is null before accessing its fields
* Be careful with nested container navigation to avoid infinite loops
* Ensure proper type checking when processing mixed unit types

== Related Functions/Fields ==

* [[Manual:DIL_Manual/outside|outside]] - The unit that contains this unit
* [[Manual:DIL_Manual/next|next]] - The next unit at the same containment level
* [[Manual:DIL_Manual/foreach|foreach]] - Function for iterating through units of specific types
* [[Manual:DIL_Manual/unitptr|unitptr]] - Information about unit pointers and their fields

== See Also ==

* Inventory management systems
* Container operations
* Unit hierarchy and relationships
* Linked list navigation patterns</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/inside_descr</title>
     <ns>0</ns>
     <id>937514</id>
     <revision>
       <id>1499827</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of inside_descr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= inside_descr =
 field: string &apos;&apos;&apos;inside_descr&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;inside_descr&apos;&apos;&apos; field contains the text that players see when they are inside a unit and look around.

== Description ==

The &apos;&apos;&apos;inside_descr&apos;&apos;&apos; field provides access to the description text that is displayed when a character is inside a unit and issues a look command. This is most commonly used for rooms, but can also apply to containers, vehicles, or any other unit that can contain other units.

This field is read-write (RW), meaning it can be both read and modified by DIL programs to dynamically change the appearance of locations from within.

== Field Access ==

{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.inside_descr || string || The description text seen from inside the unit
|}

== Availability ==

This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==

=== Reading Inside Description ===
dilbegin check_room_description();
var
   room : unitptr;
   desc : string;
code
{
   room := self.outside;  // Get the room containing this object
   desc := room.inside_descr;
   
   act(&quot;Room description: &quot; + desc, A_ALWAYS, activator, null, null, TO_CHAR);
} dilend

=== Modifying Inside Description ===
dilbegin modify_room();
var
   room : unitptr;
   new_desc : string;
code
{
   room := self.outside;
   new_desc := &quot;This is a newly modified room description.&quot;;
   
   room.inside_descr := new_desc;
   act(&quot;The room has been modified.&quot;, A_ALWAYS, activator, null, null, TO_CHAR);
} dilend

=== Graffiti System ===
dilbegin do_graffiti();
var
   room : unitptr;
   original_desc : string;
   new_desc : string;
code
{
   room := self.outside.outside;  // Get the room
   original_desc := room.inside_descr;
   
   // Add graffiti to the room description
   new_desc := original_desc + &quot; &lt;div class=&apos;red&apos;&gt;Red graffiti is painted here!&lt;/div&gt;&quot;;
   room.inside_descr := new_desc;
   
   act(&quot;You add graffiti to the room.&quot;, A_ALWAYS, activator, null, null, TO_CHAR);
} dilend

== Usage Notes ==

* Changes to inside_descr are immediately visible to players in the unit
* The description is saved with the unit if the unit is persistent
* HTML formatting can be included in the description text
* This field is commonly used for rooms but applies to any container unit
* Useful for dynamic room descriptions, graffiti systems, environmental effects, and story progression

== Error Handling ==

* Ensure the unit exists before accessing the field
* Be cautious with HTML formatting to avoid breaking display
* Consider length limits for very long descriptions

== Related Functions/Fields ==

* [[Manual:DIL_Manual/outside_descr|outside_descr]] - The description of the unit from the outside
* [[Manual:DIL_Manual/extra|extra]] - Extra descriptions system for more complex description handling
* [[Manual:DIL_Manual/act|act]] - Function for sending messages to players
* [[Manual:DIL_Manual/unitptr|unitptr]] - Information about unit pointers and their fields

== See Also ==

* Room description management
* Dynamic content systems
* Player customization features
* Environmental storytelling</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/integer</title>
     <ns>0</ns>
     <id>885821</id>
     <revision>
       <id>1713651</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of integer.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= integer =
 type: &apos;&apos;&apos;integer&apos;&apos;&apos;

The &apos;&apos;&apos;integer&apos;&apos;&apos; type represents signed 32-bit numeric values used throughout DIL programs for calculations, comparisons, and boolean operations.

== Description ==
An &apos;&apos;&apos;integer&apos;&apos;&apos; is a fundamental numeric data type in DIL that supports signed 32-bit values. Integers can be used for mathematical operations, comparisons, boolean logic, and as indexes for arrays and data structures. They are essential for game mechanics calculations, character statistics, experience tracking, and conditional logic.

Integer variables are automatically managed by the DIL runtime and are saved with DIL programs when attached to saved units, making them persistent across game sessions.

== Declaration ==
Integer variables are declared using the `var` keyword:
 var
    my_integer : integer;

Static integer literals can be defined in decimal or hexadecimal format:
 42        // Decimal
 0x10      // Hexadecimal (equivalent to 16)

== Operations ==
=== Arithmetic Operators ===
* `+` (addition)
* `-` (subtraction/negation)
* `*` (multiplication)
* `/` (division)

=== Comparison Operators ===
* `==` (equal to)
* `!=` (not equal to)
* `&lt;` (less than)
* `&gt;` (greater than)
* `&lt;=` (less than or equal to)
* `&gt;=` (greater than or equal to)

=== Logical Operators ===
* `and` - Logical AND
* `or` - Logical OR
* `not` - Logical NOT

=== Bitwise Operators ===
* `&amp;` (bitwise AND) - Used for flag operations
* `|` (bitwise OR) - Used for flag operations

== Boolean Usage ==
In DIL, integers are treated as boolean values:
* Non-zero values evaluate to TRUE
* Zero evaluates to FALSE

This allows integers to be used directly in conditional statements:
 if (some_integer)        // TRUE if non-zero
 if (not some_integer)   // TRUE if zero

== Examples ==
=== Basic Arithmetic ===
dilbegin basic_math();
var
    health : integer;
    damage : integer;
    remaining : integer;
code
{
    health := 100;
    damage := 25;
    remaining := health - damage;
    
    sendtext(&quot;Health: &quot; + itoa(health) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Damage: &quot; + itoa(damage) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Remaining: &quot; + itoa(remaining) + &quot;&lt;br/&gt;&quot;, self);
} dilend

=== Comparison and Logic ===
dilbegin check_combat_ready();
var
    level : integer;
    health : integer;
code
{
    level := self.level;
    health := self.hp;
    
    if (level &gt;= 10 and health &gt; 50) {
        sendtext(&quot;You are ready for combat!&lt;br/&gt;&quot;, self);
    } else if (level &lt; 10 or health &lt;= 0) {
        sendtext(&quot;You are not ready for combat.&lt;br/&gt;&quot;, self);
    } else {
        sendtext(&quot;You need more health to be ready.&lt;br/&gt;&quot;, self);
    }
} dilend

=== Experience Calculations ===
dilbegin calculate_xp_bonus(base_xp : integer, level : integer);
var
    bonus : integer;
    total_xp : integer;
code
{
    // Calculate 10% bonus for high-level characters
    if (level &gt; 20) {
        bonus := base_xp / 10;
    } else {
        bonus := 0;
    }
    
    total_xp := base_xp + bonus;
    
    sendtext(&quot;Base XP: &quot; + itoa(base_xp) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Bonus: &quot; + itoa(bonus) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Total XP: &quot; + itoa(total_xp) + &quot;&lt;br/&gt;&quot;, self);
} dilend

=== Flag Operations ===
dilbegin check_player_flags();
var
    flags : integer;
    is_admin : integer;
    is_immortal : integer;
code
{
    flags := self.pcflags;
    
    // Use bitwise AND to check specific flags
    is_admin := flags &amp; PC_ADMIN;
    is_immortal := flags &amp; PC_IMMORTAL;
    
    if (is_admin) {
        sendtext(&quot;You have admin privileges.&lt;br/&gt;&quot;, self);
    }
    
    if (is_immortal) {
        sendtext(&quot;You are immortal.&lt;br/&gt;&quot;, self);
    }
    
    if (not (is_admin or is_immortal)) {
        sendtext(&quot;You are a regular player.&lt;br/&gt;&quot;, self);
    }
} dilend

=== Loop Counter ===
dilbegin count_items();
var
    i : integer;
    count : integer;
code
{
    count := 0;
    i := 0;
    
    while (i &lt; 10) {
        count := count + 1;
        i := i + 1;
    }
    
    sendtext(&quot;Counted &quot; + itoa(count) + &quot; items.&lt;br/&gt;&quot;, self);
} dilend

=== Random Number Generation ===
dilbegin random_damage();
var
    base_damage : integer;
    random_mod : integer;
    total_damage : integer;
code
{
    base_damage := 10;
    random_mod := rnd(1, 6);  // Random 1-6
    total_damage := base_damage + random_mod;
    
    act(&quot;You deal $2d points of damage!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    act(&quot;$1n deals $2d points of damage!&quot;, A_ALWAYS, self, itoa(total_damage), null, TO_ALL);
} dilend

=== Hexadecimal Usage ===
dilbegin hex_examples();
var
    color_value : integer;
    mask : integer;
code
{
    // Using hexadecimal for color values
    color_value := 0xFF0000;  // Blue color
    mask := 0x00FF00;     // Green mask
    
    sendtext(&quot;Color value: &quot; + itoa(color_value) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Green component: &quot; + itoa((color_value &amp; mask) &gt;&gt; 8) + &quot;&lt;br/&gt;&quot;, self);
} dilend

=== Array Indexing ===
dilbegin array_access();
var
    numbers : intlist;
    i : integer;
    sum : integer;
code
{
    numbers := {10, 20, 30, 40, 50};
    sum := 0;
    i := 0;
    
    while (i &lt; length(numbers)) {
        sum := sum + numbers.[i];
        i := i + 1;
    }
    
    sendtext(&quot;Sum: &quot; + itoa(sum) + &quot;&lt;br/&gt;&quot;, self);
} dilend

== Usage Notes ==
* Integers are signed 32-bit values (approximately -2.1 billion to +2.1 billion)
* Hexadecimal values are prefixed with &apos;0x&apos; for clarity
* Integer division truncates toward zero
* Use parentheses to ensure proper operator precedence
* Boolean operations treat any non-zero value as TRUE
* Bitwise operations are commonly used for flag manipulation
* Integer variables are automatically allocated and managed
* Values are persistent when attached to saved units

== Error Handling ==
* Division by zero will result in runtime error
* Overflow can occur with very large calculations
* Type mismatch errors occur when using string operations on integers
* Array bounds checking is required for intlist access
* Invalid hexadecimal format will cause compilation error

== Related Functions/Fields ==
* [[Manual:DIL_Manual/itoa|itoa]] - Convert integer to string
* [[Manual:DIL_Manual/atoi|atoi]] - Convert string to integer
* [[Manual:DIL_Manual/getinteger|getinteger]] - Retrieve system integer values
* [[Manual:DIL_Manual/intlist|intlist]] - Integer list type
* [[Manual:DIL_Manual/rnd|rnd]] - Generate random integers
* [[Manual:DIL_Manual/length|length]] - Get length of integer lists

== See Also ==
* String type and operations
* Floating point operations
* Boolean logic and control structures
* Flag manipulation and bitwise operations
* Array and list operations</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/integerlist</title>
     <ns>0</ns>
     <id>609802</id>
     <revision>
       <id>1414331</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of integerlist.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= integerlist =
 type: &apos;&apos;&apos;integerlist&apos;&apos;&apos;

The &apos;&apos;&apos;integerlist&apos;&apos;&apos; type represents an ordered array of integer values that can be dynamically resized and manipulated in DIL programs.

== Description ==
An &apos;&apos;&apos;integerlist&apos;&apos;&apos; is a collection data type that stores multiple integer values in a sequence. Unlike individual integer variables, an integerlist allows you to manage groups of related numbers, such as weapon skill values, experience amounts, damage values, or any other numeric data that needs to be processed as a set.

Integerlists are automatically managed by the DIL runtime, handling memory allocation and resizing as needed. They are saved with DIL programs when attached to saved units, making them persistent across game sessions.

== Declaration ==
Integerlist variables are declared using the `var` keyword:
 var
    my_numbers : integerlist;

Static integerlists are defined using curly braces:
  {10, 20, 30, 40, 50}

== Access ==
Individual elements are accessed using 0-based indexing with square brackets:
  my_list.[3]    // Access 4th element (index 3)

== Examples ==
=== Basic Declaration and Access ===
dilbegin basic_intlist();
var
    weapon_skills : integerlist;
    skill_level : integer;
code
{
    // Initialize with weapon skill values
    weapon_skills := {5, 3, 6, 9, 3, 9};
    
    // Access specific weapon skill
    skill_level := weapon_skills.[2];  // Get 3rd weapon skill (value 6)
    
    sendtext(&quot;Weapon skill at index 2: &quot; + itoa(skill_level) + &quot;&lt;br/&gt;&quot;, self);
    
    // Modify a value
    weapon_skills.[2] := 7;
    sendtext(&quot;Modified weapon skill to: &quot; + itoa(weapon_skills.[2]) + &quot;&lt;br/&gt;&quot;, self);
} dilend

=== Dynamic Operations ===
dilbegin dynamic_intlist();
var
    numbers : integerlist;
    i : integer;
    sum : integer;
code
{
    // Start with empty list
    numbers := {};
    
    // Add values dynamically
    numbers.[0] := 10;
    numbers.[1] := 20;
    numbers.[2] := 30;
    
    // Calculate sum
    sum := 0;
    i := 0;
    while (i &lt; length(numbers)) {
        sum := sum + numbers.[i];
        i := i + 1;
    }
    
    sendtext(&quot;List contains &quot; + itoa(length(numbers)) + &quot; elements.&lt;br/&gt;&quot;, self);
    sendtext(&quot;Sum of all elements: &quot; + itoa(sum) + &quot;&lt;br/&gt;&quot;, self);
} dilend

=== Inserting Values ===
dilbegin insert_example();
var
    items : integerlist;
    i : integer;
code
{
    // Start with some values
    items := {100, 200, 300};
    
    // Insert 150 at position 1
    insert(items, 1, 150);
    
    // Insert at end
    insert(items, length(items), 400);
    
    // Display all values
    i := 0;
    while (i &lt; length(items)) {
        sendtext(&quot;Item &quot; + itoa(i) + &quot;: &quot; + itoa(items.[i]) + &quot;&lt;br/&gt;&quot;, self);
        i := i + 1;
    }
} dilend

=== List Processing ===
dilbegin process_scores();
var
    scores : integerlist;
    i : integer;
    high_score : integer;
    average : integer;
code
{
    // Simulate some scores
    scores := {85, 92, 78, 96, 88, 91};
    
    // Find highest score
    high_score := 0;
    i := 0;
    while (i &lt; length(scores)) {
        if (scores.[i] &gt; high_score) {
            high_score := scores.[i];
        }
        i := i + 1;
    }
    
    // Calculate average
    average := 0;
    i := 0;
    while (i &lt; length(scores)) {
        average := average + scores.[i];
        i := i + 1;
    }
    average := average / length(scores);
    
    sendtext(&quot;Highest score: &quot; + itoa(high_score) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Average score: &quot; + itoa(average) + &quot;&lt;br/&gt;&quot;, self);
} dilend

=== Weapon Skill Management ===
dilbegin weapon_skills();
var
    weapon_types : integerlist;
    i : integer;
code
{
    // Weapon skill values for different weapon types
    weapon_types := {5, 3, 6, 9, 3, 9};
    
    // Check if player has specific weapon skill
    i := 0;
    while (i &lt; length(weapon_types)) {
        if (weapon_types.[i] == 5) {
            sendtext(&quot;You have sword skill level &quot; + itoa(weapon_types.[i]) + &quot;&lt;br/&gt;&quot;, self);
        } else if (weapon_types.[i] == 3) {
            sendtext(&quot;You have axe skill level &quot; + itoa(weapon_types.[i]) + &quot;&lt;br/&gt;&quot;, self);
        }
        i := i + 1;
    }
} dilend

=== Experience Tracking ===
dilbegin track_experience();
var
    xp_gains : integerlist;
    total_xp : integer;
    i : integer;
code
{
    // Track XP gains from different sources
    xp_gains := {100, 250, 150, 300};
    
    // Calculate total XP gained
    total_xp := 0;
    i := 0;
    while (i &lt; length(xp_gains)) {
        total_xp := total_xp + xp_gains.[i];
        i := i + 1;
    }
    
    sendtext(&quot;Total XP gained: &quot; + itoa(total_xp) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Number of sources: &quot; + itoa(length(xp_gains)) + &quot;&lt;br/&gt;&quot;, self);
} dilend

=== Random Value Generation ===
dilbegin random_values();
var
    random_numbers : integerlist;
    i : integer;
code
{
    // Generate list of random numbers
    random_numbers := {};
    
    i := 0;
    while (i &lt; 5) {
        insert(random_numbers, i, rnd(1, 100));
        i := i + 1;
    }
    
    // Display the random values
    i := 0;
    while (i &lt; length(random_numbers)) {
        sendtext(&quot;Random value &quot; + itoa(i) + &quot;: &quot; + itoa(random_numbers.[i]) + &quot;&lt;br/&gt;&quot;, self);
        i := i + 1;
    }
} dilend

=== Quest Progress Tracking ===
dilbegin quest_progress();
var
    quest_stages : integerlist;
    current_stage : integer;
code
{
    // Quest stage values
    quest_stages := {1, 2, 3, 4, 5};
    
    current_stage := 1;  // Player is at stage 1
    
    // Check if player can advance
    if (current_stage &lt; length(quest_stages)) {
        sendtext(&quot;You can advance to stage &quot; + itoa(quest_stages.[current_stage]) + &quot;&lt;br/&gt;&quot;, self);
        current_stage := current_stage + 1;
    } else {
        sendtext(&quot;You have completed all quest stages.&lt;br/&gt;&quot;, self);
    }
} dilend

== Usage Notes ==
* Integerlists use 0-based indexing (first element is at index 0)
* Lists are automatically resized when accessing beyond current bounds
* Setting an index beyond current size expands the list with empty values (0) for gaps
* Static lists are defined with curly braces and comma-separated values
* Lists are saved with DIL programs when attached to saved units
* The &apos;&apos;&apos;length()&apos;&apos;&apos; function returns the current size of an integerlist
* Use &apos;&apos;&apos;insert()&apos;&apos;&apos; function to add values at specific positions
* Lists can contain duplicate values unless explicitly prevented by logic

== Error Handling ==
* Accessing an index that doesn&apos;t exist returns 0 (or empty value)
* Negative indices are invalid and will cause runtime errors
* Type mismatch errors occur when using string operations on integerlists
* Out of memory errors can occur with extremely large lists
* Always check list bounds when iterating with &apos;&apos;&apos;length()&apos;&apos;&apos; function

== Related Functions/Fields ==
* [[Manual:DIL_Manual/length|length]] - Get the number of elements in an integerlist
* [[Manual:DIL_Manual/insert|insert]] - Insert values at specific positions in an integerlist
* [[Manual:DIL_Manual/remove|remove]] - Remove elements from an integerlist
* [[Manual:DIL_Manual/integer|integer]] - Individual integer type documentation
* [[Manual:DIL_Manual/stringlist|stringlist]] - String list equivalent type
* [[Manual:DIL_Manual/vals|vals]] - Field that returns integerlist from extra descriptions

== See Also ==
* Array and list operations
* Data structure manipulation
* Loop and iteration patterns
* Type conversion functions (atoi, itoa)
* Extra description and quest systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/interrupt</title>
     <ns>0</ns>
     <id>682111</id>
     <revision>
       <id>1485566</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of interrupt.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= interrupt =
 function: integer &apos;&apos;&apos;interrupt&apos;&apos;&apos;(flags : integer, dilexp : expression, label : label);

The &apos;&apos;&apos;interrupt&apos;&apos;&apos; function sets up an interrupt handler for specific message classes with conditional execution and label jumping.

== Description ==

The &apos;&apos;&apos;interrupt&apos;&apos;&apos; function creates an interrupt handler that monitors for messages matching specified flag classes. When a matching message occurs, the DIL expression is evaluated. If the expression evaluates to true, execution jumps to the specified label. If false, the next interrupt (if any) is checked.

Interrupts are saved and restored when the &apos;&apos;&apos;recall&apos;&apos;&apos; keyword is used in the DIL program. The function returns an integer identifier that can be used with the &apos;&apos;&apos;clear()&apos;&apos;&apos; function to remove the interrupt.

== PARAMETERS ==

{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| flags || integer || Bitwise combination of message class flags (SFB_*) to monitor
|-
| dilexp || expression || DIL expression evaluated when matching message received
|-
| label || label || Target label where execution continues when dilexp is true
|}

Common message flags include:
* SFB_COM - Combat messages
* SFB_MSG - User messages 
* SFB_CMD - Command messages
* SFB_TICK - Timer messages
* SFB_DEAD - Death messages

Multiple flags can be combined using the bitwise OR operator (|).

== Examples ==

=== Basic Combat Interrupt ===
 interrupt(SFB_COM, activator == self, broken);

This sets up an interrupt that triggers on combat messages where the activator is the same as the program owner, jumping to the :broken: label.

=== Message Handling ===
 interrupt(SFB_MSG, argument == &quot;cured&quot;, the_end);

This monitors for user messages with the argument &quot;cured&quot; and jumps to :the_end: when received.

=== Clearable Interrupt ===
 i1 := interrupt(SFB_MSG, argument == &quot;relief&quot;, relief);
 
 :relief:
 /* Clear interrupt after one-time use */
 clear(i1);
 pause;
 goto loop;

This shows how to store the interrupt ID and clear it after use.

== Usage Notes ==

* Interrupts are checked in the order they are defined
* Multiple interrupts can be active simultaneously
* Use &apos;&apos;&apos;clear()&apos;&apos;&apos; with the returned ID to remove interrupts
* Interrupts with &apos;&apos;&apos;recall&apos;&apos;&apos; keyword persist across save/load cycles
* The &apos;&apos;&apos;aware&apos;&apos;&apos; keyword may be needed to receive messages from the program owner

== Error Handling ==

* Invalid message flags will cause compilation errors
* Labels must exist in the current DIL program scope
* Expression evaluation errors may cause runtime failures
* Ensure proper cleanup of interrupts to avoid memory leaks

== Related Functions/Fields ==

* [[Manual:DIL_Manual/clear|clear]] - Removes an interrupt
* [[Manual:DIL_Manual/wait|wait]] - Waits for specific message classes

== See Also ==

* Message handling and event systems
* DIL program control structures
* Flag constants and bitwise operations</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/isaff</title>
     <ns>0</ns>
     <id>1157420</id>
     <revision>
       <id>1091498</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of isaff.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= isaff =
 function: integer &apos;&apos;&apos;isaff&apos;&apos;&apos;(u : unitptr, i : integer);

The &apos;&apos;&apos;isaff&apos;&apos;&apos; function tests whether a unit is affected by a specific affect ID.

== Description ==

The &apos;&apos;&apos;isaff&apos;&apos;&apos; function scans a unit for any affect matching the specified affect ID and returns TRUE (1) if one is found, or FALSE (0) if not. This is commonly used to check if a character or object has a specific spell effect, status condition, or magical property.

== PARAMETERS ==

{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit to be examined (PC, NPC, or object)
|-
| i || integer || The affect ID to check for (ID_* constants)
|}

Common affect IDs include:
* ID_BLIND_CHAR - Blindness affect
* ID_CORPSE - Corpse affect (on objects)
* ID_BLESS - Bless affect
* ID_CURSE - Curse affect
* ID_INVISIBILITY - Invisibility affect
* ID_DETECT_MAGIC - Magic detection affect
* ID_DETECT_INVISIBLE - Invisibility detection affect
* ID_HOLD - Hold/paralysis affect
* ID_CHARM - Charm affect
* ID_SPL_RAISE_* - Various spell raise affects (STR, DEX, CON, etc.)

== Examples ==

=== Basic Blindness Check ===
 if (isaff(self, ID_BLIND_CHAR))
   sendtext(&quot;You&apos;re blinded&quot;, self);

This checks if the program owner is blinded and sends a message if so.

=== Corpse Detection ===
 if ((i.objecttype == ITEM_CONTAINER) and isaff(i, ID_CORPSE))
 {
    act(&quot;$1n savagely devour $2n.&quot;, A_SOMEONE, self, i, null, TO_ROOM);
    while (i.inside)
       link(i.inside, i.outside);
    destroy(i);
 }

This example from a dog NPC checks if an object is a corpse container and eats it.

=== Multiple Affect Removal ===
 if (isaff(self, ID_BLESS))
   subaff(self, ID_BLESS);
 else if (isaff(self, ID_CURSE))
   subaff(self, ID_CURSE);
 else if (isaff(self, ID_INVISIBILITY))
   subaff(self, ID_INVISIBILITY);

This shows how to check for and remove specific affects.

== Usage Notes ==

* Affects are temporary modifications to units
* Multiple affects of the same ID can exist on a unit
* The function only checks for the presence of at least one matching affect
* Use &apos;&apos;&apos;getaffects()&apos;&apos;&apos; to get detailed information about all affects on a unit
* Use &apos;&apos;&apos;addaff()&apos;&apos;&apos; to add new affects to a unit
* Use &apos;&apos;&apos;subaff()&apos;&apos;&apos; to remove affects from a unit

== Error Handling ==

* Invalid affect IDs will return FALSE (0)
* Null unit pointers will cause runtime errors
* Ensure the unit exists before checking affects

== Related Functions/Fields ==

* [[Manual:DIL_Manual/addaff|addaff]] - Adds an affect to a unit
* [[Manual:DIL_Manual/subaff|subaff]] - Removes an affect from a unit  
* [[Manual:DIL_Manual/getaffects|getaffects]] - Returns detailed information about all affects on a unit

== See Also ==

* Spell and affect systems
* Status condition checking
* Magical properties and effects</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/islight</title>
     <ns>0</ns>
     <id>1008469</id>
     <revision>
       <id>1560937</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of islight.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= islight =
 function: integer &apos;&apos;&apos;islight&apos;&apos;&apos;(u : unitptr);

The &apos;&apos;&apos;islight&apos;&apos;&apos; function tests whether a unit is a light source.

== Description ==

The &apos;&apos;&apos;islight&apos;&apos;&apos; function checks if the specified unit is a light source. This typically includes items like torches, lanterns, and other objects that can illuminate rooms. The function returns TRUE (1) if the unit is a light source, or FALSE (0) if not.

== PARAMETERS ==

{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit to be checked (any unit type, typically objects)
|}

== Examples ==

=== Basic Light Check ===
 if (islight(self))
   sendtext(&quot;This item provides light.&quot;, self);

This checks if the current unit is a light source and sends a message if so.

=== Room Lighting Check ===
 if (not islight(self.outside))
 {
    act(&quot;It is pitch black.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    return;
 }

This example from a directions DIL checks if the room (self.outside) has light, and if not, informs the player that it&apos;s pitch black.

=== Light Source Inventory Check ===
 foreach (UNIT_ST_OBJ, i)
 {
    if (islight(i))
    {
       act(&quot;$1n glows with light.&quot;, A_SOMEONE, i, null, null, TO_ROOM);
    }
 }

This iterates through all objects and identifies which ones are light sources.

== Usage Notes ==

* Light sources are typically objects with ITEM_LIGHT object type
* The function checks the unit&apos;s internal light-emitting properties
* Use &apos;&apos;&apos;setbright()&apos;&apos;&apos; to modify how much light a unit emits
* The &apos;&apos;&apos;bright&apos;&apos;&apos; field of a unit indicates how much light it produces
* The &apos;&apos;&apos;light&apos;&apos;&apos; field shows how much light is currently inside a unit
* Light sources are essential for visibility in dark rooms

== Error Handling ==

* Null unit pointers will cause runtime errors
* Ensure the unit exists before checking if it&apos;s a light source
* The function returns FALSE (0) for non-light source units

== Related Functions/Fields ==

* [[Manual:DIL_Manual/setbright|setbright]] - Sets the brightness of a unit
* [[Manual:DIL_Manual/bright|bright]] - Field showing how much light a unit emits
* [[Manual:DIL_Manual/light|light]] - Field showing how much light is inside a unit
* [[Manual:DIL_Manual/illum|illum]] - Field showing light created by units inside transparent units
* [[Manual:DIL_Manual/objecttype|objecttype]] - The type of an object (ITEM_* constants)

== See Also ==

* Lighting and visibility systems
* Object types and properties
* Environmental effects and illumination</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/isplayer</title>
     <ns>0</ns>
     <id>1003618</id>
     <revision>
       <id>1287585</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of isplayer.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= isplayer =

; isplayer : integer ( pcname : string )
: Tests whether a player with the specified name exists in the game database.

== Description ==

The &apos;&apos;&apos;isplayer&apos;&apos;&apos; function checks if a player with the given name exists in the game&apos;s player database. This is useful for validating player names before performing operations like deletion, or for checking if a character has been properly saved. The function works regardless of whether the player is currently online or offline.

== Parameters ==

; pcname : string
: The name of the player to check for existence in the database.

== Return Value ==

; integer
: Returns TRUE (1) if a player with the specified name exists in the database, or FALSE (0) if not.

== Examples ==

=== Basic Player Validation ===
 if (not isplayer(arg))
 {
    sendtext(arg + &quot; is not a character.&amp;n&quot;, self);
    quit;
 }
 
This validates that the provided argument corresponds to an existing player character.

=== Guest Account Check ===
 if (not isplayer(self.name))
 {
    sendtext(&quot;&lt;div class=&apos;score&apos;&gt;You remain a GUEST until you &apos;save&apos; yourself&lt;/div&gt;&lt;br/&gt;&quot;, self);
    quit;
 }
 
This example from a score command checks if the current character has been saved yet (guest accounts don&apos;t exist in the database until saved).

=== Admin Delete Validation ===
 if (self.level &gt; 200)
 {
    if (not isplayer(arg))
    {
       sendtext(arg + &quot; is not a character.&amp;n&quot;, self);
       quit;
    }
    delete_player(arg);
    sendtext(arg + &quot; has been deleted.&amp;n&quot;, self);
 }
 
This shows how an administrator can validate a player exists before deleting them.

== Usage Notes ==

* The function checks the player database, not just online players
* Guest accounts (unsaved characters) will return FALSE since they don&apos;t exist in the database yet
* This is commonly used with &apos;&apos;&apos;delete_player()&apos;&apos;&apos; to validate before deletion
* Player names are case-sensitive for the lookup
* The function uses &apos;&apos;&apos;find_player_id()&apos;&apos;&apos; internally to locate the player

== Common Use Cases ==

* Validating player names before administrative operations
* Checking if a character has been saved (distinguishing guests from real characters)
* Preventing operations on non-existent players
* Admin tools for player management

== See Also ==

; delete_player : Deletes a player from the database
; findunit : Finds a unit by name (online units only)
; findsymbolic : Finds a unit by symbolic name </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/isset</title>
     <ns>0</ns>
     <id>713724</id>
     <revision>
       <id>1346309</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of isset.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= isset =

; isset : integer ( i : integer , bit : integer )
: Tests whether specific bits are set in an integer value.

== Description ==

The &apos;&apos;&apos;isset&apos;&apos;&apos; function performs a bitwise AND operation to check if one or more bits are set in an integer value. This is commonly used to test flag fields on units, such as character flags, unit flags, manipulation flags, and exit flags. The function returns TRUE if any of the specified bits are set in the target integer.

== Parameters ==

; i : integer
: The integer value to examine, typically a flag field from a unit.

; bit : integer
: The bit mask to test for. Can be a single bit or multiple bits combined with bitwise OR.

== Return Value ==

; integer
: Returns TRUE (1) if any of the bits specified in &apos;bit&apos; are set in &apos;i&apos;, or FALSE (0) if none are set.

== Examples ==

=== Basic Flag Check ===
 if (isset(self.flags, UNIT_FL_BURIED))
    act(&quot;A &quot;+self.name+&quot; rots away.&quot;, A_SOMEONE, self, null, null, TO_ROOM);
 
This checks if the unit has the BURIED flag set before displaying a rot message.

=== Manipulation Flag Check ===
 if (isset(self.manipulate, MANIPULATE_TAKE))
    sendtext(&quot;This item can be taken.&quot;, self);
 
This checks if the item can be taken by players.

=== Character Status Checks ===
 if (isset(self.charflags, CHAR_PROTECTED))
    sendtext(&quot;You are a protected citizen.&quot;, self);
 else if (isset(self.charflags, CHAR_OUTLAW))
    sendtext(&quot;You are wanted dead or alive by the law.&quot;, self);
 
This checks various character status flags.

=== Exit State Check ===
 if (isset(room.exit_info[dir], EX_CLOSED))
    sendtext(&quot;The exit is closed.&quot;, self);
 
This checks if a specific exit is closed.

=== Multiple Bit Check ===
 if (isset(self.pcflags, PC_PK_RELAXED | PC_INFORM))
    // Both PK_RELAXED and INFORM bits are checked
 
This shows how to check for multiple bits at once.

== Common Flag Types ==

; self.flags : UNIT_FL_* flags
: General unit properties (BURIED, TRANS, NO_BURY, etc.)

; self.charflags : CHAR_* flags  
: Character-specific flags (PROTECTED, OUTLAW, HIDE, GROUP, etc.)

; self.pcflags : PC_* flags
: Player-specific flags (PK_RELAXED, BRIEF, INFORM, etc.)

; self.manipulate : MANIPULATE_* flags
: How unit can be handled (TAKE, HOLD, WEAR, etc.)

; self.openflags : EX_* flags
: Open/lock properties (OPEN_CLOSE, LOCKED, PICK_PROOF, etc.)

; room.exit_info[dir] : EX_* flags
: Exit-specific properties (CLOSED, LOCKED, CLIMB, etc.)

== Usage Notes ==

* Uses the IS_SET() macro internally for the bitwise test
* Returns TRUE if ANY of the specified bits are set (logical OR behavior)
* Multiple bits can be tested using bitwise OR operator (|)
* This is the standard way to test flag fields in DIL programming
* Flag constants are defined in values.h and/or vme.h

== See Also ==

; visible : Checks if a unit is visible to another unit
; manipulate : Field showing how unit can be handled
; flags : Field showing general unit properties
; charflags : Field showing character-specific properties </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/itoa</title>
     <ns>0</ns>
     <id>1229511</id>
     <revision>
       <id>1395645</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of itoa.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= itoa =

; itoa : string ( i : integer )
: Converts an integer to its string representation.

== Description ==

The &apos;&apos;&apos;itoa&apos;&apos;&apos; function converts an integer value to a string containing the decimal representation of that number. This is commonly used for displaying numerical values in messages, constructing strings with numbers, or converting numbers for string operations.

== Parameters ==

; i : integer
: The integer value to convert to string.

== Return Value ==

; string
: Returns a string containing the decimal representation of the input integer.

== Examples ==

=== Basic Conversion ===
 s := itoa(42);
 // s now contains &quot;42&quot;
 
Simple conversion of a number to string.

=== Message Construction ===
 act(&quot;You have &quot;+itoa(self.hp)+&quot; hit points remaining.&quot;, 
     A_ALWAYS, self, null, null, TO_CHAR);
 
Displays current hit points in a message to the player.

=== String Concatenation ===
 id := &quot;$reward &quot;+ self.symname + &quot; &quot; + itoa(self.idx) + &quot; &quot;+ juris;
 
Constructs a database key using unit index converted to string.

=== Time Display ===
 act(&quot;Only &quot;+itoa(du)+&quot; hours till freedom!&quot;, 
     A_ALWAYS, self, null, null, TO_CHAR);
 
Shows remaining time in jail with converted number.

=== Database Operations ===
 jd.extra.[id].descr := self.name+&quot; is currently serving time in jail. &quot;+itoa(du)+&quot; hours remaining&quot;;
 
Updates database description with numeric information.

== Usage Notes ==

* Converts integers to decimal string representation
* Commonly used with &apos;&apos;&apos;sendtext()&apos;&apos;&apos; and &apos;&apos;&apos;act()&apos;&apos;&apos; for displaying numbers
* Complementary to &apos;&apos;&apos;atoi()&apos;&apos;&apos; which converts strings to integers
* Essential for constructing messages that include numerical values
* Used frequently in score displays, time displays, and status messages

== Common Use Cases ==

* Displaying player statistics (HP, mana, experience)
* Showing time remaining or elapsed time
* Constructing database keys with numeric components
* Creating debug or log messages with values
* Building command outputs with numerical data

== See Also ==

; atoi : Converts a string to an integer
; sendtext : Sends text to a player
; act : Sends formatted messages to units
; moneystring : Converts money amounts to formatted strings </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/key</title>
     <ns>0</ns>
     <id>1081107</id>
     <revision>
       <id>1761679</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of key.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= key =

; key : string (RO)
: The key identifier that will open this unit.

== Description ==

The &apos;&apos;&apos;key&apos;&apos;&apos; field is a read-only string property that contains the key identifier required to open or unlock a unit. This is typically used on doors, containers, and other lockable objects. The key value is usually in the format &quot;key_name@zone&quot; and corresponds to a key object that players can possess.

== Field Access ==

; unit.key : string (Read-Only)
: Returns the key identifier string for this unit.

== Examples ==

=== Basic Key Check ===
 if (item.key == &quot;&quot;)
 {
    act(&quot;Odd, you can&apos;t seem to find a keyhole.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    return;
 }
 
This checks if an item has a key defined before attempting lock/unlock operations.

=== Key Validation ===
 pc := findsymbolic(self, item.key, FIND_UNIT_IN_ME);
 
 if ((pc == null) and (self.level &lt; IMMORTAL_LEVEL))
 {
    act(&quot;You don&apos;t seem to have the proper key.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    return;
 }
 
This searches the player&apos;s inventory for the required key object.

=== Display Key Information ===
 sendtext(&quot;Key required: &quot; + item.key, self);
 
This displays what key is needed for an object.

=== Key Format Examples ===
 &quot;bronze_key@midgaard&quot;
 &quot;big_key@blackzon&quot;
 &quot;door_key@myzone&quot;
 
Typical key identifier formats.

== Usage Notes ==

* The key field is read-only and cannot be modified directly
* Key identifiers are typically in &quot;name@zone&quot; format
* The key string corresponds to the symbolic name of a key object
* Players must possess the matching key object to open locked items
* Immortals (level &gt;= IMMORTAL_LEVEL) can often bypass key requirements
* Empty string (&quot;&quot;) indicates no key is required or the unit is not lockable

== Common Use Cases ==

* Checking if doors or containers can be locked/unlocked
* Validating that players have the correct key
* Displaying key requirements to players
* Implementing lock/unlock commands
* Creating puzzles with specific key requirements

== Related Fields ==

; openflags : Contains lock/unlock state information
; findsymbolic : Used to locate key objects in inventory

== See Also ==

; findsymbolic : Finds units by symbolic name
; isset : Tests flag bits like EX_LOCKED
; openflags : Field containing open/lock state
; EX_LOCKED : Flag indicating locked state </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/killedit</title>
     <ns>0</ns>
     <id>648798</id>
     <revision>
       <id>1066075</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of killedit.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= killedit =

; killedit : procedure ( u : unitptr )
: Terminates editing mode for a player character.

== Description ==

The &apos;&apos;&apos;killedit&apos;&apos;&apos; procedure forcefully terminates the editing mode for a player character. This is used when a player needs to stop editing before they are finished, such as when they are killed, transferred to another location, or when the editing session needs to be interrupted for any reason. This prevents the player from being stuck in editing mode.

== Parameters ==

; u : unitptr
: The player character to remove from editing mode. Must be a PC unit.

== Usage Notes ==

* Only works on player characters (PC units), not NPCs or objects
* Used to interrupt editing sessions that would otherwise continue indefinitely
* Essential for cleanup when players are killed or moved while editing
* Complements the &apos;&apos;&apos;beginedit()&apos;&apos;&apos; function which starts editing mode
* Automatically clears editing state and restores normal command processing

== Examples ==

=== Basic Cleanup ===
 interrupt (SFB_DEAD, self == activator, int_quit);
 
 :int_quit:
 killedit(self);
 quit;
 
This kills editing when the player dies during an editing session.

=== Board Reply Cleanup ===
 interrupt (SFB_MSG, ((activator == self) and (argument == &quot;linkdead&quot;)), clean_up);
 interrupt (SFB_DEAD, activator == self, clean_up);
 interrupt (SFB_COM, activator == self, clean_up);
 
 :clean_up:
 killedit(self);
 quit;
 
This example from a board reply system kills editing on various interrupt conditions.

=== Transfer Cleanup ===
 if (self.outside != original_room)
 {
    killedit(self);
    act(&quot;You were transferred while editing!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }
 
This handles cases where a player is moved while editing.

== Common Use Cases ==

* Player death during editing sessions
* Player transfer to another location while editing
* Forced termination of problematic editing sessions
* Cleanup in error conditions
* Timeout scenarios where editing needs to end

== Related Functions ==

; beginedit : Starts editing mode for a player
; SFB_EDIT : Message sent when player finishes editing
; wait : Used to wait for SFB_EDIT messages

== Error Handling ==

* Function will fail if the unit is not a player character
* Always validate unit type before calling killedit
* Use proper error checking to ensure the unit is valid

== See Also ==

; beginedit : Starts editing mode
; textformat : Formats text from editing input
; SFB_EDIT : Editing completion message flag </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/lastroom</title>
     <ns>0</ns>
     <id>533087</id>
     <revision>
       <id>1768844</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of lastroom.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= lastroom =
 function: room &apos;&apos;&apos;lastroom&apos;&apos;&apos;(character : pc);

The &apos;&apos;&apos;lastroom&apos;&apos;&apos; function retrieves the room a player character just left.

== Description ==

The &apos;&apos;&apos;lastroom&apos;&apos;&apos; function accesses the character&apos;s last known location before their current room. This is useful for tracking player movement, creating follow effects, or implementing scripts that need to know where a player came from.

This function only works on player characters (PCs). It will fail if used on NPCs or non-character units.

== Parameters ==

{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| character || pc || The player character to get the last room from. Must be a valid PC unit.
|}

== Return Value ==

; room
: Returns a room unitptr to the room the character just left. Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if:
* The input is not a valid unit
* The input is not a player character (PC)
* The character has no last room recorded

== Examples ==

=== Basic Usage ===
 previous_room := lastroom(self);
 if (previous_room != null) {
    exec(&quot;say You just arrived from &quot; + previous_room.name, self);
 }

This retrieves and displays the room the player just came from.

=== Movement Tracking ===
 if (lastroom(activator).name == &quot;The Dark Forest&quot;) {
    act(&quot;$1n says &apos;Ah, fresh from the forest I see.&apos;&quot;, A_ALWAYS, self, null, activator, TO_VICT);
 }

This checks if a player arrived from a specific room and responds accordingly.

== Usage Notes ==

* This function is currently not used anywhere in the DikuMUD codebase
* The function internally calls the C++ method &apos;&apos;&apos;getLastLocation()&apos;&apos;&apos; on the character
* Only player characters have their last room tracked
* The returned unitptr can be used with other room-related functions
* Use proper error checking as the function can return fail

== Error Handling ==

* Always validate the return value is not null before using it
* Ensure the input unit is a valid player character
* Handle cases where no last room is recorded

== See Also ==

; room : Room unit type
; position : Character position information
; outside : Current room location field</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/left</title>
     <ns>0</ns>
     <id>608610</id>
     <revision>
       <id>1256175</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of left.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= left =
 function: string &apos;&apos;&apos;left&apos;&apos;&apos;(input : string, length : integer);

The &apos;&apos;&apos;left&apos;&apos;&apos; function extracts the leftmost characters from a string.

== Description ==

The &apos;&apos;&apos;left&apos;&apos;&apos; function extracts a specified number of characters from the beginning (left side) of a string. If the requested length is longer than the input string, the entire string is returned.

This function is commonly used for string prefix matching, extracting substrings from the beginning of text, command parsing and abbreviation handling.

== Parameters ==

{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| input || string || The original string to be parsed
|-
| length || integer || The number of characters to extract from the left side of the string
|}

== Return Value ==

; string
: Returns the left portion of the input string with the specified length. Returns &apos;&apos;&apos;null&apos;&apos;&apos; if:
* The input string is empty
* The length parameter is 0
* Either parameter is invalid

== Examples ==

=== Basic Usage ===
 result := left(&quot;shorten me&quot;, 5);
 // result contains &quot;short&quot;

Simple extraction of the first 5 characters.

=== Length Exceeds String ===
 result := left(&quot;hi&quot;, 10);
 // result contains &quot;hi&quot;

When length exceeds string length, the entire string is returned.

=== Command Abbreviation ===
 if (command == left(&quot;help&quot;, length(command))) {
    exec(&quot;help &quot; + argument, self);
 }

Handles command abbreviations by matching prefixes.

=== Command System ===
 commands := {&quot;look&quot;, &quot;get&quot;, &quot;drop&quot;, &quot;inventory&quot;};
 i := 0;
 while (i &lt; length(commands)) {
    if (input == left(commands.[i], length(input))) {
        exec(commands.[i] + &quot; &quot; + rest, self);
        break;
    }
    i := i + 1;
 }

Advanced command abbreviation system that checks all possible matches.

== Usage Notes ==

* The function allocates new memory for the returned string
* If the input string is shorter than the requested length, the entire string is returned
* Empty strings or zero length requests return null
* This is the counterpart to the &apos;&apos;&apos;right&apos;&apos;&apos; function
* Commonly used in command parsing systems

== Error Handling ==

* Always validate input parameters before calling
* Check for null return values when using empty strings or zero length
* Ensure length parameter is positive

== See Also ==

; right : Extract characters from the right side of a string
; mid : Extract characters from the middle of a string
; length : Get the length of a string
; getwords : Split string into words</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/length</title>
     <ns>0</ns>
     <id>756174</id>
     <revision>
       <id>1553173</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of length.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= length =
 function: integer &apos;&apos;&apos;length&apos;&apos;&apos;(input : string);
 function: integer &apos;&apos;&apos;length&apos;&apos;&apos;(input : stringlist);
 function: integer &apos;&apos;&apos;length&apos;&apos;&apos;(input : intlist);

The &apos;&apos;&apos;length&apos;&apos;&apos; function returns the size of strings, stringlists, or intlists.

== Description ==

The &apos;&apos;&apos;length&apos;&apos;&apos; function is a versatile function that can measure the size of three different data types. It&apos;s commonly used for looping through lists, string validation and processing, array bounds checking, and conditional logic based on data size.

== Parameters ==

{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| input || string, stringlist, or intlist || The variable to measure the length of
|}

== Return Value ==

; integer
: Returns the length of the input:
* For strings: number of characters
* For stringlists: number of strings in the list
* For intlists: number of integers in the list
Returns &apos;&apos;&apos;0&apos;&apos;&apos; if the input is null or empty. Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if the input type is invalid.

== Examples ==

=== String Length ===
 len := length(&quot;hello&quot;);
 // len contains 5

 len := length(&quot;&quot;);
 // len contains 0

=== Stringlist Length ===
 words := {&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;};
 count := length(words);
 // count contains 3

 empty_list := {};
 count := length(empty_list);
 // count contains 0

=== Intlist Length ===
 numbers := {1, 2, 3, 4, 5};
 count := length(numbers);
 // count contains 5

=== List Iteration ===
 i := 0;
 while (i &lt; length(myintlist)) {
    // Process myintlist.[i]
    i := i + 1;
 }

Common pattern for iterating through all elements in a list.

=== Random Selection ===
 messages := {&quot;Hello&quot;, &quot;Goodbye&quot;, &quot;Maybe later&quot;};
 index := rnd(0, length(messages) - 1);
 exec(&quot;say &quot; + messages.[index], self);

Randomly selects and displays a message from a list.

=== Processing All Elements ===
 i := 0;
 while (i &lt; length(song_lines)) {
    exec(&quot;emote sings, &apos;&quot; + song_lines.[i] + &quot;&apos;&quot;, self);
    pause;
    i := i + 1;
 }

Processes each element in a stringlist sequentially.

== Usage Notes ==

* The function handles null inputs gracefully by returning 0
* For strings, this counts characters (not bytes)
* For lists, this returns the number of elements, not the highest index
* Invalid input types will cause the function to return fail
* Essential for proper loop bounds checking

== Error Handling ==

* Always check for fail return when input type might be invalid
* Handle null/empty inputs which return 0
* Use proper bounds checking when accessing list elements

== See Also ==

; stringlist : String array type
; intlist : Integer array type
; getwords : Split strings into stringlists
; rnd : Generate random numbers</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/level</title>
     <ns>0</ns>
     <id>1023624</id>
     <revision>
       <id>1671162</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of level.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= level =
 field: integer &apos;&apos;&apos;.level&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;level&apos;&apos;&apos; field returns level information for characters and commands.

== Description ==

The &apos;&apos;&apos;level&apos;&apos;&apos; field provides access to level information for different unit types. When accessed on character units (PC/NPC), it returns the character&apos;s current level. When accessed on command pointers, it returns the minimum level required to use that command.

== Field Access ==

; unit.level : integer (Read-only)
: Returns the character&apos;s level for PC/NPC units.

; cmdptr.level : integer (Read-only)
: Returns the minimum level required to use the command.

== Availability ==

This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* cmdptr (Command pointer)

== Examples ==

=== Character Level Check ===
 if (activator.level &gt; 20) {
    exec(&quot;say You are experienced enough to enter.&quot;, self);
 }

Checks if a player meets minimum level requirements.

=== Level Restriction ===
 if (pc.level &lt; 253) {
    sendtext(&quot;You must be at least level 253 to use this command.&quot;, pc);
    quit;
 }

Prevents low-level players from using powerful commands.

=== Level Comparison ===
 if (self.level &lt; target.level) {
    exec(&quot;say $2n is too powerful for me to fight.&quot;, self, target);
 }

Compares levels between two characters.

=== Command Level Requirement ===
 cmd := getcommand(&quot;kick&quot;);
 if (self.level &lt; cmd.level) {
    sendtext(&quot;You must be level &quot; + itoa(cmd.level) + &quot; to use kick.&quot;, self);
 }

Checks if player meets command&apos;s level requirement.

=== Immortal Check ===
 if (self.level &gt;= IMMORTAL_LEVEL) {
    exec(&quot;wizi&quot;, self);
 }

Allows immortal-only actions for high-level characters.

=== Command List ===
 cmd := chead();
 while (cmd) {
    sendtext(cmd.name + &quot; (requires level &quot; + itoa(cmd.level) + &quot;)&quot;, self);
    cmd := cmd.next;
 }

Lists all commands with their level requirements.

== Usage Notes ==

* For characters, this field is read-only
* The level system typically ranges from 1 to 253 for players, with 200+ being immortal levels
* NPCs also have levels that determine their difficulty
* Command level requirements prevent low-level characters from using powerful commands
* The field returns fail if accessed on invalid unit types
* Essential for access control and content gating

== Error Handling ==

* Function returns fail if accessed on invalid unit types
* Always validate unit type before accessing level field
* Handle cases where level might not be available

== See Also ==

; vlevel : Virtual level field
; experience : Experience points field
; cmdptr : Command pointer type
; getcommand : Get a specific command pointer
; chead : Get first command in list</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/lifespan</title>
     <ns>0</ns>
     <id>874962</id>
     <revision>
       <id>1835571</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of lifespan.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= lifespan =
 field: integer &apos;&apos;&apos;.lifespan&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;lifespan&apos;&apos;&apos; field is used to get or set the maximum lifespan of a player character in the game.

== Description ==

The &apos;&apos;&apos;lifespan&apos;&apos;&apos; field represents the maximum age a player character can reach before dying of old age. This value is measured in the game&apos;s internal time units and is compared against the character&apos;s current age to determine if they have exceeded their maximum lifespan.

== Field Access ==

; pc.lifespan : integer (Read/Write)
: The character&apos;s maximum lifespan in game time units.

== Availability ==

This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==

=== Basic Usage ===
 max_age := self.lifespan;
 sendtext(&quot;Your maximum lifespan is: &quot; + itoa(max_age), self);

Retrieves and displays the character&apos;s maximum lifespan.

=== Age Check ===
 if (((realtime - self.birth) / SECS_PER_MUD_YEAR) &gt; self.lifespan) {
    sendtext(&quot;You have exceeded your maximum lifespan!&quot;, self);
    // Handle death of old age
 }

Checks if character has exceeded their maximum lifespan.

=== Setting Lifespan ===
 if (self.level &gt;= IMMORTAL_LEVEL) {
    target.lifespan := 1000;  // Set very long lifespan
    sendtext(&quot;You grant &quot; + target.name + &quot; extended life.&quot;, self);
 }

Allows immortals to modify character lifespan.

=== Function Example ===
 dilbegin integer hit_l_num(pc:unitptr, point:integer);
 code
 {
     if (pc.type == UNIT_ST_PC) {
         if (((realtime - pc.birth) / SECS_PER_MUD_YEAR) &gt; pc.lifespan)
             return (-1);
         return (3 * point + 20);
     }
     else
         return (3 * point + 10);
 } dilend

Example function that checks lifespan before calculating hit points.

== Usage Notes ==

* Read access: Available to all DIL code
* Write access: Only available with root access level (zone access level != 0)
* This field only applies to player characters (UNIT_ST_PC)
* Attempting to access this field on non-player units will result in fail
* The lifespan comparison is typically done by calculating the character&apos;s age in years and comparing it to the lifespan value
* SECS_PER_MUD_YEAR is a constant that converts real-time seconds to game years

== Error Handling ==

* Function returns fail if accessed on non-player units
* Write access requires appropriate zone permissions
* Always validate unit type before accessing this field

== See Also ==

; birth : Time when the PC was created
; realtime : Current time in seconds since epoch
; SECS_PER_MUD_YEAR : Constant for time conversion</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/light</title>
     <ns>0</ns>
     <id>362359</id>
     <revision>
       <id>1578930</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of light.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= light =

field: integer &apos;&apos;&apos;.light&apos;&apos;&apos; (Read-only)

== Description ==

The &apos;&apos;&apos;light&apos;&apos;&apos; field returns the number of active light sources contained within a unit.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| light || integer || Read-only || Number of active light sources in the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==

 dilbegin example_light();
 var
    light_count : integer;
 
 code
 {
    light_count := self.light;
    exec(&quot;say This unit contains &quot; + itoa(light_count) + &quot; light sources.&quot;, self);
 } dilend

== Usage Notes ==

* This field is read-only and cannot be modified directly
* Use the [[Manual:DIL_Manual/setbright|setbright]] procedure to change how much light a unit emits
* The &apos;&apos;&apos;islight&apos;&apos;&apos; function can be used to check if a unit is a light source
* Related fields include &apos;&apos;&apos;bright&apos;&apos;&apos; (how much the unit lights up) and &apos;&apos;&apos;illum&apos;&apos;&apos; (light from transparent containers)

== Error Handling ==

* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if the unitptr is null
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if the unit is not applicable

== Related Functions/Fields ==

* [[Manual:DIL_Manual/islight|islight]]
* [[Manual:DIL_Manual/setbright|setbright]]
* [[Manual:DIL_Manual/unitptr.bright|unitptr.bright]]
* [[Manual:DIL_Manual/unitptr.illum|unitptr.illum]]

== See Also == </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/link</title>
     <ns>0</ns>
     <id>856109</id>
     <revision>
       <id>1632255</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of link.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= link =

function: &apos;&apos;&apos;link&apos;&apos;&apos;(u : unitptr, t : unitptr);

== Description ==

The &apos;&apos;&apos;link&apos;&apos;&apos; procedure moves a unit into another unit&apos;s hierarchy. This function automatically unequips items if they are currently equipped before moving them.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || Unit to link (the unit being moved)
|-
| t || unitptr || Unit to link into (the destination unit)
|}

== Usage Notes ==

The link procedure performs the following operations:

* If the source unit is an equipped object, it will be unequipped automatically
* Removes the source unit from its current location using unit_from_unit()
* Places the source unit into the destination unit using unit_to_unit()
* Prevents recursive linking (a unit cannot be linked into itself or its own contents)
* Prevents linking rooms into rooms

== Examples ==

 dilbegin cuff_target(deputy : unitptr, targ : unitptr, cuffs : unitptr);
 var
    depname: string;

 code
 {
    act(&quot;You cuff $3n.&quot;, A_SOMEONE, deputy, null, targ, TO_CHAR);
    act(&quot;$1n surprises you and put $2n around your wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_VICT);
    act(&quot;$1n puts $2n around $3N&apos;s wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_NOTVICT);

    follow(targ, deputy);
    depname := deputy.name;
    link(cuffs, targ);
    unequip(equipment(targ, WEAR_WRIST_R));
    addequip(cuffs, WEAR_WRIST_R);
    dilcopy(&quot;cuffed@midgaard(&quot;+depname+&quot;)&quot;, targ);
    dilcopy(&quot;cuffed2@midgaard(&quot;+depname+&quot;)&quot;, targ);

    exec(&quot;sigh&quot;, targ);
    return;
 } dilend

== Error Handling ==

* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if either unitptr is null
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if attempting recursive linking
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if attempting to link rooms into rooms

== Related Functions/Fields ==

* [[Manual:DIL_Manual/unequip|unequip]]
* [[Manual:DIL_Manual/addequip|addequip]]
* [[Manual:DIL_Manual/equipment|equipment]]

== See Also == </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/load</title>
     <ns>0</ns>
     <id>538017</id>
     <revision>
       <id>1791243</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of load.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= load =

function: unitptr &apos;&apos;&apos;load&apos;&apos;&apos;(s : string);

== Description ==

The &apos;&apos;&apos;load&apos;&apos;&apos; function creates a new unit from the database using its symbolic name. The loaded unit is automatically placed inside the unit that executed the load command.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || Symbolic name of the unit to load (format: &quot;name@zone&quot;)
|}

== Examples ==

The load function performs the following operations:

* Looks up the unit in the database using the symbolic name
* Creates a new instance of the unit (except for rooms, which cannot be loaded)
* If the unit is money, properly initializes the money amount
* Automatically places the loaded unit inside the loading unit&apos;s inventory
* Activates any load-time DIL programs on the loaded unit

 dilbegin example_load();
 var
    obj : unitptr;
 
 code
 {
    obj := load(&quot;tbag@midgaard&quot;);
    if (obj != null)
    {
       link(obj, self);
       exec(&quot;say I loaded a trash bag!&quot;, self);
    }
    else
    {
       exec(&quot;say Failed to load the bag.&quot;, self);
    }
 } dilend

== Usage Notes ==

* Rooms cannot be loaded and will generate an error in the system log
* If the symbolic name does not exist, an error is logged and null is returned
* The loaded unit is automatically placed in the loader&apos;s inventory
* Use the [[Manual:DIL_Manual/link|link]] procedure to move the loaded unit to a different location
* Money units are properly initialized with their correct amount
* Symbolic names follow the format &quot;name@zone&quot; (e.g., &quot;garlic@midgaard&quot;)

== Error Handling ==

* Returns &apos;&apos;&apos;null&apos;&apos;&apos; if the symbolic name does not exist
* Returns &apos;&apos;&apos;null&apos;&apos;&apos; if attempting to load a room
* Logs errors to the system log for debugging

== Related Functions/Fields ==

* [[Manual:DIL_Manual/link|link]]
* [[Manual:DIL_Manual/findsymbolic|findsymbolic]]
* [[Manual:DIL_Manual/destroy|destroy]]
* [[Manual:DIL_Manual/unitptr.symname|unitptr.symname]]

== See Also == </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/loadcount</title>
     <ns>0</ns>
     <id>639763</id>
     <revision>
       <id>1053430</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of loadcount.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= loadcount =

field: integer &apos;&apos;&apos;.loadcount&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;loadcount&apos;&apos;&apos; field returns the number of units currently loaded in the game that share the same definition (zoneidx, nameidx) as the specified unit. This field is read-only and provides a way to track how many instances of a particular object, NPC, or room template are currently active in the game world.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| loadcount || integer || Read-only || Number of loaded units with same definition
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin check_load_counts();
 var
   bag: unitptr;
   guard: unitptr;
 code
 {
   bag := load(&quot;tot_bag2@hallows23&quot;);
   if (bag.loadcount &gt; 250)
   {
     destroy(bag);
     log(&quot;Too many bag2 instances loaded: &quot; + bag.loadcount);
   }
   
   guard := load(&quot;cityguard@midgaard&quot;);
   log(&quot;City guards loaded: &quot; + guard.loadcount);
 } dilend

== Usage Notes ==
* The loadcount is based on the unit&apos;s definition (zoneidx and nameidx combination)
* Units with the same symbolic name but from different zones will have separate load counts
* The count includes the current unit if it&apos;s loaded
* This field is useful for population control and preventing excessive loading of certain unit types
* For unique units without a file index, the function returns 1

== Error Handling ==
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if the unitptr is null
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if the unit is not applicable

== Related Functions/Fields ==
* [[Manual:DIL_Manual/nameidx|nameidx]] - The unique database name in the zone
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - The unique database zone name
* [[Manual:DIL_Manual/symname|symname]] - The concatenated nameidx@zoneidx
* [[Manual:DIL_Manual/idx|idx]] - The constant ID for the unit

== See Also ==
* [[Manual:DIL_Manual/load()|load()]] - Load a unit into the game
* [[Manual:DIL_Manual/destroy()|destroy()]] - Remove a unit from the game
* [[Manual:DIL_Manual/findsymbolic()|findsymbolic()]] - Find units by symbolic name and index </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/loadlevel</title>
     <ns>0</ns>
     <id>1180843</id>
     <revision>
       <id>1606502</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of loadlevel.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= loadlevel =

field: integer &apos;&apos;&apos;.loadlevel&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;loadlevel&apos;&apos;&apos; field returns the load level of a zone. This represents the minimum character level required to load items from that zone. This field is read-only and provides access to zone-level loading restrictions.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| loadlevel || integer || Read-only || Minimum character level required to load items from zone
|}

== Availability ==
This field is available on the following unit types:
* zoneptr (Zone pointer)

== Examples ==
 dilbegin check_zone_load();
 var
   z: zoneptr;
   player_level: integer;
 code
 {
   z := findzone(&quot;midgaard&quot;);
   if (z == null)
   {
     log(&quot;Zone not found&quot;);
     quit;
   }
   
   player_level := self.level;
   if (player_level &lt; z.loadlevel)
   {
     sendtext(&quot;You are not high enough level to load items from this zone.&amp;n&quot;, self);
     quit;
   }
   
   sendtext(&quot;Zone load level: &quot; + z.loadlevel + &quot;&amp;n&quot;, self);
 } dilend

 dilbegin zone_info(zonename: string);
 var
   z: zoneptr;
   info: string;
 code
 {
   z := findzone(zonename);
   if (z == null)
   {
     sendtext(&quot;Zone &apos;&quot; + zonename + &quot;&apos; not found.&amp;n&quot;, self);
     quit;
   }
   
   info := &quot;Zone Information for &quot; + z.name + &quot;&amp;n&quot;;
   info := info + &quot;Load Level: &quot; + z.loadlevel + &quot;&amp;n&quot;;
   info := info + &quot;Reset Time: &quot; + z.resettime + &quot;&amp;n&quot;;
   info := info + &quot;Access Level: &quot; + z.access + &quot;&amp;n&quot;;
   
   pagestring(info, self);
 } dilend

== Usage Notes ==
* The loadlevel is a zone-wide setting that affects all items within the zone
* This field is used to enforce level restrictions on item loading
* Players must meet or exceed the loadlevel to load items from the zone
* The loadlevel is typically set in the zone configuration file
* This field is read-only; to modify load levels, you must edit the zone files

== Error Handling ==
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if the zoneptr is null
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if the zone is not applicable

== Related Functions/Fields ==
* [[Manual:DIL_Manual/access|access]] - Zone access level
* [[Manual:DIL_Manual/resettime|resettime]] - Zone reset time
* [[Manual:DIL_Manual/resetmode|resetmode]] - Zone reset mode
* [[Manual:DIL_Manual/payonly|payonly]] - Zone pay-only status
* [[Manual:DIL_Manual/findzone()|findzone()]] - Find a zone by name
* [[Manual:DIL_Manual/zhead()|zhead()]] - Get first zone in global list

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type documentation
* [[Manual:DIL_Manual/load()|load()]] - Load a unit into the game
* [[Manual:DIL_Manual/findzone()|findzone()]] - Find zone by name </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/loadstr</title>
     <ns>0</ns>
     <id>609055</id>
     <revision>
       <id>1691939</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of loadstr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= loadstr =

function: integer &apos;&apos;&apos;loadstr&apos;&apos;&apos;(filename : string, buff : string);

== Description ==
The &apos;&apos;&apos;loadstr&apos;&apos;&apos; function is used to load string content from disk files into a DIL string variable. This function is essential for creating persistent data storage systems such as message boards, news systems, mail systems, and NPC memory systems. The function reads files from the zone&apos;s DIL file directory under a &quot;strings&quot; subdirectory.

&apos;&apos;&apos;loadstr&apos;&apos;&apos; includes security restrictions and requires appropriate access levels (greater than 10) to execute. The function validates filenames to prevent illegal file access attempts.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| filename || string || The name of the file to load from the strings subdirectory
|-
| buff || string || A string variable that will receive the loaded file content (passed by reference)
|}

== Examples ==
* Requires zone access level greater than 10
* Filenames are validated using &apos;&apos;&apos;store_name_test&apos;&apos;&apos; to prevent illegal access
* Files are restricted to the zone&apos;s DIL file directory under &quot;strings&quot; subdirectory
* Security violations are logged and may terminate the DIL program

== Examples ==
Basic file loading:
 dilbegin load_example();
 var
  result:integer;
  content:string;
 code
 {
  result := loadstr(&quot;news.txt&quot;, content);
  if (result &gt; 0)
  {
   sendtext(content + &quot;[&amp;n]&quot;, self);
  }
  else
  {
   log(&quot;Failed to load news.txt, result: &quot; + itoa(result));
  }
  quit;
 }
 dilend

Message board system (from board reply DIL):
 err := loadstr(brdname + &quot;.idx&quot;, temp);
 if (err &lt; 0)
 {
  log(&quot;Error in boards on: &quot; + brdname);
  act(&quot;This board doesn&apos;t work report to an administrator.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
  goto quitboard;
 }

== Usage Notes ==
* Requires zone access level greater than 10
* Filenames are validated using &apos;&apos;&apos;store_name_test&apos;&apos;&apos; to prevent illegal access
* Files are restricted to the zone&apos;s DIL file directory under &quot;strings&quot; subdirectory
* Security violations are logged and may terminate the DIL program
* Disk access is always slow. To maintain server performance:
** Keep file sizes to a minimum
** Avoid frequent &apos;&apos;&apos;loadstr&apos;&apos;&apos; operations in time-critical code
** Consider caching frequently accessed data in memory
* The second parameter (buff) is modified by reference to contain the loaded content
* Empty files will result in buff being set to null
* The function automatically handles memory allocation and cleanup
* Use with &apos;&apos;&apos;savestr&apos;&apos;&apos; for complete persistent storage solutions

== Error Handling ==
* Returns &apos;&apos;&apos;FILE_LOADED&apos;&apos;&apos; (non-zero) when the file was successfully loaded
* Returns &apos;&apos;&apos;FILE_NOT_FOUND&apos;&apos;&apos; (0) when the specified file does not exist
* Returns &apos;&apos;&apos;FILE_OUT_OF_MEMORY&apos;&apos;&apos; when insufficient memory to load the file
* Returns &apos;&apos;&apos;FILE_TO_LARGE&apos;&apos;&apos; when the file exceeds size limits
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; when parameters are invalid or access is denied
* Invalid parameters result in &apos;&apos;&apos;fail&apos;&apos;&apos; return value
* Security violations terminate the DIL program with WAITCMD_QUIT
* File system errors are logged to the zone log
* Memory allocation failures return appropriate error codes

== Related Functions/Fields ==
* [[Manual:DIL_Manual/savestr|savestr]] - Save string content to files
* [[Manual:DIL_Manual/delstr|delstr]] - Delete string files
* [[Manual:DIL_Manual/split|split]] - Split loaded strings into arrays (useful for line-by-line processing)

== See Also ==
* [[Manual:DIL_Manual/FILE_LOADED|FILE_LOADED]] - Success constant
* [[Manual:DIL_Manual/FILE_NOT_FOUND|FILE_NOT_FOUND]] - File not found constant  
* [[Manual:DIL_Manual/FILE_OUT_OF_MEMORY|FILE_OUT_OF_MEMORY]] - Memory error constant
* [[Manual:DIL_Manual/FILE_TO_LARGE|FILE_TO_LARGE]] - File size error constant </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/log</title>
     <ns>0</ns>
     <id>890252</id>
     <revision>
       <id>1718063</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of log.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= log =

procedure: &apos;&apos;&apos;log&apos;&apos;&apos;(s : string);

== Description ==
The &apos;&apos;&apos;log&apos;&apos;&apos; procedure writes a text string to the zone&apos;s log file for debugging and error tracking purposes. This is an essential tool for DIL developers to monitor program execution, track errors, and debug complex DIL programs. The logged output is written to the zone&apos;s log file using the server&apos;s logging system.

The &apos;&apos;&apos;log&apos;&apos;&apos; procedure is particularly useful for tracking program flow, debugging variable values, and recording error conditions that occur during DIL execution. Unlike normal game messages, log entries are permanently recorded and can be reviewed by administrators and developers.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The text message to be written to the zone log file
|}

== Usage Notes ==
* Log entries are written to the zone&apos;s log file (typically found in the server&apos;s log directory)
* The procedure is primarily intended for debugging and development purposes
* Log entries include timestamps and zone information automatically
* Use meaningful log messages to facilitate debugging
* Avoid excessive logging in production code as it can impact server performance

== Examples ==
Basic error logging:
 dilbegin load_example();
 var
  result:integer;
  content:string;
 code
 {
  result := loadstr(&quot;news.txt&quot;, content);
  if (result &lt; 0)
  {
   log(&quot;Failed to load news.txt, result: &quot; + itoa(result));
   quit;
  }
  
  log(&quot;Successfully loaded news.txt&quot;);
  sendtext(content + &quot;[&amp;n]&quot;, self);
  quit;
 }
 dilend

Debugging program flow:
 dilbegin debug_example(target : unitptr);
 var
  i:integer;
 code
 {
  log(&quot;Starting debug_example for target: &quot; + target.name);
  
  if (target == null)
  {
   log(&quot;Error: target is null&quot;);
   quit;
  }
  
  log(&quot;Target type: &quot; + itoa(target.type));
  log(&quot;Target zone: &quot; + target.zoneidx);
  
  i := 0;
  while (i &lt; 5)
  {
   log(&quot;Processing iteration: &quot; + itoa(i));
   pause;
   i := i + 1;
  }
  
  log(&quot;Completed debug_example&quot;);
  quit;
 }
 dilend

Error tracking in file operations:
 dilbegin save_data(data : string);
 var
  result:integer;
 code
 {
  log(&quot;Attempting to save data, length: &quot; + itoa(length(data)));
  
  result := savestr(&quot;datafile.txt&quot;, data, &quot;w&quot;);
  if (result &lt; 1)
  {
   log(&quot;Error: Failed to save datafile.txt, result: &quot; + itoa(result));
   quit;
  }
  
  log(&quot;Successfully saved datafile.txt&quot;);
  quit;
 }
 dilend

== Error Handling ==
* The procedure handles null string pointers gracefully
* No return value is generated, so errors cannot be detected programmatically
* If logging fails (due to file system issues), the error is typically logged at the server level
* Always validate string parameters before logging to avoid null pointer issues

== Performance Considerations ==
* Excessive logging can impact server performance
* Log file I/O operations are relatively expensive
* Consider using conditional logging or log levels for production code
* Large log messages should be avoided for performance reasons

== Related Functions/Fields ==
* [[Manual:DIL_Manual/flog|flog]] - Log to specific files with more control over output destination
* [[Manual:DIL_Manual/logcrime|logcrime]] - Log criminal activities for justice system tracking
* [[Manual:DIL_Manual/szonelog|szonelog]] - Low-level zone logging function (internal use)

== See Also ==
* [[Manual:DIL_Manual/DIL Debugging|DIL Debugging]] - General debugging techniques for DIL programs
* [[Manual:DIL_Manual/Zone Administration|Zone Administration]] - Zone log file management
* [[Manual:DIL_Manual/Server Logging|Server Logging]] - Server-wide logging system overview </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/logcrime</title>
     <ns>0</ns>
     <id>803869</id>
     <revision>
       <id>907315</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of logcrime.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= logcrime =

procedure: &apos;&apos;&apos;logcrime&apos;&apos;&apos;(criminal : unitptr, victim : unitptr, crime_type : integer);

== Description ==
Registers a crime committed against a victim by a criminal. The &apos;&apos;&apos;logcrime&apos;&apos;&apos; procedure automatically handles group members of the criminal and other related entities. This function is typically used in theft, assault, and other criminal activities within the MUD to maintain a record of offenses for potential punishment or tracking purposes.

When logging crimes like theft, remember to make the criminal visible if they fail their attempts, as shown in the example usage.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| criminal || unitptr || The criminal (main suspect) who committed the crime
|-
| victim || unitptr || The victim who was affected by the crime  
|-
| crime_type || integer || The type of crime using CRIME_XXX constants from values.h and/or vme.h
|}

== Examples ==
dilbegin steal(arg : string);
external
    onefreehand();
    bobcheck(victim : unitptr);
    provoked_attack (victim : unitptr, ch : unitptr);
    awareness_check(thief : unitptr, victim : unitptr, skill : integer, msg : string);
    integer skillbattle2(skillidx : integer, abiidx1 : integer, abiidx2 : integer, opp : unitptr, oabiidx1 : integer, oabiidx2 : integer);

var
   skilla  :  integer;
   skillb  :  integer;
   skillc  :  integer;
   skilld  :  integer;
   hm      :  integer;
   vict    :  unitptr;
   targ    :  unitptr;
   t       :  string;
   temp    : string;
   ti      : integer;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_STEAL] &lt;= 0))
   {
      act(&quot;You must practice first.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   onefreehand();

   if (not (&quot; from &quot; in arg))
   {
      act(&quot;Steal what from who?&quot;, A_SOMEONE, self, null, null,  TO_CHAR);
      quit;
   }

   /* needed for multi word names */
   t := getword(arg);
   temp := getword(arg);
   while (temp != &quot;from&quot;)
   {
      t := (t + &quot; &quot; + temp);
      temp := getword(arg);
   }

   vict := findunit(self, arg, FIND_UNIT_SURRO, null);
   if ((vict == null) or not visible(self, vict))
   {
      act(&quot;No such person to steal from.&quot;,  A_SOMEONE, self, null,  null, TO_CHAR);
      quit;
   }


   if (vict == self)
   {
      act(&quot;But you already have it - no need to steal it from yourself.&quot;, A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if ((vict.type != UNIT_ST_PC) and (vict.type != UNIT_ST_NPC))
   {
      act(&quot;Why bother? Just get the darn thing!&quot;, A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   bobcheck(vict);

   targ := findunit(vict, t, FIND_UNIT_IN_ME, null);

   if ((targ == null) or not visible(self, targ))
   {
      act(&quot;You can&apos;t find that on $3n.&quot;, A_SOMEONE, self, targ, vict, TO_CHAR);
      quit;
   }

   if (targ.objecttype == ITEM_MONEY)
   {
      act(&quot;That would take a different type of finesse, try pickpocket instead.&quot;, A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
   }

   if (targ.equip != 0)  /* 0 = not equipped, value not in values.h */
   {
      act(&quot;You can only steal non-equiped items!&quot;, A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
   }

   if (targ.zoneidx == &quot;treasure&quot;)
   {
      act(&quot;A chill runs down your spine...someone or something is watching.&quot;,
         A_ALWAYS, self, null, null, TO_CHAR);
      act(&quot;You change your mind about stealing that.&quot;, A_ALWAYS, self,
         null, null, TO_CHAR);
      quit;
   }

   ti := can_carry(self,targ,1);

   if (ti == 1)
   {
      act (&quot;You can&apos;t carry another thing.&quot;, A_ALWAYS,self,null,null,TO_CHAR);
      quit;
   }

    hm := skillbattle2(SKI_STEAL, ABIL_DEX, ABIL_BRA, vict, ABIL_BRA, ABIL_DEX);
    if (isaff(self, ID_INVISIBILITY))
        hm := hm + 50;

   if (hm &lt;= -25)
   {
      act(&quot;You are caught!&quot;, A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
      {
         subaff(self, ID_INVISIBILITY);
      }
      act(&quot;You catch $1n trying to steal your $2n!&quot;, A_SOMEONE, self, targ,
          vict, TO_VICT);
      act(&quot;You see $1n trying to steal something from $3n...$3e doesn&apos;t &quot; +
          &quot;seem amused!&quot;, A_SOMEONE, self, targ, vict, TO_NOTVICT);
      provoked_attack(vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
   }

   if (hm &lt;= 0)
   {
      act(&quot;You fail to steal $3n&apos;s $2n, but at least no one was watching!&quot;,
        A_SOMEONE, self, targ, vict, TO_CHAR);
      quit;
   }

   if (hm &lt; 25)
   {
      act(&quot;You steal $2n from $3n just as $3e turns toward you..You have &quot;+
          &quot;been caught!&quot;, A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
      {
          subaff(self, ID_INVISIBILITY);
      }
      act(&quot;Arrgh!  $1n just stole your $2n!&quot;, A_SOMEONE, self, targ, vict, TO_VICT);
      act(&quot;You see $1n steal something from $3n...$3e doesn&apos;t seem amused!&quot;,
          A_SOMEONE, self, targ, vict, TO_NOTVICT);
      link(targ, self);
      provoked_attack(vict, self);
      logcrime(self, vict, CRIME_STEALING);
      send_done(&quot;steal&quot;,self,targ,vict,hm,arg,null, CMD_AUTO_NONE);
      quit;
   }

   act(&quot;You stealthily steal $3n&apos;s $2n and quickly tuck it out of sight!&quot;, A_SOMEONE, self, targ, vict, TO_CHAR);
   link(targ, self);
   awareness_check(self, vict, SKI_STEAL, &quot;You notice $2n stealing something from $3n&quot;);
   send_done(&quot;steal&quot;,self,targ,vict,hm,arg,null, CMD_AUTO_NONE);
   quit;
} dilend

== Usage Notes ==
* Use CRIME_XXX constants from values.h and/or vme.h for the crime_type parameter
* The function automatically registers group members of the criminal
* For theft-related crimes, ensure the criminal is made visible if they fail their attempt
* This is typically called after a criminal action has been detected or failed

== Error Handling ==
The procedure includes type checking to ensure:
* criminal parameter is a valid unitptr
* victim parameter is a valid unitptr  
* crime_type parameter is an integer
* Both criminal and victim units are character units (PC or NPC)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/provoked_attack|provoked_attack]] - Often called after logging a crime
* [[Manual:DIL_Manual/awareness_check|awareness_check]] - Used to detect criminal activities
* [[Manual:DIL_Manual/act|act]] - For displaying crime-related messages

== See Also ==
* CRIME_XXX constants in values.h and/or vme.h </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/loglevel</title>
     <ns>0</ns>
     <id>685285</id>
     <revision>
       <id>1298033</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of loglevel.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= loglevel =

field: integer &apos;&apos;&apos;.loglevel&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;.loglevel&apos;&apos;&apos; field is accessed on a &apos;&apos;&apos;cmdptr&apos;&apos;&apos; (command pointer) and returns an integer value representing the minimum character level that can see log entries for this command. A value of 0 indicates that no logging is performed for this command.

This field is useful for understanding which commands have logging enabled and at what privilege level the logs are accessible.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .loglevel || integer || Read-only || Minimum character level that can see command logs (0 = no logging)
|}

== Availability ==
This field is available on the following unit type:
* cmdptr (Command pointer)

== Examples ==
 dilbegin log_example(arg : string);
 var
   cmd : cmdptr;
   log_level : integer;

 code
 {
   // Get a specific command
   cmd := getcommand(&quot;kick&quot;);
   
   if (cmd)
   {
     log_level := cmd.loglevel;
     
     if (log_level = 0)
       act(&quot;Command &apos;$2t&apos; has no logging enabled.&quot;, A_ALWAYS, self, cmd.name, null, TO_CHAR);
     else
       act(&quot;Command &apos;$2t&apos; logs are visible to level $3d+ characters.&quot;, A_ALWAYS, self, cmd.name, log_level, TO_CHAR);
   }
   else
     act(&quot;Command &apos;kick&apos; not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);

   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.loglevel&apos;&apos;&apos; field is read-only and cannot be modified
* A value of 0 means the command does not generate any log entries
* Higher values indicate that only characters at or above that level can view the command&apos;s logs
* This field is typically used by administrators and builders to understand command logging behavior

== Error Handling ==
* If accessed on a null &apos;&apos;&apos;cmdptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* If accessed on an invalid pointer type, the operation will result in an error

== Related Functions/Fields ==
* [[Manual:DIL_Manual/chead|chead]] - Gets the first command in the command list
* [[Manual:DIL_Manual/getcommand|getcommand]] - Gets a specific command by name
* [[Manual:DIL_Manual/cmdptr.name|cmdptr.name]] - Gets the command name
* [[Manual:DIL_Manual/cmdptr.level|cmdptr.level]] - Gets the minimum level to use the command
* [[Manual:DIL_Manual/cmdptr.type|cmdptr.type]] - Gets the command type
* [[Manual:DIL_Manual/cmdptr.position|cmdptr.position]] - Gets the minimum position to use the command

== See Also ==
* [[Manual:DIL_Manual/cmdptr|cmdptr]] - Command pointer type documentation </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/mana</title>
     <ns>0</ns>
     <id>411915</id>
     <revision>
       <id>1616528</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of mana.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= mana =

field: integer &apos;&apos;&apos;.mana&apos;&apos;&apos; (Read/Write)

== Description ==
The &apos;&apos;&apos;.mana&apos;&apos;&apos; field is accessed on character units (PC or NPC) and returns or sets the current mana points of the character. Mana is typically used for casting spells and using magical abilities.

This field is read/write, allowing you to both retrieve the current mana value and modify it directly.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .mana || integer || Read/Write || Current mana points of the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
 dilbegin mana_restore(char : unitptr);
 var
   current_mana : integer;
   max_mana : integer;

 code
 {
   // Check if the unit is a character
   if (char.type = UNIT_ST_PC or char.type = UNIT_ST_NPC)
   {
     current_mana := char.mana;
     max_mana := char.max_mana;
     
     act(&quot;$1n has $2d/$3d mana points.&quot;, A_ALWAYS, char, current_mana, max_mana, TO_ROOM);
     
     // Restore mana to full
     char.mana := max_mana;
     
     act(&quot;$1n&apos;s mana has been fully restored.&quot;, A_ALWAYS, char, null, null, TO_CHAR);
   }
   else
     act(&quot;Target is not a character.&quot;, A_ALWAYS, self, null, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin mana_drain(victim : unitptr, amount : integer);
 code
 {
   if (victim.type = UNIT_ST_PC or victim.type = UNIT_ST_NPC)
   {
     if (victim.mana &gt;= amount)
     {
       victim.mana := victim.mana - amount;
       act(&quot;You drain $2d mana from $1n.&quot;, A_ALWAYS, self, amount, victim, TO_CHAR);
       act(&quot;$1n drains $2d mana from you!&quot;, A_ALWAYS, self, amount, victim, TO_VICT);
       act(&quot;$1n drains mana from $3n.&quot;, A_ALWAYS, self, null, victim, TO_NOTVICT);
     }
     else
     {
       victim.mana := 0;
       act(&quot;You completely drain $1n&apos;s mana.&quot;, A_ALWAYS, self, null, victim, TO_CHAR);
       act(&quot;$1n completely drains your mana!&quot;, A_ALWAYS, self, null, victim, TO_VICT);
     }
   }

   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.mana&apos;&apos;&apos; field can be both read and modified
* Mana values should typically be kept within reasonable bounds (0 to max_mana)
* Setting mana above &apos;&apos;&apos;max_mana&apos;&apos;&apos; is possible but may have unintended effects
* This field is commonly used in spell casting systems, death sequences, and mana restoration mechanics
* When modifying mana, consider the impact on game balance and player experience

== Error Handling ==
* If accessed on a non-character unit type, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* If accessed on a null &apos;&apos;&apos;unitptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* Setting negative values may result in unexpected behavior

== Related Functions/Fields ==
* [[Manual:DIL_Manual/max_mana|max_mana]] - Gets the maximum mana of a character
* [[Manual:DIL_Manual/endurance|endurance]] - Gets/sets the current endurance points
* [[Manual:DIL_Manual/hp|hp]] - Gets/sets the current hit points
* [[Manual:DIL_Manual/experience|experience]] - Sets experience points
* [[Manual:DIL_Manual/cast_spell|cast_spell]] - Function that typically consumes mana

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields documentation </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/manipulate</title>
     <ns>0</ns>
     <id>1077252</id>
     <revision>
       <id>1032398</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of manipulate.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= manipulate =
 field: integer &apos;&apos;&apos;.manipulate&apos;&apos;&apos; [Read/Write]

The &apos;&apos;&apos;.manipulate&apos;&apos;&apos; field is accessed on any unit and returns or sets bit flags that specify how the unit can be handled. These flags determine what actions can be performed on the unit, such as taking, dropping, or manipulating it in various ways.

== Description ==
This field is read/write, allowing you to both retrieve the current manipulation flags and modify them directly.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .manipulate || integer || Read/Write || Bit flags specifying how the unit can be handled
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin check_manipulate(item : unitptr);
 code
 {
   // Check if an item can be taken
   if (isset(item.manipulate, MANIPULATE_TAKE))
     act(&quot;You can take the $2n.&quot;, A_ALWAYS, self, item, null, TO_CHAR);
   else
     act(&quot;You cannot take the $2n.&quot;, A_ALWAYS, self, item, null, TO_CHAR);

   // Check if an item can be dropped
   if (isset(item.manipulate, MANIPULATE_DROP))
     act(&quot;You can drop the $2n.&quot;, A_ALWAYS, self, item, null, TO_CHAR);
   else
     act(&quot;You cannot drop the $2n.&quot;, A_ALWAYS, self, item, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin set_untakeable(item : unitptr);
 code
 {
   // Make an item untakeable
   unset(item.manipulate, MANIPULATE_TAKE);
   act(&quot;The $2n suddenly becomes impossible to take.&quot;, A_ALWAYS, self, item, null, TO_ALL);
   
   quit;
 }
 dilend

 dilbegin janitor_cleanup();
 var
    trash : unitptr;

 code
 {
   foreach (UNIT_ST_OBJ, trash)
   {
      // Only process objects that can be taken
      if (not isset(trash.manipulate, MANIPULATE_TAKE))
         continue;
      
      // Additional cleanup logic here
      act(&quot;$1n picks up the $2n.&quot;, A_ALWAYS, self, trash, null, TO_ROOM);
      exec(&quot;get &quot; + trash.name, self);
   }

   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.manipulate&apos;&apos;&apos; field uses bit flags that can be checked with [[Manual:DIL_Manual/isset|isset]] and modified with [[Manual:DIL_Manual/set|set]]/[[Manual:DIL_Manual/unset|unset]]
* Common manipulation flags include MANIPULATE_TAKE, MANIPULATE_DROP, and others defined in values.h/vme.h
* This field is essential for controlling object behavior and accessibility
* Setting inappropriate flags may cause unexpected behavior in the game
* The field is commonly used in conjunction with [[Manual:DIL_Manual/can_carry|can_carry]] and other movement-related functions

== Error Handling ==
* If accessed on a null &apos;&apos;&apos;unitptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* Setting invalid flag combinations may result in undefined behavior
* Some flags may be overridden by the game engine based on unit type or state

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isset|isset]] - Checks if specific bits are set in an integer
* [[Manual:DIL_Manual/set|set]] - Sets specific bits in an integer
* [[Manual:DIL_Manual/unset|unset]] - Clears specific bits in an integer
* [[Manual:DIL_Manual/can_carry|can_carry]] - Checks if a unit can carry another unit
* [[Manual:DIL_Manual/flags|flags]] - General unit flags field

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* MANIPULATE_* flags in values.h and/or vme.h for complete flag definitions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/mapx</title>
     <ns>0</ns>
     <id>1074396</id>
     <revision>
       <id>1723226</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of mapx.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= mapx =
 field: integer &apos;&apos;&apos;.mapx&apos;&apos;&apos; [Read-only]

The &apos;&apos;&apos;.mapx&apos;&apos;&apos; field is accessed on room units and returns the X coordinate of the room on a map grid. This field is used to position rooms within a coordinate system, typically for mapping, visualization, or spatial calculations.

== Description ==
If a room has not been assigned map coordinates, this field returns -1.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .mapx || integer || Read-only || X coordinate of the room on the map grid (-1 if not set)
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin show_room_coordinates(room : unitptr);
 code
 {
   // Check if the unit is a room
   if (room.type != UNIT_ST_ROOM)
   {
     act(&quot;Target is not a room.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Get coordinates
   if (room.mapx != -1 and room.mapy != -1)
     act(&quot;Room coordinates: X=$2d, Y=$3d&quot;, A_ALWAYS, self, room.mapx, room.mapy, TO_CHAR);
   else
     act(&quot;This room has no map coordinates assigned.&quot;, A_ALWAYS, self, null, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin find_adjacent_rooms(center_room : unitptr);
 var
   room : unitptr;
   x, y : integer;
   adjacent : stringlist;

 code
 {
   if (center_room.type != UNIT_ST_ROOM or center_room.mapx = -1)
   {
     act(&quot;Invalid center room or no coordinates.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   x := center_room.mapx;
   y := center_room.mapy;

   // Search for rooms with adjacent coordinates
   foreach (UNIT_ST_ROOM, room)
   {
     if (room.mapx = -1 or room.mapy = -1)
       continue;

     // Check if room is adjacent (within 1 coordinate)
     if ((room.mapx &gt;= x - 1) and (room.mapx &lt;= x + 1) and
         (room.mapy &gt;= y - 1) and (room.mapy &lt;= y + 1) and
         (room != center_room))
     {
       addstring(adjacent, room.title + &quot; (&quot; + itoa(room.mapx) + &quot;,&quot; + itoa(room.mapy) + &quot;)&quot;);
     }
   }

   if (length(adjacent) &gt; 0)
   {
     act(&quot;Adjacent rooms found:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     foreach (adjacent as line)
       act(&quot;  $2t&quot;, A_ALWAYS, self, line, null, TO_CHAR);
   }
   else
     act(&quot;No adjacent rooms found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin generate_map_html(room : unitptr);
 var
   html : string;

 code
 {
   if (room.type != UNIT_ST_ROOM)
   {
     quit;
   }

   // Generate HTML with map coordinates if available
   if (room.mapx != -1)
     html := &quot;&lt;div class=&apos;room&apos; x=&apos;&quot; + itoa(room.mapx) + &quot;&apos; y=&apos;&quot; + itoa(room.mapy) + &quot;&apos;&gt;&quot; + room.title + &quot;&lt;/div&gt;&quot;;
   else
     html := &quot;&lt;div class=&apos;room&apos;&gt;&quot; + room.title + &quot;&lt;/div&gt;&quot;;

   sendtext(html, self);
   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.mapx&apos;&apos;&apos; field is read-only and cannot be modified through DIL
* This field works in conjunction with [[Manual:DIL_Manual/mapy|mapy]] to provide complete 2D coordinates
* A value of -1 indicates that the room has not been assigned map coordinates
* Map coordinates are typically set in the zone files or through administrative commands
* This field is commonly used for mapping systems, spatial calculations, and room visualization
* Coordinates are typically used for grid-based mapping where each room has an X,Y position

== Error Handling ==
* If accessed on a non-room unit type, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* If accessed on a null &apos;&apos;&apos;unitptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* The field itself never fails - it always returns an integer (coordinates or -1)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/mapy|mapy]] - Gets the Y coordinate of a room
* [[Manual:DIL_Manual/unit_st_room|unit_st_room]] - Room-specific fields documentation
* [[Manual:DIL_Manual/findroom|findroom]] - Finds a room by name
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - Gets the zone name of a room

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/unit_st_room|unit_st_room]] - Room-specific fields and properties</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/mapy</title>
     <ns>0</ns>
     <id>1040309</id>
     <revision>
       <id>993975</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of mapy.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= mapy =
 field: integer &apos;&apos;&apos;.mapy&apos;&apos;&apos; [Read-only]

The &apos;&apos;&apos;.mapy&apos;&apos;&apos; field is accessed on room units and returns the Y coordinate of the room on a map grid. This field is used to position rooms within a coordinate system, typically for mapping, visualization, or spatial calculations.

== Description ==
If a room has not been assigned map coordinates, this field returns -1.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .mapy || integer || Read-only || Y coordinate of the room on the map grid (-1 if not set)
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin show_room_coordinates(room : unitptr);
 code
 {
   // Check if the unit is a room
   if (room.type != UNIT_ST_ROOM)
   {
     act(&quot;Target is not a room.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Get coordinates
   if (room.mapx != -1 and room.mapy != -1)
     act(&quot;Room coordinates: X=$2d, Y=$3d&quot;, A_ALWAYS, self, room.mapx, room.mapy, TO_CHAR);
   else
     act(&quot;This room has no map coordinates assigned.&quot;, A_ALWAYS, self, null, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin calculate_distance(room1 : unitptr, room2 : unitptr);
 var
   x1, y1, x2, y2 : integer;
   distance : integer;

 code
 {
   if (room1.type != UNIT_ST_ROOM or room2.type != UNIT_ST_ROOM)
   {
     act(&quot;Both targets must be rooms.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Check if both rooms have coordinates
   if (room1.mapx = -1 or room1.mapy = -1 or room2.mapx = -1 or room2.mapy = -1)
   {
     act(&quot;One or both rooms lack map coordinates.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   x1 := room1.mapx;
   y1 := room1.mapy;
   x2 := room2.mapx;
   y2 := room2.mapy;

   // Calculate Manhattan distance
   distance := (x2 - x1) + (y2 - y1);
   if (distance &lt; 0)
     distance := -distance;

   act(&quot;Distance between rooms: $2d&quot;, A_ALWAYS, self, distance, null, TO_CHAR);
   quit;
 }
 dilend

 dilbegin generate_map_legend();
 var
   room : unitptr;
   min_x, max_x, min_y, max_y : integer;
   first_room : integer;

 code
 {
   min_x := 999999;
   max_x := -999999;
   min_y := 999999;
   max_y := -999999;
   first_room := TRUE;

   // Find coordinate bounds
   foreach (UNIT_ST_ROOM, room)
   {
     if (room.mapx = -1 or room.mapy = -1)
       continue;

     if (first_room)
     {
       min_x := room.mapx;
       max_x := room.mapx;
       min_y := room.mapy;
       max_y := room.mapy;
       first_room := FALSE;
     }
     else
     {
       if (room.mapx &lt; min_x) min_x := room.mapx;
       if (room.mapx &gt; max_x) max_x := room.mapx;
       if (room.mapy &lt; min_y) min_y := room.mapy;
       if (room.mapy &gt; max_y) max_y := room.mapy;
     }
   }

   if (first_room)
   {
     act(&quot;No rooms with map coordinates found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   act(&quot;Map bounds: X($2d-$3d), Y($4d-$5d)&quot;, A_ALWAYS, self, min_x, max_x, min_y, max_y, TO_CHAR);
   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.mapy&apos;&apos;&apos; field is read-only and cannot be modified through DIL
* This field works in conjunction with [[Manual:DIL_Manual/mapx|mapx]] to provide complete 2D coordinates
* A value of -1 indicates that the room has not been assigned map coordinates
* Map coordinates are typically set in the zone files or through administrative commands
* This field is commonly used for mapping systems, spatial calculations, and room visualization
* Coordinates are typically used for grid-based mapping where each room has an X,Y position
* The Y coordinate usually represents the vertical position on the map grid

== Error Handling ==
* If accessed on a non-room unit type, operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* If accessed on a null &apos;&apos;&apos;unitptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* The field itself never fails - it always returns an integer (coordinates or -1)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/mapx|mapx]] - Gets the X coordinate of a room
* [[Manual:DIL_Manual/unit_st_room|unit_st_room]] - Room-specific fields documentation
* [[Manual:DIL_Manual/findroom|findroom]] - Finds a room by name
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - Gets the zone name of a room

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/unit_st_room|unit_st_room]] - Room-specific fields and properties</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/master</title>
     <ns>0</ns>
     <id>1104253</id>
     <revision>
       <id>1568871</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of master.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= master =
 field: unitptr &apos;&apos;&apos;.master&apos;&apos;&apos; [Read-only]

The &apos;&apos;&apos;.master&apos;&apos;&apos; field is accessed on character units (PC or NPC) and returns a unitptr to the character that this character is currently following. If the character is not following anyone, this field returns null.

== Description ==
This field represents the &quot;master&quot; in a master/follower relationship, where the current character is the follower and the returned unitptr is the master they are following.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .master || unitptr || Read-only || The character this unit is following (null if not following anyone)
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
 dilbegin check_following(char : unitptr);
 code
 {
   // Check if the unit is a character
   if (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC)
   {
     act(&quot;Target is not a character.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Check who the character is following
   if (char.master = null)
     act(&quot;$1n is not following anyone.&quot;, A_ALWAYS, char, null, null, TO_ROOM);
   else
     act(&quot;$1n is following $2n.&quot;, A_ALWAYS, char, char.master, null, TO_ROOM);

   quit;
 }
 dilend

 dilbegin stop_following();
 code
 {
   // Check if self is following someone
   if (self.master != null)
   {
     act(&quot;You stop following $1n.&quot;, A_ALWAYS, self, self.master, null, TO_CHAR);
     act(&quot;$2n stops following you.&quot;, A_ALWAYS, self.master, self, null, TO_CHAR);
     act(&quot;$2n stops following $1n.&quot;, A_ALWAYS, self.master, self, null, TO_NOTVICT);
     
     // Use the follow function to break the following relationship
     follow(self, self);
   }
   else
     act(&quot;You are not following anyone.&quot;, A_ALWAYS, self, null, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin group_leader();
 var
   leader : unitptr;
   group_members : stringlist;

 code
 {
   // Find the group leader (someone not following anyone)
   leader := self;
   
   while (leader.master != null and leader.master != leader)
     leader := leader.master;

   if (leader = self)
     act(&quot;You are the group leader.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
   else
     act(&quot;$1n is the group leader.&quot;, A_ALWAYS, self, leader, null, TO_CHAR);

   // Count group members
   foreach (UNIT_ST_PC, leader)
   {
     if (leader.master = self or leader = self)
       addstring(group_members, leader.name);
   }

   if (length(group_members) &gt; 1)
   {
     act(&quot;Group members:&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     foreach (group_members as member)
       act(&quot;  $2t&quot;, A_ALWAYS, self, member, null, TO_CHAR);
   }

   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.master&apos;&apos;&apos; field is read-only and cannot be modified directly
* To change who a character follows, use the [[Manual:DIL_Manual/follow|follow]] function
* A character following themselves indicates they are not following anyone
* This field is commonly used in group management, pet control, and NPC behavior systems
* The master/follower relationship forms chains - a character can be both a master and a follower simultaneously
* When a character stops following, their master field typically becomes null or points to themselves

== Error Handling ==
* If accessed on a non-character unit type, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* If accessed on a null &apos;&apos;&apos;unitptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* The field itself never fails - it always returns a unitptr (which may be null)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/follow|follow]] - Makes a character follow another character
* [[Manual:DIL_Manual/follower|follower]] - Gets the first follower of a character
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields documentation

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields and properties</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/max_endurance</title>
     <ns>0</ns>
     <id>514153</id>
     <revision>
       <id>1710981</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of max_endurance.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= max_endurance =
 field: integer &apos;&apos;&apos;.max_endurance&apos;&apos;&apos; [Read-only]

The &apos;&apos;&apos;.max_endurance&apos;&apos;&apos; field is accessed on character units (PC or NPC) and returns the maximum endurance points of the character. This represents the highest possible endurance value the character can have, which is used as the upper bound for current endurance calculations.

== Description ==
Endurance is typically used for physical activities, movement, and combat stamina.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .max_endurance || integer || Read-only || Maximum endurance points of the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
 dilbegin show_endurance_status(char : unitptr);
 code
 {
   // Check if the unit is a character
   if (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC)
   {
     act(&quot;Target is not a character.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Display endurance information
   act(&quot;$1n&apos;s endurance: $2d/$3d&quot;, A_ALWAYS, char, char.endurance, char.max_endurance, TO_ROOM);
   
   // Calculate endurance percentage
   if (char.max_endurance &gt; 0)
   {
     var percentage : integer;
     percentage := (char.endurance * 100) / char.max_endurance;
     act(&quot;Endurance at $2d% capacity.&quot;, A_ALWAYS, char, percentage, null, TO_CHAR);
   }

   quit;
 }
 dilend

 dilbegin restore_endurance(char : unitptr);
 code
 {
   if (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC)
   {
     act(&quot;Target is not a character.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Restore endurance to maximum
   char.endurance := char.max_endurance;
   act(&quot;$1n&apos;s endurance has been fully restored.&quot;, A_ALWAYS, char, null, null, TO_ROOM);
   act(&quot;Your endurance has been fully restored.&quot;, A_ALWAYS, char, null, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin endurance_check(threshold : integer);
 code
 {
   // Check if self has sufficient endurance
   if (self.endurance &lt; threshold)
   {
     act(&quot;You don&apos;t have enough endurance for that action.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     act(&quot;You need at least $2d endurance.&quot;, A_ALWAYS, self, threshold, null, TO_CHAR);
     quit;
   }

   // Calculate remaining endurance
   var remaining : integer;
   remaining := self.max_endurance - self.endurance;
   act(&quot;You have $2d endurance points remaining.&quot;, A_ALWAYS, self, remaining, null, TO_CHAR);

   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.max_endurance&apos;&apos;&apos; field is read-only and cannot be modified directly
* This field represents the theoretical maximum endurance a character can have
* Maximum endurance is typically determined by character level, race, and other attributes
* This field is commonly used in conjunction with [[Manual:DIL_Manual/endurance|endurance]] to calculate percentages and ratios
* The value is used as the upper bound when restoring endurance after death, rest, or magical effects
* Endurance systems are often used for movement costs, combat fatigue, and special abilities

== Error Handling ==
* If accessed on a non-character unit type, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* If accessed on a null &apos;&apos;&apos;unitptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* The field itself never fails - it always returns an integer value

== Related Functions/Fields ==
* [[Manual:DIL_Manual/endurance|endurance]] - Gets/sets the current endurance points
* [[Manual:DIL_Manual/max_hp|max_hp]] - Gets the maximum hit points
* [[Manual:DIL_Manual/max_mana|max_mana]] - Gets the maximum mana points
* [[Manual:DIL_Manual/hp|hp]] - Gets/sets the current hit points
* [[Manual:DIL_Manual/mana|mana]] - Gets/sets the current mana points

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/max_hp</title>
     <ns>0</ns>
     <id>577529</id>
     <revision>
       <id>1108234</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of max_hp.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= max_hp =
 field: integer &apos;&apos;&apos;.max_hp&apos;&apos;&apos; [Read-only (PC) / Read-write (NPC &amp; Obj)]

The &apos;&apos;&apos;.max_hp&apos;&apos;&apos; field is accessed on character units (PC/NPC) and objects, returning the maximum hitpoints of the unit. This represents the highest possible health value the unit can have.

== Description ==
For player characters, this field is read-only. For mobiles (NPCs) and objects, this field is read/write, allowing modification of their maximum health.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .max_hp || integer || Read-only (PC) / Read-write (NPC &amp; Obj) || Maximum hitpoints of the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character) - Read-only access
* UNIT_ST_NPC (Non-Player Character) - Read-write access
* UNIT_ST_OBJ (Object) - Read-write access

== Examples ==
 dilbegin show_health_status(char : unitptr);
 code
 {
   // Check if the unit is a character
   if (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC)
   {
     act(&quot;Target is not a character.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Display health information
   act(&quot;$1n&apos;s health: $2d/$3d&quot;, A_ALWAYS, char, char.hp, char.max_hp, TO_ROOM);
   
   // Calculate health percentage
   if (char.max_hp &gt; 0)
   {
     var percentage : integer;
     percentage := (char.hp * 100) / char.max_hp;
     act(&quot;Health at $2d% capacity.&quot;, A_ALWAYS, char, percentage, null, TO_CHAR);
   }

   quit;
 }
 dilend

 dilbegin heal_to_full(char : unitptr);
 code
 {
   if (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC)
   {
     act(&quot;Target is not a character.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Restore health to maximum
   char.hp := char.max_hp;
   act(&quot;$1n&apos;s health has been fully restored.&quot;, A_ALWAYS, char, null, null, TO_ROOM);
   act(&quot;Your health has been fully restored.&quot;, A_ALWAYS, char, null, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin create_tough_npc(template : unitptr);
 var
   new_npc : unitptr;

 code
 {
   // Create a new NPC based on template
   new_npc := clone(template);
   
   if (new_npc = null)
   {
     act(&quot;Failed to create new NPC.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Make the NPC tougher by increasing max HP (only works for NPCs)
   if (new_npc.type = UNIT_ST_NPC)
   {
     new_npc.max_hp := new_npc.max_hp * 2;  // Double the max HP
     new_npc.hp := new_npc.max_hp;           // Set current HP to new max
     
     act(&quot;$1n looks much tougher than $2n!&quot;, A_ALWAYS, new_npc, template, null, TO_ROOM);
   }
   else
     act(&quot;Can only modify max_hp for NPCs, not players.&quot;, A_ALWAYS, self, null, null, TO_CHAR);

   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.max_hp&apos;&apos;&apos; field has different access permissions based on unit type
* For players (PCs), this field is read-only to maintain game balance
* For NPCs and objects, this field is read-write, allowing dynamic modification
* This field is commonly used in conjunction with [[Manual:DIL_Manual/hp|hp]] to calculate health percentages
* Maximum hitpoints are typically determined by character level, race, class, and equipment
* The value is used as an upper bound when restoring health after death, healing, or rest
* Objects use this field to determine durability and breakage thresholds

== Error Handling ==
* If accessed on a null &apos;&apos;&apos;unitptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* If attempting to write to a player&apos;s max_hp, the operation may be restricted or fail
* The field itself never fails when reading - it always returns an integer value

== Related Functions/Fields ==
* [[Manual:DIL_Manual/hp|hp]] - Gets/sets the current hitpoints
* [[Manual:DIL_Manual/max_mana|max_mana]] - Gets the maximum mana points
* [[Manual:DIL_Manual/max_endurance|max_endurance]] - Gets the maximum endurance points
* [[Manual:DIL_Manual/experience|experience]] - Sets experience points (which can affect max_hp for NPCs)

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/max_mana</title>
     <ns>0</ns>
     <id>1005942</id>
     <revision>
       <id>1275812</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of max_mana.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= max_mana =
 field: integer &apos;&apos;&apos;.max_mana&apos;&apos;&apos; [Read-only]

The &apos;&apos;&apos;.max_mana&apos;&apos;&apos; field is accessed on character units (PC or NPC) and returns the maximum mana points of the character. This represents the highest possible mana value the character can have, which is used as the upper bound for current mana calculations.

== Description ==
Mana is typically used for casting spells, using magical abilities, and powering special effects.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| .max_mana || integer || Read-only || Maximum mana points of character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
 dilbegin show_mana_status(char : unitptr);
 code
 {
   // Check if the unit is a character
   if (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC)
   {
     act(&quot;Target is not a character.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Display mana information
   act(&quot;$1n&apos;s mana: $2d/$3d&quot;, A_ALWAYS, char, char.mana, char.max_mana, TO_ROOM);
   
   // Calculate mana percentage
   if (char.max_mana &gt; 0)
   {
     var percentage : integer;
     percentage := (char.mana * 100) / char.max_mana;
     act(&quot;Mana at $2d% capacity.&quot;, A_ALWAYS, char, percentage, null, TO_CHAR);
   }

   quit;
 }
 dilend

 dilbegin restore_mana(char : unitptr);
 code
 {
   if (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC)
   {
     act(&quot;Target is not a character.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }

   // Restore mana to maximum
   char.mana := char.max_mana;
   act(&quot;$1n&apos;s mana has been fully restored.&quot;, A_ALWAYS, char, null, null, TO_ROOM);
   act(&quot;Your mana has been fully restored.&quot;, A_ALWAYS, char, null, null, TO_CHAR);

   quit;
 }
 dilend

 dilbegin mana_check(cost : integer);
 code
 {
   // Check if self has sufficient mana
   if (self.mana &lt; cost)
   {
     act(&quot;You don&apos;t have enough mana for that spell.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     act(&quot;You need at least $2d mana.&quot;, A_ALWAYS, self, cost, null, TO_CHAR);
     quit;
   }

   // Calculate remaining mana
   var remaining : integer;
   remaining := self.max_mana - self.mana;
   act(&quot;You have $2d mana points remaining.&quot;, A_ALWAYS, self, remaining, null, TO_CHAR);

   quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;.max_mana&apos;&apos;&apos; field is read-only and cannot be modified directly
* This field represents the theoretical maximum mana a character can have
* Maximum mana is typically determined by character level, class, race, intelligence, and other attributes
* This field is commonly used in conjunction with [[Manual:DIL_Manual/mana|mana]] to calculate percentages and ratios
* The value is used as the upper bound when restoring mana after death, rest, or magical effects
* Mana systems are often used for spell casting costs, magical item usage, and special abilities

== Error Handling ==
* If accessed on a non-character unit type, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* If accessed on a null &apos;&apos;&apos;unitptr&apos;&apos;&apos;, the operation will return &apos;&apos;&apos;fail&apos;&apos;&apos;
* The field itself never fails - it always returns an integer value

== Related Functions/Fields ==
* [[Manual:DIL_Manual/mana|mana]] - Gets/sets the current mana points
* [[Manual:DIL_Manual/max_hp|max_hp]] - Gets the maximum hit points
* [[Manual:DIL_Manual/max_endurance|max_endurance]] - Gets the maximum endurance points
* [[Manual:DIL_Manual/cast_spell|cast_spell]] - Function that typically consumes mana
* [[Manual:DIL_Manual/experience|experience]] - Sets experience points (which can affect max_mana indirectly)

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/medium</title>
     <ns>0</ns>
     <id>850241</id>
     <revision>
       <id>1517162</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of medium.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= medium =
 variable: unitptr &apos;&apos;&apos;medium&apos;&apos;&apos;

The &apos;&apos;&apos;medium&apos;&apos;&apos; variable is a built-in unit pointer that refers to the unit which was used as the medium during an operation. This variable is automatically set by the game engine when certain commands or actions are performed.

== Description ==
For example, when using the &apos;get&apos; command to take an item from a container, the container (such as a bag) becomes the medium. In spell casting or recharge operations, the item being affected becomes the medium.

== Return Value ==
Returns unitptr:
* &apos;&apos;&apos;unitptr&apos;&apos;&apos; - The unit that served as the medium for the operation
* &apos;&apos;&apos;null&apos;&apos;&apos; - When no medium was involved in the operation

== Examples ==
 dilbegin recharge_service();
 external
   string accept_dil@function (pc:unitptr,s:string);

 var
    item : unitptr;
    cost : integer;
    answer : string;

 code
 {
    // Wait for someone to give an item for recharging
    wait (SFB_DONE, (command(&quot;give&quot;)) and (self == activator));

    // Get the item being recharged (the medium)
    item := medium;
    
    if (item = null)
    {
       exec(&quot;say I need an item to recharge.&quot;, self);
       quit;
    }

    // Check if it&apos;s a rechargeable item
    if (item.type != UNIT_ST_OBJ)
    {
       exec(&quot;say I can only recharge objects.&quot;, self);
       quit;
    }

    // Recharge logic here...
    exec(&quot;say I will recharge your &quot; + item.title + &quot;.&quot;, self);
    quit;
 }
 dilend

 dilbegin container_check();
 var
    container : unitptr;
    item : unitptr;

 code
 {
    // When someone tries to get an item, check the container
    container := medium;
    
    if (container = null)
    {
       // No container involved
       quit;
    }

    if (container.type != UNIT_ST_OBJ)
    {
       act(&quot;$1n is not a container.&quot;, A_ALWAYS, container, null, null, TO_CHAR);
       quit;
    }

    act(&quot;You search through $1n.&quot;, A_ALWAYS, activator, container, null, TO_CHAR);
    quit;
 }
 dilend

 dilbegin spell_medium_check();
 var
    spell_target : unitptr;
    casting_medium : unitptr;

 code
 {
    // In spell casting, medium might be the focus item
    spell_target := target;
    casting_medium := medium;

    if (casting_medium != null)
    {
       act(&quot;You cast the spell through $1n.&quot;, A_ALWAYS, self, casting_medium, null, TO_CHAR);
       act(&quot;$1n channels magical energy through $2n.&quot;, A_ALWAYS, self, casting_medium, spell_target, TO_ROOM);
    }
    else
    {
       act(&quot;You cast the spell directly.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }

    quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;medium&apos;&apos;&apos; variable is automatically set by the game engine
* It is read-only and cannot be modified by DIL code
* This variable is context-dependent and only meaningful within specific operations
* Common contexts where medium is set include:
** &apos;get&apos; commands - the container being accessed
** &apos;put&apos; commands - the container being used
** Spell casting - the item or focus being used
** Recharge operations - the item being recharged
* The variable is typically null outside of these specific operation contexts
* Use [[Manual:DIL_Manual/activator|activator]] to identify who initiated the operation

== Error Handling ==
* The &apos;&apos;&apos;medium&apos;&apos;&apos; variable itself never fails - it always returns a unitptr (which may be null)
* Always check for null before using the medium to avoid errors
* The variable is only meaningful in the appropriate operation context

== Related Functions/Fields ==
* [[Manual:DIL_Manual/activator|activator]] - The unit that activated the DIL program
* [[Manual:DIL_Manual/target|target]] - The target of an operation
* [[Manual:DIL_Manual/self|self]] - The unit executing the DIL program

== See Also ==
* DIL message documentation for more information on operation contexts
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/meleeattack</title>
     <ns>0</ns>
     <id>947866</id>
     <revision>
       <id>1687383</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of meleeattack.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= meleeattack =
 function: integer &apos;&apos;&apos;meleeattack&apos;&apos;&apos;(ch : unitptr, vict : unitptr, bonus : integer, wtype : integer, primary : integer);

The &apos;&apos;&apos;meleeattack&apos;&apos;&apos; function performs a melee attack from one character against another. The attacker uses their currently wielded weapon or bare hands to strike the victim, with optional bonuses and weapon type specifications.

== Description ==
This function handles the complete combat resolution including weapon checks, damage calculations, and hit determination.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| ch || unitptr || The character performing the attack
| vict || unitptr || The victim being attacked
| bonus || integer || Any penalty or bonus added to the attack roll
| wtype || integer || The weapon type of the attack (WPN_* constants). If valid, bypasses equipped weapon
| primary || integer || Determines whether to use primary weapon (TRUE) or off-hand attack (FALSE)
|}

== Return Value ==
Returns integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - Amount of damage dealt to the victim
* &apos;&apos;&apos;-1&apos;&apos;&apos; - When the attack fails

== Examples ==
 dilbegin simple_attack();
 var
    victim : unitptr;
    damage : integer;

 code
 {
    // Find a random victim in the room
    foreach (UNIT_ST_PC, victim)
    {
       if (victim != self and visible(self, victim))
          break;
    }

    if (victim = null)
    {
       act(&quot;There is no one here to attack.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Perform a basic melee attack
    damage := meleeattack(self, victim, 0, 0, TRUE);
    
    if (damage &gt; 0)
       act(&quot;You hit $1n for $2d damage!&quot;, A_ALWAYS, self, victim, damage, TO_CHAR);
    else
       act(&quot;You miss $1n.&quot;, A_ALWAYS, self, victim, null, TO_CHAR);

    quit;
 }
 dilend

 dilbegin special_kick();
 var
    target : unitptr;
    damage : integer;

 code
 {
    // Find a target to kick
    target := self.fighting;
    
    if (target = null)
    {
       act(&quot;You aren&apos;t fighting anyone.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Perform a kick attack (bypasses weapon)
    damage := meleeattack(self, target, 0, WPN_CIRCLE_KICK, TRUE);
    
    if (damage &gt; 0)
    {
       act(&quot;You kick $1n for $2d damage!&quot;, A_ALWAYS, self, target, damage, TO_CHAR);
       act(&quot;$1n kicks you for $2d damage!&quot;, A_ALWAYS, self, target, damage, TO_VICT);
       act(&quot;$1n kicks $3n for $2d damage!&quot;, A_ALWAYS, self, target, damage, TO_NOTVICT);
    }
    else
    {
       act(&quot;Your kick at $1n misses.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
       act(&quot;$1n&apos;s kick at you misses.&quot;, A_ALWAYS, self, target, null, TO_VICT);
    }

    quit;
 }
 dilend

 dilbegin spider_bite();
 var
    prey : unitptr;
    damage : integer;

 code
 {
    // Spider special attack - always uses bite regardless of weapon
    prey := self.fighting;
    
    if (prey = null)
    {
       act(&quot;You aren&apos;t fighting anyone.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Perform bite attack with bonus
    damage := meleeattack(self, prey, 75, WPN_BITE, TRUE);
    
    if (damage &gt; 0)
    {
       act(&quot;You bite $1n for $2d damage!&quot;, A_ALWAYS, self, prey, damage, TO_CHAR);
       act(&quot;$1n bites you for $2d damage!&quot;, A_ALWAYS, self, prey, damage, TO_VICT);
    }
    else
    {
       act(&quot;Your bite at $1n misses.&quot;, A_ALWAYS, self, prey, null, TO_CHAR);
    }

    quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;wtype&apos;&apos;&apos; parameter allows bypassing the equipped weapon when a specific attack type is desired
* When &apos;&apos;&apos;wtype&apos;&apos;&apos; is a valid weapon type (WPN_*), that weapon type is used regardless of equipped weapon
* The &apos;&apos;&apos;primary&apos;&apos;&apos; parameter determines whether to use the wielded primary weapon (TRUE) or allow off-hand attacks (FALSE)
* The &apos;&apos;&apos;bonus&apos;&apos;&apos; parameter can be positive (bonus) or negative (penalty) to modify the attack roll
* This function automatically handles combat resolution, including hit/miss determination
* The function respects standard combat mechanics like position checks and visibility requirements
* For special attacks like kicks or bites, set appropriate &apos;&apos;&apos;wtype&apos;&apos;&apos; even if no weapon is equipped

== Error Handling ==
* Returns &apos;&apos;&apos;-1&apos;&apos;&apos; if any parameter is invalid or if the attack cannot be performed
* Returns &apos;&apos;&apos;-1&apos;&apos;&apos; if the attacker or victim is not a valid character unit
* The function will fail if the attacker is in a position that doesn&apos;t allow combat
* Always ensure both attacker and victim are valid character units before calling

== Related Functions/Fields ==
* [[Manual:DIL_Manual/cast_spell|cast_spell]] - For magical attacks instead of melee
* [[Manual:DIL_Manual/one_hit|one_hit]] - The underlying combat resolution function
* [[Manual:DIL_Manual/fighting|fighting]] - Field to check current combat target
* [[Manual:DIL_Manual/position|position]] - Field to check combat readiness
* [[Manual:DIL_Manual/weapon|weapon]] - Field to check equipped weapon type

== See Also ==
* WPN_* constants in values.h for weapon type definitions
* Combat and damage system documentation
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/meleedamage</title>
     <ns>0</ns>
     <id>325204</id>
     <revision>
       <id>1121219</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of meleedamage.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= meleedamage =
 function: integer &apos;&apos;&apos;meleedamage&apos;&apos;&apos;(ch : unitptr, vict : unitptr, b : integer, wt : integer);

The &apos;&apos;&apos;meleedamage&apos;&apos;&apos; function performs a melee damage calculation from one character against another. This function is specifically designed for missile and thrown weapon damage calculations, taking into account weapon types, bonuses, and special circumstances.

== Description ==
The function handles the complete damage resolution including hit determination and damage amount calculation.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| ch || unitptr || The character performing the attack
| vict || unitptr || The victim being attacked
| b || integer || Any penalty or bonus added to the attack
| wt || integer || The weapon type of the attack (WPN_* constants). If valid, bypasses equipped weapon
|}

== Return Value ==
Returns integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - Amount of damage dealt to the victim
* &apos;&apos;&apos;-1&apos;&apos;&apos; - When the attack fails

== Examples ==
 dilbegin simple_throw_damage();
 var
    weapon : unitptr;
    target : unitptr;
    damage : integer;

 code
 {
    // Get a weapon from inventory
    weapon := equipment(self, WEAR_WIELD);
    
    if (weapon = null)
    {
       act(&quot;You need to wield a weapon first.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Find a target to throw at
    target := self.fighting;
    
    if (target = null)
    {
       act(&quot;You aren&apos;t fighting anyone.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Calculate throwing damage
    damage := meleedamage(self, target, 0, weapon.value[0]);
    
    if (damage &gt; 0)
       act(&quot;Your throw hits $1n for $2d damage!&quot;, A_ALWAYS, self, target, damage, TO_CHAR);
    else
       act(&quot;Your throw at $1n misses.&quot;, A_ALWAYS, self, target, null, TO_CHAR);

    quit;
 }
 dilend

 dilbegin weapon_bonus_check();
 var
    attacker : unitptr;
    victim : unitptr;
    damage : integer;

 code
 {
    // Test damage with different bonuses
    attacker := self;
    victim := self.fighting;
    
    if (victim = null)
    {
       act(&quot;You need a target first.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Test with no bonus
    damage := meleedamage(attacker, victim, 0, 0);
    act(&quot;No bonus damage: $2d&quot;, A_ALWAYS, self, damage, null, TO_CHAR);
    
    // Test with positive bonus
    damage := meleedamage(attacker, victim, 10, 0);
    act(&quot;With +10 bonus: $2d&quot;, A_ALWAYS, self, damage, null, TO_CHAR);
    
    // Test with negative bonus (penalty)
    damage := meleedamage(attacker, victim, -15, 0);
    act(&quot;With -15 penalty: $2d&quot;, A_ALWAYS, self, damage, null, TO_CHAR);

    quit;
 }
 dilend

 dilbegin rock_throw();
 var
    rock : unitptr;
    target : unitptr;
    damage : integer;

 code
 {
    // Create a rock to throw
    rock := load(&quot;rock@midgaard&quot;);
    
    if (rock = null)
    {
       act(&quot;No rocks available.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Find target
    target := self.fighting;
    
    if (target = null)
    {
       act(&quot;You need a target.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    // Throw rock (using unarmed damage type)
    damage := meleedamage(self, target, 0, 0);
    
    if (damage &gt; 0)
    {
       act(&quot;You hit $1n with a rock for $2d damage!&quot;, A_ALWAYS, self, target, damage, TO_CHAR);
       act(&quot;$1n hits you with a rock for $2d damage!&quot;, A_ALWAYS, self, target, damage, TO_VICT);
    }
    else
    {
       act(&quot;Your rock throw at $1n misses.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    }

    // Clean up
    destroy(rock);
    quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;wt&apos;&apos;&apos; parameter allows bypassing the equipped weapon when a specific attack type is desired
* When &apos;&apos;&apos;wt&apos;&apos;&apos; is a valid weapon type (WPN_*), that weapon type is used regardless of equipped weapon
* The &apos;&apos;&apos;b&apos;&apos;&apos; parameter can be positive (bonus) or negative (penalty) to modify the attack roll
* This function is specifically designed for missile and thrown weapon damage calculations
* The function automatically handles combat resolution, including hit/miss determination
* Unlike [[Manual:DIL_Manual/meleeattack|meleeattack]], this function focuses on weapon damage rather than character combat
* The function respects standard combat mechanics like position checks and visibility requirements

== Error Handling ==
* Returns &apos;&apos;&apos;-1&apos;&apos;&apos; if any parameter is invalid or if the attack cannot be performed
* Returns &apos;&apos;&apos;-1&apos;&apos;&apos; if the attacker or victim is not a valid character unit
* The function will fail if the attacker is in a position that doesn&apos;t allow combat
* Always ensure both attacker and victim are valid character units before calling

== Related Functions/Fields ==
* [[Manual:DIL_Manual/meleeattack|meleeattack]] - For direct character melee attacks
* [[Manual:DIL_Manual/one_hit|one_hit]] - The underlying combat resolution function
* [[Manual:DIL_Manual/equipment|equipment]] - To check equipped weapon type
* [[Manual:DIL_Manual/weapon|weapon]] - Field to check equipped weapon
* [[Manual:DIL_Manual/cast_spell|cast_spell]] - For magical attacks instead of melee

== See Also ==
* WPN_* constants in values.h for weapon type definitions
* Combat and damage system documentation
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/mid</title>
     <ns>0</ns>
     <id>886439</id>
     <revision>
       <id>1648790</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of mid.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= mid =

== Syntax ==
 function: string &apos;&apos;&apos;mid&apos;&apos;&apos;(o : string, s : integer, e : integer);

== Description ==
The &apos;&apos;&apos;mid&apos;&apos;&apos; function extracts a substring from a string, returning the portion of the string defined by the start and end positions. This function is commonly used for parsing strings and extracting specific portions of text.

The function performs bounds checking to ensure the start and end positions are valid within the string length.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| o || string || The original string to be parsed
| s || integer || The starting position (1-based index) in the string
| e || integer || The ending position (1-based index) in the string
|}

== Return Value ==
Returns string:
* &apos;&apos;&apos;string&apos;&apos;&apos; - The substring from position &apos;s&apos; to position &apos;e&apos;
* &apos;&apos;&apos;null&apos;&apos;&apos; - When parameters are invalid or out of bounds

== Examples ==
 dilbegin parse_weapon_name();
 var
    full_name : string;
    weapon_type : string;

 code
 {
    full_name := &quot;longsword +2 of fire&quot;;
    
    // Extract weapon type (first word)
    weapon_type := mid(full_name, 1, 9);
    act(&quot;Weapon type: $2t&quot;, A_ALWAYS, self, weapon_type, null, TO_CHAR);
    
    // Extract enchantment (after &quot;+&quot;)
    weapon_type := mid(full_name, 12, 14);
    act(&quot;Enchantment: $2t&quot;, A_ALWAYS, self, weapon_type, null, TO_CHAR);
    
    // Extract material (after &quot;of &quot;)
    weapon_type := mid(full_name, 16, 18);
    act(&quot;Material: $2t&quot;, A_ALWAYS, self, weapon_type, null, TO_CHAR);
    
    quit;
 }
 dilend

 dilbegin parse_filename();
 var
    filename : string;
    name : string;
    extension : string;

 code
 {
    filename := &quot;player_data_backup_2023_12_25.txt&quot;;
    
    // Extract name (before first underscore)
    name := mid(filename, 1, 15);
    act(&quot;Filename: $2t&quot;, A_ALWAYS, self, name, null, TO_CHAR);
    
    // Extract extension (after last underscore)
    extension := mid(filename, 17, 3);
    act(&quot;Extension: $2t&quot;, A_ALWAYS, self, extension, null, TO_CHAR);
    
    quit;
 }
 dilend

 dilbegin extract_middle();
 var
    sentence : string;
    middle : string;

 code
 {
    sentence := &quot;The quick brown fox jumps over the lazy dog&quot;;
    
    // Extract middle portion (characters 11-20)
    middle := mid(sentence, 11, 20);
    act(&quot;Middle: $2t&quot;, A_ALWAYS, self, middle, null, TO_CHAR);
    
    quit;
 }
 dilend

== Usage Notes ==
* The &apos;&apos;&apos;mid&apos;&apos;&apos; function uses 1-based indexing for positions (first character is position 1)
* If the start position is less than 1 or greater than the string length, the function returns null
* If the end position is less than the start position or greater than the string length, the function returns null
* The function returns the substring from start position &apos;s&apos; up to but not including position &apos;e&apos;
* This function is commonly used for parsing file names, extracting words, and string manipulation
* The function performs memory allocation for the returned string

== Error Handling ==
* Returns &apos;&apos;&apos;null&apos;&apos;&apos; if any parameter is invalid or if positions are out of bounds
* Returns &apos;&apos;&apos;null&apos;&apos;&apos; if start or end positions are invalid (negative or beyond string length)
* The function will fail if the original string is null
* Always validate positions before calling the function to avoid errors

== Related Functions/Fields ==
* [[Manual:DIL_Manual/left|left]] - Extracts characters from the left side of a string
* [[Manual:DIL_Manual/right|right]] - Extracts characters from the right side of a string
* [[Manual:DIL_Manual/substring|substring]] - Alternative function for string extraction
* [[Manual:DIL_Manual/strlen|strlen]] - Gets the length of a string for bounds checking

== See Also ==
* String manipulation and parsing functions documentation
* DIL string operations documentation </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/minv</title>
     <ns>0</ns>
     <id>832993</id>
     <revision>
       <id>1262514</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of minv.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= minv =

== Syntax ==
field: &apos;&apos;&apos;.minv&apos;&apos;&apos;

== Description ==
The &apos;&apos;&apos;.minv&apos;&apos;&apos; field represents the &apos;wizard invisibility&apos; level of a unit. This field controls the visibility of units to players based on their wizard level. A unit with a higher minv value will only be visible to players with an equal or higher wizard level.

This is commonly used for:
* Making items invisible to regular players but visible to wizards
* Hiding administrative objects from normal gameplay
* Creating wizard-only content or tools

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Current wizard invisibility level
|-
| Write || integer || Set new wizard invisibility level
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
=== Basic Usage ===
 dilbegin check_wizinv(item : unitptr);
 var
    wizlevel : integer;
 code
 {
    wizlevel := self.level;  // Get player&apos;s wizard level
    
    if (item.minv &gt; wizlevel)
    {
       sendtext(&quot;You can&apos;t see this item - it&apos;s too wizardly for you!&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;You can see the item: &quot; + item.name + &quot;&amp;n&quot;, self);
    }
 } dilend

=== Setting Wizard Invisibility ===
 dilbegin make_wizinv(obj : unitptr, level : integer);
 code
 {
    obj.minv := level;
    sendtext(&quot;Object &quot; + obj.name + &quot; is now wizinvisible at level &quot; + itoa(level) + &quot;&amp;n&quot;, self);
 } dilend

=== Death Protection Example ===
 dilbegin protect_items_on_death();
 var
    u : unitptr;
    nextu : unitptr;
 code
 {
    // Make all equipped items wizinvisible to protect them from corpse transfer
    u := self.inside;
    while (u)
    {
       nextu := u.next;
       if (u.minv &lt; 1)
       {
          u.minv := 1;  // Make visible only to level 1+ wizards
       }
       u := nextu;
    }
 } dilend

=== Wizard Menu Example ===
 dilbegin wiz_menu();
 var
    wizlvl : integer;
 code
 {
    sendtext(&quot;Current WizInv level: &quot; + itoa(self.minv) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Enter new WizInv Level (0-&quot; + itoa(self.level) + &quot;): &quot;, self);
    wait(SFB_CMD, TRUE);
    
    wizlvl := atoi(cmdstr);
    if (wizlvl &gt; self.level)
      wizlvl := self.level;
    
    self.minv := wizlvl;
    sendtext(&quot;WizInv level set to &quot; + itoa(wizlvl) + &quot;&amp;n&quot;, self);
 } dilend

== Usage Notes ==
* The minv value ranges from 0 (visible to everyone) to the maximum wizard level
* Players can only see units with minv  their current wizard level
* Regular players (level 0) can only see units with minv = 0
* This field is read-write and can be modified at runtime
* Commonly used in death routines to protect items from being transferred to corpses

== Error Handling ==
* Setting minv to a negative value may cause undefined behavior
* Setting minv higher than the maximum wizard level will make the item invisible to all players
* The field will return 0 for units that don&apos;t have wizard invisibility set

== Related Functions/Fields ==
* [[Manual:DIL_Manual/level|level]] - Player&apos;s wizard level
* [[Manual:DIL_Manual/findunit|findunit]] - Finding units (respects wizard invisibility)
* [[Manual:DIL_Manual/findsymbolic|findsymbolic]] - Finding units by symbolic name (respects wizard invisibility)

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer documentation
* [[Manual:DIL_Manual/wizard|wizard]] - Wizard-related commands and functions
* [[Manual:DIL_Manual/invisibility|invisibility]] - Regular invisibility mechanics </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/moneystring</title>
     <ns>0</ns>
     <id>1197912</id>
     <revision>
       <id>1563882</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of moneystring.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= moneystring =

== Syntax ==
 string &apos;&apos;&apos;moneystring&apos;&apos;&apos;(amt : integer, verbose : integer);

== Description ==
Converts a monetary amount into a formatted string representation. The function can display the amount in either verbose format (full coin names like &quot;gold pieces&quot;) or abbreviated format (coin type abbreviations like &quot;gp&quot;).

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| amt || integer || The amount of money to convert (in base currency units)
|-
| verbose || integer || Flag for output format: 0 = abbreviated format (e.g., &quot;gp&quot;), non-zero = verbose format (e.g., &quot;gold pieces&quot;)
|}

== Return Value ==
Returns &apos;&apos;&apos;string&apos;&apos;&apos;:
* A formatted string containing the monetary representation
* The string is formatted according to the verbose parameter
* Uses the default currency system (DEF_CURRENCY)

== Examples ==
 dilbegin charge_example();
 var
    cost : integer;
    price_str : string;
 code
 {
    cost := 250;  // 2 gold, 5 silver
    
    // Abbreviated format
    price_str := moneystring(cost, 0);
    exec(&quot;say The price is &quot; + price_str, self);
    
    // Verbose format  
    price_str := moneystring(cost, 1);
    exec(&quot;say That equals &quot; + price_str, self);
 } dilend

== Usage Notes ==
* The function uses the default currency system defined by DEF_CURRENCY
* When verbose = 0, returns abbreviated coin types (e.g., &quot;gp&quot;, &quot;sp&quot;, &quot;cp&quot;)
* When verbose  0, returns full coin names (e.g., &quot;gold pieces&quot;, &quot;silver pieces&quot;)
* The amount parameter is interpreted in the smallest currency unit (copper pieces equivalent)

== Error Handling ==
* If parameters are not integers, a DIL runtime error will occur
* The function will fail if the amount parameter is not a valid integer

== Related Functions/Fields ==
* [[Manual:DIL_Manual/transfermoney|transfermoney]] - Transfers money between units
* [[Manual:DIL_Manual/purse|purse]] - Checks specific coin types in a unit&apos;s inventory

== See Also ==
* Currency constants: IRON_PIECE, COPPER_PIECE, SILVER_PIECE, GOLD_PIECE, PLATINUM_PIECE </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/movement</title>
     <ns>0</ns>
     <id>725901</id>
     <revision>
       <id>1431226</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of movement.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= movement =

== Syntax ==
 field: &apos;&apos;&apos;.movement&apos;&apos;&apos; (Read/Write)

== Description ==
The &apos;&apos;&apos;movement&apos;&apos;&apos; field specifies the terrain type or sector of a room, which determines movement costs, swimming requirements, and other environmental effects. This field is used to control how characters and NPCs move through different types of terrain.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current terrain type as a SECT_* constant
|-
| Write || integer || Sets the terrain type using SECT_* constants
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Usage Notes ==
The movement field uses SECT_* constants defined in values.h and/or vme.h. Common terrain types include:
* &apos;&apos;&apos;SECT_WATER_SAIL&apos;&apos;&apos; - Water terrain requiring swimming or boats
* &apos;&apos;&apos;SECT_INSIDE&apos;&apos;&apos; - Indoor areas
* &apos;&apos;&apos;SECT_CITY&apos;&apos;&apos; - City streets
* &apos;&apos;&apos;SECT_FIELD&apos;&apos;&apos; - Open fields
* &apos;&apos;&apos;SECT_FOREST&apos;&apos;&apos; - Forested areas
* &apos;&apos;&apos;SECT_MOUNTAIN&apos;&apos;&apos; - Mountainous terrain
* &apos;&apos;&apos;SECT_DESERT&apos;&apos;&apos; - Desert areas

The terrain type affects:
* Movement endurance costs via the [[Manual:DIL_Manual/movementloss|movementloss]] function
* Swimming requirements and drowning checks
* Special movement behaviors for different races

== Examples ==
 dilbegin terrain_check();
 var
    current_room : unitptr;
    terrain_type : integer;
 code
 {
    current_room := unit_room@function(self);
    terrain_type := current_room.movement;
    
    if (terrain_type == SECT_WATER_SAIL)
    {
       exec(&quot;say This area requires swimming or a boat!&quot;, self);
    }
    else if (terrain_type == SECT_INSIDE)
    {
       exec(&quot;say We are indoors.&quot;, self);
    }
    
    // Change terrain to forest
    current_room.movement := SECT_FOREST;
 } dilend

== Error Handling ==
* Accessing .movement on non-room units will result in a DIL runtime error
* Setting invalid terrain values may cause undefined behavior
* The field requires a valid room unit pointer

== Related Functions/Fields ==
* [[Manual:DIL_Manual/movementloss|movementloss]] - Calculates movement cost for terrain types
* [[Manual:DIL_Manual/unit_room@function|unit_room@function]] - Gets the room a unit is in
* [[Manual:DIL_Manual/roomflags|roomflags]] - Additional room properties

== See Also ==
* Room exit fields: &apos;&apos;&apos;exit_to[]&apos;&apos;&apos;, &apos;&apos;&apos;exit_info[]&apos;&apos;&apos;, &apos;&apos;&apos;exit_names[]&apos;&apos;&apos;
* Environmental constants: SECT_*, EX_*, ROOM_FL_* </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/mudday</title>
     <ns>0</ns>
     <id>1085947</id>
     <revision>
       <id>1460599</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of mudday.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= mudday =

== Syntax ==
 variable: &apos;&apos;&apos;mudday&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;mudday&apos;&apos;&apos; variable returns the current day number in the MUD&apos;s internal time system. This built-in variable allows DIL programs to track and respond to the passage of time within the game world, enabling time-based events, scheduling, and conditional logic.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current day number (0-based)
|}

== Examples ==
 dilbegin daily_reset();
 var
    current_day : integer;
    last_reset : integer;
 code
 {
    :init:
    last_reset := mudday;
    
    :check_reset:
    current_day := mudday;
    
    // Check if a new day has started
    if (current_day != last_reset)
    {
       exec(&quot;say A new day begins!&quot;, self);
       last_reset := current_day;
    }
    
    pause;
    goto check_reset;
 } dilend

 dilbegin time_based_event();
 var
    day_hour : integer;
 code
 {
    // Calculate total hours since epoch
    day_hour := mudhour + mudday * MUD_DAY;
    
    // Check if it&apos;s morning (hours 6-11)
    if ((mudhour &gt;= 6) and (mudhour &lt; 12))
    {
       exec(&quot;say Good morning! The sun is rising.&quot;, self);
    }
    // Check if it&apos;s evening (hours 18-21)
    else if ((mudhour &gt;= 18) and (mudhour &lt; 22))
    {
       exec(&quot;say Good evening! The day is ending.&quot;, self);
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;mudday&apos;&apos;&apos; variable is read-only and cannot be modified
* Day numbers typically start from 0 and increment each MUD day
* Used in conjunction with &apos;&apos;&apos;mudhour&apos;&apos;&apos; for complete time tracking
* The &apos;&apos;&apos;MUD_DAY&apos;&apos;&apos; constant represents the number of hours in one MUD day
* Time calculations often use the formula: `total_hours = mudhour + mudday * MUD_DAY`

== Error Handling ==
* The variable is always available and does not generate runtime errors
* Returns valid integer values in all contexts

== Related Functions/Fields ==
* [[Manual:DIL_Manual/mudhour|mudhour]] - Current hour in the MUD (0-23)
* [[Manual:DIL_Manual/mudmonth|mudmonth]] - Current month in the MUD
* [[Manual:DIL_Manual/mudyear|mudyear]] - Current year in the MUD
* [[Manual:DIL_Manual/realtime|realtime]] - Real-world system time
* [[Manual:DIL_Manual/asctime|asctime]] - Convert real time to formatted string

== See Also ==
* Time constants: &apos;&apos;&apos;MUD_DAY&apos;&apos;&apos;, &apos;&apos;&apos;MUD_HOUR&apos;&apos;&apos;, &apos;&apos;&apos;MUD_MONTH&apos;&apos;&apos;
* Time-based functions: [[Manual:DIL_Manual/heartbeat|heartbeat]], [[Manual:DIL_Manual/wait|wait]], [[Manual:DIL_Manual/pause|pause]] </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/mudhour</title>
     <ns>0</ns>
     <id>768155</id>
     <revision>
       <id>1899672</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of mudhour.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= mudhour =

== Syntax ==
 variable: &apos;&apos;&apos;mudhour&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;mudhour&apos;&apos;&apos; variable returns the current hour number in the MUD&apos;s internal time system. This built-in variable allows DIL programs to track and respond to the time of day within the game world, enabling hour-based events, scheduling, and conditional logic.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current hour number (0-23)
|}

== Examples ==
 dilbegin time_greeting();
 var
    current_hour : integer;
 code
 {
    current_hour := mudhour;
    
    // Time-based greetings
    if ((current_hour &gt;= 5) and (current_hour &lt; 12))
    {
       exec(&quot;say Good morning!&quot;, self);
    }
    else if ((current_hour &gt;= 12) and (current_hour &lt; 18))
    {
       exec(&quot;say Good afternoon!&quot;, self);
    }
    else if ((current_hour &gt;= 18) and (current_hour &lt; 22))
    {
       exec(&quot;say Good evening!&quot;, self);
    }
    else
    {
       exec(&quot;say Good night!&quot;, self);
    }
 } dilend

 dilbegin shop_schedule();
 var
    hour : integer;
 code
 {
    :check_time:
    hour := mudhour;
    
    // Shop open from 8 AM to 8 PM
    if ((hour &gt;= 8) and (hour &lt; 20))
    {
       if (self.position == POSITION_SLEEPING)
       {
          exec(&quot;wake&quot;, self);
          exec(&quot;say The shop is now open!&quot;, self);
       }
    }
    else
    {
       if (self.position != POSITION_SLEEPING)
       {
          exec(&quot;say The shop is now closed!&quot;, self);
          exec(&quot;sleep&quot;, self);
       }
    }
    
    pause;
    goto check_time;
 } dilend

 dilbegin guard_duty();
 var
    schedule : intlist;
 code
 {
    // Guard schedule: wake at 6, patrol until 18, sleep at 22
    schedule := {6, 18, 22};
    
    :main_loop:
    pause;
    
    if (mudhour == schedule.[0])  // Wake up
    {
       exec(&quot;wake&quot;, self);
       exec(&quot;say Time for my shift!&quot;, self);
    }
    else if (mudhour == schedule.[1])  // End patrol
    {
       exec(&quot;say My patrol is done.&quot;, self);
    }
    else if (mudhour == schedule.[2])  // Sleep
    {
       exec(&quot;say Time to rest.&quot;, self);
       exec(&quot;sleep&quot;, self);
    }
    
    goto main_loop;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;mudhour&apos;&apos;&apos; variable is read-only and cannot be modified
* Hours range from 0 (midnight) to 23 (11 PM)
* Used in conjunction with &apos;&apos;&apos;mudday&apos;&apos;&apos; for complete time tracking
* Common time ranges:
** 0-5: Night/early morning
** 6-11: Morning
** 12-17: Afternoon
** 18-23: Evening/night
* Time calculations often use the formula: `total_hours = mudhour + mudday * MUD_DAY`

== Error Handling ==
* The variable is always available and does not generate runtime errors
* Returns valid integer values (0-23) in all contexts

== Related Functions/Fields ==
* [[Manual:DIL_Manual/mudday|mudday]] - Current day in the MUD
* [[Manual:DIL_Manual/mudmonth|mudmonth]] - Current month in the MUD
* [[Manual:DIL_Manual/mudyear|mudyear]] - Current year in the MUD
* [[Manual:DIL_Manual/realtime|realtime]] - Real-world system time
* [[Manual:DIL_Manual/asctime|asctime]] - Convert real time to formatted string

== See Also ==
* Time constants: &apos;&apos;&apos;MUD_DAY&apos;&apos;&apos;, &apos;&apos;&apos;MUD_HOUR&apos;&apos;&apos;, &apos;&apos;&apos;MUD_MONTH&apos;&apos;&apos;
* Time-based functions: [[Manual:DIL_Manual/heartbeat|heartbeat]], [[Manual:DIL_Manual/wait|wait]], [[Manual:DIL_Manual/pause|pause]]
* Scheduling functions: [[Manual:DIL_Manual/DailyRoutine@quests|DailyRoutine@quests]] </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/mudmonth</title>
     <ns>0</ns>
     <id>963585</id>
     <revision>
       <id>1098769</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of mudmonth.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= mudmonth =

== Syntax ==
 variable: &apos;&apos;&apos;mudmonth&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;mudmonth&apos;&apos;&apos; variable returns the current month number in the MUD&apos;s internal time system. This built-in variable allows DIL programs to track and respond to seasonal changes, monthly events, and time-based conditional logic within the game world.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current month number (0-based)
|}

== Examples ==
 dilbegin seasonal_event();
 var
    current_month : integer;
    month_name : string;
    month_names : stringlist;
 code
 {
    month_names := {&quot;Month of Winter&quot;, &quot;Month of the Winter Wolf&quot;,
                   &quot;Month of the Frost Giant&quot;, &quot;Month of the Spring&quot;,
                   &quot;Month of Futility&quot;, &quot;Month of the Sun&quot;, 
                   &quot;Month of the Heat&quot;, &quot;Month of the Long Shadows&quot;,
                   &quot;Month of the Ancient Darkness&quot;};
    
    current_month := mudmonth;
    month_name := month_names.[current_month];
    
    exec(&quot;say Welcome to &quot; + month_name + &quot;!&quot;, self);
    
    // Seasonal behavior
    if (current_month &lt;= 2)  // Winter months (0-2)
    {
       exec(&quot;say It&apos;s cold outside, bundle up!&quot;, self);
    }
    else if (current_month &lt;= 5)  // Spring months (3-5)
    {
       exec(&quot;say The flowers are blooming!&quot;, self);
    }
    else if (current_month &lt;= 7)  // Summer months (6-7)
    {
       exec(&quot;say It&apos;s a beautiful summer day!&quot;, self);
    }
    else  // Fall months (8-8)
    {
       exec(&quot;say The leaves are changing colors!&quot;, self);
    }
 } dilend

 dilbegin time_display();
 var
    buffer : string;
    month_names : stringlist;
    day_names : stringlist;
    month_idx : integer;
    day_idx : integer;
    hour_12 : integer;
    ampm : string;
 code
 {
    month_names := {&quot;Month of Winter&quot;, &quot;Month of the Winter Wolf&quot;,
                   &quot;Month of the Frost Giant&quot;, &quot;Month of the Spring&quot;,
                   &quot;Month of Futility&quot;, &quot;Month of the Sun&quot;, 
                   &quot;Month of the Heat&quot;, &quot;Month of the Long Shadows&quot;,
                   &quot;Month of the Ancient Darkness&quot;};
    
    day_names := {&quot;the Day of the Bull&quot;, &quot;the Day of the Deception&quot;,
                  &quot;the Day of Thunder&quot;, &quot;the Day of Freedom&quot;,
                  &quot;the Day of the Great Gods&quot;, &quot;the Day of the Sun&quot;,
                  &quot;the Day of the Moon&quot;};
    
    month_idx := mudmonth;
    day_idx := mudday % 7;
    hour_12 := mudhour;
    
    if (hour_12 == 0)
    {
       hour_12 := 12;
       ampm := &quot;O-clock, Midnight!&quot;;
    }
    else if (hour_12 == 12)
    {
       ampm := &quot;O-clock, High noon!&quot;;
    }
    else if (hour_12 &lt; 12)
    {
       ampm := &quot;AM&quot;;
    }
    else
    {
       hour_12 := hour_12 - 12;
       ampm := &quot;PM&quot;;
    }
    
    buffer := &quot;It is &quot; + itoa(hour_12) + &quot; &quot; + ampm + &quot;, on &quot; + day_names.[day_idx] + &quot;,&lt;br/&gt;&quot;;
    buffer := buffer + &quot;the &quot; + itoa(mudday + 1) + &quot;th Day of the &quot; + month_names.[month_idx] +
              &quot;, Year &quot; + itoa(mudyear) + &quot;.&lt;br/&gt;&quot;;
    
    sendtext(buffer, self);
 } dilend

 dilbegin monthly_festival();
 var
    current_month : integer;
 code
 {
    :check_month:
    current_month := mudmonth;
    
    // Different festival each month
    if (current_month == 0)  // Month of Winter
    {
       exec(&quot;say The Winter Festival begins!&quot;, self);
       exec(&quot;emote lights torches and prepares hot cider.&quot;, self);
    }
    else if (current_month == 3)  // Month of the Spring
    {
       exec(&quot;say The Spring Celebration starts!&quot;, self);
       exec(&quot;emote decorates with flowers and ribbons.&quot;, self);
    }
    else if (current_month == 6)  // Month of the Heat
    {
       exec(&quot;say The Summer Solstice Festival!&quot;, self);
       exec(&quot;emote prepares for the longest day of the year.&quot;, self);
    }
    else if (current_month == 8)  // Month of the Ancient Darkness
    {
       exec(&quot;say The Harvest Festival begins!&quot;, self);
       exec(&quot;emote gathers crops for the coming winter.&quot;, self);
    }
    
    // Wait until next month
    while (mudmonth == current_month)
    {
       pause;
    }
    goto check_month;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;mudmonth&apos;&apos;&apos; variable is read-only and cannot be modified
* Month numbers are 0-based (0 = first month, 8 = last month in the example)
* The MUD typically has 9 months (0-8) as shown in the example
* Used in conjunction with &apos;&apos;&apos;mudday&apos;&apos;&apos;, &apos;&apos;&apos;mudhour&apos;&apos;&apos;, and &apos;&apos;&apos;mudyear&apos;&apos;&apos; for complete time tracking
* Common month themes from the example:
** 0-2: Winter months
** 3-5: Spring months  
** 6-7: Summer months
** 8: Fall month

== Error Handling ==
* The variable is always available and does not generate runtime errors
* Returns valid integer values (0-8) in all contexts

== Related Functions/Fields ==
* [[Manual:DIL_Manual/mudday|mudday]] - Current day in the MUD
* [[Manual:DIL_Manual/mudhour|mudhour]] - Current hour in the MUD
* [[Manual:DIL_Manual/mudyear|mudyear]] - Current year in the MUD
* [[Manual:DIL_Manual/realtime|realtime]] - Real-world system time
* [[Manual:DIL_Manual/asctime|asctime]] - Convert real time to formatted string

== See Also ==
* Time constants: &apos;&apos;&apos;MUD_DAY&apos;&apos;&apos;, &apos;&apos;&apos;MUD_HOUR&apos;&apos;&apos;, &apos;&apos;&apos;MUD_MONTH&apos;&apos;&apos;
* Time-based functions: [[Manual:DIL_Manual/heartbeat|heartbeat]], [[Manual:DIL_Manual/wait|wait]], [[Manual:DIL_Manual/pause|pause]]
* String functions: [[Manual:DIL_Manual/itoa|itoa]] - Convert integer to string for display </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/mudyear</title>
     <ns>0</ns>
     <id>750772</id>
     <revision>
       <id>977626</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of mudyear.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= mudyear =

== Syntax ==
 variable: &apos;&apos;&apos;mudyear&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;mudyear&apos;&apos;&apos; variable returns the current year number in the MUD&apos;s internal time system. This built-in variable allows DIL programs to track and respond to long-term time progression, enabling year-based events, age calculations, and historical tracking within the game world.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current year number
|}

== Examples ==
 dilbegin new_year_celebration();
 var
    current_year : integer;
    last_year : integer;
 code
 {
    :init:
    last_year := mudyear;
    
    :check_year:
    current_year := mudyear;
    
    // Check if a new year has started
    if (current_year != last_year)
    {
       exec(&quot;say Happy New Year! Welcome to year &quot; + itoa(current_year) + &quot;!&quot;, self);
       exec(&quot;emote celebrates the arrival of the new year with fireworks!&quot;, self);
       last_year := current_year;
    }
    
    pause;
    goto check_year;
 } dilend

 dilbegin age_calculator(pc : unitptr);
 var
    age_in_years : integer;
    birth_year : integer;
 code
 {
    // Calculate character&apos;s age in mud years
    age_in_years := (realtime - pc.birth) / SECS_PER_MUD_YEAR;
    birth_year := mudyear - age_in_years;
    
    exec(&quot;say You were born in year &quot; + itoa(birth_year) + &quot;!&quot;, self);
    exec(&quot;say You are &quot; + itoa(age_in_years) + &quot; years old.&quot;, self);
    
    // Age-based messages
    if (age_in_years &lt; 18)
    {
       exec(&quot;say You are still quite young!&quot;, self);
    }
    else if (age_in_years &lt; 50)
    {
       exec(&quot;say You are in the prime of your life!&quot;, self);
    }
    else if (age_in_years &lt; 100)
    {
       exec(&quot;say You are getting on in years!&quot;, self);
    }
    else
    {
       exec(&quot;say You are truly ancient!&quot;, self);
    }
 } dilend

 dilbegin historical_event();
 var
    current_year : integer;
    event_year : integer;
    years_since : integer;
 code
 {
    current_year := mudyear;
    event_year := 850;  // Year of some historical event
    years_since := current_year - event_year;
    
    if (years_since == 0)
    {
       exec(&quot;say The Great Battle is happening this very year!&quot;, self);
    }
    else if (years_since == 1)
    {
       exec(&quot;say It has been one year since the Great Battle.&quot;, self);
    }
    else
    {
       exec(&quot;say It has been &quot; + itoa(years_since) + &quot; years since the Great Battle.&quot;, self);
    }
    
    // Century-based events
    if ((current_year % 100) == 0)
    {
       exec(&quot;say This is a century year! A time of great celebration!&quot;, self);
    }
 } dilend

 dilbegin complete_time_display();
 var
    buffer : string;
    month_names : stringlist;
    day_names : stringlist;
    month_idx : integer;
    day_idx : integer;
    hour_12 : integer;
    ampm : string;
    day_num : integer;
    suffix : string;
 code
 {
    month_names := {&quot;Month of Winter&quot;, &quot;Month of the Winter Wolf&quot;,
                   &quot;Month of the Frost Giant&quot;, &quot;Month of the Spring&quot;,
                   &quot;Month of Futility&quot;, &quot;Month of the Sun&quot;, 
                   &quot;Month of the Heat&quot;, &quot;Month of the Long Shadows&quot;,
                   &quot;Month of the Ancient Darkness&quot;};
    
    day_names := {&quot;the Day of the Bull&quot;, &quot;the Day of the Deception&quot;,
                  &quot;the Day of Thunder&quot;, &quot;the Day of Freedom&quot;,
                  &quot;the Day of the Great Gods&quot;, &quot;the Day of the Sun&quot;,
                  &quot;the Day of the Moon&quot;};
    
    month_idx := mudmonth;
    day_idx := mudday % 7;
    hour_12 := mudhour;
    day_num := mudday + 1;
    
    // Format hour with AM/PM
    if (hour_12 == 0)
    {
       hour_12 := 12;
       ampm := &quot;O-clock, Midnight!&quot;;
    }
    else if (hour_12 == 12)
    {
       ampm := &quot;O-clock, High noon!&quot;;
    }
    else if (hour_12 &lt; 12)
    {
       ampm := &quot;AM&quot;;
    }
    else
    {
       hour_12 := hour_12 - 12;
       ampm := &quot;PM&quot;;
    }
    
    // Day suffix
    if (day_num == 1)
       suffix := &quot;st&quot;;
    else if (day_num == 2)
       suffix := &quot;nd&quot;;
    else if (day_num == 3)
       suffix := &quot;rd&quot;;
    else
       suffix := &quot;th&quot;;
    
    buffer := &quot;It is &quot; + itoa(hour_12) + &quot; &quot; + ampm + &quot;, on &quot; + day_names.[day_idx] + &quot;,&lt;br/&gt;&quot;;
    buffer := buffer + &quot;the &quot; + itoa(day_num) + suffix + &quot; Day of the &quot; + month_names.[month_idx] +
              &quot;, Year &quot; + itoa(mudyear) + &quot;.&lt;br/&gt;&quot;;
    
    sendtext(buffer, self);
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;mudyear&apos;&apos;&apos; variable is read-only and cannot be modified
* Used in conjunction with &apos;&apos;&apos;mudday&apos;&apos;&apos;, &apos;&apos;&apos;mudhour&apos;&apos;&apos;, and &apos;&apos;&apos;mudmonth&apos;&apos;&apos; for complete time tracking
* Common uses include:
** Age calculations using &apos;&apos;&apos;SECS_PER_MUD_YEAR&apos;&apos;&apos; constant
** Historical event tracking
** Century-based celebrations
** Long-term quest progression
** Character generation (setting birth years)

== Error Handling ==
* The variable is always available and does not generate runtime errors
* Returns valid integer values in all contexts

== Related Functions/Fields ==
* [[Manual:DIL_Manual/mudday|mudday]] - Current day in the MUD
* [[Manual:DIL_Manual/mudhour|mudhour]] - Current hour in the MUD
* [[Manual:DIL_Manual/mudmonth|mudmonth]] - Current month in the MUD
* [[Manual:DIL_Manual/realtime|realtime]] - Real-world system time
* [[Manual:DIL_Manual/asctime|asctime]] - Convert real time to formatted string

== See Also ==
* Time constants: &apos;&apos;&apos;SECS_PER_MUD_YEAR&apos;&apos;&apos;, &apos;&apos;&apos;MUD_DAY&apos;&apos;&apos;, &apos;&apos;&apos;MUD_HOUR&apos;&apos;&apos;, &apos;&apos;&apos;MUD_MONTH&apos;&apos;&apos;
* Time-based functions: [[Manual:DIL_Manual/heartbeat|heartbeat]], [[Manual:DIL_Manual/wait|wait]], [[Manual:DIL_Manual/pause|pause]]
* Character fields: &apos;&apos;&apos;birth&apos;&apos;&apos; - Character&apos;s birth timestamp
* String functions: [[Manual:DIL_Manual/itoa|itoa]] - Convert integer to string for display </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/name</title>
     <ns>0</ns>
     <id>950183</id>
     <revision>
       <id>1449073</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of name.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= name =

== Syntax ==
 field: &apos;&apos;&apos;.name&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;name&apos;&apos;&apos; field returns the primary name or identifier of various unit types. This field provides access to the name/identifier of units, extra descriptions, commands, and zones, allowing DIL programs to identify and reference different entities by their names.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || string || Returns the primary name/identifier of the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)
* cmdptr (Command pointer)
* extraptr (Extra description pointer)
* zoneptr (Zone pointer)

== Examples ==
 dilbegin cuff_target(deputy : unitptr, targ : unitptr, cuffs : unitptr);
 var
    depname : string;
 code
 {
    act(&quot;You cuff $3n.&quot;, A_SOMEONE, deputy, null, targ, TO_CHAR);
    act(&quot;$1n surprises you and put $2n around your wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_VICT);
    act(&quot;$1n puts $2n around $3N&apos;s wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_NOTVICT);

    follow(targ, deputy);
    depname := deputy.name;
    link(cuffs, targ);
    unequip(equipment(targ, WEAR_WRIST_R));
    addequip(cuffs, WEAR_WRIST_R);
    dilcopy(&quot;cuffed@midgaard(&quot;+depname+&quot;)&quot;, targ);
    dilcopy(&quot;cuffed2@midgaard(&quot;+depname+&quot;)&quot;, targ);

    exec(&quot;sigh&quot;, targ);
    return;
 } dilend

 dilbegin identify_item(item : unitptr);
 var
    item_name : string;
 code
 {
    if (item.type != UNIT_ST_OBJ)
    {
       exec(&quot;say That&apos;s not an object!&quot;, self);
       return;
    }
    
    item_name := item.name;
    exec(&quot;say This is called: &quot; + item_name, self);
    
    // Check if it has special names
    if (length(item.names) &gt; 1)
    {
       exec(&quot;say It&apos;s also known as: &quot; + item.names.[1], self);
    }
 } dilend

 dilbegin command_info(cmd : cmdptr);
 var
    cmd_name : string;
 code
 {
    cmd_name := cmd.name;
    exec(&quot;say This command is: &quot; + cmd_name, self);
 } dilend

 dilbegin zone_details(zone : zoneptr);
 var
    zone_name : string;
 code
 {
    zone_name := zone.name;
    exec(&quot;say Current zone: &quot; + zone_name, self);
 } dilend

 dilbegin extra_description_check(extra : extraptr);
 var
    extra_name : string;
 code
 {
    extra_name := extra.name;
    exec(&quot;say This extra is called: &quot; + extra_name, self);
    
    // Check for additional names
    if (length(extra.names) &gt; 1)
    {
       exec(&quot;say Also known as: &quot; + extra.names.[1], self);
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;name&apos;&apos;&apos; field is read-only and cannot be modified
* Returns different types of names depending on the unit type:
** For units (PC/NPC/Obj/Room): Returns the primary name from the names list
** For extra descriptions: Returns the primary name from the extra&apos;s names list
** For commands: Returns the command string
** For zones: Returns the zone name
* For units with multiple names, use the &apos;&apos;&apos;names&apos;&apos;&apos; field to access all names
* The primary name is typically the first name in the names list

== Error Handling ==
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if the unit pointer is null or invalid
* Returns &apos;&apos;&apos;error&apos;&apos;&apos; if accessed on an unsupported type
* Always check if the unit is valid before accessing the name field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/names|names]] - Stringlist of all names for a unit
* [[Manual:DIL_Manual/title|title]] - Title field for characters
* [[Manual:DIL_Manual/symname|symname]] - Symbolic name of a unit
* [[Manual:DIL_Manual/nameidx|nameidx]] - Name index of a unit
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - Zone index of a unit

== See Also ==
* Unit type constants: &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos;
* String functions: [[Manual:DIL_Manual/length|length]], [[Manual:DIL_Manual/addstring|addstring]], [[Manual:DIL_Manual/substring|substring]]
* Identification functions: [[Manual:DIL_Manual/isplayer|isplayer]], [[Manual:DIL_Manual/findunit|findunit]], [[Manual:DIL_Manual/findsymbolic|findsymbolic]] </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/nameidx</title>
     <ns>0</ns>
     <id>1075105</id>
     <revision>
       <id>1832725</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of nameidx.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= nameidx =

== Syntax ==
 field: &apos;&apos;&apos;.nameidx&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;nameidx&apos;&apos;&apos; field returns the unique database name identifier of a unit within its zone. This field provides the name portion of a unit&apos;s full &quot;name@zone&quot; identifier, allowing DIL programs to reference specific units by their unique database names.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || string || Returns the unique database name of the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
 dilbegin identify_corpse(corpse : unitptr);
 var
    corpse_id : string;
 code
 {
    if (corpse.type != UNIT_ST_OBJ)
    {
       exec(&quot;say That&apos;s not an object!&quot;, self);
       return;
    }
    
    corpse_id := corpse.nameidx;
    exec(&quot;say This corpse has ID: &quot; + corpse_id, self);
    
    // Check if it&apos;s a specific type of corpse
    if (corpse_id == &quot;corpsebasis&quot;)
    {
       exec(&quot;say This is a basic corpse.&quot;, self);
    }
    else if (corpse_id == &quot;slime@basis&quot;)
    {
       exec(&quot;say This is a slime-based corpse.&quot;, self);
    }
 } dilend

 dilbegin check_special_items(item : unitptr);
 var
    item_id : string;
 code
 {
    item_id := item.nameidx;
    
    // Check for specific quest items by their nameidx
    if (item_id == &quot;tot_bag2&quot;)
    {
       exec(&quot;say This is a treasure bag type 2!&quot;, self);
    }
    else if (item_id == &quot;tot_bag3&quot;)
    {
       exec(&quot;say This is a treasure bag type 3!&quot;, self);
    }
    else
    {
       exec(&quot;say This item has ID: &quot; + item_id, self);
    }
 } dilend

 dilbegin zone_reference(unit : unitptr);
 var
    zone_name : string;
    unit_ref : string;
 code
 {
    zone_name := unit.zoneidx;
    unit_ref := unit.nameidx + &quot;@&quot; + zone_name;
    
    exec(&quot;say Unit reference: &quot; + unit_ref, self);
    exec(&quot;say Zone: &quot; + zone_name, self);
    exec(&quot;say Name: &quot; + unit.nameidx, self);
 } dilend

 dilbegin load_specific_unit();
 var
    target_unit : unitptr;
    unit_id : string;
 code
 {
    // Example of loading a unit by its nameidx@zoneidx
    unit_id := &quot;cuffs@midgaard&quot;;
    target_unit := load(unit_id);
    
    if (target_unit != null)
    {
       exec(&quot;say Loaded unit: &quot; + target_unit.name, self);
       exec(&quot;say Its ID is: &quot; + target_unit.nameidx, self);
       exec(&quot;say In zone: &quot; + target_unit.zoneidx, self);
    }
    else
    {
       exec(&quot;say Could not find unit: &quot; + unit_id, self);
    }
 } dilend

 dilbegin debug_unit_info(unit : unitptr);
 var
    debug_info : string;
 code
 {
    debug_info := &quot;Unit Info:&lt;br/&gt;&quot;;
    debug_info := &quot;Name: &quot; + unit.name + &quot;&lt;br/&gt;&quot;;
    debug_info := &quot;NameIdx: &quot; + unit.nameidx + &quot;&lt;br/&gt;&quot;;
    debug_info := &quot;Zone: &quot; + unit.zoneidx + &quot;&lt;br/&gt;&quot;;
    debug_info := &quot;Full Ref: &quot; + unit.nameidx + &quot;@&quot; + unit.zoneidx + &quot;&lt;br/&gt;&quot;;
    
    sendtext(debug_info, self);
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;nameidx&apos;&apos;&apos; field is read-only and cannot be modified
* Returns the unique database name portion of a unit&apos;s identifier
* The full unit identifier is composed of: nameidx@zoneidx
* Used for database operations and unit referencing
* Common for identifying specific instances of units within zones
* Essential for [[Manual:DIL_Manual/load|load]] function and database operations
* Different from [[Manual:DIL_Manual/name|name]] field which returns the display name
* The nameidx is typically the filename or database identifier without zone prefix

== Error Handling ==
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if unit pointer is null or invalid
* Returns &apos;&apos;&apos;error&apos;&apos;&apos; if accessed on an unsupported unit type
* Always validate unit before accessing nameidx field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/name|name]] - Primary display name of the unit
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - Zone identifier portion of unit reference
* [[Manual:DIL_Manual/symname|symname]] - Symbolic name of the unit
* [[Manual:DIL_Manual/load|load]] - Load unit by nameidx@zoneidx reference
* [[Manual:DIL_Manual/findunit|findunit]] - Find unit by name search
* [[Manual:DIL_Manual/findsymbolic|findsymbolic]] - Find unit by symbolic name

== See Also ==
* Unit type constants: &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos;
* String functions: [[Manual:DIL_Manual/substring|substring]], [[Manual:DIL_Manual/length|length]]
* Database functions: [[Manual:DIL_Manual/store|store]], [[Manual:DIL_Manual/restore|restore]], [[Manual:DIL_Manual/delunit|delunit]]
* Reference format: nameidx@zoneidx (standard unit identification) </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/names</title>
     <ns>0</ns>
     <id>442786</id>
     <revision>
       <id>911881</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of names.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= names =

 field: stringlist &apos;&apos;&apos;.names&apos;&apos;&apos; (Read/Write)

== Description ==
The &apos;&apos;&apos;names&apos;&apos;&apos; field provides access to the complete list of names and keywords that identify a unit.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || stringlist || Returns list of all names for the unit
|-
| Write || stringlist || Can modify the names list (add/remove names)
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)
* extraptr (Extra description pointer)

== Examples ==
 dilbegin check_item_names(item : unitptr);
 var
    item_names : stringlist;
 code
 {
    item_names := item.names;
    exec(&quot;say This item has &quot; + itoa(length(item_names)) + &quot; names.&quot;, self);
    exec(&quot;say Primary name: &quot; + item_names.[0], self);
 } dilend

 dilbegin find_by_keyword(target : unitptr);
 var
    all_names : stringlist;
 code
 {
    all_names := target.names;
    if (&quot;sword&quot; in all_names)
    {
       exec(&quot;say This is a sword-type weapon.&quot;, self);
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;names&apos;&apos;&apos; field provides read/write access to the complete name list
* The first name in the list (index 0) is typically the primary name used by [[Manual:DIL_Manual/name|name]] field
* Names can be accessed by index using array notation: `unit.names.[index]`
* Common uses include:
** Multiple aliases for NPCs and objects
** Keyword matching for extra descriptions
** Exit names for rooms
** Weapon type identification
* Use [[Manual:DIL_Manual/addstring|addstring]] and [[Manual:DIL_Manual/remove|remove]] functions to modify the names list
* Use [[Manual:DIL_Manual/length|length]] function to get the number of names
* Use the &apos;&apos;&apos;in&apos;&apos;&apos; operator to check if a specific name exists in the list

== Error Handling ==
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if unit pointer is null or invalid
* Returns &apos;&apos;&apos;error&apos;&apos;&apos; if accessed on an unsupported unit type
* Index out of bounds when accessing names.[index] will cause runtime errors
* Always validate the unit type before accessing the names field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/name|name]] - Primary name field (first name in names list)
* [[Manual:DIL_Manual/addstring|addstring]] - Add a name to the names list
* [[Manual:DIL_Manual/remove|remove]] - Remove a name from the names list
* [[Manual:DIL_Manual/insert|insert]] - Insert a name at specific position
* [[Manual:DIL_Manual/length|length]] - Get number of names in the list
* [[Manual:DIL_Manual/substring|substring]] - Extract part of a name string
* [[Manual:DIL_Manual/in|in]] - Check if name exists in the names list

== See Also ==
* Unit type constants: &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos;
* String functions: [[Manual:DIL_Manual/split|split]], [[Manual:DIL_Manual/getwords|getwords]], [[Manual:DIL_Manual/substring|substring]]
* Array access: Use bracket notation for stringlist elements
* Extra description functions: [[Manual:DIL_Manual/addextra|addextra]], [[Manual:DIL_Manual/subextra|subextra]] </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/natural_armour</title>
     <ns>0</ns>
     <id>849470</id>
     <revision>
       <id>905383</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of natural_armour.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= natural_armour =

 field: integer &apos;&apos;&apos;.natural_armour&apos;&apos;&apos; (Read/Write)

== Description ==
The &apos;&apos;&apos;natural_armour&apos;&apos;&apos; field specifies the base armor class of an NPC when not wearing equipment.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current natural armor value
|-
| Write || integer || Sets the natural armor value
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
 dilbegin set_npc_armor(npc : unitptr, armor_value : integer);
 code
 {
    npc.natural_armour := armor_value;
    exec(&quot;say NPC armor set to: &quot; + itoa(armor_value), self);
 } dilend

 dilbegin check_npc_protection(npc : unitptr);
 var
    current_armor : integer;
 code
 {
    current_armor := npc.natural_armour;
    if (current_armor &gt; 50)
    {
       exec(&quot;say This NPC has heavy natural armor.&quot;, self);
    }
    else
    {
       exec(&quot;say This NPC has light natural armor.&quot;, self);
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;natural_armour&apos;&apos;&apos; field is read/write accessible on NPCs
* Represents the base armor class when the NPC is not equipped with any armor
* Works in conjunction with worn armor items to provide total protection
* Typical values might range from 0 (no natural armor) to 100+ (very high natural armor)
* Used during NPC creation and modification to set innate defensive capabilities
* Only applies to NPC characters, not PCs or objects

== Error Handling ==
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if unit pointer is null or not an NPC
* Returns &apos;&apos;&apos;error&apos;&apos;&apos; if accessed on an unsupported unit type
* Setting invalid values may cause undefined behavior in combat calculations
* Always validate unit type before accessing natural_armour field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/armor|armor]] - Worn armor equipment
* [[Manual:DIL_Manual/defensive|defensive]] - Defensive combat values
* [[Manual:DIL_Manual/offensive|offensive]] - Offensive combat values
* [[Manual:DIL_Manual/npcflags|npcflags]] - NPC-specific flags and settings
* [[Manual:DIL_Manual/defaultpos|defaultpos]] - Default position of NPCs

== See Also ==
* Unit type constants: &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos;
* Combat-related fields: &apos;&apos;&apos;attack_type&apos;&apos;&apos;, &apos;&apos;&apos;natural_armour&apos;&apos;&apos;
* NPC creation functions: [[Manual:DIL_Manual/reset_race|reset_race]], [[Manual:DIL_Manual/reset_level|reset_level]]
* Equipment functions: [[Manual:DIL_Manual/addequip|addequip]], [[Manual:DIL_Manual/unequip|unequip]] </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/next</title>
     <ns>0</ns>
     <id>355798</id>
     <revision>
       <id>1472514</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of next.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= next =

 field: unitptr &apos;&apos;&apos;.next&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;next&apos;&apos;&apos; field returns a pointer to the next unit in a linked list for traversal.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || unitptr/extraptr/cmdptr/zoneptr || Returns pointer to next unit in sequence
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)
* extraptr (Extra description pointer)
* cmdptr (Command pointer)
* zoneptr (Zone pointer)

== Examples ==
 dilbegin count_inventory_items(pc : unitptr);
 var
    current_item : unitptr;
    item_count : integer;
 code
 {
    current_item := pc.inside;
    item_count := 0;
    
    while (current_item != null)
    {
       item_count := item_count + 1;
       current_item := current_item.next;
    }
    
    exec(&quot;say Found &quot; + itoa(item_count) + &quot; items.&quot;, self);
 } dilend

 dilbegin walk_extra_descriptions(extra : extraptr);
 var
    current_extra : extraptr;
    count : integer;
 code
 {
    current_extra := extra;
    count := 0;
    
    while (current_extra != null)
    {
       count := count + 1;
       exec(&quot;say Extra &quot; + itoa(count) + &quot;: &quot; + current_extra.names.[0], self);
       current_extra := current_extra.next;
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;next&apos;&apos;&apos; field is read-only and cannot be modified
* Returns a pointer to the next unit in the respective list/structure
* Returns &apos;&apos;&apos;null&apos;&apos;&apos; when reaching the end of a list
* Used for traversing:
** Inventory items (unit.inside, unit.outside chains)
** Extra description chains
** Command lists
** Zone lists
** Room exits
* Essential for [[Manual:DIL_Manual/foreach|foreach]] loops and list traversal
* Common pattern: check for null before accessing next

== Error Handling ==
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if unit pointer is null or invalid
* Returns &apos;&apos;&apos;error&apos;&apos;&apos; if accessed on an unsupported unit type
* Always check for null before dereferencing next pointer
* Infinite loops can occur if not properly checking for null termination

== Related Functions/Fields ==
* [[Manual:DIL_Manual/foreach|foreach]] - Iterate through units in local environment
* [[Manual:DIL_Manual/findunit|findunit]] - Find specific unit by name
* [[Manual:DIL_Manual/ghead|ghead]] - Get first unit in global list
* [[Manual:DIL_Manual/inside|inside]] - Access contained units
* [[Manual:DIL_Manual/outside|outside]] - Access containing unit
* [[Manual:DIL_Manual/exit_names|exit_names]] - Room exit names list

== See Also ==
* Unit type constants: &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos;, &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos;
* Pointer types: unitptr, extraptr, cmdptr, zoneptr
* List traversal: [[Manual:DIL_Manual/names|names]], [[Manual:DIL_Manual/length|length]] for checking bounds
* Navigation functions: [[Manual:DIL_Manual/findroom|findroom]], [[Manual:DIL_Manual/walkto|walkto]] </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/nopriority</title>
     <ns>0</ns>
     <id>1136434</id>
     <revision>
       <id>1224623</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of nopriority.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= nopriority =

 function: integer &apos;&apos;&apos;nopriority&apos;&apos;&apos;();

== Description ==
The &apos;&apos;&apos;nopriority&apos;&apos;&apos; function cancels active priority procedures for the current DIL program.

== Return Value ==
Returns &apos;&apos;&apos;integer&apos;&apos;&apos;:
* &apos;&apos;&apos;0&apos;&apos;&apos; - Successfully canceled priority procedures
* &apos;&apos;&apos;non-zero&apos;&apos;&apos; - Error code if cancellation failed

== Examples ==
 dilbegin reset_priority();
 var
    result : integer;
 code
 {
    priority(SFB_MSG, argument == &quot;admin_reset&quot;);
    result := nopriority();
    
    if (result == 0)
    {
       exec(&quot;say Priority reset successfully.&quot;, self);
    }
 } dilend

 dilbegin emergency_override();
 code
 {
    priority(SFB_MSG, argument == &quot;emergency&quot;);
    exec(&quot;say Emergency mode active!&quot;, self);
    pause;
    nopriority();
    exec(&quot;say Emergency mode deactivated.&quot;, self);
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;nopriority&apos;&apos;&apos; function cancels all priority procedures set by [[Manual:DIL_Manual/priority|priority]] function
* Used to reset interrupt handling to default state
* Common in systems that need to temporarily override priority behavior:
** Emergency stop routines
** Administrative override functions
** System reset procedures
* Priority levels determine which DIL program gets control during activation
* Higher priority numbers take precedence over lower ones

== Error Handling ==
* Returns &apos;&apos;&apos;0&apos;&apos;&apos; on successful cancellation
* Returns &apos;&apos;&apos;non-zero&apos;&apos;&apos; error code if cancellation fails
* The function itself does not validate parameters - errors come from the underlying priority system

== Related Functions/Fields ==
* [[Manual:DIL_Manual/priority|priority]] - Set priority for activation interrupts
* [[Manual:DIL_Manual/interrupt|interrupt]] - Set up interrupt handling for specific message classes
* [[Manual:DIL_Manual/clear|clear]] - Clear specific interrupt handlers
* [[Manual:DIL_Manual/on_activation|on_activation]] - Handle activation-time interrupts

== See Also ==
* Interrupt flags: &apos;&apos;&apos;SFB_PRIORITY&apos;&apos;&apos;, &apos;&apos;&apos;SFB_MSG&apos;&apos;&apos;, &apos;&apos;&apos;SFB_DEAD&apos;&apos;&apos;
* Priority levels and activation order in DIL interrupt system
* DIL program activation and interrupt handling mechanisms </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/notes</title>
     <ns>0</ns>
     <id>855947</id>
     <revision>
       <id>1783991</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of notes.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= notes =

 field: string &apos;&apos;&apos;.notes&apos;&apos;&apos; (Read/Write)

== Description ==
The &apos;&apos;&apos;notes&apos;&apos;&apos; field stores zone-specific documentation as a string.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || string || Returns the current notes text for the zone
|-
| Write || string || Sets the notes text for the zone
|}

== Availability ==
This field is available on the following unit types:
* zoneptr (Zone pointer)

== Examples ==
 dilbegin display_zone_notes(zone : zoneptr);
 code
 {
    exec(&quot;say Zone notes: &quot; + zone.notes, self);
 } dilend

 dilbegin set_admin_notes();
 var
    admin_zone : zoneptr;
 code
 {
    admin_zone := findroom(&quot;admin@midgaard&quot;);
    if (admin_zone != null)
    {
       admin_zone.notes := &quot;Administrative zone - restricted access&quot;;
       exec(&quot;say Notes updated.&quot;, self);
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;notes&apos;&apos;&apos; field provides read/write access to zone notes
* Used for storing zone documentation, policies, or descriptive text
* Notes can contain multiple lines separated by newline characters
* Common uses include:
** Zone descriptions and instructions
** Administrative information
** Development status tracking
** Zone-specific rules or policies
* Notes are stored as plain text strings
* Use [[Manual:DIL_Manual/split|split]] function to process multi-line notes

== Error Handling ==
* Returns &apos;&apos;&apos;fail&apos;&apos;&apos; if zone pointer is null or invalid
* Returns &apos;&apos;&apos;error&apos;&apos;&apos; if accessed on an unsupported unit type
* Setting very long notes may cause memory issues
* Always validate zone pointer before accessing the notes field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/name|name]] - Zone name field
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - Zone identifier field
* [[Manual:DIL_Manual/findroom|findroom]] - Locate specific zones
* [[Manual:DIL_Manual/split|split]] - Process multi-line strings
* [[Manual:DIL_Manual/pagestring|pagestring]] - Display text to players
* String functions: [[Manual:DIL_Manual/length|length]], [[Manual:DIL_Manual/substring|substring]]

== See Also ==
* Zone management functions and commands
* Zone pointer fields: &apos;&apos;&apos;name&apos;&apos;&apos;, &apos;&apos;&apos;zoneidx&apos;&apos;&apos;, &apos;&apos;&apos;resetmode&apos;&apos;&apos;, &apos;&apos;&apos;resettime&apos;&apos;&apos;
* Zone constants and reset modes from values.h
* Administrative zone building tools </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/npc_head</title>
     <ns>0</ns>
     <id>713601</id>
     <revision>
       <id>1150695</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of npc_head.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= npc_head =

 function: unitptr &apos;&apos;&apos;npc_head&apos;&apos;&apos;();

== Description ==
The &apos;&apos;&apos;npc_head&apos;&apos;&apos; function returns a pointer to the first NPC in the global NPC list.

== Return Value ==
Returns &apos;&apos;&apos;unitptr&apos;&apos;&apos;:
* &apos;&apos;&apos;unitptr&apos;&apos;&apos; - Pointer to the first NPC in the global list
* &apos;&apos;&apos;null&apos;&apos;&apos; - If no NPCs exist in the global list

== Examples ==
 dilbegin check_first_npc();
 var
    first_npc : unitptr;
 code
 {
    first_npc := npc_head();
    if (first_npc != null)
    {
       exec(&quot;say First NPC: &quot; + first_npc.name, self);
    }
    else
    {
       exec(&quot;say No NPCs found.&quot;, self);
    }
 } dilend

 dilbegin count_global_npcs();
 var
    current_npc : unitptr;
    count : integer;
 code
 {
    current_npc := npc_head();
    count := 0;
    
    while (current_npc != null)
    {
       count := count + 1;
       current_npc := current_npc.next;
    }
    
    exec(&quot;say Total NPCs: &quot; + itoa(count), self);
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;npc_head&apos;&apos;&apos; function returns the first NPC in the global NPC list
* Used for global NPC management and operations
* The returned NPC can be used with standard NPC functions and fields
* Returns &apos;&apos;&apos;null&apos;&apos;&apos; if no NPCs exist in the global list
* This function provides access to the head of the NPC chain for traversal
* Common use cases include:
** Global quest NPC management
** NPC patrol systems
** Global NPC initialization and cleanup
** Access to the primary NPC for administrative functions

== Error Handling ==
* Returns &apos;&apos;&apos;null&apos;&apos;&apos; if no NPCs exist in the global list
* Always validate the returned pointer before use
* The function itself does not validate parameters

== Related Functions/Fields ==
* [[Manual:DIL_Manual/ghead|ghead]] - Get first unit in global list (same as npc_head for NPCs)
* [[Manual:DIL_Manual/next|next]] - Navigate to next unit in a list (used for NPC chain traversal)
* Global NPC management functions
* Unit type constants: &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos;
* NPC-specific fields: [[Manual:DIL_Manual/npcflags|npcflags]], [[Manual:DIL_Manual/natural_armour|natural_armour]], [[Manual:DIL_Manual/defaultpos|defaultpos]]

== See Also ==
* Global list management functions
* NPC creation and management functions
* Unit pointer operations and traversal
* Chain navigation patterns using [[Manual:DIL_Manual/next|next]] field </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/npccount</title>
     <ns>0</ns>
     <id>381324</id>
     <revision>
       <id>915257</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of npccount.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= npccount =

== Syntax ==
 function: integer &apos;&apos;&apos;npccount&apos;&apos;&apos;(zone : zoneptr);

== Description ==
The &apos;&apos;&apos;npccount&apos;&apos;&apos; function returns the number of NPCs in a specific zone.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| zone || zoneptr || Zone pointer to get NPC count for
|}

== Return Value ==
Returns &apos;&apos;&apos;integer&apos;&apos;&apos;:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - Number of NPCs/mobiles in the specified zone
* &apos;&apos;&apos;0&apos;&apos;&apos; - If zone pointer is null or invalid
* &apos;&apos;&apos;-1&apos;&apos;&apos; - If zone is not found or access error occurs

== Examples ==
 dilbegin check_zone_population(zone : zoneptr);
 var
    npc_count : integer;
 code
 {
    npc_count := npccount(zone);
    exec(&quot;say Zone has &quot; + itoa(npc_count) + &quot; NPCs.&quot;, self);
 } dilend

 dilbegin zone_capacity_check();
 var
    target_zone : zoneptr;
    current_npcs : integer;
 code
 {
    target_zone := findroom(&quot;city@midgaard&quot;);
    if (target_zone != null)
    {
       current_npcs := npccount(target_zone);
       if (current_npcs &gt; 50)
       {
          exec(&quot;say Zone is overpopulated.&quot;, self);
       }
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;npccount&apos;&apos;&apos; function requires a valid zone pointer parameter
* Used for zone management and administrative purposes
* Common applications include:
** Zone population monitoring
** NPC load balancing
** Zone capacity management
** Statistical analysis and reporting
* The function only counts NPCs, not objects or rooms
* Returns -1 if the zone pointer is null or invalid

== Error Handling ==
* Returns &apos;&apos;&apos;-1&apos;&apos;&apos; if zone pointer is null or invalid
* Returns &apos;&apos;&apos;error&apos;&apos;&apos; if zone parameter is not a zoneptr
* Always validate the zone pointer before calling the function

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zhead|zhead]] - Get first zone in global list
* [[Manual:DIL_Manual/findroom|findroom]] - Find specific zone by name
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type and fields
* Zone management functions: [[Manual:DIL_Manual/reset|reset]], [[Manual:DIL_Manual/store|store]]
* Zone fields: [[Manual:DIL_Manual/name|name]], [[Manual:DIL_Manual/zoneidx|zoneidx]], [[Manual:DIL_Manual/npcs|npcs]]

== See Also ==
* Zone type constants and management
* Administrative zone building tools
* NPC creation and management functions
* Zone statistics and monitoring functions </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/npcflags</title>
     <ns>0</ns>
     <id>1142794</id>
     <revision>
       <id>1120753</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of npcflags.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= npcflags =

== Syntax ==
 function: &apos;&apos;&apos;npcflags&apos;&apos;&apos;(npc : unitptr, flags : integer);

== Description ==
The &apos;&apos;&apos;npcflags&apos;&apos;&apos; function modifies behavioral flags for non-player characters.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| npc || unitptr || The NPC character to modify
|-
| flags || integer || The flag value to set (bitwise OR of existing flags)

== Return Value ==
Returns &apos;&apos;&apos;integer&apos;&apos;&apos;:
* &apos;&apos;&apos;0&apos;&apos;&apos; - Successfully set the NPC flags
* &apos;&apos;&apos;non-zero&apos;&apos;&apos; - Error code if modification failed

== Examples ==
 dilbegin set_aggressive(npc : unitptr);
 var
    current_flags : integer;
 code
 {
    current_flags := npc.npcflags;
    npcflags(npc, current_flags | NPC_AGGRESSIVE);
    exec(&quot;say NPC is now aggressive.&quot;, self);
 } dilend

 dilbegin toggle_guard_mode(npc : unitptr);
 var
    flags : integer;
 code
 {
    flags := npc.npcflags;
    if (flags &amp; NPC_GUARD)
    {
       npcflags(npc, flags &amp; ~NPC_GUARD);
       exec(&quot;say Guard mode disabled.&quot;, self);
    }
    else
    {
       npcflags(npc, flags | NPC_GUARD);
       exec(&quot;say Guard mode enabled.&quot;, self);
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;npcflags&apos;&apos;&apos; function modifies the NPC &apos;&apos;&apos;npcflags&apos;&apos;&apos; field using bitwise operations
* Common flag constants include:
** &apos;&apos;&apos;NPC_AGGRESSIVE&apos;&apos;&apos; - NPC will attack enemies on sight
** &apos;&apos;&apos;NPC_GUARD&apos;&apos;&apos; - NPC will guard and protect area
** &apos;&apos;&apos;NPC_SENTINEL&apos;&apos;&apos; - NPC will stay in designated area
** &apos;&apos;&apos;NPC_STAY_ZONE&apos;&apos;&apos; - NPC will not leave its zone
* Flags are combined using bitwise OR (|) operator
* Use [[Manual:DIL_Manual/isaff|isaff]] function to check if specific flags are set
* The function provides direct field modification equivalent to: `npc.npcflags := npc.npcflags | flags`

== Error Handling ==
* Returns &apos;&apos;&apos;0&apos;&apos;&apos; on successful flag modification
* Returns &apos;&apos;&apos;non-zero&apos;&apos;&apos; error code if:
** NPC pointer is null or invalid
** Flags parameter is invalid
* NPC is not of type UNIT_ST_NPC

== Related Functions/Fields ==
* [[Manual:DIL_Manual/npcflags|npcflags]] - NPC flags field (this function)
* [[Manual:DIL_Manual/isaff|isaff]] - Check if specific NPC flags are set
* [[Manual:DIL_Manual/unit_st_npc.hlp|unit_st_npc.hlp]] - NPC-specific fields and constants
* Bitwise operations: Use | (OR) operator to combine flags

== See Also ==
* NPC behavior constants: &apos;&apos;&apos;NPC_AGGRESSIVE&apos;&apos;&apos;, &apos;&apos;&apos;NPC_GUARD&apos;&apos;&apos;, &apos;&apos;&apos;NPC_SENTINEL&apos;&apos;&apos;, &apos;&apos;&apos;NPC_STAY_ZONE&apos;&apos;&apos;
* Bit manipulation: [[Manual:DIL_Manual/and|and]], [[Manual:DIL_Manual/or|or]], [[Manual:DIL_Manual/not|not]] operators
* Unit type constants: &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/npcs</title>
     <ns>0</ns>
     <id>467264</id>
     <revision>
       <id>1084470</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of npcs.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= npcs =

== Syntax ==
 function: unitptr &apos;&apos;&apos;npcs&apos;&apos;&apos;(zone : zoneptr);

== Description ==
The &apos;&apos;&apos;npcs&apos;&apos;&apos; function returns a pointer to the first NPC in the specified zone.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| zone || zoneptr || Zone pointer to search for NPCs
|}

== Return Value ==
Returns &apos;&apos;&apos;unitptr&apos;&apos;&apos;:
* &apos;&apos;&apos;unitptr&apos;&apos;&apos; - Pointer to the first NPC found in the specified zone
* &apos;&apos;&apos;null&apos;&apos;&apos; - If no NPCs exist in the zone or zone pointer is invalid

== Examples ==
 dilbegin find_zone_npcs(zone : zoneptr);
 var
    first_npc : unitptr;
 code
 {
    first_npc := npcs(zone);
    if (first_npc != null)
    {
       exec(&quot;say First NPC: &quot; + first_npc.name, self);
    }
    else
    {
       exec(&quot;say No NPCs in zone.&quot;, self);
    }
 } dilend

 dilbegin list_zone_npcs(zone : zoneptr);
 var
    current_npc : unitptr;
    count : integer;
 code
 {
    current_npc := npcs(zone);
    count := 0;
    
    while (current_npc != null)
    {
       count := count + 1;
       exec(&quot;say NPC &quot; + itoa(count) + &quot;: &quot; + current_npc.name, self);
       current_npc := current_npc.next;
    }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;npcs&apos;&apos;&apos; function requires a valid zone pointer parameter
* Used for administrative NPC management and zone population monitoring
* Returns the first NPC found in the zone&apos;s NPC list
* The returned NPC can be used with standard NPC functions and fields
* Common use cases include:
** Zone administration and NPC management
** Patrol system coordination
** Population monitoring and statistics

== Error Handling ==
* Returns &apos;&apos;&apos;null&apos;&apos;&apos; if:
** Zone pointer is null or invalid
** No NPCs exist in the specified zone
* Zone pointer does not point to a valid zone

== Related Functions/Fields ==
* [[Manual:DIL_Manual/npccount|npccount]] - Count NPCs in a zone
* [[Manual:DIL_Manual/findroom|findroom]] - Find a specific zone by name
* [[Manual:DIL_Manual/npcflags|npcflags]] - Modify NPC behavior flags
* [[Manual:DIL_Manual/npc_head|npc_head]] - Get first NPC in global list
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type and fields
* Zone management functions: [[Manual:DIL_Manual/store|store]], [[Manual:DIL_Manual/restore|restore]]

== See Also ==
* Zone pointer fields: &apos;&apos;&apos;name&apos;&apos;&apos;, &apos;&apos;&apos;zoneidx&apos;&apos;&apos;, &apos;&apos;&apos;npcs&apos;&apos;&apos;, &apos;&apos;&apos;rooms&apos;&apos;&apos;, &apos;&apos;&apos;objs&apos;&apos;&apos;
* NPC type constants: &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos;
* Administrative zone building and management </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/null</title>
     <ns>0</ns>
     <id>1020017</id>
     <revision>
       <id>1494593</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of null.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= null =

== Syntax ==
Constant: &apos;&apos;&apos;null&apos;&apos;&apos;

== Description ==
The &apos;&apos;&apos;null&apos;&apos;&apos; keyword represents a null pointer value in DIL, indicating a pointer does not point to any valid object.

== Usage Notes ==
* &apos;&apos;&apos;null&apos;&apos;&apos; can be used with any pointer type (unitptr, extraptr, cmdptr, etc.)
* Many functions return &apos;&apos;&apos;null&apos;&apos;&apos; to indicate failure or that no object was found
* &apos;&apos;&apos;null&apos;&apos;&apos; is commonly used as a parameter in functions like &apos;&apos;&apos;act()&apos;&apos;&apos; where a medium argument is optional
* When comparing pointers, use `== null` or `!= null` to check for null values

== Examples ==
 dilbegin check_for_item();
 var
    my_unit : unitptr;
 code
 {
    my_unit := findunit(self, &quot;sword&quot;, FIND_UNIT_INVEN, null);
    if (my_unit == null)
    {
       act(&quot;You don&apos;t have a sword.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
 } dilend

 dilbegin use_null_parameter();
 code
 {
    act(&quot;You look around.&quot;, A_SOMEONE, self, null, null, TO_CHAR);
 } dilend

== Error Handling ==
When working with functions that return pointers, always check for &apos;&apos;&apos;null&apos;&apos;&apos; before using the returned value to avoid runtime errors:

 if (returned_pointer != null)
 {
    // Safe to use the pointer
 }
 else
 {
    // Handle the null case
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findunit|findunit]] - Returns null if unit not found
* [[Manual:DIL_Manual/findroom|findroom]] - Returns null if room not found
* [[Manual:DIL_Manual/restore|restore]] - Returns null if restore fails
* [[Manual:DIL_Manual/load|load]] - Returns null if load fails
* [[Manual:DIL_Manual/act|act]] - Often uses null as optional medium parameter

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]]
* [[Manual:DIL_Manual/extraptr|extraptr]]
* [[Manual:DIL_Manual/cmdptr|cmdptr]]
* [[Manual:DIL_Manual/if|if]] - Can test for null values in conditions </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/obj_head</title>
     <ns>0</ns>
     <id>805944</id>
     <revision>
       <id>1645863</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of obj_head.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= obj_head =
 function: unitptr &apos;&apos;&apos;obj_head&apos;&apos;&apos;();

The &apos;&apos;&apos;obj_head&apos;&apos;&apos;() function returns a pointer to the first object in the global object list.

== Description ==
The &apos;&apos;&apos;obj_head&apos;&apos;&apos;() function provides access to the head of the linked list containing all objects currently loaded in the game. Based on the C implementation, the function checks if the global object head pointer (`g_obj_head`) points to a valid object using the `isObj()` method. If valid, it returns the pointer; otherwise, it returns null.

== Return Value ==
Returns unitptr:
* &apos;&apos;&apos;unitptr&apos;&apos;&apos; - Pointer to the first object in the global object list
* &apos;&apos;&apos;null&apos;&apos;&apos; - If no objects are loaded or the head pointer is invalid

== Usage Notes ==
* This function is currently marked as obsolete and not used in any DIL programs
* The returned pointer can be used to traverse the global object list
* Always check for null before using the returned pointer
* This function provides access to all objects in the game, regardless of location

== Examples ==
 dilbegin list_objects();
 var
    current_obj : unitptr;
    count : integer;
 
 code
 {
    count := 0;
    current_obj := obj_head();
    
    while (current_obj != null)
    {
       count := count + 1;
       act(&quot;Object: $1n&quot;, A_ALWAYS, self, current_obj, null, TO_CHAR);
       current_obj := current_obj.next;
    }
    
    act(&quot;Total objects: $2d&quot;, A_ALWAYS, self, count, null, TO_CHAR);
 } dilend

== Error Handling ==
Always check the return value for null before using it:

 first_obj := obj_head();
 if (first_obj != null)
 {
    name := first_obj.name;
 }
 else
 {
    act(&quot;No objects found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/npc_head|npc_head]] - Returns first NPC in global list
* [[Manual:DIL_Manual/room_head|room_head]] - Returns first room in global list
* [[Manual:DIL_Manual/ghead|ghead]] - Returns first unit in global list
* [[Manual:DIL_Manual/zone_head|zone_head]] - Returns first zone in global list
* [[Manual:DIL_Manual/command_head|command_head]] - Returns first command in global list

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]]
* [[Manual:DIL_Manual/next|next]] - Navigate to next unit in list
* [[Manual:DIL_Manual/isObj|isObj]] - Check if unit is an object </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/objcount</title>
     <ns>0</ns>
     <id>756028</id>
     <revision>
       <id>1740164</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of objcount.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= objcount =
 field: integer &apos;&apos;&apos;.objcount&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;objcount&apos;&apos;&apos; field returns the number of objects defined in a specific zone.

== Description ==
The &apos;&apos;&apos;objcount&apos;&apos;&apos; field provides access to the count of objects that belong to the specified zone. Based on the C implementation, this field operates on a zone pointer and calls the `getNumOfObjects()` method to retrieve the object count for that zone.

== Field Access ==
This is a field access on zoneptrs:
 zone.objcount

== Availability ==
This field is available on the following unit types:
* zoneptr

== Examples ==
 dilbegin zone_object_info();
 var
    current_zone : zoneptr;
    obj_num : integer;
 
 code
 {
    current_zone := zhead();
    
    while (current_zone != null)
    {
       obj_num := current_zone.objcount;
       act(&quot;Zone $1t has $2d objects&quot;, A_ALWAYS, self, obj_num, current_zone, TO_CHAR);
       current_zone := current_zone.next;
    }
 } dilend

== Usage Notes ==
* This field is currently marked as obsolete and not used in any DIL programs
* The count includes all objects defined in the zone&apos;s file, regardless of whether they are currently loaded
* Use with [[Manual:DIL_Manual/findzone|findzone]] to get a zone pointer by name
* Combine with [[Manual:DIL_Manual/roomcount|roomcount]] and [[Manual:DIL_Manual/npccount|npccount]] for complete zone statistics

== Error Handling ==
Always check the zone pointer for null before accessing objcount:

 if (zone_ptr != null)
 {
    count := zone_ptr.objcount;
 }
 else
 {
    act(&quot;Invalid zone pointer.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/roomcount|roomcount]] - Number of rooms in a zone
* [[Manual:DIL_Manual/npccount|npccount]] - Number of NPCs in a zone
* [[Manual:DIL_Manual/findzone|findzone]] - Find a zone by name
* [[Manual:DIL_Manual/zhead|zhead]] - Get first zone in global list
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]]
* [[Manual:DIL_Manual/objs|objs]] - Pointer to base objects of zone
* [[Manual:DIL_Manual/resetmode|resetmode]] - Zone reset mode
* [[Manual:DIL_Manual/loadlevel|loadlevel]] - Zone load level </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/objectflags</title>
     <ns>0</ns>
     <id>1033457</id>
     <revision>
       <id>1512010</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of objectflags.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= objectflags =
 field: integer &apos;&apos;&apos;.objectflags&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;objectflags&apos;&apos;&apos; field provides access to the special property flags for objects.

== Description ==
The &apos;&apos;&apos;objectflags&apos;&apos;&apos; field specifies various characteristics and behaviors that objects can have in the game. Based on the C implementation, this field returns a reference to the object&apos;s flags, allowing both reading and writing of the flag values. The flags are stored as bit positions that can be tested and modified using bitwise operations.

== Field Access ==
This is a field access on object unitptrs:
 obj.objectflags

== Availability ==
This field is available on the following unit types:
* UNIT_ST_OBJ (Object)

== Usage Notes ==
Use the [[Manual:DIL_Manual/isset|isset]] function to test for specific flag values.
Use bitwise operations to set or clear flags.

== Examples ==
 dilbegin check_weapon_properties(weapon : unitptr);
 var
    flags : integer;
 
 code
 {
    if (weapon.type != UNIT_ST_OBJ)
    {
       act(&quot;$1n is not an object.&quot;, A_ALWAYS, self, weapon, null, TO_CHAR);
       return;
    }
    
    flags := weapon.objectflags;
    
    if (isset(flags, OBJ_NO_DUAL))
       act(&quot;$1n is too large for dual-wielding.&quot;, A_ALWAYS, self, weapon, null, TO_CHAR);
    else
       act(&quot;$1n can be used for dual-wielding.&quot;, A_ALWAYS, self, weapon, null, TO_CHAR);
 } dilend

== Error Handling ==
Always verify the unit is an object before accessing objectflags:

 if (unit.type == UNIT_ST_OBJ)
 {
    flags := unit.objectflags;
 }
 else
 {
    act(&quot;Not an object.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isset|isset]] - Test if specific flag bits are set
* [[Manual:DIL_Manual/objecttype|objecttype]] - Type of the object
* [[Manual:DIL_Manual/value|value]] - Object values array
* [[Manual:DIL_Manual/manipulate|manipulate]] - Object manipulation flags
* [[Manual:DIL_Manual/equip|equip]] - Equipment position of object

== See Also ==
* [[Manual:DIL_Manual/unit_st_obj|unit_st_obj]] - Other object fields
* [[Manual:DIL_Manual/manipulate|manipulate]] - Object manipulation flags
* [[Manual:DIL_Manual/isset|isset]] - Bit testing function
* [[Manual:DIL_Manual/value|value]] - Object-specific values </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/objecttype</title>
     <ns>0</ns>
     <id>458823</id>
     <revision>
       <id>1378509</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of objecttype.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= objecttype =
 field: integer &apos;&apos;&apos;.objecttype&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;objecttype&apos;&apos;&apos; field provides access to the type classification of objects.

== Description ==
The &apos;&apos;&apos;objecttype&apos;&apos;&apos; field determines what category an object belongs to and influences how the object behaves and what properties it has. Based on the C implementation, this field returns a reference to the object&apos;s type value, allowing both reading and writing of the object type. The type is stored as an integer constant that corresponds to predefined ITEM_* values.

== Field Access ==
This is a field access on object unitptrs:
 obj.objecttype

== Availability ==
This field is available on the following unit types:
* UNIT_ST_OBJ (Object)

== Usage Notes ==
Object types are defined as ITEM_* constants in values.h and/or vme.h.
Different object types have different behaviors and use the [[Manual:DIL_Manual/value|value]] array differently.

== Examples ==
 dilbegin identify_object(obj : unitptr);
 var
    obj_type : integer;
 
 code
 {
    if (obj.type != UNIT_ST_OBJ)
    {
       act(&quot;$1n is not an object.&quot;, A_ALWAYS, self, obj, null, TO_CHAR);
       return;
    }
    
    obj_type := obj.objecttype;
    
    if (obj_type == ITEM_WEAPON)
       act(&quot;$1n is a weapon.&quot;, A_ALWAYS, self, obj, null, TO_CHAR);
    else if (obj_type == ITEM_CONTAINER)
       act(&quot;$1n is a container.&quot;, A_ALWAYS, self, obj, null, TO_CHAR);
    else if (obj_type == ITEM_FOOD)
       act(&quot;$1n is food.&quot;, A_ALWAYS, self, obj, null, TO_CHAR);
    else
       act(&quot;$1n is of type: $2d&quot;, A_ALWAYS, self, obj_type, obj, TO_CHAR);
 } dilend

== Error Handling ==
Always verify the unit is an object before accessing objecttype:

 if (unit.type == UNIT_ST_OBJ)
 {
    obj_type := unit.objecttype;
 }
 else
 {
    act(&quot;Not an object.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/value|value]] - Object-specific values array
* [[Manual:DIL_Manual/objectflags|objectflags]] - Object property flags
* [[Manual:DIL_Manual/manipulate|manipulate]] - Object manipulation flags
* [[Manual:DIL_Manual/type|type]] - Unit type field
* [[Manual:DIL_Manual/equip|equip]] - Equipment position

== See Also ==
* [[Manual:DIL_Manual/unit_st_obj|unit_st_obj]] - Other object fields
* [[Manual:DIL_Manual/value|value]] - Object-specific values
* [[Manual:DIL_Manual/objectflags|objectflags]] - Object property flags
* [[Manual:DIL_Manual/manipulate|manipulate]] - Object manipulation flags </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/objs</title>
     <ns>0</ns>
     <id>1187237</id>
     <revision>
       <id>1025568</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of objs.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= objs =
 field: unitptr &apos;&apos;&apos;.objs&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;objs&apos;&apos;&apos; field returns a pointer to the first object in a zone&apos;s object list.

== Description ==
The &apos;&apos;&apos;objs&apos;&apos;&apos; field provides access to the head of the linked list containing all objects defined within a specific zone. Based on the C implementation, this field operates on a zone pointer and calls the `findFirstObj()` method to retrieve the first object in that zone&apos;s object list.

== Field Access ==
This is a field access on zoneptrs:
 zone.objs

== Availability ==
This field is available on the following unit types:
* zoneptr

== Usage Notes ==
* This field is currently marked as obsolete and not used in any DIL programs
* The returned pointer can be used to traverse the zone&apos;s object list using the [[Manual:DIL_Manual/next|next]] field
* Use with [[Manual:DIL_Manual/findzone|findzone]] to get a zone pointer by name
* Combine with [[Manual:DIL_Manual/objcount|objcount]] to get the total number of objects in the zone

== Examples ==
 dilbegin list_zone_objects(zone_name : string);
 var
    target_zone : zoneptr;
    current_obj : unitptr;
    count : integer;
 
 code
 {
    target_zone := findzone(zone_name);
    
    if (target_zone == null)
    {
       act(&quot;Zone &apos;$1t&apos; not found.&quot;, A_ALWAYS, self, zone_name, null, TO_CHAR);
       return;
    }
    
    count := 0;
    current_obj := target_zone.objs;
    
    act(&quot;Objects in zone &apos;$1t&apos;:&quot;, A_ALWAYS, self, zone_name, null, TO_CHAR);
    
    while (current_obj != null)
    {
       act(&quot;  $1n&quot;, A_ALWAYS, self, current_obj, null, TO_CHAR);
       count := count + 1;
       current_obj := current_obj.next;
    }
    
    act(&quot;Total: $1d objects&quot;, A_ALWAYS, self, count, null, TO_CHAR);
 } dilend

== Error Handling ==
Always check the zone pointer for null and verify the return value:

 zone := findzone(zone_name);
 if (zone != null)
 {
    first_obj := zone.objs;
    if (first_obj != null)
    {
       // Safe to use the object pointer
       name := first_obj.name;
    }
    else
    {
       act(&quot;No objects in zone.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    }
 }
 else
 {
    act(&quot;Zone not found.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/objcount|objcount]] - Number of objects in a zone
* [[Manual:DIL_Manual/npcs|npcs]] - Pointer to first NPC in zone
* [[Manual:DIL_Manual/rooms|rooms]] - Pointer to first room in zone
* [[Manual:DIL_Manual/findzone|findzone]] - Find a zone by name
* [[Manual:DIL_Manual/zhead|zhead]] - Get first zone in global list
* [[Manual:DIL_Manual/next|next]] - Navigate to next object in list

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type
* [[Manual:DIL_Manual/objcount|objcount]] - Count of objects in zone
* [[Manual:DIL_Manual/npcs|npcs]] - NPCs in zone
* [[Manual:DIL_Manual/rooms|rooms]] - Rooms in zone
* [[Manual:DIL_Manual/findzone|findzone]] - Zone lookup function </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/offensive</title>
     <ns>0</ns>
     <id>1029315</id>
     <revision>
       <id>1514913</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of offensive.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= offensive =
 field: integer &apos;&apos;&apos;.offensive&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;offensive&apos;&apos;&apos; field provides access to the offensive bonus modifier for characters.

== Description ==
The &apos;&apos;&apos;offensive&apos;&apos;&apos; field represents a bonus or penalty applied to the character&apos;s offensive combat capabilities, affecting their ability to successfully hit targets in combat. Based on the C implementation, this field returns a reference to the character&apos;s offensive bonus value, allowing both reading and writing of the modifier.

== Field Access ==
This is a field access on character unitptrs:
 char.offensive

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Usage Notes ==
This field represents a combat modifier that affects attack accuracy and effectiveness.
Positive values improve offensive capabilities, while negative values impose penalties.
This field is part of the combat system alongside [[Manual:DIL_Manual/defensive|defensive]] and [[Manual:DIL_Manual/attack_type|attack_type]].

== Examples ==
 dilbegin check_offensive(target : unitptr);
 var
    off_bonus : integer;
 
 code
 {
    if ((target.type != UNIT_ST_PC) and (target.type != UNIT_ST_NPC))
    {
       act(&quot;$1n is not a character.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
       return;
    }
    
    off_bonus := target.offensive;
    
    if (off_bonus &gt; 0)
       act(&quot;$1n has a +$2d offensive bonus.&quot;, A_ALWAYS, self, off_bonus, target, TO_CHAR);
    else if (off_bonus &lt; 0)
       act(&quot;$1n has a $2d offensive penalty.&quot;, A_ALWAYS, self, off_bonus, target, TO_CHAR);
    else
       act(&quot;$1n has no offensive modifier.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
 } dilend

== Error Handling ==
Always verify the unit is a character before accessing offensive:

 if ((unit.type == UNIT_ST_PC) or (unit.type == UNIT_ST_NPC))
 {
    bonus := unit.offensive;
 }
 else
 {
    act(&quot;Not a character unit.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/defensive|defensive]] - Defensive bonus modifier
* [[Manual:DIL_Manual/attack_type|attack_type]] - Non-weapon attack type
* [[Manual:DIL_Manual/meleeattack|meleeattack]] - Perform melee attack
* [[Manual:DIL_Manual/meleedamage|meleedamage]] - Calculate melee damage
* [[Manual:DIL_Manual/weapons|weapons]] - Weapon skills array
* [[Manual:DIL_Manual/abilities|abilities]] - Abilities array

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Other character fields
* [[Manual:DIL_Manual/defensive|defensive]] - Defensive combat modifier
* [[Manual:DIL_Manual/attack_type|attack_type]] - Attack type setting
* [[Manual:DIL_Manual/meleeattack|meleeattack]] - Melee attack function
* [[Manual:DIL_Manual/opponent|opponent]] - Current opponent in combat </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/on_activation</title>
     <ns>0</ns>
     <id>320704</id>
     <revision>
       <id>1086333</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of on_activation.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= on_activation =
 function: integer &apos;&apos;&apos;on_activation&apos;&apos;&apos;(dilexp : string, label : string);

Sets up an interrupt that is executed before every activation of DIL program, allowing conditional control over program execution based on game state.

== Description ==
The &apos;&apos;&apos;on_activation&apos;&apos;&apos; function creates a special type of interrupt that evaluates a boolean expression each time the DIL program is about to be activated. This is particularly useful for catching situations where an NPC has fallen asleep, is fighting, is injured, or is in other states that should prevent normal program execution.

When the boolean expression evaluates to TRUE:
* If the label parameter is &apos;&apos;&apos;SKIP&apos;&apos;&apos;, the program activation is skipped for this cycle but the interrupt remains active
* If the label parameter is a valid label name, the program jumps to that label and the interrupt is automatically cleared

When the boolean expression evaluates to FALSE, the program continues normal execution and the interrupt remains active for future activations.

The function returns an integer index that can be used with the &apos;&apos;&apos;clear()&apos;&apos;&apos; function to manually remove the interrupt.

Internally, &apos;&apos;&apos;on_activation&apos;&apos;&apos; is implemented as a macro that calls &apos;&apos;&apos;interrupt&apos;&apos;&apos;(SFB_ACTIVATE, dilexp, label).

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| dilexp || string || A boolean DIL expression to evaluate before each program activation
|-
| label || string || Label to jump to if expression is true, or the reserved keyword &apos;&apos;&apos;SKIP&apos;&apos;&apos;
|}

== Return Value ==
Returns an integer representing the index to the interrupt handling the on_activation. This value can be used with the &apos;&apos;&apos;clear()&apos;&apos;&apos; function to manually remove the interrupt.

== Examples ==
 dilbegin guard_post();
 var
 code
 {
    on_activation((self.position &lt;= POSITION_SLEEPING) or 
                 (self.position == POSITION_FIGHTING), skip);
    
    :start:
    heartbeat := PULSE_SEC*5;
    pause;
    exec(&quot;say I am on duty and alert.&quot;, self);
    goto start;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;on_activation&apos;&apos;&apos; interrupt is evaluated before every program activation, before any other interrupts
* When using &apos;&apos;&apos;SKIP&apos;&apos;&apos;, the program simply doesn&apos;t activate for that cycle but the interrupt remains active
* When jumping to a label, the interrupt is automatically cleared after the jump
* The interrupt remains active until explicitly cleared with &apos;&apos;&apos;clear()&apos;&apos;&apos; or when triggered with a label jump
* Multiple &apos;&apos;&apos;on_activation&apos;&apos;&apos; calls can be made to handle different conditions
* The boolean expression can be complex, using logical operators (and, or) and parentheses
* The expression should be efficient as it&apos;s evaluated frequently
* Common use cases include checking position states, health conditions, combat status, or environmental factors
* The expression is evaluated in the context of the program owner (self)

== Error Handling ==
* If the boolean expression contains invalid syntax, the program will fail to compile
* If the specified label doesn&apos;t exist, a runtime error will occur when the condition evaluates to true
* Invalid return values from &apos;&apos;&apos;clear()&apos;&apos;&apos; are ignored silently
* The interrupt index returned should be stored if you plan to manually clear the interrupt
* Ensure proper parentheses usage in complex boolean expressions to avoid evaluation order issues

== Related Functions/Fields ==
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system for specific message types
* [[Manual:DIL_Manual/clear|clear]] - Removes interrupts by index
* [[Manual:DIL_Manual/pause|pause]] - Waits for game pulses
* [[Manual:DIL_Manual/wait|wait]] - Waits for specific conditions
* [[Manual:DIL_Manual/self.position|self.position]] - Unit position field commonly used in activation conditions
* [[Manual:DIL_Manual/self.hp|self.hp]] - Character health field for injury checks
* [[Manual:DIL_Manual/mudhour|mudhour]] - Current game hour for time-based conditions

== See Also ==
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system overview
* [[Manual:DIL_Manual/on|on]] - Value-based interrupt handling
* [[Manual:DIL_Manual/position|position]] - Unit position constants and values
* [[Manual:DIL_Manual/SFB_ACTIVATE|SFB_ACTIVATE]] - Internal flag for activation interrupts </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/on_goto</title>
     <ns>0</ns>
     <id>1108944</id>
     <revision>
       <id>1848628</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of on_goto.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= on...goto =
 statement: &apos;&apos;&apos;on&apos;&apos;&apos; n : integer goto (label1 : string, label2 : string, ...);

Conditional goto statement that transfers program control to different labels based on integer value.

== Description ==
The &apos;&apos;&apos;on&apos;&apos;&apos; statement with multiple labels provides a structured way to transfer program control to different sections based on the value of an integer expression. It&apos;s essentially a multi-way conditional jump that selects which label to jump to based on the integer parameter &apos;n&apos;.

The construct takes the form:
 on n goto (label1, label2, ..., labelN);

Where &apos;n&apos; is the integer value to evaluate, and the program jumps to the label corresponding to that value. If &apos;n&apos; is 0, the program jumps to label1; if &apos;n&apos; is 1, it jumps to label2; and so on. The number of labels must match the range of possible values for &apos;n&apos;.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| n || integer || The integer value to evaluate for label selection
| label1 || string || The label to jump to when n equals 0
| label2 || string || The label to jump to when n equals 1
| ... || string || Additional labels for subsequent values (label3 for n=2, etc.)
|}

== Examples ==
 dilbegin multi_direction();
 var
    direction : integer;
 code
 {
    :start:
    direction := rnd(0, 3);
    
    on direction goto (north, south, east, west);
    
    :north:
    exec(&quot;go north&quot;, self);
    goto start;
    
    :south:
    exec(&quot;go south&quot;, self);
    goto start;
    
    :east:
    exec(&quot;go east&quot;, self);
    goto start;
    
    :west:
    exec(&quot;go west&quot;, self);
    goto start;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;on&apos;&apos;&apos; statement with multiple labels is equivalent to a series of if-else statements
* The integer parameter &apos;n&apos; determines which label to jump to (0-based indexing)
* Labels must be defined elsewhere in the program using the format &apos;:labelname:&apos;
* The number of labels provided must match the range of possible values for &apos;n&apos;
* If &apos;n&apos; is outside the range of provided labels, the on statement is skipped
* This construct is useful for creating state machines, menu systems, or multi-way branching
* The on statement provides cleaner code structure compared to nested if-else chains
* Each label represents a potential execution path from the current point

== Error Handling ==
* Ensure the integer &apos;n&apos; is properly validated before using it in the on statement
* Verify that all referenced labels exist in the program
* Check that the range of &apos;n&apos; values matches the number of labels provided
* Be careful with infinite loops when using on statements without proper exit conditions
* Remember that on statements transfer control unconditionally - they don&apos;t check conditions
* Test all possible code paths to ensure proper behavior for each value of &apos;n&apos;
* Use meaningful label names to improve code readability and maintenance

== Related Functions/Fields ==
* [[Manual:DIL_Manual/goto|goto]] - Unconditional jump to a specific label
* [[Manual:DIL_Manual/if|if]] - Conditional branching based on boolean expressions
* [[Manual:DIL_Manual/rnd|rnd]] - Generate random numbers for on statement selection
* [[Manual:DIL_Manual/atoi|atoi]] - Convert strings to integers for numeric comparisons

== See Also ==
* [[Manual:DIL_Manual/goto|goto]] - Unconditional jumping
* [[Manual:DIL_Manual/if|if]] - Conditional branching
* [[Manual:DIL_Manual/while|while]] - Loop construct (alternative to on-based loops)
* [[Manual:DIL_Manual/switch|switch]] - Similar multi-way branching construct </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/opendiff</title>
     <ns>0</ns>
     <id>1117642</id>
     <revision>
       <id>1622915</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of opendiff.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= opendiff =
 field: integer &apos;&apos;&apos;.opendiff&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;opendiff&apos;&apos;&apos; field provides access to the open difficulty modifier for units.

== Description ==
The &apos;&apos;&apos;opendiff&apos;&apos;&apos; field represents how difficult it is to open or pick the lock on a unit, affecting the success rate of lockpicking attempts and other opening actions. Based on the C implementation, this field returns a reference to the unit&apos;s open difficulty value, allowing both reading and writing of the modifier.

== Field Access ==
This is a field access on unitptrs:
 unit.opendiff

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Usage Notes ==
This field represents the difficulty level for opening or picking locks on the unit.
Higher values make locks more difficult to pick, while lower values make them easier.
This field is used in conjunction with [[Manual:DIL_Manual/openflags|openflags]] to determine the lock state.
The value is typically used as a modifier in skill checks for lockpicking abilities.

== Examples ==
 dilbegin check_lock_difficulty(target : unitptr);
 var
    difficulty : integer;
 
 code
 {
    if (target == null)
    {
       act(&quot;No target specified.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    difficulty := target.opendiff;
    
    if (difficulty == 0)
       act(&quot;$1n has no lock difficulty.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    else if (difficulty &lt; 10)
       act(&quot;$1n has an easy lock (difficulty: $2d).&quot;, A_ALWAYS, self, difficulty, target, TO_CHAR);
    else if (difficulty &lt; 20)
       act(&quot;$1n has a moderate lock (difficulty: $2d).&quot;, A_ALWAYS, self, difficulty, target, TO_CHAR);
    else if (difficulty &lt; 30)
       act(&quot;$1n has a hard lock (difficulty: $2d).&quot;, A_ALWAYS, self, difficulty, target, TO_CHAR);
    else
       act(&quot;$1n has an extremely hard lock (difficulty: $2d).&quot;, A_ALWAYS, self, difficulty, target, TO_CHAR);
 } dilend

== Error Handling ==
Always verify the unit pointer is valid before accessing opendiff:

 if (unit != null)
 {
    difficulty := unit.opendiff;
 }
 else
 {
    act(&quot;Invalid unit pointer.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/openflags|openflags]] - Open/close/lock state flags
* [[Manual:DIL_Manual/exit_diff|exit_diff]] - Exit-specific difficulty values
* [[Manual:DIL_Manual/skillchecksa|skillchecksa]] - Skill checking function
* [[Manual:DIL_Manual/skills|skills]] - Character skills array
* [[Manual:DIL_Manual/SKI_PICK_LOCK|SKI_PICK_LOCK]] - Lockpicking skill constant

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer documentation
* [[Manual:DIL_Manual/openflags|openflags]] - Open state flags
* [[Manual:DIL_Manual/exit_diff|exit_diff]] - Exit difficulty values
* [[Manual:DIL_Manual/skillchecksa|skillchecksa]] - Skill checking system
* [[Manual:DIL_Manual/isset|isset]] - Flag testing function </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/openflags</title>
     <ns>0</ns>
     <id>695605</id>
     <revision>
       <id>1679388</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of openflags.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= openflags =
 field: integer &apos;&apos;&apos;.openflags&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;openflags&apos;&apos;&apos; field provides access to the open/close/lock state flags for units.

== Description ==
The &apos;&apos;&apos;openflags&apos;&apos;&apos; field contains bit flags that determine whether a unit (typically doors, containers, or objects with lids) is open, closed, locked, or has other special properties. Based on the C implementation, this field returns a reference to the unit&apos;s open flags value, allowing both reading and writing of the flag bits.

== Field Access ==
This is a field access on unitptrs:
 unit.openflags

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Usage Notes ==
This field uses bit flags that can be tested and modified using [[Manual:DIL_Manual/isset|isset]] and bitwise operations.
Common flag constants include:
* &apos;&apos;&apos;EX_CLOSED&apos;&apos;&apos; - Unit is closed
* &apos;&apos;&apos;EX_LOCKED&apos;&apos;&apos; - Unit is locked
* &apos;&apos;&apos;EX_OPEN_CLOSE&apos;&apos;&apos; - Unit can be opened and closed
* &apos;&apos;&apos;EX_PICKPROOF&apos;&apos;&apos; - Unit cannot be picked

== Examples ==
 dilbegin check_open_state(target : unitptr);
 var
    flags : integer;
 
 code
 {
    if (target == null)
    {
       act(&quot;No target specified.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    flags := target.openflags;
    
    if (isset(flags, EX_CLOSED))
       act(&quot;$1n is closed.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    else
       act(&quot;$1n is open.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    
    if (isset(flags, EX_LOCKED))
       act(&quot;$1n is locked.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    else
       act(&quot;$1n is unlocked.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
 } dilend

== Error Handling ==
Always verify the unit pointer is valid before accessing openflags:

 if (unit != null)
 {
    flags := unit.openflags;
 }
 else
 {
    act(&quot;Invalid unit pointer.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isset|isset]] - Test if specific flag bits are set
* [[Manual:DIL_Manual/opendiff|opendiff]] - Open difficulty modifier
* [[Manual:DIL_Manual/exit_info|exit_info]] - Exit-specific information
* [[Manual:DIL_Manual/exit_diff|exit_diff]] - Exit difficulty values
* [[Manual:DIL_Manual/key|key]] - Key required to open unit

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer documentation
* [[Manual:DIL_Manual/isset|isset]] - Flag testing function
* [[Manual:DIL_Manual/opendiff|opendiff]] - Open difficulty field
* [[Manual:DIL_Manual/exit_info|exit_info]] - Exit information field
* [[Manual:DIL_Manual/key|key]] - Key field for units
* [[Manual:DIL_Manual/EX_CLOSED|EX_CLOSED]] - Closed flag constant
* [[Manual:DIL_Manual/EX_LOCKED|EX_LOCKED]] - Locked flag constant </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/openroll</title>
     <ns>0</ns>
     <id>1129331</id>
     <revision>
       <id>1723879</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of openroll.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= openroll =
 function: integer &apos;&apos;&apos;openroll&apos;&apos;&apos;(dice : integer, end : integer);

== Description ==
The &apos;&apos;&apos;openroll&apos;&apos;&apos;() function generates an open-ended dice roll with a specified margin. This function produces random integers that follow a bell curve distribution, where results near the center are more likely than extreme values.

Based on the C implementation, this function performs an open-ended roll where values can continue indefinitely in both directions, but with decreasing probability for extreme results.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| dice || integer || The size of the dice being rolled (determines the range)
|-
| end || integer || The margin for the open-ended roll (controls probability distribution)
|}

== Return Value ==
Returns integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - A random integer following open-ended dice distribution
* &apos;&apos;&apos;fail&apos;&apos;&apos; - If parameters are invalid

== Usage Notes ==
The function generates values in approximately +/- 2^31 range in worst case scenarios.
The &apos;&apos;&apos;dice&apos;&apos;&apos; parameter determines the base range and probability distribution.
The &apos;&apos;&apos;end&apos;&apos;&apos; parameter sets the margin where results can continue open-ended.
Results near the center are more probable than extreme values.
This is useful for skill checks, damage rolls, and other randomization needs.

== Examples ==
=== Basic Open Roll ===
 dilbegin basic_openroll();
 var
    result : integer;
 
 code
 {
    // Roll 1-100 with open-ended continuation
    result := openroll(100, 5);
    
    act(&quot;Open roll result: $1d&quot;, A_ALWAYS, self, result, null, TO_CHAR);
    
    if (result &gt; 100)
       act(&quot;Exceptional success! ($1d)&quot;, A_ALWAYS, self, result, null, TO_CHAR);
    else if (result &lt; 1)
       act(&quot;Critical failure! ($1d)&quot;, A_ALWAYS, self, result, null, TO_CHAR);
    else
       act(&quot;Normal result: $1d&quot;, A_ALWAYS, self, result, null, TO_CHAR);
 } dilend

=== Skill Check Simulation ===
 dilbegin skill_check(difficulty : integer);
 var
    roll : integer;
    success : integer;
 
 code
 {
    // Roll against difficulty with open-ended dice
    roll := openroll(50, 10);
    
    if (roll &gt;= difficulty)
    {
       success := roll - difficulty + 50; // Success margin
       act(&quot;Skill check: $1d vs $2d = SUCCESS by $3d&quot;, 
          A_ALWAYS, self, roll, difficulty, success, TO_CHAR);
    }
    else
    {
       success := roll - difficulty - 50; // Failure margin
       act(&quot;Skill check: $1d vs $2d = FAILURE by $3d&quot;, 
          A_ALWAYS, self, roll, difficulty, success, TO_CHAR);
    }
 } dilend

== Error Handling ==
Always validate parameters are positive integers:

 if ((dice &gt; 0) and (end &gt;= 0))
 {
    result := openroll(dice, end);
 }
 else
 {
    act(&quot;Invalid parameters for openroll.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    return;
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/rnd|rnd]] - Basic random number generation
* [[Manual:DIL_Manual/dice|dice]] - Traditional dice rolling
* [[Manual:DIL_Manual/random|random]] - Random number generation
* [[Manual:DIL_Manual/skillchecksa|skillchecksa]] - Skill checking system

== See Also ==
* [[Manual:DIL_Manual/dice|dice]] - Standard dice rolling
* [[Manual:DIL_Manual/rnd|rnd]] - Random number generation
* [[Manual:DIL_Manual/skillchecksa|skillchecksa]] - Skill resolution system
* [[Manual:DIL_Manual/random|random]] - General randomization</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/opponent</title>
     <ns>0</ns>
     <id>680446</id>
     <revision>
       <id>910124</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of opponent.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= opponent =
 function: integer &apos;&apos;&apos;opponent&apos;&apos;&apos;(u1 : unitptr, u2 : unitptr);

== Description ==
The &apos;&apos;&apos;opponent&apos;&apos;&apos;() function checks if two characters are in combat with each other. This function determines whether one unit is directly engaged in combat with another unit, either as attacker or defender.

Based on the C implementation, this function uses the `CHAR_COMBAT` and `FindOpponent()` methods to determine combat relationships between characters.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u1 || unitptr || First character to check combat relationship
|-
| u2 || unitptr || Second character to check combat relationship
|}

== Return Value ==
Returns integer:
* &apos;&apos;&apos;TRUE&apos;&apos;&apos; (1) - If u1 is in combat with u2
* &apos;&apos;&apos;FALSE&apos;&apos;&apos; (0) - If u1 is not in combat with u2

== Usage Notes ==
The function checks for direct combat engagement between two characters.
In most combat systems, a character typically has one primary opponent but may be engaged with multiple opponents.
This function is directional - opponent(u1, u2) may return different result than opponent(u2, u1).
Both characters must be valid unit pointers of type UNIT_ST_PC or UNIT_ST_NPC.
Characters must be awake and capable of combat (not sleeping, etc.).

== Examples ==
=== Basic Combat Check ===
 dilbegin check_combat_status(char1 : unitptr, char2 : unitptr);
 var
    in_combat : integer;
 
 code
 {
    in_combat := opponent(char1, char2);
    
    if (in_combat)
       act(&quot;$1n is fighting with $2n.&quot;, A_ALWAYS, self, char1, char2, TO_CHAR);
    else
       act(&quot;$1n is not fighting with $2n.&quot;, A_ALWAYS, self, char1, char2, TO_CHAR);
 } dilend

=== Target Validation ===
 dilbegin validate_attack_target(target : unitptr);
 var
    can_attack : integer;
 
 code
 {
    if (target == null)
    {
       act(&quot;No target specified.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       return FALSE;
    }
    
    if ((target.type != UNIT_ST_PC) and (target.type != UNIT_ST_NPC))
    {
       act(&quot;$1n is not a valid combat target.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
       return FALSE;
    }
    
    can_attack := opponent(self, target);
    
    if (can_attack)
       act(&quot;You can attack $1n.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    else
       act(&quot;You are not in combat with $1n.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    
    return can_attack;
 } dilend

== Error Handling ==
Always validate parameters before calling opponent:

 if ((u1 != null) and (u2 != null) and
     ((u1.type == UNIT_ST_PC) or (u1.type == UNIT_ST_NPC)) and
     ((u2.type == UNIT_ST_PC) or (u2.type == UNIT_ST_NPC)))
 {
    result := opponent(u1, u2);
 }
 else
 {
    act(&quot;Invalid unit pointers for opponent check.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    return FALSE;
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/set_fighting|set_fighting]] - Set two characters to fight each other
* [[Manual:DIL_Manual/fighting|fighting]] - Get current opponent of a character
* [[Manual:DIL_Manual/opponentcount|opponentcount]] - Number of opponents a character is fighting
* [[Manual:DIL_Manual/position|position]] - Character position (affects combat ability)
* [[Manual:DIL_Manual/CHAR_SELF_DEFENCE|CHAR_SELF_DEFENCE]] - Self-defense character flag
* [[Manual:DIL_Manual/CHAR_LEGAL_TARGET|CHAR_LEGAL_TARGET]] - Legal target character flag

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields
* [[Manual:DIL_Manual/set_fighting|set_fighting]] - Manual combat setup
* [[Manual:DIL_Manual/fighting|fighting]] - Current opponent field
* [[Manual:DIL_Manual/meleeattack|meleeattack]] - Perform melee attack
* [[Manual:DIL_Manual/meleedamage|meleedamage]] - Calculate melee damage
* [[Manual:DIL_Manual/position|position]] - Character positioning system</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/opponentcount</title>
     <ns>0</ns>
     <id>358377</id>
     <revision>
       <id>1898482</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of opponentcount.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= opponentcount =
 field: integer &apos;&apos;&apos;.opponentcount&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;opponentcount&apos;&apos;&apos; field provides access to the number of opponents a character is currently fighting. This field indicates how many different units the character is engaged in combat with.

Based on the C implementation, this field calls the `NoOpponents()` method to retrieve the current opponent count for the character.

== Field Access ==
This is a field access on character unitptrs:
 char.opponentcount

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Usage Notes ==
The opponentcount field is read-only (RO) and cannot be modified directly.
This field represents the total number of opponents, not just the primary opponent.
A value of 0 means the character is not currently fighting anyone.
This field is useful for checking combat status and multi-opponent situations.

== Examples ==
=== Basic Combat Status Check ===
 dilbegin check_combat_status(target : unitptr);
 var
    opponent_num : integer;
 
 code
 {
    if ((target.type != UNIT_ST_PC) and (target.type != UNIT_ST_NPC))
    {
       act(&quot;$1n is not a character.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
       return;
    }
    
    opponent_num := target.opponentcount;
    
    if (opponent_num == 0)
       act(&quot;$1n is not fighting anyone.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    else if (opponent_num == 1)
       act(&quot;$1n is fighting one opponent.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    else
       act(&quot;$1n is fighting $1d opponents.&quot;, A_ALWAYS, self, opponent_num, target, TO_CHAR);
 } dilend

=== Multi-Opponent Detection ===
 dilbegin detect_gang_attack();
 var
    aggressor : unitptr;
    victim : unitptr;
 
 code
 {
    // Look for characters fighting multiple opponents
    foreach (UNIT_ST_PC, aggressor)
    {
       if (aggressor.opponentcount &gt; 1)
       {
          act(&quot;$1n is fighting multiple opponents!&quot;, A_ALWAYS, self, aggressor, null, TO_CHAR);
          
          // Find who they&apos;re fighting
          foreach (UNIT_ST_PC, victim)
          {
             if (opponent(aggressor, victim))
                act(&quot;  -&gt; $1n&quot;, A_ALWAYS, self, victim, null, TO_CHAR);
          }
       }
    }
 } dilend

== Error Handling ==
Always verify that unit is a character before accessing opponentcount:

 if ((unit.type == UNIT_ST_PC) or (unit.type == UNIT_ST_NPC))
 {
    count := unit.opponentcount;
 }
 else
 {
    act(&quot;Not a character unit.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/opponent|opponent]] - Check if two characters are opponents
* [[Manual:DIL_Manual/fighting|fighting]] - Get current primary opponent
* [[Manual:DIL_Manual/set_fighting|set_fighting]] - Set combat between characters
* [[Manual:DIL_Manual/position|position]] - Character position (affects combat status)
* [[Manual:DIL_Manual/charflags|charflags]] - Character flags for combat states

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]] - Character-specific fields
* [[Manual:DIL_Manual/fighting|fighting]] - Primary opponent field
* [[Manual:DIL_Manual/opponent|opponent]] - Opponent checking function
* [[Manual:DIL_Manual/set_fighting|set_fighting]] - Combat setup function
* [[Manual:DIL_Manual/position|position]] - Character positioning system</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/outside</title>
     <ns>0</ns>
     <id>406113</id>
     <revision>
       <id>1376124</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of outside.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= outside =
 field: unitptr &apos;&apos;&apos;.outside&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;outside&apos;&apos;&apos; field provides access to the containing unit of a given unit. This field points to the unit that contains the specified unit in the game&apos;s hierarchy.

== Field Access ==
This is a field access on type unitptr:
 unit.outside

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Usage Notes ==
The outside field is read-only (RO) and cannot be modified directly
only via functions suck as link().
This field represents the &quot;parent&quot; or &quot;container&quot; relationship in the unit hierarchy.
For characters, outside typically points to the room they are currently in.
For objects, outside points to the unit that contains the object.
For rooms, outside points to the room that contains this room (if any).
A value of null indicates the unit is at the top level of the hierarchy
(and is a room).

== Examples ==
=== Basic Container Check ===
 dilbegin check_container(item : unitptr);
 var
    container : unitptr;
 
 code
 {
    if (item == null)
    {
       act(&quot;No item specified.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    container := item.outside;
    
    if (container == null)
       act(&quot;$1n is not contained by anything.&quot;, A_ALWAYS, self, item, null, TO_CHAR);
    else if (container.type == UNIT_ST_ROOM)
       act(&quot;$1n is in room: $2n&quot;, A_ALWAYS, self, item, container, TO_CHAR);
    else if (container.type == UNIT_ST_PC)
       act(&quot;$1n is carried by: $2n&quot;, A_ALWAYS, self, item, container, TO_CHAR);
    else
       act(&quot;$1n is contained by: $2n&quot;, A_ALWAYS, self, item, container, TO_CHAR);
 } dilend

=== Inventory Analysis ===
 dilbegin analyze_inventory();
 var
    item : unitptr;
    item_count : integer;
 
 code
 {
    item_count := 0;
    
    act(&quot;=== Inventory Analysis ===&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    
    foreach (UNIT_ST_OBJ, item)
    {
       if (item.outside == self)
       {
          item_count := item_count + 1;
          act(&quot;$1n&quot;, A_ALWAYS, self, item, null, TO_CHAR);
       }
    }
    
    act(&quot;Total items carried: $1d&quot;, A_ALWAYS, self, item_count, null, TO_CHAR);
 } dilend

== Error Handling ==
Always verify that unit pointer is valid before accessing outside:

 if (unit != null)
 {
    container := unit.outside;
 }
 else
 {
    act(&quot;Invalid unit pointer.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/inside|inside]] - Access to contained units
* [[Manual:DIL_Manual/next|next]] - Navigate to next unit in list
* [[Manual:DIL_Manual/gnext|gnext]] - Navigate to next unit in global list
* [[Manual:DIL_Manual/findunit|findunit]] - Find units in environment
* [[Manual:DIL_Manual/link|link]] - Link units together
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer documentation

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer documentation
* [[Manual:DIL_Manual/inside|inside]] - Internal contents field
* [[Manual:DIL_Manual/next|next]] - List navigation
* [[Manual:DIL_Manual/link|link]] - Unit linking
* [[Manual:DIL_Manual/findunit|findunit]] - Unit searching
* [[Manual:DIL_Manual/gnext|gnext]] - Global navigation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/outside_descr</title>
     <ns>0</ns>
     <id>826700</id>
     <revision>
       <id>1269085</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of outside_descr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= outside_descr =
 field: string &apos;&apos;&apos;.outside_descr&apos;&apos;&apos; (Read/Write)

== Description ==
The &apos;&apos;&apos;outside_descr&apos;&apos;&apos; field provides access to the description of a unit as seen from the outside. This field contains the text that players see when looking at a unit from an external perspective.

Based on the C implementation, this field returns a reference to the unit&apos;s outside description string, allowing both reading and writing of the description.

== Field Access ==
This is a field access on unitptrs:
 unit.outside_descr

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Usage Notes ==
The outside_descr field is read-write (RW) and can be modified directly.
This field contains the description text seen when looking at unit from outside.
For rooms, this is typically the description seen when entering or looking from adjacent rooms.
For objects, this is the description seen when examining the object from outside.
For characters, this is the description seen by others when looking at the character.

== Examples ==
=== Reading Outside Description ===
 dilbegin examine_outside(target : unitptr);
 var
    description : string;
 
 code
 {
    if (target == null)
    {
       act(&quot;No target specified.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    description := target.outside_descr;
    
    if (description == &quot;&quot;)
       act(&quot;$1n has no outside description.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    else
       act(&quot;$1n&apos;s outside description:&quot;, A_ALWAYS, self, target, null, TO_CHAR);
       act(description, A_ALWAYS, self, target, null, TO_CHAR);
 } dilend

=== Setting Outside Description ===
 dilbegin set_outside_description(target : unitptr, new_desc : string);
 var
    old_desc : string;
 
 code
 {
    if (target == null)
    {
       act(&quot;No target specified.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
       return;
    }
    
    old_desc := target.outside_descr;
    target.outside_descr := new_desc;
    
    act(&quot;$1n&apos;s outside description changed.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    act(&quot;Old: $1t&quot;, A_ALWAYS, self, old_desc, target, TO_CHAR);
    act(&quot;New: $1t&quot;, A_ALWAYS, self, new_desc, target, TO_CHAR);
 } dilend

== Error Handling ==
Always verify that unit pointer is valid before accessing outside_descr:

 if (unit != null)
 {
    description := unit.outside_descr;
 }
 else
 {
    act(&quot;Invalid unit pointer.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/inside_descr|inside_descr]] - Description seen from inside
* [[Manual:DIL_Manual/title|title]] - Unit title field
* [[Manual:DIL_Manual/names|names]] - Unit names list
* [[Manual:DIL_Manual/extra|extra]] - Extra descriptions
* [[Manual:DIL_Manual/description|description]] - General description field

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer documentation
* [[Manual:DIL_Manual/inside_descr|inside_descr]] - Internal description field
* [[Manual:DIL_Manual/title|title]] - Unit title field
* [[Manual:DIL_Manual/extra|extra]] - Extra description system
* [[Manual:DIL_Manual/sact|sact]] - String action construction
* [[Manual:DIL_Manual/act|act]] - Action function for displaying descriptions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/pagestring</title>
     <ns>0</ns>
     <id>1094335</id>
     <revision>
       <id>1462881</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of pagestring.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= pagestring =
 function: void &apos;&apos;&apos;pagestring&apos;&apos;&apos;(text : string, target : unitptr);

== Description ==
The &apos;&apos;&apos;pagestring&apos;&apos;&apos;() function displays a formatted text string to a player character, typically used for showing multi-page information that doesn&apos;t scroll off the screen. This function formats the text for proper display and waits for the player to press enter before continuing.

Based on the C implementation, this function calls the `CHAR_DESCRIPTOR()` method to send formatted text to a character&apos;s descriptor.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| text || string || The text string to be displayed to the player
|-
| target || unitptr || The player character to receive the paged text
|}

== Return Value ==
Returns nothing:
* &apos;&apos;&apos;void&apos;&apos;&apos; - No return value

== Usage Notes ==
The function displays text to the specified player character and waits for user input before continuing.
Text is formatted to fit within the player&apos;s screen width.
This is commonly used for displaying help files, clan information, skill lists, and other multi-page content.
The function automatically handles pagination and formatting for optimal display.

== Examples ==
=== Basic Page Display ===
 dilbegin show_help();
 var
    help_text : string;
 
 code
 {
    help_text := &quot;Welcome to the MUD!&amp;n&amp;n&quot;;
    help_text := help_text + &quot;Commands available:&amp;n&amp;n&quot;;
    help_text := help_text + &quot;  look     - Look around you&amp;n&amp;n&quot;;
    help_text := help_text + &quot;  say      - Say something&amp;n&amp;n&quot;;
    help_text := help_text + &quot;  quit     - Exit the game&amp;n&amp;n&amp;n&quot;;
    help_text := help_text + &quot;&amp;nPress ENTER to continue...&quot;;
    
    pagestring(help_text, self);
 } dilend

=== Score Display ===
 dilbegin show_score();
 var
    score_text : string;
 
 code
 {
    score_text := &quot;Score for &quot; + self.name + &quot;&amp;n&amp;n&quot;;
    score_text := score_text + &quot;Level: &quot; + itoa(self.level) + &quot;&amp;n&amp;n&quot;;
    score_text := score_text + &quot;Experience: &quot; + itoa(self.exp) + &quot;&amp;n&amp;n&quot;;
    score_text := score_text + &quot;Gold: &quot; + itoa(self.money) + &quot;&amp;n&amp;n&quot;;
    score_text := score_text + &quot;Hit Points: &quot; + itoa(self.hp) + &quot;/&quot; + itoa(self.max_hp) + &quot;&amp;n&amp;n&quot;;
    score_text := score_text + &quot;Mana: &quot; + itoa(self.mana) + &quot;/&quot; + itoa(self.max_mana) + &quot;&amp;n&amp;n&quot;;
    score_text := score_text + &quot;Endurance: &quot; + itoa(self.endurance) + &quot;/&quot; + itoa(self.max_endurance) + &quot;&amp;n&amp;n&quot;;
    score_text := score_text + &quot;&amp;nPress ENTER to continue...&quot;;
    
    pagestring(score_text, self);
 } dilend

== Error Handling ==
Always validate that target is a valid player character:

 if (target == null)
 {
    act(&quot;Invalid target for pagestring.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    return;
 }
 
 if (target.type != UNIT_ST_PC)
 {
    act(&quot;Target must be a player character.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
    return;
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/sendtext|sendtext]] - Send text to a player
* [[Manual:DIL_Manual/act|act]] - Display messages to players
* [[Manual:DIL_Manual/extra|extra]] - Access to extra descriptions
* [[Manual:DIL_Manual/skills|skills]] - Character skills array
* [[Manual:DIL_Manual/abilities|abilities]] - Character abilities array
* [[Manual:DIL_Manual/equipment|equipment]] - Get equipment in specific slot

== See Also ==
* [[Manual:DIL_Manual/sendtext|sendtext]] - Text output function
* [[Manual:DIL_Manual/act|act]] - Action display function
* [[Manual:DIL_Manual/extra|extra]] - Extra description system
* [[Manual:DIL_Manual/skills|skills]] - Character skills documentation
* [[Manual:DIL_Manual/abilities|abilities]] - Character abilities documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/pathto</title>
     <ns>0</ns>
     <id>445339</id>
     <revision>
       <id>1053441</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of pathto.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= pathto =
 function: integer &apos;&apos;&apos;pathto&apos;&apos;&apos;(from : unitptr, to : unitptr);

== Description ==
The &apos;&apos;&apos;pathto&apos;&apos;&apos; function calculates the direction needed to move from one unit to another. It determines the shortest path direction from the room containing the &quot;from&quot; unit to the room containing the &quot;to&quot; unit. The function returns a directional constant that can be used with movement commands.

The function works by finding the rooms that contain both units and then calculating the optimal movement direction between them using the underlying move_to function.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| from || unitptr || The unit from which the path is calculated (source unit)
|-
| to || unitptr || The unit to which the path is calculated (target unit)
|}

== Return Value ==
Returns integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - Direction constant (DIR_XXX values) indicating the direction to move
* &apos;&apos;&apos;fail&apos;&apos;&apos; - When either parameter is null or invalid

The returned value corresponds to direction constants defined in values.h and/or vme.h, such as DIR_NORTH, DIR_SOUTH, DIR_EAST, DIR_WEST, etc.

== Examples ==
 dilbegin find_path_to_target();
 var
    direction : integer;
    target_room : unitptr;
    current_room : unitptr;
 code
 {
    // Find a specific room
    target_room := findroom(&quot;inn@midgaard&quot;);
    
    if (target_room != null)
    {
       // Get direction from current location to target
       direction := pathto(self, target_room);
       
       if (direction != -1)
       {
          sendtext(&quot;Direction to target: &quot; + itoa(direction) + &quot;&lt;br/&gt;&quot;, self);
       }
       else
       {
          sendtext(&quot;No path found to target.&lt;br/&gt;&quot;, self);
       }
    }
    
    quit;
 } dilend

== Usage Notes ==
* The function operates on the rooms containing the units, not the units themselves
* Both units must be in valid rooms for the function to work properly
* The returned direction is the first step in the shortest path to the target
* Direction constants can be converted to readable names using stringlist constants like DIR_SL_LONG

== Error Handling ==
The function will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Either the &quot;from&quot; or &quot;to&quot; parameter is null
* Either unit is not contained in a valid room
* The parameters are not of unitptr type

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findroom|findroom]] - Find a specific room by name
* [[Manual:DIL_Manual/findunit|findunit]] - Find a specific unit in the world
* [[Manual:DIL_Manual/unit_room|unit_room]] - Get the room containing a unit

== See Also ==
* [[Manual:DIL_Manual/move|move]] - Move a unit in a specific direction
* [[Manual:DIL_Manual/goto|goto]] - Teleport to a specific location </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/paycheck</title>
     <ns>0</ns>
     <id>1213010</id>
     <revision>
       <id>1118341</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of paycheck.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= paycheck =
 function: integer &apos;&apos;&apos;paycheck&apos;&apos;&apos;(u1 : unitptr, u2 : unitptr);

== Description ==
The &apos;&apos;&apos;paycheck&apos;&apos;&apos; function checks whether a player has pay access to a specific location. It determines if the player u2 is allowed to access the zone where unit u1 is located, based on the game&apos;s accounting and pay-access system.

The function is commonly used to verify if a player can enter certain areas that require payment or special access permissions. When accounting mode is disabled, the function always returns true (allowing access).

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u1 || unitptr || The unit to check access against (typically the target location/room)
|-
| u2 || unitptr || The player to check access for (must be a character unit)
|}

== Return Value ==
Returns integer:
* &apos;&apos;&apos;1 (TRUE)&apos;&apos;&apos; - The player has access to the location
* &apos;&apos;&apos;0 (FALSE)&apos;&apos;&apos; - The player does not have access to the location
* &apos;&apos;&apos;fail&apos;&apos;&apos; - When either parameter is null or invalid

== Examples ==
 dilbegin check_zone_access();
 var
    target_room : unitptr;
    can_enter : integer;
 code
 {
    // Find a specific room to check access for
    target_room := findroom(&quot;shop@midgaard&quot;);
    
    if (target_room != null)
    {
       // Check if current player can access this room
       can_enter := paycheck(target_room, self);
       
       if (can_enter)
       {
          sendtext(&quot;You can enter this location.&lt;br/&gt;&quot;, self);
       }
       else
       {
          sendtext(&quot;You need to pay to access this location.&lt;br/&gt;&quot;, self);
       }
    }
    
    quit;
 } dilend

 dilbegin movement_paycheck(mover : unitptr, direction : integer);
 var
    target_room : unitptr;
    current_room : unitptr;
 code
 {
    current_room := unit_room(mover);
    
    if (current_room.exit_to[direction] != null)
    {
       target_room := current_room.exit_to[direction];
       
       // Check pay access before allowing movement
       if (not paycheck(target_room, mover))
       {
          sendtext(&quot;You must pay to enter this area.&lt;br/&gt;&quot;, mover);
          return;
       }
       
       // Proceed with movement if access is granted
       move(mover, direction);
    }
    
    quit;
 } dilend

== Usage Notes ==
* When accounting mode is disabled (g_cServerConfig.isAccounting() == false), the function always returns 1 (TRUE)
* The first parameter (u1) should be the unit representing the location you want to check access for
* The second parameter (u2) should be the player character you&apos;re checking access for
* Non-player characters used as u2 will always return TRUE
* The function checks the zone&apos;s pay-access requirements, not individual room requirements

== Error Handling ==
The function will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Either parameter is null
* The first parameter is not a valid unit
* The second parameter is not a character unit (isChar() returns false)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findroom|findroom]] - Find a specific room by name
* [[Manual:DIL_Manual/unit_room|unit_room]] - Get the room containing a unit
* [[Manual:DIL_Manual/acc_balance|acc_balance]] - Get player&apos;s account balance (when accounting is enabled)
* [[Manual:DIL_Manual/acc_total|acc_total]] - Get player&apos;s total credit (when accounting is enabled)

== See Also ==
* [[Manual:DIL_Manual/move|move]] - Move a unit in a specific direction
* [[Manual:DIL_Manual/act|act]] - Send messages to units
* [[Manual:DIL_Manual/isAccounting|isAccounting]] - Check if accounting mode is enabled </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/payonly</title>
     <ns>0</ns>
     <id>1278759</id>
     <revision>
       <id>1388053</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of payonly.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= payonly =
 field: integer &apos;&apos;&apos;.payonly&apos;&apos;&apos; (Read-only)

== Description ==
The &apos;&apos;&apos;payonly&apos;&apos;&apos; field provides access to the payment status of a zone. This field indicates whether the zone requires payment to access or is free to access.

== Field Access ==
This is a field access on zoneptrs:
  zone.payonly

== Availability ==
This field is available on the following unit types:
* zoneptr (Zone pointer)

== Examples ==
=== Zone Payment Check ===
 dilbegin check_zone_payment();
 var
    zones : zoneptr;
    pay_zones : integer;
    free_zones : integer;
 
 code
 {
    pay_zones := 0;
    free_zones := 0;
    
    zones := zhead();
    while (zones != null)
    {
       if (zones.payonly)
          pay_zones := pay_zones + 1;
       else
          free_zones := free_zones + 1;
       
       act(&quot;Zone: $1t - Pay-only: $2t&quot;, A_ALWAYS, self, zones.title, 
          (zones.payonly ? &quot;YES&quot; : &quot;NO&quot;), TO_CHAR);
       
       zones := zones.next;
    }
    
    act(&quot;Total pay zones: $1d&quot;, A_ALWAYS, self, pay_zones, null, TO_CHAR);
    act(&quot;Total free zones: $1d&quot;, A_ALWAYS, self, free_zones, null, TO_CHAR);
 } dilend
== Usage Notes ==
The payonly field is read-only (RO) and cannot be modified directly.
This field indicates whether the zone requires payment for access.
A non-zero value means the zone is pay-only.
A zero value means the zone is free to access.

== Error Handling ==
Always verify that zone pointer is valid before accessing payonly:

 if (zone != null)
 {
    is_pay_zone := zone.payonly;
 }
 else
 {
    act(&quot;Invalid zone pointer.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zhead|zhead]] - Get first zone in global list
* [[Manual:DIL_Manual/access|access]] - Zone access level
* [[Manual:DIL_Manual/loadlevel|loadlevel]] - Zone load level
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type
* [[Manual:DIL_Manual/zhead|zhead]] - Get first zone in global list
* [[Manual:DIL_Manual/access|access]] - Zone access level
* [[Manual:DIL_Manual/loadlevel|loadlevel]] - Zone load level</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/pc_head</title>
     <ns>0</ns>
     <id>645968</id>
     <revision>
       <id>1527632</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of pc_head.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= pc_head =
 function: unitptr &apos;&apos;&apos;pc_head&apos;&apos;&apos;();

== Description ==
The &apos;&apos;&apos;pc_head&apos;&apos;&apos; function returns the first player character in the global player list. This function provides access to the head of the linked list of all player characters currently connected to the game, allowing iteration through all players using the gnext field.

The function is commonly used for operations that need to process all connected players, such as global announcements, mass updates, or player statistics collection.

== Parameters ==
This function takes no parameters.

== Return Value ==
Returns unitptr:
* &apos;&apos;&apos;unitptr&apos;&apos;&apos; - The first player character in the global player list
* &apos;&apos;&apos;null&apos;&apos;&apos; - When there are no player characters connected or the list is empty

== Examples ==
 dilbegin announce_to_all(message : string);
 var
    current_pc : unitptr;
 code
 {
    // Get the first player in the list
    current_pc := pc_head();
    
    // Iterate through all connected players
    while (current_pc != null)
    {
       // Send message to current player
       sendtext(message + &quot;&lt;br/&gt;&quot;, current_pc);
       
       // Move to next player in the list
       current_pc := current_pc.gnext;
    }
    
    quit;
 } dilend

 dilbegin count_online_players();
 var
    current_pc : unitptr;
    player_count : integer;
 code
 {
    player_count := 0;
    current_pc := pc_head();
    
    // Count all connected players
    while (current_pc != null)
    {
       if (current_pc.type == UNIT_ST_PC)
       {
          player_count := player_count + 1;
       }
       
       current_pc := current_pc.gnext;
    }
    
    sendtext(&quot;There are &quot; + itoa(player_count) + &quot; players online.&lt;br/&gt;&quot;, self);
    quit;
 } dilend

 dilbegin force_all_players(command : string);
 var
    current_pc : unitptr;
 code
 {
    // Only allow immortals to use this
    if (self.level &lt; IMMORTAL_LEVEL)
    {
       sendtext(&quot;You don&apos;t have permission to use this command.&lt;br/&gt;&quot;, self);
       quit;
    }
    
    current_pc := pc_head();
    
    // Force all lower level players to execute command
    while (current_pc != null)
    {
       if (current_pc.type == UNIT_ST_PC and current_pc != self)
       {
          if (self.level &gt; current_pc.level)
          {
             exec(command, current_pc);
             act(&quot;You have forced $3n to &apos;&quot; + command + &quot;&apos;&quot;, A_ALWAYS, self, null, current_pc, TO_CHAR);
          }
       }
       
       current_pc := current_pc.gnext;
    }
    
    sendtext(&quot;Done.&lt;br/&gt;&quot;, self);
    quit;
 } dilend

== Usage Notes ==
* The returned unit is the head of a global linked list of all player characters
* Use the gnext field to iterate through the list: current_pc := current_pc.gnext
* The list includes all connected player characters, regardless of their location
* Always check for null when iterating, as the list may be empty
* The function returns null when no players are connected to the game

== Error Handling ==
The function is generally safe and does not generate errors:
* Returns null when no players are connected
* The underlying C implementation checks if g_unit_list is a PC before returning it

== Related Functions/Fields ==
* [[Manual:DIL_Manual/npc_head|npc_head]] - Get the first NPC in the global NPC list
* [[Manual:DIL_Manual/obj_head|obj_head]] - Get the first object in the global object list
* [[Manual:DIL_Manual/room_head|room_head]] - Get the first room in the global room list
* [[Manual:DIL_Manual/gnext|gnext]] - Field to navigate to the next unit in the global list

== See Also ==
* [[Manual:DIL_Manual/findunit|findunit]] - Find a specific unit in the game world
* [[Manual:DIL_Manual/act|act]] - Send messages to units
* [[Manual:DIL_Manual/exec|exec]] - Execute a command for a specific unit </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/pcflags</title>
     <ns>0</ns>
     <id>1183435</id>
     <revision>
       <id>1321842</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of pcflags.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= pcflags =

 field: integer &apos;&apos;&apos;.pcflags&apos;&apos;&apos;
 type: &apos;&apos;&apos;integer&apos;&apos;&apos;
 access: &apos;&apos;&apos;Read/Write&apos;&apos;&apos;

== Syntax ==
 unit.pcflags

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current PC flags value
|-
| Write || integer || Sets the PC flags to the specified value
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Description ==
The &apos;&apos;&apos;pcflags&apos;&apos;&apos; field contains various player option flags that control player behavior and permissions. These flags are bit-based constants that can be checked, set, or cleared using the &apos;&apos;&apos;isset&apos;&apos;&apos;, &apos;&apos;&apos;set&apos;&apos;&apos;, and &apos;&apos;&apos;clear&apos;&apos;&apos; functions.

Common PC flags include:
* &apos;&apos;&apos;PC_PK_RELAXED&apos;&apos;&apos; - Player has signed the &quot;book of blood&quot; and can participate in player killing
* &apos;&apos;&apos;PC_INFORM&apos;&apos;&apos; - Player receives information about other players entering the game

== Examples ==
 dilbegin check_pk_status(player : unitptr);
 var
    is_pk_enabled : integer;
 code
 {
    // Check if player has PK enabled
    is_pk_enabled := isset(player.pcflags, PC_PK_RELAXED);
    
    if (is_pk_enabled)
    {
       sendtext(&quot;You are signed up for player killing.&lt;br/&gt;&quot;, player);
    }
    else
    {
       sendtext(&quot;You are not signed up for player killing.&lt;br/&gt;&quot;, player);
    }
    
    quit;
 } dilend

 dilbegin toggle_inform_mode();
 var
    current_flags : integer;
 code
 {
    // Only allow players to use this on themselves
    if (activator != self)
    {
       sendtext(&quot;You can only change your own inform status.&lt;br/&gt;&quot;, self);
       quit;
    }
    
    current_flags := self.pcflags;
    
    if (isset(current_flags, PC_INFORM))
    {
       // Turn off inform mode
       clear(self.pcflags, PC_INFORM);
       sendtext(&quot;Inform mode disabled.&lt;br/&gt;&quot;, self);
    }
    else
    {
       // Turn on inform mode
       set(self.pcflags, PC_INFORM);
       sendtext(&quot;Inform mode enabled.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin sign_death_book();
 var
    current_flags : integer;
 code
 {
    // Check if player is high enough level
    if (self.level &lt; 50)
    {
       sendtext(&quot;You must be level 50 or higher to sign the death book.&lt;br/&gt;&quot;, self);
       quit;
    }
    
    current_flags := self.pcflags;
    
    if (isset(current_flags, PC_PK_RELAXED))
    {
       sendtext(&quot;You are already signed up for player killing.&lt;br/&gt;&quot;, self);
    }
    else
    {
       // Sign the player up for PK
       set(self.pcflags, PC_PK_RELAXED);
       sendtext(&quot;You have signed the book of blood! You can now participate in player killing.&lt;br/&gt;&quot;, self);
       act(&quot;$1n has signed the book of blood!&quot;, A_ALWAYS, self, null, null, TO_ROOM);
    }
    
    quit;
 } dilend

== Usage Notes ==
* The pcflags field is only available on player characters (UNIT_ST_PC)
* Flags are bit-based, so multiple flags can be set simultaneously
* Use &apos;&apos;&apos;isset()&apos;&apos;&apos; to check if a flag is set
* Use &apos;&apos;&apos;set()&apos;&apos;&apos; to set a flag
* Use &apos;&apos;&apos;clear()&apos;&apos;&apos; to clear a flag
* The field is read/write, allowing modification of player flags
* Common flag constants are defined in values.h and/or vme.h with PC_ prefix

== Error Handling ==
The field access will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Attempting to access pcflags on a non-player character unit
* The unit is null or invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isset|isset]] - Check if a flag bit is set
* [[Manual:DIL_Manual/set|set]] - Set a flag bit
* [[Manual:DIL_Manual/clear|clear]] - Clear a flag bit
* [[Manual:DIL_Manual/npcflags|npcflags]] - Similar field for NPC flags

== See Also ==
* [[Manual:DIL_Manual/meleedamage|meleedamage]] - Function that checks PC_PK_RELAXED for combat
* [[Manual:DIL_Manual/gamestate|gamestate]] - Function that checks PC_INFORM for player notifications </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/playtime</title>
     <ns>0</ns>
     <id>1083136</id>
     <revision>
       <id>1141717</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of playtime.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= playtime =

 field: integer &apos;&apos;&apos;.playtime&apos;&apos;&apos;
 type: &apos;&apos;&apos;integer&apos;&apos;&apos;
 access: &apos;&apos;&apos;Read-only&apos;&apos;&apos;

== Syntax ==
 unit.playtime

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the total time played in seconds
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Description ==
The &apos;&apos;&apos;playtime&apos;&apos;&apos; field contains the total amount of time a player character has been connected to the game, measured in seconds. This value accumulates over the player&apos;s entire gaming session history and is persistent across logins.

The time is calculated by the underlying C++ function getTotalTimePlayedInSeconds() and represents the cumulative time the player has been actively playing the game.

== Examples ==
 dilbegin show_playtime();
 var
    total_seconds : integer;
    hours : integer;
    minutes : integer;
    seconds : integer;
 code
 {
    // Get total playtime in seconds
    total_seconds := self.playtime;
    
    // Convert to hours, minutes, seconds
    hours := total_seconds / 3600;
    minutes := (total_seconds % 3600) / 60;
    seconds := total_seconds % 60;
    
    sendtext(&quot;You have played for &quot; + itoa(hours) + &quot; hours, &quot; + 
             itoa(minutes) + &quot; minutes, and &quot; + itoa(seconds) + &quot; seconds.&lt;br/&gt;&quot;, self);
    
    quit;
 } dilend

 dilbegin check_veteran_status(player : unitptr);
 var
    total_hours : integer;
 code
 {
    // Check if player has played for more than 100 hours
    total_hours := player.playtime / 3600;
    
    if (total_hours &gt; 100)
    {
       sendtext(&quot;You are a veteran player with &quot; + itoa(total_hours) + &quot; hours of playtime!&lt;br/&gt;&quot;, player);
    }
    else
    {
       sendtext(&quot;You have &quot; + itoa(total_hours) + &quot; hours of playtime. Keep playing!&lt;br/&gt;&quot;, player);
    }
    
    quit;
 } dilend

 dilbegin playingstring();
 var
    tmp_played : integer;
    hours_played : integer;
    days_played : integer;
    years_played : integer;
    time_str : string;
    tf : integer;
 code
 {
    tmp_played := self.playtime / 3600;
    hours_played := tmp_played % 24;
    days_played := ((tmp_played/24)%365);
    years_played := ((tmp_played/24)/365);
    
    tf := FALSE;
    time_str := &quot;You have been playing for&quot;;
    
    if (years_played &gt; 0)
    {
       time_str := time_str + &quot; &quot; + itoa(years_played) + &quot; years&quot;;
       tf := TRUE;
    }
    
    if ((days_played &gt; 0) and (tf == TRUE))
    {
       time_str := time_str + &quot;, &quot; + itoa(days_played) + &quot; days&quot;;
    }
    else if (days_played &gt; 0)
    {
       time_str := time_str + &quot; &quot; + itoa(days_played) + &quot; days&quot;;
       tf := TRUE;
    }
    
    if ((hours_played &gt; 0) and (tf == TRUE))
    {
       time_str := time_str + &quot;, &quot; + itoa(hours_played) + &quot; hours&quot;;
    }
    else if (hours_played &gt; 0)
    {
       time_str := time_str + &quot;, and &quot; + itoa(hours_played) + &quot; hours&quot;;
       tf := TRUE;
    }
    
    if (tf != TRUE)
       time_str := time_str + &quot; less than an hour.&lt;br/&gt;&quot;;
    else
       time_str := time_str + &quot;.&lt;br/&gt;&quot;;
    
    sendtext(time_str, self);
    quit;
 } dilend

== Usage Notes ==
* The playtime field is read-only and cannot be modified by DIL code
* The value is measured in seconds since the player&apos;s creation
* Time accumulates across all gaming sessions and is persistent
* To convert to hours, divide by 3600 (60 * 60)
* To convert to days, divide by 86400 (24 * 60 * 60)
* The field is only available on player characters (UNIT_ST_PC)
* The value includes all time the player has been connected to the game

== Error Handling ==
The field access will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Attempting to access playtime on a non-player character unit
* The unit is null or invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/birth|birth]] - The time when the PC was created (timestamp)
* [[Manual:DIL_Manual/editing|editing]] - Whether the PC is currently in edit mode
* [[Manual:DIL_Manual/hometown|hometown]] - The player&apos;s hometown setting

== See Also ==
* [[Manual:DIL_Manual/itoa|itoa]] - Convert integer to string for display
* [[Manual:DIL_Manual/sendtext|sendtext]] - Send text to a player
* [[Manual:DIL_Manual/act|act]] - Send formatted messages to units </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/position</title>
     <ns>0</ns>
     <id>317384</id>
     <revision>
       <id>974528</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of position.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= position =

 field: integer &apos;&apos;&apos;.position&apos;&apos;&apos;
 type: &apos;&apos;&apos;integer&apos;&apos;&apos;
 access: &apos;&apos;&apos;Read/Write&apos;&apos;&apos;

== Syntax ==
 unit.position

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current position of the character
|-
| Write || integer || Sets the position of the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* cmdptr (Command pointer)

== Description ==
The &apos;&apos;&apos;position&apos;&apos;&apos; field contains the current physical position of a character or the minimum position required to use a command. For characters, this represents their current state such as standing, sitting, fighting, or sleeping. For commands, it specifies the minimum position a character must be in to use that command.

Common position constants include:
* &apos;&apos;&apos;POSITION_STANDING&apos;&apos;&apos; - Character is standing
* &apos;&apos;&apos;POSITION_SITTING&apos;&apos;&apos; - Character is sitting
* &apos;&apos;&apos;POSITION_RESTING&apos;&apos;&apos; - Character is resting
* &apos;&apos;&apos;POSITION_SLEEPING&apos;&apos;&apos; - Character is sleeping
* &apos;&apos;&apos;POSITION_FIGHTING&apos;&apos;&apos; - Character is fighting
* &apos;&apos;&apos;POSITION_STUNNED&apos;&apos;&apos; - Character is stunned

== Examples ==
 dilbegin check_character_position();
 var
    current_pos : integer;
 code
 {
    current_pos := self.position;
    
    if (current_pos == POSITION_FIGHTING)
    {
       sendtext(&quot;You are currently fighting!&lt;br/&gt;&quot;, self);
    }
    else if (current_pos == POSITION_SLEEPING)
    {
       sendtext(&quot;You are sleeping and cannot do that.&lt;br/&gt;&quot;, self);
    }
    else if (current_pos == POSITION_STANDING)
    {
       sendtext(&quot;You are standing ready for action.&lt;br/&gt;&quot;, self);
    }
    else
    {
       sendtext(&quot;Your current position is: &quot; + itoa(current_pos) + &quot;&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin guard_routine();
 var
    guard_pos : integer;
 code
 {
    guard_pos := self.position;
    
    // Check if guard is awake and able to respond
    if (guard_pos &lt;= POSITION_SLEEPING)
    {
       sendtext(&quot;The guard is asleep and doesn&apos;t respond.&lt;br/&gt;&quot;, activator);
       quit;
    }
    
    // Check if guard is busy fighting
    if (guard_pos == POSITION_FIGHTING)
    {
       sendtext(&quot;The guard is busy fighting!&lt;br/&gt;&quot;, activator);
       quit;
    }
    
    // Guard is awake and available
    act(&quot;The guard says &apos;Hello there, how can I help you?&apos;&quot;, A_ALWAYS, self, null, null, TO_ROOM);
    
    quit;
 } dilend

 dilbegin force_character_stand();
 var
    target : unitptr;
 code
 {
    target := activator;
    
    if (target.position == POSITION_SLEEPING)
    {
       // Wake up the character
       target.position := POSITION_STANDING;
       act(&quot;$1n wakes up and stands up.&quot;, A_ALWAYS, target, null, null, TO_ROOM);
       sendtext(&quot;You wake up and stand up.&lt;br/&gt;&quot;, target);
    }
    else if (target.position == POSITION_SITTING)
    {
       // Make the character stand
       target.position := POSITION_STANDING;
       act(&quot;$1n stands up.&quot;, A_ALWAYS, target, null, null, TO_ROOM);
       sendtext(&quot;You stand up.&lt;br/&gt;&quot;, target);
    }
    else
    {
       sendtext(&quot;You are already standing.&lt;br/&gt;&quot;, target);
    }
    
    quit;
 } dilend

 dilbegin check_command_requirements();
 var
    cmd : cmdptr;
 code
 {
    cmd := getcommand(&quot;kick&quot;);
    
    if (cmd != null)
    {
       sendtext(&quot;Command: &quot; + cmd.name + &quot;&lt;br/&gt;&quot;, self);
       sendtext(&quot;Minimum position required: &quot; + itoa(cmd.position) + &quot;&lt;br/&gt;&quot;, self);
       sendtext(&quot;Your current position: &quot; + itoa(self.position) + &quot;&lt;br/&gt;&quot;, self);
       
       if (self.position &lt; cmd.position)
       {
          sendtext(&quot;You are not in the right position to use this command.&lt;br/&gt;&quot;, self);
       }
       else
       {
          sendtext(&quot;You can use this command in your current position.&lt;br/&gt;&quot;, self);
       }
    }
    
    quit;
 } dilend

== Usage Notes ==
* For characters, the position field represents their current physical state
* For commands, the position field specifies the minimum position required to use the command
* Use [[Manual:DIL_Manual/position_update|position_update]] after modifying HP to ensure proper position updates
* Common position checks include comparing against POSITION_SLEEPING, POSITION_FIGHTING, etc.
* Position constants are defined in values.h and/or vme.h with POSITION_ prefix
* The field is read/write for characters, allowing manual position changes

== Error Handling ==
The field access will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Attempting to access position on a non-character unit (except cmdptr)
* The unit is null or invalid
* Attempting to set an invalid position value

== Related Functions/Fields ==
* [[Manual:DIL_Manual/position_update|position_update]] - Updates character position based on current HP
* [[Manual:DIL_Manual/on_activation|on_activation]] - Can be used to check position conditions
* [[Manual:DIL_Manual/cmdptr|cmdptr]] - Command pointer type that also has position field

== See Also ==
* [[Manual:DIL_Manual/fighting|fighting]] - Field to check if character is in combat
* [[Manual:DIL_Manual/sleep|sleep]] - Command to put character to sleep
* [[Manual:DIL_Manual/wake|wake]] - Command to wake up character
* [[Manual:DIL_Manual/stand|stand]] - Command to make character stand </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/position_update</title>
     <ns>0</ns>
     <id>1270291</id>
     <revision>
       <id>1843962</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of position_update.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= position_update =

 procedure: &apos;&apos;&apos;position_update&apos;&apos;&apos;(u : unitptr);

== Syntax ==
 position_update(u : unitptr);

== Description ==
The &apos;&apos;&apos;position_update&apos;&apos;&apos; procedure updates a character&apos;s position based on their current hitpoints and other status conditions. This procedure is essential after manually modifying a character&apos;s HP field, as it ensures the character&apos;s position (standing, fighting, sleeping, dead, etc.) is properly updated to reflect their current state.

The procedure checks the character&apos;s hitpoints and automatically adjusts their position accordingly. If the character&apos;s HP drops to zero or below, they may be killed or incapacitated. The underlying C function update_pos() handles the actual position calculation and updates.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The character (PC or NPC) to update position for
|}

== Return Value ==
This procedure does not return a value.

== Examples ==
 dilbegin damage_character(target : unitptr, damage : integer);
 var
    old_hp : integer;
 code
 {
    old_hp := target.hp;
    target.hp := target.hp - damage;
    
    // Always call position_update after modifying HP
    position_update(target);
    
    if (target.hp &lt;= 0)
    {
       act(&quot;$2n has been killed!&quot;, A_ALWAYS, self, target, null, TO_ROOM);
       sendtext(&quot;You have been killed!&lt;br/&gt;&quot;, target);
    }
    else
    {
       act(&quot;$1n damages $2n for &quot; + itoa(damage) + &quot; points!&quot;, A_ALWAYS, self, target, null, TO_ROOM);
       sendtext(&quot;You damage &quot; + target.name + &quot; for &quot; + itoa(damage) + &quot; points!&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin heal_character();
 var
    heal_amount : integer;
 code
 {
    heal_amount := 50;
    self.hp := self.hp + heal_amount;
    
    // Update position after healing
    position_update(self);
    
    if (self.position == POSITION_STANDING)
    {
       sendtext(&quot;You feel fully healed and ready for action!&lt;br/&gt;&quot;, self);
    }
    else if (self.position == POSITION_RESTING)
    {
       sendtext(&quot;You feel much better but still need rest.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin poison_effect();
 var
    poison_damage : integer;
 code
 {
    poison_damage := 10;
    
    // Apply poison damage
    self.hp := self.hp - poison_damage;
    
    // Update position to check if character dies from poison
    position_update(self);
    
    if (self.hp &lt;= 0)
    {
       act(&quot;$1n writhes in agony and dies from the poison!&quot;, A_ALWAYS, self, null, null, TO_ROOM);
    }
    else
    {
       act(&quot;$1n shivers from the effects of poison.&quot;, A_ALWAYS, self, null, null, TO_ROOM);
       sendtext(&quot;You feel the poison coursing through your veins.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin item_recharge_service();
 external
    accept_dil@function(pc : unitptr, s : string);
 var
    pc : unitptr;
    item : unitptr;
 code
 {
    // Initialize service
    self.spells[SPL_RECONSTRUCT] := 200;
    self.abilities[ABIL_BRA] := 150;
    self.abilities[ABIL_MAG] := 150;
    
    // Update position after setting up abilities
    position_update(self);
    
    // Service logic continues...
    quit;
 } dilend

== Usage Notes ==
* Always call &apos;&apos;&apos;position_update&apos;&apos;&apos; after manually modifying a character&apos;s HP field
* The procedure automatically determines the appropriate position based on HP and other factors
* If the character dies (HP &lt;= 0), the procedure will handle death processing
* The procedure may trigger secure() checks if the character is destroyed
* Position constants like POSITION_DEAD, POSITION_STUNNED, POSITION_FIGHTING are used internally
* This is essential for maintaining game consistency when modifying character health

== Error Handling ==
The procedure will fail when:
* The parameter is not a valid unitptr
* The unit is not a character (PC or NPC)
* The unit is null or invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/position|position]] - Field to read or set character position directly
* [[Manual:DIL_Manual/hp|hp]] - Field representing character&apos;s hitpoints
* [[Manual:DIL_Manual/secure|secure]] - Function that may be triggered if character dies during position_update
* [[Manual:DIL_Manual/die|die]] - Function called if character position becomes POSITION_DEAD

== See Also ==
* [[Manual:DIL_Manual/meleedamage|meleedamage]] - Function that automatically calls position_update
* [[Manual:DIL_Manual/cast_spell|cast_spell]] - Function that may affect character position
* [[Manual:DIL_Manual/abilities|abilities]] - Field that may affect character capabilities
* [[Manual:DIL_Manual/update_pos|update_pos]] - Underlying C function that performs the position calculation </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/power</title>
     <ns>0</ns>
     <id>958169</id>
     <revision>
       <id>1242953</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of power.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= power =

 variable: &apos;&apos;&apos;power&apos;&apos;&apos;
 type: &apos;&apos;&apos;integer&apos;&apos;&apos;
 access: &apos;&apos;&apos;Read/Write&apos;&apos;&apos;

== Syntax ==
 power

== Description ==
The &apos;&apos;&apos;power&apos;&apos;&apos; variable is a built-in integer variable that represents the power level of certain actions, particularly in spell casting and damage contexts. It is commonly used in permission messages and damage calculations to control the magnitude or effectiveness of an action.

The power variable is context-dependent and its meaning changes based on the situation:
* In spell casting contexts, it represents the spell&apos;s power or effectiveness
* In damage contexts, it represents the amount of damage being dealt
* In permission checks, it can be modified to allow or block certain actions

The variable can be reassigned during DIL execution to modify the power of ongoing actions.

== Examples ==
 dilbegin spell_power_control();
 var
    spell_power : integer;
 code
 {
    // Check current spell power
    spell_power := power;
    
    if (spell_power &gt; 100)
    {
       sendtext(&quot;This is a very powerful spell!&lt;br/&gt;&quot;, self);
    }
    else if (spell_power &gt; 50)
    {
       sendtext(&quot;This is a moderately powerful spell.&lt;br/&gt;&quot;, self);
    }
    else
    {
       sendtext(&quot;This is a weak spell.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin damage_permission();
 var
    damage_amount : integer;
 code
 {
    // Set power for damage request
    damage_amount := 100;
    power := damage_amount;
    
    // Check if target can handle this damage
    if (activator.level &lt; 10)
    {
       // Reduce power for low-level players
       power := 50;
       sendtext(&quot;Your damage is reduced to &quot; + itoa(power) + &quot; due to your level.&lt;br/&gt;&quot;, activator);
    }
    
    sendtext(&quot;Damage power set to: &quot; + itoa(power) + &quot;&lt;br/&gt;&quot;, self);
    
    quit;
 } dilend

 dilbegin spell_interception();
 var
    original_power : integer;
 code
 {
    // Store original power
    original_power := power;
    
    // Check if this is a harmful spell
    if (command(&quot;cast&quot;) and (argument == &quot;fireball&quot;))
    {
       // Block the spell by setting power to -1
       power := -1;
       sendtext(&quot;Fireball spells are not allowed here!&lt;br/&gt;&quot;, activator);
       block;
    }
    
    // Restore original power for other spells
    power := original_power;
    
    quit;
 } dilend

 dilbegin adaptive_damage();
 var
    base_damage : integer;
    target_level : integer;
 code
 {
    base_damage := 50;
    target_level := target.level;
    
    // Adjust power based on target level
    if (target_level &gt; 20)
    {
       power := base_damage / 2; // Reduce damage for high-level targets
    }
    else if (target_level &lt; 5)
    {
       power := base_damage / 2; // Reduce damage for low-level targets
    }
    else
    {
       power := base_damage; // Normal damage
    }
    
    act(&quot;$1n adjusts attack power to &quot; + itoa(power) + &quot;.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
    
    quit;
 } dilend

== Usage Notes ==
* The power variable is only available in specific contexts like SFB_PRE events
* It is automatically set by the system based on the action being performed
* The variable can be modified to change the effectiveness of spells or damage
* Setting power to -1 typically blocks or cancels the action
* The variable is reset for each new action or event
* Power values are context-dependent and may represent different things in different situations

== Error Handling ==
The variable access will fail when:
* Attempting to access power outside of valid contexts (like SFB_PRE events)
* The variable is not initialized for the current action type

== Related Functions/Fields ==
* [[Manual:DIL_Manual/send_pre|send_pre]] - Function that uses power for message power level
* [[Manual:DIL_Manual/send_done|send_done]] - Function that includes power in message parameters
* [[Manual:DIL_Manual/SFB_PRE|SFB_PRE]] - Event flag that enables power variable access
* [[Manual:DIL_Manual/command|command]] - Function to check current command being executed

== See Also ==
* [[Manual:DIL_Manual/argument|argument]] - Variable containing command arguments
* [[Manual:DIL_Manual/activator|activator]] - Variable containing the unit that triggered the action
* [[Manual:DIL_Manual/target|target]] - Variable containing the target of the action
* [[Manual:DIL_Manual/medium|medium]] - Variable containing the medium through which action occurs </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/priority</title>
     <ns>0</ns>
     <id>520428</id>
     <revision>
       <id>1014426</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of priority.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= priority =

 procedure: &apos;&apos;&apos;priority&apos;&apos;&apos;();

== Syntax ==
 priority();

== Description ==
The &apos;&apos;&apos;priority&apos;&apos;&apos; procedure sets the current DIL program to have priority over other DIL programs. When priority is set, no other DIL programs with lower priority will be executed until the &apos;&apos;&apos;nopriority&apos;&apos;&apos; procedure is called or the program terminates.

This procedure is used to ensure that critical DIL routines can execute without interference from other programs that might be attached to the same unit or in the same environment. It&apos;s commonly used in rescue missions, time-sensitive actions, or when a character needs to maintain control over their actions.

== Return Value ==
This procedure does not return a value.

== Examples ==
 dilbegin rescue_mission(target_room : string);
 external
    unit_room@function(u : unitptr);
    walk_room@function(s : string, i : integer);
 var
    current_room : unitptr;
 code
 {
    current_room := unit_room@function(self);
    
    if (current_room.symname != target_room)
    {
       // Set priority to ensure uninterrupted rescue
       priority;
       self.outside_descr := &quot;I must rescue someone in &quot; + target_room + &quot;!&quot;;
       
       // Walk to target location
       walk_room@function(target_room, 8);
       
       // Arrived at target, allow other DILs to take over
       nopriority;
       self.outside_descr := &quot;I&apos;m ready to begin the rescue!&quot;;
    }
    else
    {
       sendtext(&quot;You&apos;re already at the rescue location.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin urgent_message();
 var
    message : string;
 code
 {
    message := &quot;This is an urgent announcement that must not be interrupted!&quot;;
    
    // Set priority to ensure message delivery
    priority;
    
    // Send the message to all players
    send_to_all(message);
    
    // Brief pause to ensure message is seen
    pause;
    
    // Release priority for other programs
    nopriority;
    
    quit;
 } dilend

 dilbegin combat_mode();
 var
    combat_active : integer;
 code
 {
    combat_active := (self.position == POSITION_FIGHTING);
    
    if (combat_active)
    {
       // Set priority during combat to prevent interference
       priority;
       
       // Combat-specific actions here
       self.outside_descr := &quot;You focus entirely on the battle!&quot;;
       
       // Wait until combat ends
       while (self.position == POSITION_FIGHTING)
       {
          wait(SFB_TICK, TRUE);
       }
       
       // Release priority when combat ends
       nopriority;
       self.outside_descr := &quot;You relax your combat stance.&quot;;
    }
    
    quit;
 } dilend

 dilbegin time_sensitive_action();
 var
    countdown : integer;
 code
 {
    countdown := 10;
    
    // Set priority for countdown sequence
    priority;
    
    while (countdown &gt; 0)
    {
       act(&quot;$1n counts down: &quot; + itoa(countdown) + &quot;...&quot;, A_ALWAYS, self, null, null, TO_ROOM);
       sendtext(&quot;Countdown: &quot; + itoa(countdown) + &quot;&lt;br/&gt;&quot;, self);
       
       countdown := countdown - 1;
       heartbeat := PULSE_SEC * 2;
       pause;
    }
    
    // Time&apos;s up, release priority
    nopriority;
    act(&quot;$1n&apos;s countdown is complete!&quot;, A_ALWAYS, self, null, null, TO_ROOM);
    
    quit;
 } dilend

== Usage Notes ==
* Use &apos;&apos;&apos;priority&apos;&apos;&apos; to prevent other DIL programs from interrupting critical actions
* The priority remains in effect until &apos;&apos;&apos;nopriority&apos;&apos;&apos; is called or the program ends
* Only one DIL program can have priority at a time per unit/environment
* Common usage patterns include: priority  critical actions  nopriority
* The procedure is essential for rescue missions, timed events, and combat sequences
* Multiple programs can use priority in sequence, but only one is active at a time

== Error Handling ==
The procedure will fail when:
* Called from a DIL program that doesn&apos;t have proper execution context
* The system cannot set priority due to internal state conflicts

== Related Functions/Fields ==
* [[Manual:DIL_Manual/nopriority|nopriority]] - Procedure to cancel priority and allow other DIL programs to execute
* [[Manual:DIL_Manual/SFB_PRIORITY|SFB_PRIORITY]] - Event flag that enables priority-based execution control
* [[Manual:DIL_Manual/pause|pause]] - Often used with priority to maintain control during sequences
* [[Manual:DIL_Manual/wait|wait]] - Used with priority to control execution flow

== See Also ==
* [[Manual:DIL_Manual/secure|secure]] - Function for protecting units during critical operations
* [[Manual:DIL_Manual/position|position]] - Field that may affect DIL program execution
* [[Manual:DIL_Manual/outside_descr|outside_descr]] - Field commonly modified during priority sequences
* [[Manual:DIL_Manual/send_to_all|send_to_all]] - Function for sending messages to all players </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/profession</title>
     <ns>0</ns>
     <id>812007</id>
     <revision>
       <id>1623443</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of profession.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= profession =

 field: integer &apos;&apos;&apos;.profession&apos;&apos;&apos;
 type: &apos;&apos;&apos;integer&apos;&apos;&apos;
 access: &apos;&apos;&apos;Read-only&apos;&apos;&apos;

== Syntax ==
 unit.profession

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the profession of the player character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Description ==
The &apos;&apos;&apos;profession&apos;&apos;&apos; field contains the profession identifier for a player character. This field determines the character&apos;s class or career path and is commonly used to provide profession-specific equipment, abilities, or access to certain areas.

Common profession constants include:
* &apos;&apos;&apos;PROFESSION_CONJURER&apos;&apos;&apos; - Magic user specializing in conjuration spells
* &apos;&apos;&apos;PROFESSION_PRIEST&apos;&apos;&apos; - Religious character with healing and divine powers
* &apos;&apos;&apos;PROFESSION_FIGHTER&apos;&apos;&apos; - Combat specialist focused on melee weapons
* &apos;&apos;&apos;PROFESSION_THIEF&apos;&apos;&apos; - Stealthy character skilled in disarming and backstabbing
* &apos;&apos;&apos;PROFESSION_ASSASSIN&apos;&apos;&apos; - Specialized killer with advanced stealth techniques
* &apos;&apos;&apos;PROFESSION_RANGER&apos;&apos;&apos; - Wilderness expert with nature and tracking skills
* &apos;&apos;&apos;PROFESSION_SORCERER&apos;&apos;&apos; - Magic user specializing in offensive spells
* &apos;&apos;&apos;PROFESSION_PALADIN&apos;&apos;&apos; - Holy warrior with divine combat abilities
* &apos;&apos;&apos;PROFESSION_NECROMANCER&apos;&apos;&apos; - Dark magic user specializing in death and undead
* &apos;&apos;&apos;PROFESSION_DRUID&apos;&apos;&apos; - Nature-based magic user with shapeshifting abilities
* &apos;&apos;&apos;PROFESSION_KNIGHT&apos;&apos;&apos; - Armored warrior with chivalric combat skills
* &apos;&apos;&apos;PROFESSION_BARBARIAN&apos;&apos;&apos; - Fierce warrior from tribal backgrounds

== Examples ==
 dilbegin profession_equipment();
 var
    prof : integer;
 code
 {
    prof := self.profession;
    
    if (prof == PROFESSION_FIGHTER)
    {
       sendtext(&quot;You are a mighty fighter! Here&apos;s your sword and shield.&lt;br/&gt;&quot;, self);
    }
    else if (prof == PROFESSION_MAGE)
    {
       sendtext(&quot;You are a wise mage! Here&apos;s your spellbook and staff.&lt;br/&gt;&quot;, self);
    }
    else if (prof == PROFESSION_CLERIC)
    {
       sendtext(&quot;You are a devout cleric! Here&apos;s your holy symbol and mace.&lt;br/&gt;&quot;, self);
    }
    else
    {
       sendtext(&quot;Your profession is: &quot; + itoa(prof) + &quot;&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin profession_greeting();
 var
    player_prof : integer;
 code
 {
    player_prof := activator.profession;
    
    if (player_prof == PROFESSION_THIEF)
    {
       act(&quot;Welcome back, shadow walker! The shadows await your skills.&quot;, 
          A_ALWAYS, self, null, activator, TO_CHAR);
    }
    else if (player_prof == PROFESSION_PALADIN)
    {
       act(&quot;Greetings, noble warrior! May justice guide your blade.&quot;, 
          A_ALWAYS, self, null, activator, TO_CHAR);
    }
    else if (player_prof == PROFESSION_RANGER)
    {
       act(&quot;Hail, guardian of the wild! Nature calls to you.&quot;, 
          A_ALWAYS, self, null, activator, TO_CHAR);
    }
    else if (player_prof == PROFESSION_DRUID)
    {
       act(&quot;Blessings, child of nature! The forest sings your name.&quot;, 
          A_ALWAYS, self, null, activator, TO_CHAR);
    }
    else
    {
       act(&quot;Welcome, adventurer! May your path be true.&quot;, 
          A_ALWAYS, self, null, activator, TO_CHAR);
    }
    
    quit;
 } dilend

 dilbegin profession_restriction();
 var
    target_prof : integer;
 code
 {
    target_prof := target.profession;
    
    // Check if target can enter restricted area
    if (target_prof == PROFESSION_NECROMANCER)
    {
       act(&quot;The holy grounds reject your dark presence, necromancer!&quot;, 
          A_ALWAYS, self, null, target, TO_VICT);
       act(&quot;$1n blocks $3n from entering the sacred area.&quot;, 
          A_ALWAYS, self, null, target, TO_ROOM);
    }
    else if (target_prof == PROFESSION_ASSASSIN)
    {
       act(&quot;The guards recognize you as an assassin and deny entry!&quot;, 
          A_ALWAYS, self, null, target, TO_VICT);
       act(&quot;$1n prevents $3n from entering the city.&quot;, 
          A_ALWAYS, self, null, target, TO_ROOM);
    }
    else
    {
       act(&quot;Welcome, traveler! The city gates open for you.&quot;, 
          A_ALWAYS, self, null, target, TO_VICT);
    }
    
    quit;
 } dilend

 dilbegin profession_bonus();
 var
    prof : integer;
 code
 {
    prof := self.profession;
    
    // Give profession-specific bonuses
    if (prof == PROFESSION_FIGHTER)
    {
       self.abilities[ABIL_STR] := self.abilities[ABIL_STR] + 5;
       sendtext(&quot;Your fighting spirit enhances your strength!&lt;br/&gt;&quot;, self);
    }
    else if (prof == PROFESSION_MAGE)
    {
       self.abilities[ABIL_MAG] := self.abilities[ABIL_MAG] + 5;
       sendtext(&quot;Your magical focus enhances your power!&lt;br/&gt;&quot;, self);
    }
    else if (prof == PROFESSION_CLERIC)
    {
       self.abilities[ABIL_DIV] := self.abilities[ABIL_DIV] + 5;
       sendtext(&quot;Your faith enhances your divine power!&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

== Usage Notes ==
* The profession field is read-only and cannot be modified by DIL code
* Profession is typically set during character creation or through special commands
* The field is only available on player characters (UNIT_ST_PC)
* Profession constants are defined in values.h and/or vme.h with PROFESSION_ prefix
* This field is commonly used for profession-specific equipment distribution and area restrictions

== Error Handling ==
The field access will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Attempting to access profession on a non-player character unit
* The unit is null or invalid
* The zone has insufficient access level to read profession information

== Related Functions/Fields ==
* [[Manual:DIL_Manual/level|level]] - Field representing character&apos;s level
* [[Manual:DIL_Manual/abilities|abilities]] - Array of character&apos;s ability scores
* [[Manual:DIL_Manual/skills|skills]] - Array of character&apos;s skill levels
* [[Manual:DIL_Manual/equipment|equipment]] - Function to manage character equipment

== See Also ==
* [[Manual:DIL_Manual/PROFESSION_* constants|PROFESSION_* constants]] - Profession identifier constants
* [[Manual:DIL_Manual/race|race]] - Field for character&apos;s racial type
* [[Manual:DIL_Manual/sex|sex]] - Field for character&apos;s gender
* [[Manual:DIL_Manual/guild|guild]] - Field for character&apos;s guild affiliation </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/prompt</title>
     <ns>0</ns>
     <id>389169</id>
     <revision>
       <id>1240828</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of prompt.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= prompt =

 field: string &apos;&apos;&apos;.prompt&apos;&apos;&apos;
 type: &apos;&apos;&apos;string&apos;&apos;&apos;
 access: &apos;&apos;&apos;Read/Write&apos;&apos;&apos;

== Syntax ==
 unit.prompt

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || string || Returns the current prompt string of the player
|-
| Write || string || Sets the prompt string for the player
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Description ==
The &apos;&apos;&apos;prompt&apos;&apos;&apos; field contains the command prompt string that is displayed to a player when they are ready to input commands. This string can include special format codes that display real-time character information such as health, mana, endurance, and other stats.

Common prompt format codes include:
* &apos;&apos;&apos;%h&apos;&apos;&apos; - Current hitpoints
* &apos;&apos;&apos;%H&apos;&apos;&apos; - Maximum hitpoints
* &apos;&apos;&apos;%m&apos;&apos;&apos; - Current mana points
* &apos;&apos;&apos;%M&apos;&apos;&apos; - Maximum mana points
* &apos;&apos;&apos;%e&apos;&apos;&apos; - Current endurance points
* &apos;&apos;&apos;%E&apos;&apos;&apos; - Maximum endurance points
* &apos;&apos;&apos;%n&apos;&apos;&apos; - Player&apos;s name
* &apos;&apos;&apos;%t&apos;&apos;&apos; - Player&apos;s title
* &apos;&apos;&apos;%l&apos;&apos;&apos; - Player&apos;s level
* &apos;&apos;&apos;%g&apos;&apos;&apos; - Player&apos;s gold amount
* &apos;&apos;&apos;%s&apos;&apos;&apos; - Current movement points (if applicable)
* &apos;&apos;&apos;%S&apos;&apos;&apos; - Maximum movement points (if applicable)
* &apos;&apos;&apos;%%&apos;&apos;&apos; - Literal percent sign

== Examples ==
 dilbegin set_custom_prompt();
 var
    new_prompt : string;
 code
 {
    // Set a custom prompt with health and mana
    new_prompt := &quot;[%n%h/%H%m/%M]&gt; &quot;;
    self.prompt := new_prompt;
    
    sendtext(&quot;Your prompt has been set to: &quot; + new_prompt + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Example display: [&quot; + self.name + &quot;50/100100/200]&gt; &lt;br/&gt;&quot;, self);
    
    quit;
 } dilend

 dilbegin prompt_menu();
 var
    choice : string;
 code
 {
    sendtext(&quot;Prompt Options:&lt;br/&gt;&quot;, self);
    sendtext(&quot;1. Default prompt&lt;br/&gt;&quot;, self);
    sendtext(&quot;2. Combat prompt&lt;br/&gt;&quot;, self);
    sendtext(&quot;3. Simple prompt&lt;br/&gt;&quot;, self);
    sendtext(&quot;4. Blank prompt&lt;br/&gt;&quot;, self);
    sendtext(&quot;Enter your choice (1-4): &quot;, self);
    
    wait(SFB_CMD, TRUE);
    choice := argument;
    
    if (choice == &quot;1&quot;)
    {
       self.prompt := &quot;%n%h/%Hhp %m/%M mana&gt; &quot;;
       sendtext(&quot;Default prompt set.&lt;br/&gt;&quot;, self);
    }
    else if (choice == &quot;2&quot;)
    {
       self.prompt := &quot;[COMBAT: %n%h/%Hhp] &quot;;
       sendtext(&quot;Combat prompt set.&lt;br/&gt;&quot;, self);
    }
    else if (choice == &quot;3&quot;)
    {
       self.prompt := &quot;%n&gt; &quot;;
       sendtext(&quot;Simple prompt set.&lt;br/&gt;&quot;, self);
    }
    else if (choice == &quot;4&quot;)
    {
       self.prompt := &quot;&quot;;
       sendtext(&quot;Blank prompt set.&lt;br/&gt;&quot;, self);
    }
    else
    {
       sendtext(&quot;Invalid choice.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin show_prompt_info();
 var
    current_prompt : string;
 code
 {
    current_prompt := self.prompt;
    
    sendtext(&quot;Your current prompt is: &quot; + current_prompt + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;This prompt will be displayed as: &quot; + current_prompt + &quot;&lt;br/&gt;&quot;, self);
    
    // Show what the prompt looks like with example values
    sendtext(&quot;Example with your current stats:&lt;br/&gt;&quot;, self);
    sendtext(&quot;[&quot; + self.name + &quot;50/100100/200]&gt; &lt;br/&gt;&quot;, self);
    
    quit;
 } dilend

 dilbegin conditional_prompt();
 var
    is_fighting : integer;
 code
 {
    is_fighting := (self.position == POSITION_FIGHTING);
    
    if (is_fighting)
    {
       // Show combat prompt when fighting
       self.prompt := &quot;[FIGHT: %n%h/%Hhp] &quot;;
       sendtext(&quot;Combat prompt activated.&lt;br/&gt;&quot;, self);
    }
    else
    {
       // Show normal prompt when not fighting
       self.prompt := &quot;%n%h/%H%m/%M&gt; &quot;;
       sendtext(&quot;Normal prompt activated.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

== Usage Notes ==
* The prompt field is only available on player characters (UNIT_ST_PC)
* Format codes are processed in real-time when the prompt is displayed
* The percent sign (%) is used to escape literal percent characters
* Empty string (&quot;&quot;) results in no prompt being displayed
* Prompt changes take effect immediately and persist across logins
* The field can be modified by DIL code or player commands
* Maximum prompt length may be limited by the game client

== Error Handling ==
The field access will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Attempting to access prompt on a non-player character unit
* The unit is null or invalid
* The player has the &quot;$noprompt&quot; extra description flag set

== Related Functions/Fields ==
* [[Manual:DIL_Manual/sendtext|sendtext]] - Function to send text to player&apos;s screen
* [[Manual:DIL_Manual/exec|exec]] - Function to execute commands for player
* [[Manual:DIL_Manual/position|position]] - Field that may affect prompt display
* [[Manual:DIL_Manual/extra|extra]] - Field to access extra descriptions like &quot;$noprompt&quot;

== See Also ==
* [[Manual:DIL_Manual/%h|%h]] - Health display format code
* [[Manual:DIL_Manual/%m|%m]] - Mana display format code
* [[Manual:DIL_Manual/%e|%e]] - Endurance display format code
* [[Manual:DIL_Manual/%n|%n]] - Name display format code
* [[Manual:DIL_Manual/title|title]] - Field for player&apos;s title used in %t </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/purse</title>
     <ns>0</ns>
     <id>848816</id>
     <revision>
       <id>1512097</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of purse.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= purse =

 function: integer &apos;&apos;&apos;purse&apos;&apos;&apos;(u : unitptr, coinage : integer);

== Syntax ==
 integer purse(u : unitptr, coinage : integer);

== Description ==
The &apos;&apos;&apos;purse&apos;&apos;&apos; function counts the number of money units of a specific type that a character is carrying. It searches through all money objects contained within the character&apos;s inventory and returns the total count of the specified coin type.

The function is commonly used to check if a character has sufficient funds for purchases, to display wealth information, or to implement money splitting among group members.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The character whose money should be counted
|-
| coinage || integer || The type of money to count (e.g., GOLD_PIECE, PLATINUM_PIECE)
|}

== Return Value ==
Returns integer:
* &apos;&apos;&apos;integer&apos;&apos;&apos; - Total number of money units of the specified type found in character&apos;s inventory
* &apos;&apos;&apos;0&apos;&apos;&apos; - When no money of that type is found

== Examples ==
 dilbegin check_wealth();
 var
    gold_pieces : integer;
    silver_pieces : integer;
    copper_pieces : integer;
 code
 {
    gold_pieces := purse(self, GOLD_PIECE);
    silver_pieces := purse(self, SILVER_PIECE);
    copper_pieces := purse(self, COPPER_PIECE);
    
    sendtext(&quot;You are carrying:&lt;br/&gt;&quot;, self);
    sendtext(itoa(gold_pieces) + &quot; gold pieces&lt;br/&gt;&quot;, self);
    sendtext(itoa(silver_pieces) + &quot; silver pieces&lt;br/&gt;&quot;, self);
    sendtext(itoa(copper_pieces) + &quot; copper pieces&lt;br/&gt;&quot;, self);
    
    quit;
 } dilend

 dilbegin can_afford(item_cost : integer);
 var
    player_money : integer;
 code
 {
    // Check if player can afford an item costing 100 gold pieces
    player_money := purse(activator, GOLD_PIECE);
    
    if (player_money &gt;= item_cost)
    {
       sendtext(&quot;You can afford this item!&lt;br/&gt;&quot;, activator);
       act(&quot;$1n purchases an item.&quot;, A_ALWAYS, activator, null, null, TO_ROOM);
    }
    else
    {
       sendtext(&quot;You don&apos;t have enough gold. You need &quot; + itoa(item_cost) + 
                &quot; but only have &quot; + itoa(player_money) + &quot;.&lt;br/&gt;&quot;, activator);
    }
    
    quit;
 } dilend

 dilbegin split_money(group_size : integer);
 var
    total_coins : integer;
    coins_per_person : integer;
    i : integer;
    target : unitptr;
 code
 {
    // Count total platinum pieces in the group
    total_coins := purse(self, PLATINUM_PIECE);
    
    if (total_coins &lt; group_size)
    {
       sendtext(&quot;Not enough coins to split among &quot; + itoa(group_size) + &quot; people.&lt;br/&gt;&quot;, self);
       quit;
    }
    
    coins_per_person := total_coins / group_size;
    
    // Distribute coins to group members
    target := self.follower;
    i := 1;
    
    while (target != null and i &lt;= group_size)
    {
       // Give coins to each person
       if (target.type == UNIT_ST_PC)
       {
          sendtext(&quot;You receive &quot; + itoa(coins_per_person) + &quot; platinum pieces.&lt;br/&gt;&quot;, target);
       act(&quot;$1n gives money to $3n.&quot;, A_ALWAYS, self, null, target, TO_VICT);
       }
       
       target := target.follower;
       i := i + 1;
    }
    
    quit;
 } dilend

 dilbegin money_checker();
 var
    has_gold : integer;
    has_silver : integer;
    has_copper : integer;
 code
 {
    has_gold := (purse(self, GOLD_PIECE) &gt; 0);
    has_silver := (purse(self, SILVER_PIECE) &gt; 0);
    has_copper := (purse(self, COPPER_PIECE) &gt; 0);
    
    if (has_gold and has_silver and has_copper)
    {
       sendtext(&quot;You have a variety of coins!&lt;br/&gt;&quot;, self);
    }
    else if (has_gold)
    {
       sendtext(&quot;You have gold pieces.&lt;br/&gt;&quot;, self);
    }
    else if (has_silver)
    {
       sendtext(&quot;You have silver pieces.&lt;br/&gt;&quot;, self);
    }
    else if (has_copper)
    {
       sendtext(&quot;You have copper pieces.&lt;br/&gt;&quot;, self);
    }
    else
    {
       sendtext(&quot;You don&apos;t have any money.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

== Usage Notes ==
* The function only counts money objects, not money stored in other forms
* Money objects must be in the character&apos;s direct inventory (not in containers)
* Common coin type constants include GOLD_PIECE, SILVER_PIECE, COPPER_PIECE, PLATINUM_PIECE
* The function returns 0 if no money of that type is found
* Money objects are typically created by the game&apos;s economic system
* The function is useful for wealth checking and transaction validation

== Error Handling ==
The function will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* The first parameter is not a valid unitptr
* The second parameter is not a valid integer
* The unit is null or invalid
* The coinage parameter is not a recognized money type

== Related Functions/Fields ==
* [[Manual:DIL_Manual/money|money]] - Field for direct money access on units
* [[Manual:DIL_Manual/transfermoney|transfermoney]] - Function to transfer money between characters
* [[Manual:DIL_Manual/load|load]] - Function to create money objects
* [[Manual:DIL_Manual/destroy|destroy]] - Function to remove money objects

== See Also ==
* [[Manual:DIL_Manual/GOLD_PIECE|GOLD_PIECE]] - Constant for gold piece type
* [[Manual:DIL_Manual/SILVER_PIECE|SILVER_PIECE]] - Constant for silver piece type
* [[Manual:DIL_Manual/COPPER_PIECE|COPPER_PIECE]] - Constant for copper piece type
* [[Manual:DIL_Manual/PLATINUM_PIECE|PLATINUM_PIECE]] - Constant for platinum piece type
* [[Manual:DIL_Manual/equipment|equipment]] - Function to manage character equipment slots </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/quests</title>
     <ns>0</ns>
     <id>1247640</id>
     <revision>
       <id>1345508</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of quests.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= quests =

 field: extraptr &apos;&apos;&apos;.quests&apos;&apos;&apos;
 type: &apos;&apos;&apos;extraptr&apos;&apos;&apos;
 access: &apos;&apos;&apos;Read/Write&apos;&apos;&apos;

== Syntax ==
 unit.quests

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || extraptr || Returns the quest extra description pointer
|-
| Write || extraptr || Sets the quest extra description pointer
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Description ==
The &apos;&apos;&apos;quests&apos;&apos;&apos; field contains an extra description pointer that manages a player&apos;s quest information. This field provides access to a linked list of quest entries, where each entry contains quest names, descriptions, and completion status.

The quests field is an extraptr that can be manipulated using extra description functions to add, remove, or search for specific quests.

== Examples ==
 dilbegin check_quest_status(quest_name : string);
 var
    quest_extra : extraptr;
    found_quest : extraptr;
 code
 {
    // Search for a specific quest
    found_quest := quest_name in self.quests;
    
    if (found_quest != null)
    {
       sendtext(&quot;You have the quest: &quot; + quest_name + &quot;&lt;br/&gt;&quot;, self);
       sendtext(&quot;Quest description: &quot; + found_quest.descr + &quot;&lt;br/&gt;&quot;, self);
    }
    else
    {
       sendtext(&quot;You don&apos;t have the quest: &quot; + quest_name + &quot;&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin add_new_quest(quest_name : string, quest_desc : string);
 var
    quest_list : stringlist;
 code
 {
    // Add a new quest to the player&apos;s quest list
    addextra(self.quests, quest_name, quest_desc);
    
    sendtext(&quot;Quest added: &quot; + quest_name + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Description: &quot; + quest_desc + &quot;&lt;br/&gt;&quot;, self);
    
    quit;
 } dilend

 dilbegin remove_completed_quest(quest_name : string);
 var
    quest_extra : extraptr;
 code
 {
    // Remove a specific quest from the player&apos;s quest list
    subextra(self.quests, quest_name);
    
    sendtext(&quot;Quest removed: &quot; + quest_name + &quot;&lt;br/&gt;&quot;, self);
    
    quit;
 } dilend

 dilbegin list_all_quests();
 var
    current_quest : extraptr;
    quest_count : integer;
    quest_names : stringlist;
 code
 {
    quest_count := 0;
    current_quest := self.quests;
    
    // Build a list of all quest names
    while (current_quest != null)
    {
       quest_names := quest_names + current_quest.names;
       quest_count := quest_count + 1;
       current_quest := current_quest.next;
    }
    
    sendtext(&quot;You have &quot; + itoa(quest_count) + &quot; quests:&lt;br/&gt;&quot;, self);
    
    // Display all quest names
    while (quest_count &gt; 0)
    {
       sendtext(&quot;- &quot; + quest_names.[quest_count - 1] + &quot;&lt;br/&gt;&quot;, self);
       quest_count := quest_count - 1;
    }
    
    quit;
 } dilend

 dilbegin quest_progress_check();
 var
    total_quests : integer;
    completed_quests : integer;
    current_quest : extraptr;
 code
 {
    total_quests := 0;
    completed_quests := 0;
    current_quest := self.quests;
    
    // Count total and completed quests
    while (current_quest != null)
    {
       total_quests := total_quests + 1;
       
       // Check if quest is completed (example: checking vals array)
       if (length(current_quest.vals) &gt; 0)
       {
          completed_quests := completed_quests + 1;
       }
       
       current_quest := current_quest.next;
    }
    
    sendtext(&quot;Quest Progress: &quot; + itoa(completed_quests) + &quot;/&quot; + itoa(total_quests) + &quot; completed&lt;br/&gt;&quot;, self);
    
    quit;
 } dilend

== Usage Notes ==
* The quests field is an extraptr that points to a linked list of quest entries
* Each quest entry contains names, descriptions, and status information
* Use &apos;&apos;&apos;addextra&apos;&apos;&apos; to add new quests to the list
* Use &apos;&apos;&apos;subextra&apos;&apos;&apos; to remove specific quests from the list
* Use the &apos;&apos;&apos;in&apos;&apos;&apos; operator to search for quests by name
* Quest data is persistent and saved with the player character
* The field is only available on player characters (UNIT_ST_PC)

== Error Handling ==
The field access will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Attempting to access quests on a non-player character unit
* The unit is null or invalid
* Memory allocation fails during quest manipulation

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addextra|addextra]] - Function to add new quest entries
* [[Manual:DIL_Manual/subextra|subextra]] - Function to remove quest entries
* [[Manual:DIL_Manual/extraptr|extraptr]] - Type for quest extra description pointers
* [[Manual:DIL_Manual/in|in]] - Operator to search within extra description lists

== See Also ==
* [[Manual:DIL_Manual/extra|extra]] - Field for accessing other extra descriptions
* [[Manual:DIL_Manual/names|names]] - Field to access quest names
* [[Manual:DIL_Manual/descr|descr]] - Field to access quest descriptions
* [[Manual:DIL_Manual/vals|vals]] - Field to access quest values/status </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/quit</title>
     <ns>0</ns>
     <id>409320</id>
     <revision>
       <id>1174193</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of quit.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= quit =
 procedure: &apos;&apos;&apos;quit&apos;&apos;&apos;();

The &apos;&apos;&apos;quit&apos;&apos;&apos; procedure immediately terminates the current DIL program execution.

== Description ==
The &apos;&apos;&apos;quit&apos;&apos;&apos; procedure immediately terminates the current DIL program execution. This is a fundamental control flow command that stops all further processing in the current DIL program and returns control to the calling context or terminates the program entirely.

The quit procedure is commonly used for:
* Ending program execution when conditions are met
* Exiting from error conditions or invalid states
* Terminating loops and wait states
* Providing clean exit points in complex DIL logic

== Examples ==

== Examples ==
 dilbegin simple_command();
 var
    input : string;
 code
 {
    sendtext(&quot;Type &apos;exit&apos; to quit, or anything to continue: &quot;, self);
    
    wait(SFB_CMD, TRUE);
    input := argument;
    
    if (input == &quot;exit&quot;)
    {
       sendtext(&quot;Goodbye!&lt;br/&gt;&quot;, self);
       quit;
    }
    else
    {
       sendtext(&quot;Continuing...&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin error_handling();
 var
    error_count : integer;
 code
 {
    error_count := 0;
    
    :error_loop:
    error_count := error_count + 1;
    
    if (error_count &gt; 3)
    {
       sendtext(&quot;Too many errors. Quitting...&lt;br/&gt;&quot;, self);
       quit;
    }
    
    sendtext(&quot;Error occurred. Try again.&lt;br/&gt;&quot;, self);
    goto error_loop;
 } dilend

 dilbegin menu_system();
 var
    choice : string;
 code
 {
    sendtext(&quot;Main Menu:&lt;br/&gt;&quot;, self);
    sendtext(&quot;1. Start quest&lt;br/&gt;&quot;, self);
    sendtext(&quot;2. View stats&lt;br/&gt;&quot;, self);
    sendtext(&quot;3. Exit&lt;br/&gt;&quot;, self);
    
    wait(SFB_CMD, TRUE);
    choice := argument;
    
    if (choice == &quot;1&quot;)
    {
       sendtext(&quot;Starting quest...&lt;br/&gt;&quot;, self);
       // Quest logic would go here
    }
    else if (choice == &quot;2&quot;)
    {
       sendtext(&quot;Displaying stats...&lt;br/&gt;&quot;, self);
       // Stats display logic would go here
    }
    else if (choice == &quot;3&quot;)
    {
       sendtext(&quot;Exiting...&lt;br/&gt;&quot;, self);
       quit;
    }
    else
    {
       sendtext(&quot;Invalid choice.&lt;br/&gt;&quot;, self);
       goto menu_system;
    }
    
    quit;
 } dilend

 dilbegin cleanup_resources();
 var
    temp_obj : unitptr;
 code
 {
    // Clean up temporary objects
    temp_obj := self.inside;
    
    while (temp_obj != null)
    {
       if (temp_obj.type == UNIT_ST_OBJ and temp_obj.names.[0] == &quot;temp&quot;)
       {
          destroy(temp_obj);
          sendtext(&quot;Cleaned up temporary object.&lt;br/&gt;&quot;, self);
       }
       
       temp_obj := temp_obj.next;
    }
    
    sendtext(&quot;Cleanup complete.&lt;br/&gt;&quot;, self);
    quit;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;quit&apos;&apos;&apos; procedure immediately terminates the current DIL program
* Any code after &apos;&apos;&apos;quit&apos;&apos;&apos; will not be executed
* The procedure is often used as the final statement in DIL programs
* When called from within procedures or functions, it terminates the entire call chain
* The procedure is useful for preventing infinite loops and providing clean program exits
* No parameters are required for this procedure

== Error Handling ==
The procedure does not generate errors under normal conditions:
* Always terminates execution successfully
* Cannot be used incorrectly (no parameters to validate)
* The only &quot;error&quot; condition is when the program cannot be terminated (which shouldn&apos;t occur)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/return|return]] - Function to return values from procedures
* [[Manual:DIL_Manual/wait|wait]] - Function that can be interrupted by quit
* [[Manual:DIL_Manual/pause|pause]] - Function that can be terminated by quit
* [[Manual:DIL_Manual/exec|exec]] - Function that can be terminated by quit

== See Also ==
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Wait flag that quit can interrupt
* [[Manual:DIL_Manual/dilbegin|dilbegin]] - Program start that quit can end
* [[Manual:DIL_Manual/dilend|dilend]] - Program end that quit can replace
* [[Manual:DIL_Manual/on_activation|on_activation]] - Function that may be interrupted by quit
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/race</title>
     <ns>0</ns>
     <id>873050</id>
     <revision>
       <id>1672971</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of race.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= race =

 field: integer &apos;&apos;&apos;.race&apos;&apos;&apos;
 type: &apos;&apos;&apos;integer&apos;&apos;&apos;
 access: &apos;&apos;&apos;Read/Write&apos;&apos;&apos;

== Syntax ==
 unit.race

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current race of the character
|-
| Write || integer || Sets the race of the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Description ==
The &apos;&apos;&apos;race&apos;&apos;&apos; field contains the racial identifier for a character. This field determines the character&apos;s race, which affects various game mechanics including abilities, equipment restrictions, social interactions, and combat modifiers.

Common race constants include:
* &apos;&apos;&apos;RACE_HUMAN&apos;&apos;&apos; - Human race
* &apos;&apos;&apos;RACE_DWARF&apos;&apos;&apos; - Dwarf race
* &apos;&apos;&apos;RACE_ELF&apos;&apos;&apos; - Elf race
* &apos;&apos;&apos;RACE_HALFLING&apos;&apos;&apos; - Halfling race
* &apos;&apos;&apos;RACE_GNOME&apos;&apos;&apos; - Gnome race
* &apos;&apos;&apos;RACE_HALF_OGRE&apos;&apos;&apos; - Half-ogre race
* &apos;&apos;&apos;RACE_HALF_ORC&apos;&apos;&apos; - Half-orc race
* &apos;&apos;&apos;RACE_BROWNIE&apos;&apos;&apos; - Brownie race
* &apos;&apos;&apos;RACE_HALF_ELF&apos;&apos;&apos; - Half-elf race
* &apos;&apos;&apos;RACE_GROLL&apos;&apos;&apos; - Troll race
* &apos;&apos;&apos;RACE_DARK_ELF&apos;&apos;&apos; - Dark elf race
* &apos;&apos;&apos;RACE_HALF_DROW&apos;&apos;&apos; - Dark elf (drow) race

== Examples ==
 dilbegin check_race();
 var
    character_race : integer;
 code
 {
    character_race := self.race;
    
    if (character_race == RACE_HUMAN)
    {
       sendtext(&quot;You are human.&lt;br/&gt;&quot;, self);
    }
    else if (character_race == RACE_ELF)
    {
       sendtext(&quot;You are an elf.&lt;br/&gt;&quot;, self);
    }
    else if (character_race == RACE_DWARF)
    {
       sendtext(&quot;You are a dwarf.&lt;br/&gt;&quot;, self);
    }
    else if (character_race == RACE_HALFLING)
    {
       sendtext(&quot;You are a halfling.&lt;br/&gt;&quot;, self);
    }
    else
    {
       sendtext(&quot;Your race is: &quot; + itoa(character_race) + &quot;&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin race_restriction();
 var
    target_race : integer;
 code
 {
    target_race := target.race;
    
    // Check if target can enter certain areas based on race
    if (target_race == RACE_DARK_ELF)
    {
       act(&quot;The guards block the dark elf from entering the sacred grove.&quot;, 
          A_ALWAYS, self, null, target, TO_VICT);
       act(&quot;$1n prevents $3n from entering the sacred grove.&quot;, 
          A_ALWAYS, self, null, target, TO_ROOM);
    }
    else if (target_race == RACE_ORC)
    {
       act(&quot;The villagers eye the orc warily.&lt;br/&gt;&quot;, 
          A_ALWAYS, self, null, target, TO_ROOM);
    }
    else
    {
       act(&quot;Welcome, traveler! The gates open for you.&lt;br/&gt;&quot;, 
          A_ALWAYS, self, null, target, TO_VICT);
    }
    
    quit;
 } dilend

 dilbegin race_change_menu();
 var
    choice : string;
 code
 {
    sendtext(&quot;Race Change Menu:&lt;br/&gt;&quot;, self);
    sendtext(&quot;1. Human&lt;br/&gt;&quot;, self);
    sendtext(&quot;2. Elf&lt;br/&gt;&quot;, self);
    sendtext(&quot;3. Dwarf&lt;br/&gt;&quot;, self);
    sendtext(&quot;4. Halfling&lt;br/&gt;&quot;, self);
    sendtext(&quot;5. Gnome&lt;br/&gt;&quot;, self);
    sendtext(&quot;Enter your choice (1-5): &quot;, self);
    
    wait(SFB_CMD, TRUE);
    choice := argument;
    
    if (choice == &quot;1&quot;)
    {
       self.race := RACE_HUMAN;
       sendtext(&quot;You are now human!&lt;br/&gt;&quot;, self);
    }
    else if (choice == &quot;2&quot;)
    {
       self.race := RACE_ELF;
       sendtext(&quot;You are now an elf!&lt;br/&gt;&quot;, self);
    }
    else if (choice == &quot;3&quot;)
    {
       self.race := RACE_DWARF;
       sendtext(&quot;You are now a dwarf!&lt;br/&gt;&quot;, self);
    }
    else if (choice == &quot;4&quot;)
    {
       self.race := RACE_HALFLING;
       sendtext(&quot;You are now a halfling!&lt;br/&gt;&quot;, self);
    }
    else if (choice == &quot;5&quot;)
    {
       self.race := RACE_GNOME;
       sendtext(&quot;You are now a gnome!&lt;br/&gt;&quot;, self);
    }
    else
    {
       sendtext(&quot;Invalid choice.&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

 dilbegin race_abilities();
 var
    character_race : integer;
 code
 {
    character_race := self.race;
    
    // Give race-specific bonuses
    if (character_race == RACE_ELF)
    {
       self.abilities[ABIL_DEX] := self.abilities[ABIL_DEX] + 5;
       self.abilities[ABIL_CHA] := self.abilities[ABIL_CHA] + 3;
       sendtext(&quot;Elven grace enhances your dexterity and charisma!&lt;br/&gt;&quot;, self);
    }
    else if (character_race == RACE_DWARF)
    {
       self.abilities[ABIL_STR] := self.abilities[ABIL_STR] + 5;
       self.abilities[ABIL_CON] := self.abilities[ABIL_CON] + 3;
       sendtext(&quot;Dwarven constitution enhances your strength and health!&lt;br/&gt;&quot;, self);
    }
    else if (character_race == RACE_HUMAN)
    {
       self.abilities[ABIL_BRA] := self.abilities[ABIL_BRA] + 2;
       self.abilities[ABIL_DIV] := self.abilities[ABIL_DIV] + 2;
       sendtext(&quot;Human versatility improves your intelligence and wisdom!&lt;br/&gt;&quot;, self);
    }
    
    quit;
 } dilend

== Usage Notes ==
* The race field is available on both player characters and NPCs
* Race constants are defined in values.h and/or vme.h with RACE_ prefix
* Race affects various game mechanics including abilities, equipment restrictions, and social interactions
* Some races may have sub-races or variations (half-elves, dark elves, etc.)
* Race changes may require special commands or admin privileges
* The field is persistent and saved with the character

== Error Handling ==
The field access will return &apos;&apos;&apos;fail&apos;&apos;&apos; when:
* Attempting to access race on a non-character unit (UNIT_ST_OBJ or UNIT_ST_ROOM)
* The unit is null or invalid
* The race value is not a valid race constant

== Related Functions/Fields ==
* [[Manual:DIL_Manual/reset_race|reset_race]] - Function to reset a character&apos;s race
* [[Manual:DIL_Manual/abilities|abilities]] - Array of character abilities affected by race
* [[Manual:DIL_Manual/equipment|equipment]] - Function that may have race-based restrictions
* [[Manual:DIL_Manual/profession|profession]] - Field that may interact with race requirements

== See Also ==
* [[Manual:DIL_Manual/RACE_* constants|RACE_* constants]] - Race identifier constants
* [[Manual:DIL_Manual/sex|sex]] - Field for character&apos;s gender
* [[Manual:DIL_Manual/level|level]] - Field for character&apos;s experience level
* [[Manual:DIL_Manual/guild|guild]] - Field for character&apos;s guild affiliation
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/realtime</title>
     <ns>0</ns>
     <id>543154</id>
     <revision>
       <id>1533991</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of realtime.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= realtime =
variable: &apos;&apos;&apos;realtime&apos;&apos;&apos; : integer (Read-only)

Returns the current real-world time as the number of seconds since January 1, 1970 00:00:00 UTC.

== Description ==
The &apos;&apos;&apos;realtime&apos;&apos;&apos; variable provides access to the current system time in Unix timestamp format. This represents the number of seconds that have elapsed since the Unix epoch (1970-01-01 00:00:00 UTC). For C programmers, this is equivalent to calling time(NULL).

This variable is particularly useful for implementing time-based restrictions, tracking elapsed time, or scheduling events based on real-world time rather than game time.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| realtime || integer (Read-only) || Current Unix timestamp in seconds since epoch
|}

== Availability ==
This field is available globally in all DIL programs and does not require a specific unit type.

== Examples ==
=== Basic Time Display ===
dilbegin show_current_time();
code
{
   act(&quot;Current time: &quot; + asctime(realtime), A_ALWAYS, self, null, null, TO_CHAR);
} dilend

=== Time-Based Access Control ===
dilbegin time_limited_area();
var
   last_reset : integer;

code
{
   last_reset := realtime;
   
   :main_loop:
   wait(SFB_TICK, TRUE);
   
   // Reset area every 24 hours
   if (realtime &gt; last_reset + 86400)  // 86400 seconds = 24 hours
   {
      act(&quot;The area has been reset!&quot;, A_ALWAYS, self, null, null, TO_ALL);
      last_reset := realtime;
   }
   
   goto main_loop;
} dilend

=== Player Time Limit Enforcement ===
dilbegin enforce_playtime_limit();
var
   session_start : integer;
   max_playtime  : integer;

code
{
   session_start := realtime;
   max_playtime := 14400;  // 4 hours in seconds
   
   :monitor:
   wait(SFB_TICK, TRUE);
   
   if (realtime - session_start &gt; max_playtime)
   {
      act(&quot;You have reached your time limit for today.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
      block;
   }
   
   goto monitor;
} dilend

== Usage Notes ==
* The value returned by &apos;&apos;&apos;realtime&apos;&apos;&apos; is a 32-bit integer representing seconds since the Unix epoch
* This value is independent of game time or MUD uptime
* The timestamp is in UTC, not local server time
* Useful for coordinating with external systems or implementing real-world time constraints
* Can be used with the [[Manual:DIL_Manual/asctime|asctime]] function to convert to human-readable format

== Error Handling ==
The &apos;&apos;&apos;realtime&apos;&apos;&apos; variable does not generate errors under normal circumstances. However:
* On systems with incorrect system time, the returned value may be invalid
* The value may wrap around on systems with 32-bit time_t after January 19, 2038 (Year 2038 problem)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/asctime|asctime]] - Converts Unix timestamp to human-readable string format
* [[Manual:DIL_Manual/heartbeat|heartbeat]] - Controls DIL program execution timing
* [[Manual:DIL_Manual/wait|wait]] - Pauses DIL execution for specified conditions

== See Also ==
* Unix timestamp documentation
* Time-based DIL programming patterns
* System time functions
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/reboot</title>
     <ns>0</ns>
     <id>464894</id>
     <revision>
       <id>1583743</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of reboot.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= reboot =
function: &apos;&apos;&apos;reboot&apos;&apos;&apos;(exit_code : integer);

Initiates a complete MUD server reboot with the specified exit code.

== Description ==
The &apos;&apos;&apos;reboot&apos;&apos;&apos; function immediately terminates and restarts the MUD server process. This is a system-level operation that requires root privileges on the zone. When called, the function sets global flags to trigger a server reboot and terminates the current DIL program execution.

The exit_code parameter is passed to the system&apos;s exit() function and can be used to indicate the reason for the reboot to external monitoring systems or scripts.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| exit_code || integer || The exit code to return to the operating system (typically 0 for successful reboot)
|}

== Examples ==
=== Simple Immediate Reboot ===
dilbegin cmd_reboot(arg : string);
code
{
   act(&quot;Rebooting the MUD now...&quot;, A_ALWAYS, self, null, null, TO_CHAR);
   reboot(0);
} dilend

=== Scheduled Reboot with Countdown ===
dilbegin scheduled_reboot(minutes : string);
external
   send_to_world(message : string);
var
   i : integer;
   j : integer;
   str : string;

code
{
   i := atoi(minutes);
   if (i == 0) goto reboot_now;
   
   if (i &gt; 1) str := &quot;minutes&quot;;
   else str := &quot;minute&quot;;
   
   // Only announce if less than 20 minutes
   if (i &lt; 20)
      send_to_world(&quot;The MUD will reboot in &quot; + itoa(i) + &quot; &quot; + str + &quot;.&lt;br/&gt;&quot;);
   
   heartbeat := PULSE_SEC * SECS_PER_REAL_MIN;
   
   while (i &gt; 1)
   {
      wait(SFB_TICK, TRUE);
      
      if ((i == 10) or (i == 5))
         send_to_world(&quot;The MUD will reboot in &quot; + itoa(i) + &quot; minutes.&lt;br/&gt;&quot;);
      
      i := i - 1;
   }
   
   j := SECS_PER_REAL_MIN;
   heartbeat := PULSE_SEC;
   
   while (j &gt; 0)
   {
      wait(SFB_TICK, TRUE);
      
      if (j == 30)
         send_to_world(&quot;The MUD will reboot in 30 seconds.&lt;br/&gt;&quot;);
      
      if (j == 10)
         send_to_world(&quot;The MUD will reboot in 10 seconds.&lt;br/&gt;&quot;);
      
      j := j - 1;
   }
   
   :reboot_now:
   send_to_world(&quot;Rebooting...&lt;br/&gt;&quot;);
   reboot(0);
} dilend

=== Emergency Reboot ===
dilbegin emergency_reboot();
code
{
   // Log the emergency reboot
   act(&quot;EMERGENCY REBOOT INITIATED!&quot;, A_ALWAYS, self, null, null, TO_ALL);
   
   // Use exit code 1 to indicate emergency
   reboot(1);
} dilend

== Usage Notes ==
* The zone containing the DIL program must have root privileges in the zonelist
* Any code after the &apos;&apos;&apos;reboot&apos;&apos;&apos; function call will not be executed
* The function immediately terminates the current DIL program
* All players will be disconnected during the reboot process
* The server will restart automatically after reboot
* Use [[Manual:DIL_Manual/quit|quit]] to terminate only the current DIL program without rebooting the server

== Error Handling ==
The &apos;&apos;&apos;reboot&apos;&apos;&apos; function includes security checks and error handling:

* If the zone does not have root privileges, the function will:
  ** Log a security violation to the zone log
  ** Terminate the DIL program with WAITCMD_QUIT
  ** Not execute the reboot

* If the exit_code parameter is not an integer, a type error will be generated

== Related Functions/Fields ==
* [[Manual:DIL_Manual/quit|quit]] - Terminates the current DIL program without rebooting the server
* [[Manual:DIL_Manual/heartbeat|heartbeat]] - Controls DIL program execution timing for countdown sequences
* [[Manual:DIL_Manual/wait|wait]] - Pauses DIL execution for specified conditions
* [[Manual:DIL_Manual/realtime|realtime]] - Provides current system time for scheduling

== See Also ==
* Zone privilege management
* System administration functions
* Server maintenance procedures
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/remove</title>
     <ns>0</ns>
     <id>457844</id>
     <revision>
       <id>970326</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of remove.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= remove =
function: &apos;&apos;&apos;remove&apos;&apos;&apos;(sl : stringlist or intlist, i : integer);

The &apos;&apos;&apos;remove&apos;&apos;&apos; function removes an element from a stringlist or intlist at the specified index position.

== Description ==
The &apos;&apos;&apos;remove&apos;&apos;&apos; procedure removes an element from either a stringlist or intlist at the specified index position. Unlike simply setting an element to null, this function actually removes the element and shifts all subsequent elements down by one position, maintaining a compact list without gaps.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| sl || stringlist or intlist || The stringlist or intlist to remove the element from
|-
| i || integer || The index position of the element to remove (0-based)
|}

== Examples ==
=== Basic Stringlist Removal ===
dilbegin remove_names();
var
   names : stringlist;
   i : integer;
code
{
   // Initialize a stringlist with names
   names := {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Eve&quot;};
   
   // Remove the element at index 2 (&quot;Charlie&quot;)
   remove(names, 2);
   
   // names now contains: {&quot;Alice&quot;, &quot;Bob&quot;, &quot;David&quot;, &quot;Eve&quot;}
   
   // Loop through and display remaining names
   i := 0;
   while (i &lt; length(names))
   {
      act(&quot;Name &quot; + (i+1) + &quot;: &quot; + names.[i], A_ALWAYS, self, null, null, TO_CHAR);
      i := i + 1;
   }
} dilend

=== Intlist Removal Example ===
dilbegin manage_scores();
var
   scores : intlist;
   i : integer;
code
{
   // Initialize scores
   scores := {100, 85, 92, 78, 95, 88};
   
   // Remove the score at index 3 (78)
   remove(scores, 3);
   
   // scores now contains: {100, 85, 92, 95, 88}
   
   // Calculate average
   i := 0;
   while (i &lt; length(scores))
   {
      // Process each score
      i := i + 1;
   }
} dilend

=== Removing Invalid Items ===
dilbegin clean_list();
var
   items : stringlist;
   i : integer;
code
{
   // Initialize with some empty/invalid entries
   items := {&quot;sword&quot;, &quot;&quot;, &quot;shield&quot;, &quot;armor&quot;, &quot;&quot;};
   
   // Remove empty entries (iterate backwards to avoid index shifting issues)
   i := length(items) - 1;
   while (i &gt;= 0)
   {
      if (items.[i] == &quot;&quot;)
      {
         remove(items, i);
      }
      i := i - 1;
   }
   
   // items now contains: {&quot;sword&quot;, &quot;shield&quot;, &quot;armor&quot;}
} dilend

=== Dynamic List Management ===
dilbegin manage_queue();
var
   queue : stringlist;
   player : string;
code
{
   queue := {};
   
   // Add some players to queue
   addstring(queue, &quot;Player1&quot;);
   addstring(queue, &quot;Player2&quot;);
   addstring(queue, &quot;Player3&quot;);
   
   // Process first player in queue (remove from front)
   if (length(queue) &gt; 0)
   {
      player := queue.[0];
      remove(queue, 0);
      act(&quot;Processing &quot; + player + &quot; from queue.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
   }
} dilend

== Usage Notes ==
* The index parameter is 0-based (first element is at index 0)
* When an element is removed, all subsequent elements shift down by one position
* The length of the list decreases by 1 after removal
* If the index is out of bounds, the function will fail silently
* The function works with both stringlist and intlist types
* Unlike setting an element to null, this actually removes the element and compacts the list

== Error Handling ==
The function will fail silently if:
* The first parameter is not a stringlist or intlist variable
* The second parameter is not an integer
* The index is negative or greater than or equal to the list length
* The list parameter is not a variable (cannot be a function return value)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/insert|insert]] - Inserts an element at a specified position
* [[Manual:DIL_Manual/addstring|addstring]] - Adds a string to the end of a stringlist
* [[Manual:DIL_Manual/substring|substring]] - Removes a specific string from a stringlist
* [[Manual:DIL_Manual/length|length]] - Returns the number of elements in a list
* [[Manual:DIL_Manual/stringlist|stringlist]] - String list type documentation
* [[Manual:DIL_Manual/intlist|intlist]] - Integer list type documentation

== See Also ==
* [[Manual:DIL_Manual/stringlist|stringlist]]
* [[Manual:DIL_Manual/intlist|intlist]]
* [[Manual:DIL_Manual/insert|insert]]
* [[Manual:DIL_Manual/addstring|addstring]]
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/rent</title>
     <ns>0</ns>
     <id>939918</id>
     <revision>
       <id>1731406</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of rent.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= rent =
field: integer &apos;&apos;&apos;.rent&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;rent&apos;&apos;&apos; field represents the basic cost of renting an object per time period, primarily used for special objects in the game&apos;s rental system.

== Description ==
The &apos;&apos;&apos;rent&apos;&apos;&apos; field is an integer value that specifies the basic cost of renting an object. This field is primarily used on very special objects and represents the rental fee in the old gold value system. The rent cost is typically used by shopkeepers or rental NPCs to determine how much players must pay to temporarily use or store items.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current rental cost of the object
|-
| Write || integer || Sets the rental cost of the object
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_OBJ (Object)

== Examples ==
=== Setting Rent Cost ===
dilbegin set_rent_cost(obj : unitptr, cost : integer);
code
{
   if (obj.type == UNIT_ST_OBJ)
   {
      obj.rent := cost;
      act(&quot;The rental cost for $2n has been set to &quot; + cost + &quot; gold per day.&quot;, 
          A_ALWAYS, self, obj, null, TO_CHAR);
   }
} dilend

=== Calculating Service Cost Based on Rent ===
dilbegin calculate_service_charge(item : unitptr);
var
   base_charge : integer;
   service_cost : integer;
   cash_str : string;
code
{
   // Calculate service cost as 3 times the rent value plus base fee
   base_charge := 5 * SILVER_MULT;
   service_cost := base_charge + ((item.rent) * 3);
   
   cash_str := moneystring(service_cost, TRUE);
   exec(&quot;say The service will cost you &quot; + cash_str + &quot;.&quot;, self);
} dilend

=== Rent-Based Pricing System ===
dilbegin rent_based_pricing();
var
   item : unitptr;
   daily_rate : integer;
   weekly_rate : integer;
code
{
   item := medium;
   
   if (item.type == UNIT_ST_OBJ and item.rent &gt; 0)
   {
      daily_rate := item.rent;
      weekly_rate := daily_rate * 7; // 7 days for a week
      
      act(&quot;Daily rental rate for $2n: &quot; + daily_rate + &quot; gold&quot;, 
          A_ALWAYS, self, item, null, TO_CHAR);
      act(&quot;Weekly rental rate for $2n: &quot; + weekly_rate + &quot; gold&quot;, 
          A_ALWAYS, self, item, null, TO_CHAR);
   }
   else
   {
      exec(&quot;say This item is not available for rent.&quot;, self);
   }
} dilend

=== Guild Discount Calculation ===
dilbegin guild_rental_discount(pc : unitptr, item : unitptr);
var
   base_cost : integer;
   discounted_cost : integer;
   cost_str : string;
code
{
   base_cost := (5 * PLATINUM_MULT) + ((item.rent) * 3);
   
   // Apply guild discount if applicable
   if (IsInGuild@guilds(pc, GUILD_UDG_THIEF))
   {
      discounted_cost := (5 * SILVER_MULT) + ((item.rent) * 3);
      exec(&quot;wink &quot; + pc.name, self);
      cost_str := moneystring(discounted_cost, TRUE);
      exec(&quot;say As a guild member, your rental cost is only &quot; + cost_str + &quot;.&quot;, self);
   }
   else
   {
      cost_str := moneystring(base_cost, TRUE);
      exec(&quot;say The rental cost is &quot; + cost_str + &quot;.&quot;, self);
   }
} dilend

== Usage Notes ==
* The rent value is stored as an integer representing the old gold value system
* This field is primarily used for special or premium items that can be rented
* The rent cost is typically calculated per day or per rental period
* Rent costs are often used in conjunction with base service fees
* The field is read-write and can be modified by DIL programs
* Rent values of 0 typically indicate the item is not available for rent
* The actual rental cost calculation may include additional factors like guild discounts or service fees

== Error Handling ==
Accessing the &apos;&apos;&apos;rent&apos;&apos;&apos; field will fail if:
* The unit is not an object type (UNIT_ST_OBJ)
* The unit pointer is null or invalid
* Attempting to set a negative rent value (may be allowed but not recommended)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/cost|cost]] - The basic purchase cost of an object
* [[Manual:DIL_Manual/objecttype|objecttype]] - The type of object, which may affect rental eligibility
* [[Manual:DIL_Manual/value|value]] - Additional object values that may influence rental pricing
* [[Manual:DIL_Manual/moneystring|moneystring]] - Function to convert monetary values to readable strings

== See Also ==
* [[Manual:DIL_Manual/unit_st_obj|unit_st_obj]]
* [[Manual:DIL_Manual/cost|cost]]
* [[Manual:DIL_Manual/transfermoney|transfermoney]]
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/replace</title>
     <ns>0</ns>
     <id>890224</id>
     <revision>
       <id>1324213</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of replace.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= replace =
function: string &apos;&apos;&apos;replace&apos;&apos;&apos;(t : string, n : string, o : string);

The &apos;&apos;&apos;replace&apos;&apos;&apos; function returns a new string with all occurrences of a target string replaced with a new string.

== Description ==
The &apos;&apos;&apos;replace&apos;&apos;&apos; function searches through the original string and replaces all occurrences of the target string with the replacement string. The function returns a new string with the replacements applied, leaving the original string unchanged. This is useful for text processing, template substitution, and string manipulation tasks.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| t || string || The target string to search for and replace
|-
| n || string || The replacement string to substitute for the target
|-
| o || string || The original string to search within
|}

== Examples ==
=== Basic String Replacement ===
dilbegin basic_replace();
var
   original : string;
   result : string;
code
{
   original := &quot;The quick brown fox jumps over the lazy dog.&quot;;
   result := replace(&quot;fox&quot;, &quot;cat&quot;, original);
   // result becomes: &quot;The quick brown cat jumps over the lazy dog.&quot;
   
   act(&quot;Original: &quot; + original, A_ALWAYS, self, null, null, TO_CHAR);
   act(&quot;Result: &quot; + result, A_ALWAYS, self, null, null, TO_CHAR);
} dilend

=== Template Variable Substitution ===
dilbegin template_substitution(pc : unitptr);
var
   template : string;
   result : string;
code
{
   template := &quot;%n% is a %t% of level %l%.&quot;;
   
   // Replace placeholders with actual values
   result := replace(&quot;%n%&quot;, pc.name, template);
   result := replace(&quot;%t%&quot;, pc.title, result);
   result := replace(&quot;%l%&quot;, itoa(pc.vlevel), result);
   
   // Final result: &quot;Jafar is a human of level 15.&quot;
   act(&quot;Template result: &quot; + result, A_ALWAYS, self, null, null, TO_CHAR);
} dilend

=== HTML Entity Conversion ===
dilbegin convert_html_entities(text : string);
var
   converted : string;
code
{
   converted := text;
   
   // Convert HTML entities back to characters
   converted := replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;, converted);
   converted := replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;, converted);
   converted := replace(&quot;&amp;amp;&quot;, &quot;&amp;&quot;, converted);
   
   return converted;
} dilend

=== Multiple Replacements ===
dilbegin clean_text(input : string);
var
   cleaned : string;
code
{
   cleaned := input;
   
   // Remove common unwanted characters
   cleaned := replace(&quot;\r&quot;, &quot;&quot;, cleaned);
   cleaned := replace(&quot;\n&quot;, &quot; &quot;, cleaned);
   cleaned := replace(&quot;  &quot;, &quot; &quot;, cleaned);
   
   // Replace offensive words with asterisks
   cleaned := replace(&quot;damn&quot;, &quot;****&quot;, cleaned);
   cleaned := replace(&quot;hell&quot;, &quot;****&quot;, cleaned);
   
   return cleaned;
} dilend

=== Color Code Processing ===
dilbegin process_color_codes(message : string);
var
   processed : string;
code
{
   processed := message;
   
   // Replace color placeholders with actual color codes
   processed := replace(&quot;%RED%&quot;, &quot;\033[0;31m&quot;, processed);
   processed := replace(&quot;%GREEN%&quot;, &quot;\033[0;32m&quot;, processed);
   processed := replace(&quot;%RESET%&quot;, &quot;\033[0m&quot;, processed);
   
   sendtext(processed, self);
} dilend

=== Path Normalization ===
dilbegin normalize_path(path : string);
var
   normalized : string;
code
{
   normalized := path;
   
   // Convert backslashes to forward slashes
   normalized := replace(&quot;\\&quot;, &quot;/&quot;, normalized);
   
   // Remove duplicate slashes
   normalized := replace(&quot;//&quot;, &quot;/&quot;, normalized);
   
   // Remove trailing slash (except for root)
   if (length(normalized) &gt; 1 and right(normalized, 1) == &quot;/&quot;)
   {
      normalized := left(normalized, length(normalized) - 1);
   }
   
   return normalized;
} dilend

== Usage Notes ==
* The function replaces ALL occurrences of the target string, not just the first one
* The replacement is case-sensitive (exact string matching)
* The original string is not modified; a new string is returned
* Empty strings can be used for replacement (effectively removing the target)
* If the target string is not found, the original string is returned unchanged
* The function can be chained to perform multiple replacements
* Be careful with overlapping replacements, as they may affect each other

== Error Handling ==
The function will fail if:
* Any of the parameters are not string types
* Any parameter is null or invalid
* The function returns a fail value if any parameter validation fails

== Related Functions/Fields ==
* [[Manual:DIL_Manual/left|left]] - Extracts left portion of a string
* [[Manual:DIL_Manual/right|right]] - Extracts right portion of a string
* [[Manual:DIL_Manual/length|length]] - Returns length of a string
* [[Manual:DIL_Manual/substring|substring]] - Removes strings from stringlists
* [[Manual:DIL_Manual/in|in]] - Operator to check if string contains another string

== See Also ==
* [[Manual:DIL_Manual/string|string]]
* [[Manual:DIL_Manual/left|left]]
* [[Manual:DIL_Manual/right|right]]
* [[Manual:DIL_Manual/in|in]]
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/reset_level</title>
     <ns>0</ns>
     <id>803257</id>
     <revision>
       <id>1493330</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of reset_level.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= reset_level =
function: &apos;&apos;&apos;reset_level&apos;&apos;&apos;(u : unitptr);

The &apos;&apos;&apos;reset_level&apos;&apos;&apos; function resets a player character&apos;s level to 1, typically used for character reroll or rebirth systems.

== Description ==
The &apos;&apos;&apos;reset_level&apos;&apos;&apos; procedure sets a player character&apos;s level to 1. This function is commonly used in character reroll or rebirth systems where players need to be reset to their starting state. The function only affects non-immortal player characters and requires appropriate zone access level to execute successfully.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The player character whose level will be reset
|}

== Examples ==
=== Basic Level Reset ===
dilbegin reset_player_level(pc : unitptr);
code
{
   if (pc.type == UNIT_ST_PC and not IS_IMMORTAL(pc))
   {
      reset_level(pc);
      act(&quot;Your level has been reset to 1.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
   }
} dilend

=== Character Rebirth System ===
dilbegin character_rebirth();
var
   pc : unitptr;
code
{
   pc := self;
   
   // Remove all equipment
   // (equipment removal code here)
   
   // Remove all affects
   // (affect removal code here)
   
   // Reset skills, spells, and abilities
   // (skill/spell reset code here)
   
   // Reset the character&apos;s level to 1
   reset_level(pc);
   
   // Reset race-specific attributes
   reset_race(pc);
   
   // Reset virtual level
   reset_vlevel(pc);
   
   // Reinitialize abilities
   pcinitabils@basis();
   
   act(&quot;Your character has been reborn at level 1!&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

=== Reroll Command ===
dilbegin reroll_command();
var
   pc : unitptr;
code
{
   pc := activator;
   
   if (pc.type != UNIT_ST_PC)
   {
      sendtext(&quot;Only players can reroll.&quot;, self);
      quit;
   }
   
   if (IS_IMMORTAL(pc))
   {
      sendtext(&quot;Immortals cannot reroll.&quot;, self);
      quit;
   }
   
   // Confirm reroll
   // (confirmation code here)
   
   // Reset character to starting state
   reset_level(pc);
   reset_race(pc);
   reset_vlevel(pc);
   
   // Move to starting room
   link(pc, findroom(&quot;temple@midgaard&quot;));
   
   act(&quot;You have been rerolled! Welcome back as a new character.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

=== Guild Change Reset ===
dilbegin guild_change_reset(pc : unitptr);
code
{
   // Store current guild information for later
   // (guild storage code here)
   
   // Reset character to base state
   reset_level(pc);
   reset_race(pc);
   reset_vlevel(pc);
   
   // Remove guild-specific affects and abilities
   // (guild cleanup code here)
   
   // Allow player to choose new guild
   // (guild selection code here)
   
   act(&quot;Your character has been reset for guild change.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

== Usage Notes ==
* The function only works on player characters (UNIT_ST_PC), not NPCs
* Immortal characters are protected from level reset
* The function requires zone access level &gt; 1 to execute
* This is typically used in conjunction with [[Manual:DIL_Manual/reset_race|reset_race]] and [[Manual:DIL_Manual/reset_vlevel|reset_vlevel]]
* The function sets the character&apos;s level to exactly 1
* Experience is not automatically adjusted - use [[Manual:DIL_Manual/experience|experience]] function separately if needed
* Hit points, mana, and endurance may need to be recalculated after level reset
* Skills and abilities are not affected by this function - reset them separately if needed

== Error Handling ==
The function will fail and log an error if:
* The zone access level is insufficient (must be &gt; 1)
* The unit parameter is not a valid unit pointer
* The unit is not a player character
* The character is immortal (protected from level reset)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/reset_vlevel|reset_vlevel]] - Resets a player&apos;s virtual level
* [[Manual:DIL_Manual/reset_race|reset_race]] - Resets a player&apos;s race-specific attributes
* [[Manual:DIL_Manual/experience|experience]] - Modifies character experience
* [[Manual:DIL_Manual/IS_IMMORTAL|IS_IMMORTAL]] - Checks if character is immortal
* [[Manual:DIL_Manual/pcinitabils|pcinitabils]] - Initializes player abilities

== See Also ==
* [[Manual:DIL_Manual/reset_vlevel|reset_vlevel]]
* [[Manual:DIL_Manual/reset_race|reset_race]]
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]]
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/reset_race</title>
     <ns>0</ns>
     <id>796904</id>
     <revision>
       <id>1588174</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of reset_race.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= reset_race =
function: &apos;&apos;&apos;reset_race&apos;&apos;&apos;(u : unitptr);

The &apos;&apos;&apos;reset_race&apos;&apos;&apos; function resets a character&apos;s race-specific attributes including weight, height, age, lifespan, and training costs.

== Description ==
The &apos;&apos;&apos;reset_race&apos;&apos;&apos; procedure resets a character&apos;s race-related attributes to their default values for the current race. This includes adjusting weight, height, age, lifespan, and training costs to match the character&apos;s current race setting. This function is commonly used in character reroll or rebirth systems where players need to be reset to their starting state while maintaining their chosen race.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The player character whose race attributes will be reset
|}

== Examples ==
=== Basic Race Reset ===
dilbegin reset_character_race(pc : unitptr);
code
{
   if (pc.type == UNIT_ST_PC)
   {
      reset_race(pc);
      act(&quot;Your race attributes have been reset to default values.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
   }
} dilend

=== Character Rebirth System ===
dilbegin character_rebirth();
var
   pc : unitptr;
code
{
   pc := self;
   
   // Remove all equipment and affects
   // (equipment and affect removal code here)
   
   // Reset character&apos;s level to 1
   reset_level(pc);
   
   // Reset race-specific attributes
   reset_race(pc);
   
   // Reset virtual level
   reset_vlevel(pc);
   
   // Reinitialize abilities
   pcinitabils@basis();
   
   act(&quot;Your character has been reborn with default race attributes!&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

=== Race Change Implementation ===
dilbegin change_race(pc : unitptr, new_race : integer);
code
{
   if (pc.type == UNIT_ST_PC)
   {
      // Set new race
      pc.race := new_race;
      
      // Reset all race-specific attributes for new race
      reset_race(pc);
      
      // Adjust birth time based on new race
      switch (new_race)
      {
         case RACE_HUMAN:
            pc.birth := realtime - (rnd(16, 19) * SECS_PER_MUD_YEAR);
            break;
         case RACE_ELF:
            pc.birth := realtime - (rnd(190, 215) * SECS_PER_MUD_YEAR);
            break;
         case RACE_DWARF:
            pc.birth := realtime - (rnd(60, 85) * SECS_PER_MUD_YEAR);
            break;
         // Add other races as needed
      }
      
      act(&quot;Your race has been changed and attributes reset!&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
   }
} dilend

=== Complete Character Reset ===
dilbegin full_character_reset(pc : unitptr);
code
{
   if (pc.type != UNIT_ST_PC)
   {
      sendtext(&quot;Only players can be fully reset.&quot;, self);
      quit;
   }
   
   // Store current race for later
   // (race storage code here)
   
   // Reset all character aspects
   reset_level(pc);      // Reset level to 1
   reset_race(pc);      // Reset race attributes
   reset_vlevel(pc);   // Reset virtual level
   
   // Reinitialize all systems
   pcinitabils@basis();
   
   // Reset experience to starting amount
   experience(11250, pc);
   
   // Set starting ability points
   pc.skill_points := 80;
   pc.ability_points := 40;
   
   act(&quot;Your character has been completely reset!&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

=== Reroll Command ===
dilbegin reroll_command();
var
   pc : unitptr;
code
{
   pc := activator;
   
   if (pc.type != UNIT_ST_PC)
   {
      sendtext(&quot;Only players can reroll.&quot;, self);
      quit;
   }
   
   // Confirm reroll
   // (confirmation code here)
   
   // Reset character to starting state
   reset_level(pc);
   reset_race(pc);
   reset_vlevel(pc);
   
   // Move to starting room
   link(pc, findroom(&quot;temple@midgaard&quot;));
   
   act(&quot;You have been rerolled! Welcome back as a new character.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

== Usage Notes ==
* The function only works on player characters (UNIT_ST_PC), not NPCs
* The function requires zone access level &gt; 1 to execute
* This is typically used in conjunction with [[Manual:DIL_Manual/reset_level|reset_level]] and [[Manual:DIL_Manual/reset_vlevel|reset_vlevel]]
* The function adjusts the following attributes:
** Weight based on race defaults
** Height based on race defaults  
** Age/lifespan based on race characteristics
** Training costs specific to the race
* The character&apos;s current race (pc.race) is preserved - only attributes are reset
* Birth time may need to be adjusted separately based on race
* Equipment weight and size considerations are automatically handled

== Error Handling ==
The function will fail and log an error if:
* The zone access level is insufficient (must be &gt; 1)
* The unit parameter is not a valid unit pointer
* The unit is not a player character
* The character&apos;s race value is invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/reset_level|reset_level]] - Resets a player&apos;s level to 1
* [[Manual:DIL_Manual/reset_vlevel|reset_vlevel]] - Resets a player&apos;s virtual level
* [[Manual:DIL_Manual/race|race]] - Field containing character&apos;s race (RACE_* constants)
* [[Manual:DIL_Manual/pcinitabils|pcinitabils]] - Initializes player abilities
* [[Manual:DIL_Manual/experience|experience]] - Modifies character experience
* [[Manual:DIL_Manual/SECS_PER_MUD_YEAR|SECS_PER_MUD_YEAR]] - Constant for time calculations

== See Also ==
* [[Manual:DIL_Manual/reset_level|reset_level]]
* [[Manual:DIL_Manual/reset_vlevel|reset_vlevel]]
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]]
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/reset_vlevel</title>
     <ns>0</ns>
     <id>1053420</id>
     <revision>
       <id>1713769</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of reset_vlevel.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= reset_vlevel =
function: &apos;&apos;&apos;reset_vlevel&apos;&apos;&apos;(u : unitptr);

The &apos;&apos;&apos;reset_vlevel&apos;&apos;&apos; function resets a player character&apos;s virtual level to 1, typically used for character reroll or rebirth systems.

== Description ==
The &apos;&apos;&apos;reset_vlevel&apos;&apos;&apos; procedure sets a player character&apos;s virtual level to 1. This function is commonly used in character reroll or rebirth systems where players need to be reset to their starting virtual level state. The virtual level is separate from the regular level and may affect different game mechanics or calculations. The function only affects non-immortal player characters and requires appropriate zone access level to execute successfully.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The player character whose virtual level will be reset
|}

== Examples ==
=== Basic Virtual Level Reset ===
dilbegin reset_player_vlevel(pc : unitptr);
code
{
   if (pc.type == UNIT_ST_PC and not IS_IMMORTAL(pc))
   {
      reset_vlevel(pc);
      act(&quot;Your virtual level has been reset to 1.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
   }
} dilend

=== Character Rebirth System ===
dilbegin character_rebirth();
var
   pc : unitptr;
code
{
   pc := self;
   
   // Remove all equipment and affects
   // (equipment and affect removal code here)
   
   // Reset character&apos;s level to 1
   reset_level(pc);
   
   // Reset race-specific attributes
   reset_race(pc);
   
   // Reset virtual level to 1
   reset_vlevel(pc);
   
   // Reinitialize abilities
   pcinitabils@basis();
   
   act(&quot;Your character has been reborn with virtual level 1!&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

=== Reroll Command ===
dilbegin reroll_command();
var
   pc : unitptr;
code
{
   pc := activator;
   
   if (pc.type != UNIT_ST_PC)
   {
      sendtext(&quot;Only players can reroll.&quot;, self);
      quit;
   }
   
   if (IS_IMMORTAL(pc))
   {
      sendtext(&quot;Immortals cannot reroll.&quot;, self);
      quit;
   }
   
   // Confirm reroll
   // (confirmation code here)
   
   // Reset character to starting state
   reset_level(pc);
   reset_race(pc);
   reset_vlevel(pc);
   
   // Move to starting room
   link(pc, findroom(&quot;temple@midgaard&quot;));
   
   act(&quot;You have been rerolled! Welcome back as a new character.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

=== Guild Change Reset ===
dilbegin guild_change_reset(pc : unitptr);
code
{
   // Store current guild information for later
   // (guild storage code here)
   
   // Reset character to base state
   reset_level(pc);
   reset_race(pc);
   reset_vlevel(pc);
   
   // Remove guild-specific affects and abilities
   // (guild cleanup code here)
   
   // Allow player to choose new guild
   // (guild selection code here)
   
   act(&quot;Your character has been reset for guild change.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

=== Complete Character Reset with Virtual Level ===
dilbegin full_character_reset(pc : unitptr);
var
   old_vlevel : integer;
code
{
   if (pc.type != UNIT_ST_PC)
   {
      sendtext(&quot;Only players can be fully reset.&quot;, self);
      quit;
   }
   
   // Store current virtual level for reference
   old_vlevel := pc.vlevel;
   
   // Reset all character aspects
   reset_level(pc);      // Reset level to 1
   reset_race(pc);      // Reset race attributes
   reset_vlevel(pc);   // Reset virtual level to 1
   
   // Reinitialize all systems
   pcinitabils@basis();
   
   // Reset experience to starting amount
   experience(11250, pc);
   
   // Set starting ability points
   pc.skill_points := 80;
   pc.ability_points := 40;
   
   act(&quot;Your character has been completely reset!&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
   act(&quot;Virtual level was &quot; + old_vlevel + &quot;, now reset to 1.&quot;, A_ALWAYS, pc, null, null, TO_CHAR);
} dilend

=== Virtual Level Display ===
dilbegin show_virtual_level(pc : unitptr);
code
{
   if (pc.type == UNIT_ST_PC)
   {
      act(&quot;Current virtual level: &quot; + itoa(pc.vlevel), A_ALWAYS, pc, null, null, TO_CHAR);
      act(&quot;Current regular level: &quot; + itoa(pc.level), A_ALWAYS, pc, null, null, TO_CHAR);
   }
   else
   {
      sendtext(&quot;This command only works on players.&quot;, self);
   }
} dilend

== Usage Notes ==
* The function only works on player characters (UNIT_ST_PC), not NPCs
* Immortal characters are protected from virtual level reset
* The function requires zone access level &gt; 1 to execute
* This is typically used in conjunction with [[Manual:DIL_Manual/reset_level|reset_level]] and [[Manual:DIL_Manual/reset_race|reset_race]]
* The virtual level is separate from the regular level field (pc.level)
* Virtual level may affect different game mechanics than regular level
* The function sets virtual level to exactly 1
* Experience is not automatically adjusted - use [[Manual:DIL_Manual/experience|experience]] function separately if needed
* Virtual level is often used for progression systems, training calculations, or special abilities

== Error Handling ==
The function will fail and log an error if:
* The zone access level is insufficient (must be &gt; 1)
* The unit parameter is not a valid unit pointer
* The unit is not a player character
* The character is immortal (protected from virtual level reset)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/reset_level|reset_level]] - Resets a player&apos;s regular level to 1
* [[Manual:DIL_Manual/reset_race|reset_race]] - Resets a player&apos;s race-specific attributes
* [[Manual:DIL_Manual/vlevel|vlevel]] - Field containing character&apos;s virtual level
* [[Manual:DIL_Manual/experience|experience]] - Modifies character experience
* [[Manual:DIL_Manual/IS_IMMORTAL|IS_IMMORTAL]] - Checks if character is immortal
* [[Manual:DIL_Manual/pcinitabils|pcinitabils]] - Initializes player abilities

== See Also ==
* [[Manual:DIL_Manual/reset_level|reset_level]]
* [[Manual:DIL_Manual/reset_race|reset_race]]
* [[Manual:DIL_Manual/unit_st_pc and unit_st_npc|unit_st_pc and unit_st_npc]]
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/resetmode</title>
     <ns>0</ns>
     <id>1044960</id>
     <revision>
       <id>1103310</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of resetmode.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= resetmode =
field: integer &apos;&apos;&apos;.resetmode&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;resetmode&apos;&apos;&apos; field provides access to the reset mode setting of a zone, which determines how and when the zone resets its contents.

== Description ==
The &apos;&apos;&apos;resetmode&apos;&apos;&apos; field is accessed on a zoneptr and returns an integer value representing the zone&apos;s reset mode. This value determines the reset behavior for the zone and is defined in values.h. The field is read-only, meaning it can only be queried but not modified directly through DIL.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| zone.resetmode || integer || Returns the reset mode of the zone
|}

== Availability ==
This field is available on the following unit types:
* zoneptr (Zone Pointer)

== Examples ==
dilbegin check_zone_reset(arg : string);
var
    z : zoneptr;
    buf : string;
code
{
    z := zhead();
    while (z)
    {
        buf := &quot;Zone: &quot; + z.name + &quot; Reset mode: &quot; + itoa(z.resetmode) + &quot;&amp;n&quot;;
        pagestring(buf, self);
        z := z.next;
    }
    quit;
}
dilend

== Usage Notes ==
* The &apos;&apos;&apos;resetmode&apos;&apos;&apos; field returns an integer value that corresponds to reset mode constants defined in values.h
* This field is read-only and cannot be modified directly
* The actual reset behavior is controlled by the zone reset system based on this value
* To trigger a zone reset, use the [[Manual:DIL_Manual/zonereset|zonereset]] function instead

== Error Handling ==
* Accessing &apos;&apos;&apos;resetmode&apos;&apos;&apos; on a null zoneptr will result in a DILV_FAIL
* The field will return DILV_ERR if accessed on an inappropriate unit type

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zonereset|zonereset]] - Function to manually trigger a zone reset
* [[Manual:DIL_Manual/resettime|resettime]] - Field to get/set the reset time interval of a zone
* [[Manual:DIL_Manual/loadlevel|loadlevel]] - Field to get/set the load level of a zone

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type documentation
* [[Manual:DIL_Manual/zhead|zhead]] - Function to get the first zone in the global zone list
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/resettime</title>
     <ns>0</ns>
     <id>1109380</id>
     <revision>
       <id>1204270</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of resettime.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= resettime =
field: integer &apos;&apos;&apos;.resettime&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;resettime&apos;&apos;&apos; field provides access to the reset time interval of a zone, specified in minutes.

== Description ==
The &apos;&apos;&apos;resettime&apos;&apos;&apos; field is accessed on a zoneptr and returns an integer value representing the zone&apos;s reset time in minutes. This field determines how often the zone will automatically reset its contents. The field is read-write, allowing both querying and modification of the reset time interval.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| zone.resettime || integer || Gets or sets the reset time of the zone in minutes
|}

== Availability ==
This field is available on the following unit types:
* zoneptr (Zone Pointer)

== Examples ==
dilbegin zone_reset_info(arg : string);
var
    z : zoneptr;
    buf : string;
code
{
    z := zhead();
    while (z)
    {
        buf := &quot;Zone: &quot; + z.name + &quot; Reset time: &quot; + itoa(z.resettime) + &quot; minutes&amp;n&quot;;
        pagestring(buf, self);
        z := z.next;
    }
    quit;
}
dilend

dilbegin set_zone_reset_timer();
var
    zon : zoneptr;
code
{
    // Find the current zone
    zon := zhead();
    while (zon.name != self.zone)
        zon := zon.next;
    
    if (zon.name != self.zone)
    {
        log(&quot;ZONE ERROR: Could not find zone &quot; + self.zone);
        return;
    }
    
    // Set heartbeat to zone&apos;s reset time in game ticks
    // resettime is in minutes, convert to seconds, then to PULSE_SEC ticks
    heartbeat := zon.resettime * 60 * PULSE_SEC;
    
    wait(SFB_TICK, TRUE);
    // Zone reset logic here
    quit;
}
dilend

== Usage Notes ==
* The &apos;&apos;&apos;resettime&apos;&apos;&apos; value is specified in minutes, not in game ticks
* To convert resettime to game ticks for use with [[Manual:DIL_Manual/heartbeat|heartbeat]], multiply by 60 and then by [[Manual:DIL_Manual/PULSE_SEC|PULSE_SEC]]
* The field is read-write, allowing dynamic modification of zone reset intervals
* Changes to resettime take effect immediately and affect the next reset cycle
* A resettime of 0 typically means the zone will not reset automatically

== Error Handling ==
* Accessing &apos;&apos;&apos;resettime&apos;&apos;&apos; on a null zoneptr will result in a DILV_FAIL
* The field will return DILV_ERR if accessed on an inappropriate unit type
* Setting negative values may result in undefined behavior

== Related Functions/Fields ==
* [[Manual:DIL_Manual/resetmode|resetmode]] - Field to get the reset mode of the zone
* [[Manual:DIL_Manual/zonereset|zonereset]] - Function to manually trigger a zone reset
* [[Manual:DIL_Manual/loadlevel|loadlevel]] - Field to get/set the load level of a zone
* [[Manual:DIL_Manual/heartbeat|heartbeat]] - Variable to control DIL program timing
* [[Manual:DIL_Manual/PULSE_SEC|PULSE_SEC]] - Constant for time conversion

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type documentation
* [[Manual:DIL_Manual/zhead|zhead]] - Function to get the first zone in the global zone list
* [[Manual:DIL_Manual/SFB_TICK|SFB_TICK]] - Tick flag for wait() function
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/restore</title>
     <ns>0</ns>
     <id>1272344</id>
     <revision>
       <id>1677539</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of restore.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= restore =
function: unitptr &apos;&apos;&apos;restore&apos;&apos;&apos;(filename : string, u : unitptr);

The &apos;&apos;&apos;restore&apos;&apos;&apos; function loads a copy of a unit or units that were previously saved with the [[Manual:DIL_Manual/store|store]] function from a file.

== Description ==
The &apos;&apos;&apos;restore&apos;&apos;&apos; function retrieves units that were previously saved to disk using the [[Manual:DIL_Manual/store|store]] function. The function can either restore units into a specified container unit or return a pointer to the restored unit if no container is provided. The restored units are placed in the zone&apos;s DIL file directory under a &quot;units&quot; subdirectory.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| filename || string || The name of the unit file to restore (without path extension)
|-
| u || unitptr || The unit to restore contents into, or null to return the restored unit
|}

== Examples ==
dilbegin load_saved_chest();
var
    chest : unitptr;
    result : unitptr;
code
{
    // Try to restore a saved chest, fallback to loading a new one
    result := restore(&quot;chest_save&quot;, null);
    
    if (result == null)
    {
        // No saved file found, load a fresh chest
        chest := load(&quot;donation_chest@&quot; + self.zoneidx);
        if (chest != null)
        {
            link(chest, self);
            sendtext(&quot;Loaded new donation chest.&amp;n&quot;, self);
        }
    }
    else
    {
        // Successfully restored saved chest
        link(result, self);
        sendtext(&quot;Restored saved donation chest.&amp;n&quot;, self);
    }
    quit;
}
dilend

dilbegin restore_room_contents();
var
    dummy : unitptr;
code
{
    // Restore saved room contents into the current room
    dummy := restore(&quot;room_contents.&quot; + self.zoneidx, self);
    
    if (dummy == null)
    {
        sendtext(&quot;No saved room contents found.&amp;n&quot;, self);
    }
    else
    {
        sendtext(&quot;Room contents restored successfully.&amp;n&quot;, self);
    }
    quit;
}
dilend

== Usage Notes ==
* The filename parameter should not include path or extension - the system automatically adds the proper path
* If the &apos;u&apos; parameter is null, the function returns a pointer to the restored unit
* If the &apos;u&apos; parameter is not null, the function restores contents into that unit and returns null
* The function requires zone access level  10 to execute
* Filenames are validated for security - illegal filenames will be rejected
* The main database must contain a reference for the unit &apos;name@zone&apos; to restore successfully
* Use &apos;&apos;&apos;restore&apos;&apos;&apos; sparingly as disk access is slow and can impact server performance

== Error Handling ==
* Returns null if the file cannot be found or read
* Returns DILV_FAIL if parameters are invalid
* Returns DILV_ERR if parameter types are incorrect
* Logs security violations if zone access level is insufficient
* Logs attempts to restore files with illegal names

== Related Functions/Fields ==
* [[Manual:DIL_Manual/store|store]] - Function to save units to a file
* [[Manual:DIL_Manual/delunit|delunit]] - Function to delete unit files
* [[Manual:DIL_Manual/load|load]] - Function to load units from the main database

== See Also ==
* [[Manual:DIL_Manual/link|link]] - Function to link units into containers
* [[Manual:DIL_Manual/sendtext|sendtext]] - Function to send text to players
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/return</title>
     <ns>0</ns>
     <id>736561</id>
     <revision>
       <id>1260679</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of return.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= return =
statement: &apos;&apos;&apos;return&apos;&apos;&apos; [expression];

The &apos;&apos;&apos;return&apos;&apos;&apos; statement terminates execution of a function or procedure and optionally returns a value from a function.

== Description ==
The &apos;&apos;&apos;return&apos;&apos;&apos; statement is used to exit from a DIL function or procedure. For procedures (which have no return type), the statement is used as `return;` without any expression. For functions (which have a declared return type), the statement must include an expression of the matching type: `return(expression);`. The return statement can only be used within DIL templates (functions and procedures).

== Usage ==
There are two forms of the return statement:

* For procedures: `return;`
* For functions: `return(expression);`

Where expression must evaluate to the same type as the function&apos;s declared return type.

== Examples ==
dilbegin cuff_target(deputy : unitptr, targ : unitptr, cuffs : unitptr);
var
   depname: string;
code
{
   act(&quot;You cuff $3n.&quot;, A_SOMEONE, deputy, null, targ, TO_CHAR);
   act(&quot;$1n surprises you and put $2n around your wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_VICT);
   act(&quot;$1n puts $2n around $3N&apos;s wrists.&quot;, A_SOMEONE, deputy, cuffs, targ, TO_NOTVICT);

   follow(targ, deputy);
   depname := deputy.name;
   link(cuffs, targ);
   unequip(equipment(targ, WEAR_WRIST_R));
   addequip(cuffs, WEAR_WRIST_R);
   dilcopy(&quot;cuffed@midgaard(&quot;+depname+&quot;)&quot;, targ);
   dilcopy(&quot;cuffed2@midgaard(&quot;+depname+&quot;)&quot;, targ);

   exec(&quot;sigh&quot;, targ);
   return;  // Procedure return, no value
} dilend

dilbegin integer calculate_damage(attacker : unitptr, defender : unitptr);
var
   damage : integer;
code
{
   damage := attacker.abilities.str - defender.abilities.str;
   
   if (damage &lt; 1)
      damage := 1;
   
   return(damage);  // Function return, returns integer value
} dilend

dilbegin string get_room_description(room : unitptr);
code
{
   if (room == null)
      return(&quot;Invalid room&quot;);  // Return with string literal
   
   return(room.title);  // Return with string variable
} dilend

== Usage Notes ==
* The &apos;&apos;&apos;return&apos;&apos;&apos; statement can only be used inside DIL templates (functions and procedures)
* For procedures, use `return;` without any expression
* For functions, the expression type must exactly match the function&apos;s declared return type
* When returning from a function, the return value is copied to the caller&apos;s context
* The return statement immediately terminates execution of the current template
* If used in the main program frame (not in a called function/procedure), it will quit the entire DIL program
* Return values are properly copied based on their type (strings are duplicated, pointers are handled appropriately)

== Error Handling ==
* Compile-time error if return is used outside of a template
* Compile-time error if a function return doesn&apos;t match the declared return type
* Compile-time error if a procedure includes a return expression
* Runtime error if stack corruption is detected during return
* Runtime logging if return types don&apos;t match (should never happen with proper compilation)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/quit|quit]] - Statement to terminate the entire DIL program
* [[Manual:DIL_Manual/dilcopy|dilcopy]] - Function to start new DIL programs
* [[Manual:DIL_Manual/dilbegin|dilbegin]] - Keyword to start DIL template definitions

== See Also ==
* [[Manual:DIL_Manual/function|function]] - DIL function declarations
* [[Manual:DIL_Manual/procedure|procedure]] - DIL procedure declarations
* [[Manual:DIL_Manual/external|external]] - Keyword for external function declarations
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/right</title>
     <ns>0</ns>
     <id>1165977</id>
     <revision>
       <id>1499969</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of right.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= right =
function: string &apos;&apos;&apos;right&apos;&apos;&apos;(o : string, r : integer);

The &apos;&apos;&apos;right&apos;&apos;&apos; function extracts the rightmost characters from a string.

== Description ==
The &apos;&apos;&apos;right&apos;&apos;&apos; function parses a string and returns the specified number of characters from the right side of the string. If the requested length is longer than the original string, the entire string is returned. The function handles empty strings and null values appropriately.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| o || string || The original string to be parsed
|-
| r || integer || The number of characters to extract from the right side
|}

== Examples ==
dilbegin extract_extension();
var
    filename : string;
    extension : string;
code
{
    filename := &quot;document.txt&quot;;
    extension := right(filename, 3);  // Returns &quot;txt&quot;
    
    sendtext(&quot;File extension: &quot; + extension + &quot;&amp;n&quot;, self);
    quit;
}
dilend

dilbegin get_last_word();
var
    sentence : string;
    last_word : string;
    space_pos : integer;
code
{
    sentence := &quot;The quick brown fox jumps&quot;;
    
    // Find the last space to isolate the last word
    space_pos := 0;
    // This is a simplified example - in practice you&apos;d use more robust parsing
    last_word := right(sentence, 5);  // Returns &quot;jumps&quot;
    
    sendtext(&quot;Last word: &quot; + last_word + &quot;&amp;n&quot;, self);
    quit;
}
dilend

dilbegin format_currency();
var
    amount : string;
    cents : string;
code
{
    amount := &quot;12345&quot;;  // Amount in cents
    
    // Extract last two digits for cents
    cents := right(amount, 2);  // Returns &quot;45&quot;
    
    sendtext(&quot;Cents: &quot; + cents + &quot;&amp;n&quot;, self);
    quit;
}
dilend

== Usage Notes ==
* If the length parameter (r) is greater than the string length, the entire string is returned
* If the length parameter is 0 or negative, an empty string is returned
* If the input string is empty or null, the function returns null
* The function returns a new string that is a copy of the extracted portion
* The returned string is properly null-terminated
* The function is commonly used for extracting file extensions, last words, or formatted suffixes

== Error Handling ==
* Returns null if the input string is null or empty
* Returns DILV_FAIL if either parameter is null or fails evaluation
* Returns DILV_ERR if parameter types are incorrect
* Handles length overflow gracefully by returning the entire string when r exceeds string length

== Related Functions/Fields ==
* [[Manual:DIL_Manual/left|left]] - Function to extract leftmost characters from a string
* [[Manual:DIL_Manual/mid|mid]] - Function to extract a substring from the middle of a string
* [[Manual:DIL_Manual/length|length]] - Function to get the length of a string
* [[Manual:DIL_Manual/substring|substring]] - Procedure to work with stringlist substrings

== See Also ==
* [[Manual:DIL_Manual/getwords|getwords]] - Function to split string into words
* [[Manual:DIL_Manual/strdup|strdup]] - Function to duplicate strings
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/rnd</title>
     <ns>0</ns>
     <id>567377</id>
     <revision>
       <id>1750980</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of rnd.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= rnd =
function: integer &apos;&apos;&apos;rnd&apos;&apos;&apos;(i1 : integer, i2 : integer);

The &apos;&apos;&apos;rnd&apos;&apos;&apos; function generates a random integer within a specified range.

== Description ==
The &apos;&apos;&apos;rnd&apos;&apos;&apos; function returns a random integer between the two specified values (inclusive). The function generates a uniform random distribution across the entire range from i1 to i2, including both endpoints. This is commonly used for random selection, probability-based decisions, and adding variety to DIL program behavior.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| i1 || integer || The start of the range (inclusive)
|-
| i2 || integer || The end of the range (inclusive)
|}

== Examples ==
dilbegin random_guard_behavior();
var
    choice : integer;
code
{
    // Choose a random patrol route (1-4)
    choice := rnd(1, 4);
    
    if (choice == 1)
        exec(&quot;patrol north&quot;, self);
    else if (choice == 2)
        exec(&quot;patrol south&quot;, self);
    else if (choice == 3)
        exec(&quot;patrol east&quot;, self);
    else
        exec(&quot;patrol west&quot;, self);
    
    quit;
}
dilend

dilbegin random_treasure();
var
    gold_amount : integer;
    item_type : integer;
code
{
    // Generate random gold amount between 10 and 100
    gold_amount := rnd(10, 100);
    
    // Choose random item type (1-5)
    item_type := rnd(1, 5);
    
    if (item_type == 1)
        exec(&quot;create sword&quot;, self);
    else if (item_type == 2)
        exec(&quot;create shield&quot;, self);
    else if (item_type == 3)
        exec(&quot;create potion&quot;, self);
    else if (item_type == 4)
        exec(&quot;create armor&quot;, self);
    else
        exec(&quot;create ring&quot;, self);
    
    sendtext(&quot;You found &quot; + itoa(gold_amount) + &quot; gold coins!&amp;n&quot;, self);
    quit;
}
dilend

dilbegin random_emote();
var
    emote_choice : integer;
code
{
    // Random emote selection
    emote_choice := rnd(1, 6);
    
    if (emote_choice == 1)
        act(&quot;$1n smiles happily.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    else if (emote_choice == 2)
        act(&quot;$1n looks around thoughtfully.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    else if (emote_choice == 3)
        act(&quot;$1n stretches $1s arms.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    else if (emote_choice == 4)
        act(&quot;$1n yawns loudly.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    else if (emote_choice == 5)
        act(&quot;$1n taps $1s foot impatiently.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    else
        act(&quot;$1n sighs deeply.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    
    quit;
}
dilend

== Usage Notes ==
* The range is inclusive - both i1 and i2 are possible return values
* If i1 &gt; i2, the function still works and generates numbers in the range [i2, i1]
* The function uses a uniform distribution, meaning all values in the range have equal probability
* Commonly used for: random selection, probability checks, damage variation, treasure generation
* For more complex random selection with weighted probabilities, consider using multiple rnd() calls with different ranges
* The function is suitable for game mechanics where predictable randomness is needed

== Error Handling ==
* Returns DILV_FAIL if either parameter is null or fails evaluation
* Returns DILV_ERR if either parameter is not an integer
* No runtime errors occur for valid integer inputs, even if i1 &gt; i2

== Related Functions/Fields ==
* [[Manual:DIL_Manual/openroll|openroll]] - Function for open-ended dice rolls with explosion mechanics
* [[Manual:DIL_Manual/findrndunit|findrndunit]] - Function to find a random unit matching criteria
* [[Manual:DIL_Manual/number|number]] - Core random number generation function (internal)

== See Also ==
* [[Manual:DIL_Manual/atoi|atoi]] - Function to convert strings to integers
* [[Manual:DIL_Manual/itoa|itoa]] - Function to convert integers to strings
* [[Manual:DIL_Manual/mudhour|mudhour]] - Variable for current game hour (often used with rnd for time-based events)
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/room_head</title>
     <ns>0</ns>
     <id>958659</id>
     <revision>
       <id>1738425</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of room_head.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= room_head =
function: unitptr &apos;&apos;&apos;room_head&apos;&apos;&apos;();

The &apos;&apos;&apos;room_head&apos;&apos;&apos; function returns a pointer to the first room in the global room list.

== Description ==
The &apos;&apos;&apos;room_head&apos;&apos;&apos; function retrieves the first room unit from the global list of all rooms in the game. This function provides access to the head of the room linked list, allowing traversal through all rooms in the game world using the &apos;&apos;&apos;next&apos;&apos;&apos; field. The function returns null if no rooms are available or if the global room head is not properly initialized.

== Parameters ==
This function takes no parameters.

== Examples ==
dilbegin list_all_rooms();
var
    current_room : room;
    room_count : integer;
    buffer : string;
code
{
    current_room := room_head();
    room_count := 0;
    buffer := &quot;List of all rooms:&amp;n&quot;;
    
    while (current_room != null)
    {
        buffer := buffer + current_room.name + &quot; (&quot; + current_room.zoneidx + &quot;)&amp;n&quot;;
        room_count := room_count + 1;
        current_room := current_room.next;
    }
    
    buffer := buffer + &quot;&amp;nTotal rooms: &quot; + itoa(room_count) + &quot;&amp;n&quot;;
    pagestring(buffer, self);
    quit;
}
dilend

dilbegin find_room_by_name(search_name : string);
var
    current_room : room;
    found_room : room;
code
{
    current_room := room_head();
    found_room := null;
    
    while (current_room != null and found_room == null)
    {
        if (current_room.name == search_name)
            found_room := current_room;
        else
            current_room := current_room.next;
    }
    
    if (found_room != null)
        sendtext(&quot;Found room: &quot; + found_room.title + &quot;&amp;n&quot;, self);
    else
        sendtext(&quot;Room &apos;&quot; + search_name + &quot;&apos; not found.&amp;n&quot;, self);
    
    quit;
}
dilend

== Usage Notes ==
* The function returns the first room in the global room list, which may not be in any particular order
* Use the &apos;&apos;&apos;next&apos;&apos;&apos; field to traverse through the complete list of rooms
* This function is primarily used for administrative or system-level DIL programs that need to process all rooms
* For finding specific rooms, consider using [[Manual:DIL_Manual/findroom|findroom]] which is more efficient for targeted searches
* The returned pointer is of type room (UNIT_ST_ROOM)
* This function appears to be rarely used in modern DIL code and may be considered obsolete

== Error Handling ==
* Returns null if the global room list is empty or not initialized
* Returns null if the global room head pointer is not a valid room unit
* No runtime errors occur for normal operation
* Always check the return value before using it to avoid null pointer errors

== Related Functions/Fields ==
* [[Manual:DIL_Manual/ghead|ghead]] - Function to get the first unit in the global unit list
* [[Manual:DIL_Manual/chead|chead]] - Function to get the first command in the global command list
* [[Manual:DIL_Manual/zhead|zhead]] - Function to get the first zone in the global zone list
* [[Manual:DIL_Manual/findroom|findroom]] - Function to find a specific room by name
* [[Manual:DIL_Manual/next|next]] - Field to get the next room in the list

== See Also ==
* [[Manual:DIL_Manual/room|room]] - Room unit type documentation
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type documentation
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/roomcount</title>
     <ns>0</ns>
     <id>805903</id>
     <revision>
       <id>1679320</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of roomcount.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= roomcount =
field: integer &apos;&apos;&apos;.roomcount&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;roomcount&apos;&apos;&apos; field provides access to the number of rooms contained within a zone.

== Description ==
The &apos;&apos;&apos;roomcount&apos;&apos;&apos; field is accessed on a zoneptr and returns an integer value representing the total number of rooms defined within that zone. This field is read-only and provides a quick way to determine zone size without needing to manually traverse through all rooms. The count includes all rooms registered to the zone, regardless of their current state or accessibility.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| zone.roomcount || integer || Returns the number of rooms in the zone
|}

== Availability ==
This field is available on the following unit types:
* zoneptr (Zone Pointer)

== Examples ==
dilbegin zone_statistics();
var
    current_zone : zoneptr;
    buffer : string;
code
{
    current_zone := zhead();
    buffer := &quot;Zone Statistics:&amp;n&amp;n&quot;;
    
    while (current_zone != null)
    {
        buffer := buffer + &quot;Zone: &quot; + current_zone.name + &quot;&amp;n&quot;;
        buffer := buffer + &quot;  Rooms: &quot; + itoa(current_zone.roomcount) + &quot;&amp;n&quot;;
        buffer := buffer + &quot;  Objects: &quot; + itoa(current_zone.objcount) + &quot;&amp;n&quot;;
        buffer := buffer + &quot;  NPCs: &quot; + itoa(current_zone.npccount) + &quot;&amp;n&quot;;
        buffer := buffer + &quot;  Reset time: &quot; + itoa(current_zone.resettime) + &quot; minutes&amp;n&quot;;
        buffer := buffer + &quot;&amp;n&quot;;
        
        current_zone := current_zone.next;
    }
    
    pagestring(buffer, self);
    quit;
}
dilend

== Usage Notes ==
* The &apos;&apos;&apos;roomcount&apos;&apos;&apos; field returns the total number of rooms defined in the zone&apos;s data files
* This count is read-only and cannot be modified directly
* The field is commonly used for zone statistics, administrative commands, and zone validation
* For performance reasons, use this field instead of manually counting rooms with loops
* The count includes all room types (normal, death rooms, etc.) within the zone
* This field appears to be rarely used in modern DIL code but remains functional

== Error Handling ==
* Returns 0 if the zone contains no rooms
* Returns DILV_FAIL if the zoneptr is null
* Returns DILV_ERR if accessed on an inappropriate unit type
* Always check that the zoneptr is valid before accessing this field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/objcount|objcount]] - Field to get the number of objects in a zone
* [[Manual:DIL_Manual/npccount|npccount]] - Field to get the number of NPCs in a zone
* [[Manual:DIL_Manual/zhead|zhead]] - Function to get the first zone in the global zone list
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type documentation
* [[Manual:DIL_Manual/resettime|resettime]] - Field to get the reset time of a zone

== See Also ==
* [[Manual:DIL_Manual/zone|zone]] - Zone unit type documentation
* [[Manual:DIL_Manual/findroom|findroom]] - Function to find a specific room by name
* [[Manual:DIL_Manual/room_head|room_head]] - Function to get the first room in the global room list
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/roomflags</title>
     <ns>0</ns>
     <id>403692</id>
     <revision>
       <id>1611812</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of roomflags.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= roomflags =
field: integer &apos;&apos;&apos;.roomflags&apos;&apos;&apos; (Read/Write)

The .roomflags field contains bit flags that specify various properties and behaviors of a room unit.

== Description ==
The .roomflags field is an integer bitfield that controls various properties and behaviors of room units. Each bit in the field represents a specific room characteristic or restriction. The field uses the ROOM_FL_* constants defined in values.h and/or vme.h to set and check individual flags.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current room flags as a bitfield
|-
| Write || integer || Sets the room flags to the specified bitfield value
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_ROOM (Room)

== Examples ==
=== Checking Room Flags ===
 dilbegin check_room_dark();
 var
     my_room : unitptr;
 code
 {
     my_room := self.outside;
     
     if (isset(my_room.roomflags, ROOM_FL_DARK))
         sendtext(&quot;This room is dark.&amp;n&quot;, self);
     else
         sendtext(&quot;This room is well lit.&amp;n&quot;, self);
 }
 dilend

=== Setting Room Flags ===
 dilbegin make_room_private();
 var
     my_room : unitptr;
 code
 {
     my_room := self.outside;
     
     // Make the room private (no teleportation)
     my_room.roomflags := my_room.roomflags | ROOM_FL_PRIVATE;
     
     sendtext(&quot;The room is now private.&amp;n&quot;, self);
 }
 dilend

=== Clearing Room Flags ===
 dilbegin remove_no_magic();
 var
     my_room : unitptr;
 code
 {
     my_room := self.outside;
     
     // Remove the no-magic restriction
     my_room.roomflags := my_room.roomflags &amp; ~ROOM_FL_NO_MAGIC;
     
     sendtext(&quot;Magic can now be used in this room.&amp;n&quot;, self);
 }
 dilend

== Usage Notes ==
* Use the &apos;&apos;&apos;isset()&apos;&apos;&apos; function to check if specific flags are set
* Use bitwise operators (|, &amp;, ~) to modify individual flags
* The field uses ROOM_FL_* constants from values.h and/or vme.h
* Changes to room flags affect all characters in the room immediately
* Some room flags may have game-wide implications (e.g., ROOM_FL_PRIVATE, ROOM_FL_NO_MAGIC)

== Error Handling ==
* Accessing .roomflags on non-room units will result in DILV_FAIL
* Invalid flag values may cause unexpected room behavior
* Always validate flag combinations before setting them

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isset|isset]] - Function to check if specific bits are set in an integer
* [[Manual:DIL_Manual/movement|movement]] - Field that controls the movement type of the room
* [[Manual:DIL_Manual/exit_info|exit_info]] - Field that controls exit properties and flags

== See Also ==
* [[Manual:DIL_Manual/unit_st_room|unit_st_room]] - Complete documentation of room unit fields
* [[Manual:DIL_Manual/exit_info|exit_info]] - Exit flag management
* [[Manual:DIL_Manual/movement|movement]] - Room movement type configuration
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/rooms</title>
     <ns>0</ns>
     <id>778143</id>
     <revision>
       <id>1870970</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of rooms.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= rooms =
field: unitptr &apos;&apos;&apos;.rooms&apos;&apos;&apos; (Read-only)

The .rooms field provides access to the first room unit in a zone, allowing iteration through all rooms within that zone.

== Description ==
The .rooms field is a read-only field that returns a unitptr pointing to the first room in a zone. This field is used to access and iterate through all rooms contained within a specific zone. Once you have the first room, you can navigate through the zone&apos;s rooms using the unit&apos;s .next field to traverse the complete list of rooms in that zone.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || unitptr || Returns a pointer to the first room unit in the zone
|}

== Availability ==
This field is available on the following unit types:
* zoneptr (Zone pointer)

== Examples ==
=== Listing All Rooms in a Zone ===
 dilbegin list_zone_rooms(zone_name : string);
 var
     z : zoneptr;
     room : unitptr;
     count : integer;
     output : string;
 code
 {
     // Find the specified zone
     z := zhead();
     while (z)
     {
         if (z.name == zone_name)
             break;
         z := z.next;
     }
     
     if (z == null)
     {
         sendtext(&quot;Zone &apos;&quot; + zone_name + &quot;&apos; not found.&amp;n&quot;, self);
         quit;
     }
     
     output := &quot;Rooms in zone &quot; + zone_name + &quot;:&amp;n&quot;;
     count := 0;
     
     // Iterate through all rooms in the zone
     room := z.rooms;
     while (room)
     {
         output := output + &quot;  &quot; + room.nameidx + &quot;@&quot; + room.zoneidx + &quot;&amp;n&quot;;
         count := count + 1;
         room := room.next;
     }
     
     output := output + &quot;&amp;nTotal rooms: &quot; + itoa(count) + &quot;&amp;n&quot;;
     pagestring(output, self);
 }
 dilend

=== Counting Rooms in All Zones ===
 dilbegin count_all_rooms();
 var
     z : zoneptr;
     room : unitptr;
     total_rooms : integer;
     zone_rooms : integer;
 code
 {
     total_rooms := 0;
     z := zhead();
     
     sendtext(&quot;Room count by zone:&amp;n&quot;, self);
     sendtext(&quot;==================&amp;n&quot;, self);
     
     while (z)
     {
         zone_rooms := 0;
         room := z.rooms;
         
         while (room)
         {
             zone_rooms := zone_rooms + 1;
             room := room.next;
         }
         
         sendtext(z.name + &quot;: &quot; + itoa(zone_rooms) + &quot; rooms&amp;n&quot;, self);
         total_rooms := total_rooms + zone_rooms;
         z := z.next;
     }
     
     sendtext(&quot;==================&amp;n&quot;, self);
     sendtext(&quot;Total rooms: &quot; + itoa(total_rooms) + &quot;&amp;n&quot;, self);
 }
 dilend

=== Finding a Specific Room in a Zone ===
 dilbegin find_room_in_zone(zone_name : string, room_name : string);
 var
     z : zoneptr;
     room : unitptr;
 code
 {
     // Find the zone
     z := zhead();
     while (z)
     {
         if (z.name == zone_name)
             break;
         z := z.next;
     }
     
     if (z == null)
     {
         sendtext(&quot;Zone not found.&amp;n&quot;, self);
         quit;
     }
     
     // Search for the room
     room := z.rooms;
     while (room)
     {
         if (room.nameidx == room_name)
         {
             sendtext(&quot;Found room: &quot; + room.nameidx + &quot;@&quot; + room.zoneidx + &quot;&amp;n&quot;, self);
             sendtext(&quot;Title: &quot; + room.title + &quot;&amp;n&quot;, self);
             quit;
         }
         room := room.next;
     }
     
     sendtext(&quot;Room &apos;&quot; + room_name + &quot;&apos; not found in zone &apos;&quot; + zone_name + &quot;&apos;.&amp;n&quot;, self);
 }
 dilend

== Usage Notes ==
* The .rooms field returns the first room in the zone&apos;s room list
* Use the unit&apos;s .next field to iterate through subsequent rooms
* The field returns null if the zone contains no rooms
* All rooms returned will have type UNIT_ST_ROOM
* The zone&apos;s room list is maintained internally by the MUD system
* This field is read-only; you cannot modify the zone&apos;s room list directly

== Error Handling ==
* Accessing .rooms on a null zoneptr will result in DILV_FAIL
* If the zone contains no rooms, the field returns null
* Always check for null before using the returned room pointer
* Invalid zoneptr types will result in DILV_ERR

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zhead|zhead]] - Function to get the first zone in the global zone list
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type and its available fields
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type and navigation methods (.next field)
* [[Manual:DIL_Manual/roomcount|roomcount]] - Field that returns the number of rooms in a zone

== See Also ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Complete documentation of zone pointer fields
* [[Manual:DIL_Manual/zhead|zhead]] - Getting the first zone in the list
* [[Manual:DIL_Manual/roomcount|roomcount]] - Getting room count without iteration
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer navigation and fields
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sact</title>
     <ns>0</ns>
     <id>914888</id>
     <revision>
       <id>1573305</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sact.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= sact =
 function: string &apos;&apos;&apos;sact&apos;&apos;&apos;(message : string, visibility : integer, char : unitptr, medium : unitptr/string/integer, victim : unitptr/string/integer, to_whom : integer);

The sact function formats a message string using the same syntax as act() but returns the formatted result as a string instead of sending it to players.

== Description ==
The sact function processes a message template with formatters and returns the formatted message as a string. It uses the same parameter structure and formatting rules as the [[Manual:DIL_Manual/act|act]] function, but instead of sending the message to players, it returns the processed text. This is useful when you need to capture formatted messages for later use, such as setting descriptions, logging, or building complex output strings.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| message || string || The message template with formatters (same format as act())
|-
| visibility || integer || Visibility behavior (A_SOMEONE, A_HIDEINV, A_ALWAYS)
|-
| char || unitptr || The primary character unit (referenced as $1 in formatters)
|-
| medium || unitptr/string/integer || Secondary unit/object (referenced as $2 in formatters)
|-
| victim || unitptr/string/integer || Target unit/object (referenced as $3 in formatters)
|-
| to_whom || integer || Target audience (TO_CHAR, TO_ROOM, TO_ALL, TO_REST, TO_VICT, TO_NOTVICT)
|}

== Examples ==
=== Setting Room Descriptions ===
 dilbegin set_travel_description();
 var
     desc : string;
 code
 {
     // Create a dynamic description based on character state
     desc := sact(&quot;$1n is hurrying along.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     self.outside_descr := desc;
 }
 dilend

=== Building Status Messages ===
 dilbegin create_status_report(target : unitptr);
 var
     status : string;
     output : string;
 code
 {
     if (target == null)
         quit;
     
     // Build individual status lines
     status := sact(&quot;$1n is in perfect health.&quot;, A_SOMEONE, target, null, null, TO_CHAR);
     output := &quot;Health: &quot; + status + &quot;&amp;n&quot;;
     
     status := sact(&quot;$1n is standing here.&quot;, A_SOMEONE, target, null, null, TO_CHAR);
     output := output + &quot;Position: &quot; + status + &quot;&amp;n&quot;;
     
     pagestring(output, self);
 }
 dilend

=== Combat Message Logging ===
 dilbegin log_combat_action(victim : unitptr, weapon : unitptr);
 var
     log_msg : string;
 code
 {
     // Create combat message for logging
     log_msg := sact(&quot;$1n attacks $3n with $2n!&quot;, A_ALWAYS, self, weapon, victim, TO_CHAR);
     
     // Log the message (assuming log() function exists)
     log(&quot;COMBAT: &quot; + log_msg);
     
     // Also send to players
     act(&quot;$1n attacks $3n with $2n!&quot;, A_ALWAYS, self, weapon, victim, TO_NOTVICT);
     act(&quot;You attack $3n with $2n!&quot;, A_ALWAYS, self, weapon, victim, TO_CHAR);
 }
 dilend

=== Dynamic Object Descriptions ===
 dilbegin create_object_description(obj : unitptr);
 var
     desc : string;
 code
 {
     if (obj.type != UNIT_ST_OBJ)
         quit;
     
     // Create descriptive text based on object properties
     desc := sact(&quot;$2n lies here, $3s condition appears excellent.&quot;, 
                 A_SOMEONE, self.outside, obj, obj, TO_CHAR);
     
     // Set the room&apos;s extra description
     addextra(self.outside.extra, {&quot;object&quot;, &quot;item&quot;}, desc);
 }
 dilend

== Usage Notes ==
* Uses the same message formatters as the [[Manual:DIL_Manual/act|act]] function ($1n, $2n, $3n, etc.)
* Visibility constants (A_SOMEONE, A_HIDEINV, A_ALWAYS) work the same as in act()
* The to_whom parameter affects how visibility is processed but doesn&apos;t send messages
* Returns an empty string if formatting fails or required parameters are invalid
* Useful for creating dynamic descriptions, logging systems, or message queuing
* Can be used to build complex strings by combining multiple sact() calls

== Error Handling ==
* Returns empty string if message parameter is null or empty
* Returns empty string if char parameter is null and formatters reference $1
* Type checking occurs at runtime - invalid parameter types cause function failure
* Always validate return value before using in critical operations

== Formatters ==
The function supports all standard act() formatters:
; $1n : Name of char argument (with visibility handling)
; $2n : Name of medium argument
; $3n : Name of victim argument
; $1e, $2e, $3e : Pronouns (he/she/it)
; $1m, $2m, $3m : Object pronouns (him/her/it)
; $1s, $2s, $3s : Possessive pronouns (his/her/its)
; $1a, $2a, $3a : &apos;a&apos; or &apos;an&apos; based on name
; $1p, $2p, $3p : Position (standing, fighting, etc.)
; $1t, $2t, $3t : Raw string values

== Related Functions/Fields ==
* [[Manual:DIL_Manual/act|act]] - Function that sends formatted messages to players
* [[Manual:DIL_Manual/sendtext|sendtext]] - Function for sending raw text to players
* [[Manual:DIL_Manual/pagestring|pagestring]] - Function for sending paginated output
* [[Manual:DIL_Manual/outside_descr|outside_descr]] - Field commonly set with sact() results

== See Also ==
* [[Manual:DIL_Manual/act|act]] - Message sending function with same formatting
* [[Manual:DIL_Manual/sendtext|sendtext]] - Simple text output function
* [[Manual:DIL_Manual/pagestring|pagestring]] - Paginated text output function
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/savestr</title>
     <ns>0</ns>
     <id>942334</id>
     <revision>
       <id>918372</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of savestr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= savestr =
 function: integer &apos;&apos;&apos;savestr&apos;&apos;&apos;(filename : string, buff : string, wa : string);

The savestr function saves string data to a file on disk with options to write or append to existing files.

== Description ==
The savestr function writes string content to a file in the zone&apos;s strings directory. It supports both write mode (&quot;w&quot;) to overwrite existing files and append mode (&quot;a&quot;) to add content to existing files. The function includes security checks to prevent unauthorized file access and is commonly used for implementing persistent data storage systems like message boards, news files, and player data.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| filename || string || The name of the file to save (stored in zone&apos;s strings directory)
|-
| buff || string || The string content to be written to the file
|-
| wa || string || Write mode: &quot;w&quot; to overwrite file, &quot;a&quot; to append to file
|}

== Return Values ==
The function returns an integer indicating the operation result:
* Positive value (1 or higher) - File successfully saved
* 0 or negative value - Operation failed (FILE_NOT_SAVED, FILE_NOT_CREATED, or FILE_ILEGAL_OPP)

== Examples ==
=== Simple File Write ===
 dilbegin save_news_message(message : string);
 var
     result : integer;
 code
 {
     result := savestr(&quot;news.txt&quot;, message, &quot;w&quot;);
     
     if (result &gt; 0)
         sendtext(&quot;News message saved successfully.&amp;n&quot;, self);
     else
         sendtext(&quot;Failed to save news message.&amp;n&quot;, self);
 }
 dilend

=== Message Board System ===
 dilbegin post_to_board(subject : string, content : string);
 var
     board_name : string;
     timestamp : string;
     filename : string;
     result : integer;
 code
 {
     // Create timestamp for unique filename
     timestamp := itoa(realtime);
     filename := &quot;board_&quot; + timestamp;
     
     // Save the message content
     result := savestr(filename, content, &quot;w&quot;);
     
     if (result &gt; 0)
     {
         // Update board index by appending
         board_name := &quot;main_board.idx&quot;;
         result := savestr(board_name, subject + &quot; &quot; + timestamp + &quot;&amp;n&quot;, &quot;a&quot;);
         
         if (result &gt; 0)
             act(&quot;Your message has been posted to the board.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
         else
             act(&quot;Failed to update board index.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     }
     else
     {
         act(&quot;Failed to save your message.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
     }
 }
 dilend

=== Logging System ===
 dilbegin log_player_action(action : string);
 var
     log_entry : string;
     timestamp : string;
     result : integer;
 code
 {
     timestamp := itoa(realtime);
     log_entry := timestamp + &quot; &quot; + self.name + &quot;: &quot; + action;
     
     // Append to player&apos;s personal log file
     result := savestr(&quot;player_&quot; + self.name + &quot;.log&quot;, log_entry, &quot;a&quot;);
     
     // No error handling needed for logs - continue regardless of result
 }
 dilend

=== Data Persistence ===
 dilbegin save_npc_memory(target_name : string, memory_type : string, memory_data : string);
 var
     filename : string;
     result : integer;
 code
 {
     // Create unique filename for NPC memory
     filename := &quot;npc_&quot; + target_name + &quot;_&quot; + memory_type + &quot;.mem&quot;;
     
     result := savestr(filename, memory_data, &quot;w&quot;);
     
     if (result &gt; 0)
         act(&quot;You have recorded information about &quot; + target_name + &quot;.&quot;, 
              A_ALWAYS, self, null, null, TO_CHAR);
     else
         act(&quot;Failed to record the information.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }
 dilend

== Usage Notes ==
* Files are saved in the zone&apos;s strings subdirectory (automatically created if needed)
* Write mode &quot;w&quot; overwrites existing files completely
* Append mode &quot;a&quot; adds content to the end of existing files
* The wa parameter must be exactly &quot;w&quot; or &quot;a&quot; (lowercase)
* Zone access level restrictions apply - zones with access level &gt; 10 cannot use savestr
* Empty filename or content parameters cause function failure
* Disk operations are relatively slow - minimize file sizes and access frequency
* Use with [[Manual:DIL_Manual/loadstr|loadstr]] for complete persistent data storage solutions

== Error Handling ==
* Returns 0 or negative values for failed operations
* Empty string parameters cause function to return failure code
* Security violations (insufficient zone access) cause program termination
* File system errors (disk full, permissions) return failure codes
* Always check return value before assuming success
* Invalid write mode parameter causes function failure

== Security Considerations ==
* Function requires zone access level 10 or lower
* Files are restricted to zone&apos;s strings directory
* No path traversal - filename is relative to strings directory
* Zone-based isolation prevents cross-zone file access
* Security violations are logged and terminate the DIL program

== Related Functions/Fields ==
* [[Manual:DIL_Manual/loadstr|loadstr]] - Function to load strings saved with savestr
* [[Manual:DIL_Manual/delstr|delstr]] - Function to delete files created with savestr
* [[Manual:DIL_Manual/log|log]] - Function for server-side logging
* [[Manual:DIL_Manual/realtime|realtime]] - Function for getting current timestamp

== See Also ==
* [[Manual:DIL_Manual/loadstr|loadstr]] - Loading string data from files
* [[Manual:DIL_Manual/delstr|delstr]] - Deleting string files
* File I/O patterns for persistent data storage
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/secure</title>
     <ns>0</ns>
     <id>618069</id>
     <revision>
       <id>1759818</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of secure.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= secure =
 function: void &apos;&apos;&apos;secure&apos;&apos;&apos;(u : unitptr, label);

The secure function monitors a unit and transfers execution to a specified label when the unit leaves the local environment or is destroyed.

== Description ==
The secure function sets up monitoring on a unitptr, causing the DIL program to jump to the specified label if the unit becomes unavailable in the local environment. This happens when the unit is destroyed, moves to a different location, or otherwise leaves the current execution context. The function is essential for writing robust DIL programs that need to handle cases where target units may disappear during processing.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit to monitor for availability
|-
| label || label || The label to jump to when unit becomes unavailable
|}

== Examples ==
=== Basic Unit Protection ===
 dilbegin process_target(target : unitptr);
 var
     processing : integer;
 code
 {
     if (target == null)
         quit;
     
     secure(target, target_lost);
     processing := TRUE;
     
     while (processing)
     {
         // Safe to work with target here
         act(&quot;You process $2n.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
         pause;
     }
     
     :target_lost:
     act(&quot;Your target has disappeared!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }
 dilend

=== Item Collection with Security ===
 dilbegin collect_items();
 var
     item : unitptr;
 code
 {
     foreach (UNIT_ST_OBJ, item)
     {
         // Only collect items we can see and carry
         if (not visible(self, item))
             continue;
         if (can_carry(self, item, 1) &lt;= 0)
             continue;
         
         // Secure the item before processing
         secure(item, item_gone);
         
         // Attempt to get the item
         exec(&quot;get &quot; + item.name, self);
         pause;
         
         // If we reach here, item was successfully obtained
         unsecure(item);
         continue;
         
         :item_gone:
         act(&quot;$2n vanishes before you can grab it!&quot;, 
              A_ALWAYS, self, item, null, TO_CHAR);
         unsecure(item);
     }
 }
 dilend

=== NPC Interaction Guard ===
 dilbegin talk_to_npc(npc_name : string);
 var
     npc : unitptr;
     speech : stringlist;
 code
 {
     npc := findunit(self, npc_name, FIND_UNIT_SURRO, null);
     if (npc == null)
     {
         sendtext(&quot;You don&apos;t see &quot; + npc_name + &quot; here.&amp;n&quot;, self);
         quit;
     }
     
     if (npc.type != UNIT_ST_NPC)
     {
         sendtext(npc_name + &quot; is not an NPC.&amp;n&quot;, self);
         quit;
     }
     
     secure(npc, npc_left);
     
     speech := {&quot;Hello there!&quot;, &quot;Nice weather we&apos;re having.&quot;, &quot;Can I help you?&quot;};
     
     // Start conversation
     act(&quot;You say hello to $2n.&quot;, A_ALWAYS, self, npc, null, TO_CHAR);
     act(&quot;$1n says hello to you.&quot;, A_ALWAYS, self, npc, null, TO_VICT);
     
     pause;
     
     // Continue interaction would go here
     act(&quot;You continue talking with $2n.&quot;, A_ALWAYS, self, npc, null, TO_CHAR);
     
     :npc_left:
     act(npc.name + &quot; has disappeared!&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }
 dilend

=== Complex Processing with Cleanup ===
 dilbegin enchant_item(item_name : string);
 var
     item : unitptr;
     spell_power : integer;
 code
 {
     item := findunit(self, item_name, FIND_UNIT_IN_ME, null);
     if (item == null)
     {
         sendtext(&quot;You don&apos;t have &quot; + item_name + &quot;.&amp;n&quot;, self);
         quit;
     }
     
     secure(item, item_lost);
     
     // Simulate enchantment process
     spell_power := self.abilities[ABIL_MAGIC];
     
     act(&quot;You begin enchanting $2n.&quot;, A_ALWAYS, self, item, null, TO_CHAR);
     act(&quot;$1n begins enchanting $2n.&quot;, A_ALWAYS, self, item, null, TO_ROOM);
     
     pause; // Enchantment time
     pause;
     
     // If we reach here, enchantment succeeded
     act(&quot;You successfully enchant $2n!&quot;, A_ALWAYS, self, item, null, TO_CHAR);
     act(&quot;$2n glows with magical energy!&quot;, A_ALWAYS, null, item, null, TO_ROOM);
     
     unsecure(item);
     quit;
     
     :item_lost:
     act(&quot;Your enchantment fails - $2n has vanished!&quot;, 
          A_ALWAYS, self, item, null, TO_CHAR);
     unsecure(item);
 }
 dilend

== Usage Notes ==
* The secure function sets up monitoring that triggers when unit leaves local environment
* &quot;Leaving local environment&quot; includes: destruction, moving to another room, or becoming unavailable
* Transparent rooms within the same room do NOT trigger secure (unit is still in local environment)
* Multiple units can be secured simultaneously, each with their own labels
* Use [[Manual:DIL_Manual/unsecure|unsecure]] to remove monitoring when no longer needed
* Security checks cascade through DIL sub-function frames
* The label must be defined in the current DIL program scope

== Trigger Conditions ==
A secure() is automatically triggered under these circumstances:
* When the secured unit is destroyed (via [[Manual:DIL_Manual/destroy|destroy]] function)
* When the secured unit moves to a different room/location
* When the secured unit otherwise becomes unavailable in local environment
* When certain DIL functions are called that might affect the unit (exec, destroy, etc.)
* At every step of a [[Manual:DIL_Manual/foreach|foreach]] loop
* When returning from sub-functions that have active secure() monitoring

== Error Handling ==
* If the unit parameter is null, the function will fail with a runtime error
* If the label doesn&apos;t exist, the program will fail when triggered
* Always pair secure() with corresponding [[Manual:DIL_Manual/unsecure|unsecure]]() calls
* Multiple triggered secures will jump to the last event&apos;s label
* Nested secure() calls in sub-functions propagate to parent frames

== Related Functions/Fields ==
* [[Manual:DIL_Manual/unsecure|unsecure]] - Function to remove unit monitoring
* [[Manual:DIL_Manual/destroy|destroy]] - Function that can trigger secure() monitoring
* [[Manual:DIL_Manual/exec|exec]] - Function that can trigger secure() monitoring
* [[Manual:DIL_Manual/foreach|foreach]] - Loop structure that checks secure() at each iteration

== See Also ==
* [[Manual:DIL_Manual/unsecure|unsecure]] - Removing unit security monitoring
* Unit management and protection patterns
* DIL program control flow structures
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/self</title>
     <ns>0</ns>
     <id>877531</id>
     <revision>
       <id>1428907</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of self.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= self =
 variable: unitptr &apos;&apos;&apos;self&apos;&apos;&apos;

The self variable is a unitptr that always refers to the unit currently executing the DIL program.

== Description ==
The self variable is a built-in unitptr that automatically points to the unit owning and running the current DIL program. It provides direct access to all properties and fields of the executing unit, whether it&apos;s a player character, NPC, object, or room. This is the primary way for DIL programs to reference and modify the unit that triggered their execution.

== Examples ==
=== Basic Self Reference ===
 dilbegin check_self_info();
 var
     info : string;
 code
 {
     info := &quot;You are &quot; + self.name + &quot; (&quot; + self.title + &quot;)&quot;;
     if (self.type == UNIT_ST_PC)
         info := info + &quot; - Player Character&quot;;
     else if (self.type == UNIT_ST_NPC)
         info := info + &quot; - Non-Player Character&quot;;
     else if (self.type == UNIT_ST_OBJ)
         info := info + &quot; - Object&quot;;
     else if (self.type == UNIT_ST_ROOM)
         info := info + &quot; - Room&quot;;
     
     sendtext(info + &quot;&amp;n&quot;, self);
 }
 dilend

=== Self in Combat ===
 dilbegin combat_status();
 var
     status : string;
 code
 {
     if (self.position == POSITION_FIGHTING)
     {
         if (self.fighting)
             status := &quot;You are fighting &quot; + self.fighting.name;
         else
             status := &quot;You are in combat but not fighting anyone&quot;;
     }
     else
         status := &quot;You are not in combat&quot;;
     
     act(&quot;$1n checks $1s combat status.&quot;, A_ALWAYS, self, null, TO_CHAR);
     sendtext(status + &quot;&amp;n&quot;, self);
 }
 dilend

=== Self Modification ===
 dilbegin heal_self(amount : integer);
 var
     old_hp : integer;
     new_hp : integer;
 code
 {
     old_hp := self.hp;
     new_hp := self.hp + amount;
     
     // Check bounds
     if (new_hp &gt; self.max_hp)
         new_hp := self.max_hp;
     if (new_hp &lt; 0)
         new_hp := 0;
     
     self.hp := new_hp;
     
     act(&quot;$1n feels better.&quot;, A_ALWAYS, self, null, TO_CHAR);
     act(&quot;$1n looks healthier.&quot;, A_ALWAYS, self, null, TO_ROOM);
     
     sendtext(&quot;HP: &quot; + itoa(old_hp) + &quot; -&gt; &quot; + itoa(new_hp) + &quot;&amp;n&quot;, self);
 }
 dilend

=== Self in Environmental Context ===
 dilbegin environmental_check();
 var
     env_info : string;
 code
 {
     env_info := &quot;Location: &quot; + self.outside.nameidx + &quot;@&quot; + self.outside.zoneidx;
     
     if (self.inside)
         env_info := env_info + &quot; (inside &quot; + self.inside.name + &quot;)&quot;;
     else
         env_info := env_info + &quot; (not inside anything)&quot;;
     
     if (self.outside.inside == self)
         env_info := env_info + &quot; - You are the room itself&quot;;
     
     sendtext(env_info + &quot;&amp;n&quot;, self);
 }
 dilend

=== Self Type Checking ===
 dilbegin type_specific_action();
 code
 {
     if (self.type == UNIT_ST_PC)
     {
         // Player-specific behavior
         if (self.level &lt; 5)
             sendtext(&quot;You are too inexperienced for this action.&amp;n&quot;, self);
         else
             sendtext(&quot;You perform the advanced action.&amp;n&quot;, self);
     }
     else if (self.type == UNIT_ST_NPC)
     {
         // NPC-specific behavior
         act(&quot;$1n nods knowingly.&quot;, A_ALWAYS, self, null, TO_ROOM);
     }
     else if (self.type == UNIT_ST_OBJ)
     {
         // Object-specific behavior
         sendtext(&quot;Objects cannot perform actions themselves.&amp;n&quot;, self);
     }
     else if (self.type == UNIT_ST_ROOM)
     {
         // Room-specific behavior
         sendtext(&quot;Rooms cannot perform actions.&amp;n&quot;, self);
     }
 }
 dilend

== Usage Notes ==
* self is always available in any DIL program - no declaration needed
* The type of unit self points to depends on what triggered the DIL program
* self provides access to all standard unit fields (name, title, hp, position, etc.)
* When used on objects, self refers to the object itself
* When used on rooms, self refers to the room unit
* self is equivalent to &apos;this&apos; pointer in many programming languages
* Changes to self&apos;s properties affect the actual unit in the game world

== Common Self Properties ==
Depending on the unit type, self provides access to different fields:
; For PC/NPC: self.name, self.title, self.level, self.hp, self.position, self.fighting
; For Objects: self.name, self.title, self.objecttype, self.value[], self.inside
; For Rooms: self.nameidx, self.zoneidx, self.title, self.inside, self.outside

== Error Handling ==
* self is never null - it always points to a valid unit
* Accessing fields that don&apos;t exist for the unit type will cause runtime errors
* Always check self.type before accessing type-specific fields
* Some operations may fail if self is in an invalid state (e.g., dead PC)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/activator|activator]] - Unit that triggered the current DIL activation
* [[Manual:DIL_Manual/unitptr|unitptr]] - General unit pointer type and operations
* [[Manual:DIL_Manual/position|position]] - Field for unit&apos;s current position
* [[Manual:DIL_Manual/type|type]] - Field for unit&apos;s type (UNIT_ST_* constants)

== See Also ==
* Unit type constants and their specific fields
* DIL program activation and execution context
* Unit field access and modification patterns
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/send</title>
     <ns>0</ns>
     <id>320089</id>
     <revision>
       <id>1618638</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of send.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= send =
 function: void &apos;&apos;&apos;send&apos;&apos;&apos;(message : string);

The &apos;&apos;&apos;send&apos;&apos;&apos; function sends a message to all DIL programs in the current local environment that are waiting for SFB_MSG messages.

== Description ==
The send function broadcasts a message to all DIL programs in the current local environment that are waiting with the SFB_MSG flag. Only programs that have the SFB_MSG message class enabled will receive the message.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| message || string || The message string to send to waiting DIL programs
|}

== Examples ==
=== Basic Message Sending ===
 dilbegin message_sender();
 code
 {
    send(&quot;hello_world&quot;);
    quit;
 } dilend

=== Message Receiver ===
 dilbegin message_receiver();
 code
 {
    wait(SFB_MSG);
    send(&quot;Received: &quot; + argument);
    quit;
 } dilend

=== Simple Communication ===
 dilbegin coordinator();
 code
 {
    send(&quot;task_complete&quot;);
    pause;
    send(&quot;cleanup_ready&quot;);
    quit;
 } dilend

== Usage Notes ==
* Messages are only sent to programs in the same local environment
* Only programs waiting with SFB_MSG will receive the message
* The function is commonly used for inter-program communication
* Use the &apos;aware&apos; keyword in DIL programs that need to receive messages from their owner
* The function is different from sendtext() which sends text directly to a player

== Error Handling ==
* Validates that the parameter is a string type
* If the parameter is null or invalid, the function fails silently
* The C implementation includes null pointer checking before sending the message

== Related Functions/Fields ==
* [[Manual:DIL_Manual/sendto|sendto]] - Sends a message to DIL programs in a specific unit
* [[Manual:DIL_Manual/sendtext|sendtext]] - Sends text directly to a player
* [[Manual:DIL_Manual/sendtoall|sendtoall]] - Sends a message to all DIL programs globally
* [[Manual:DIL_Manual/sendtoalldil|sendtoalldil]] - Sends a message to all DIL programs matching a pattern

== See Also ==
* [[Manual:DIL_Manual/SFB_MSG|SFB_MSG]] - Message class flag for receiving messages
* [[Manual:DIL_Manual/wait|wait]] - Function for waiting on specific message classes
* [[Manual:DIL_Manual/activator|activator]] - Variable containing the message sender
* [[Manual:DIL_Manual/argument|argument]] - Variable containing the message content</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/send_done</title>
     <ns>0</ns>
     <id>736136</id>
     <revision>
       <id>1127554</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of send_done.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= send_done =
 function: void &apos;&apos;&apos;send_done&apos;&apos;&apos;(c : string, a : unitptr, m : unitptr, t : unitptr, p : integer, arg : string, o : unitptr, i : integer);

The &apos;&apos;&apos;send_done&apos;&apos;&apos; function sends completion messages to DIL programs that are waiting for specific operations to finish.

== Description ==
The send_done function sends an SFB_DONE message to DIL programs in the surrounding area that are waiting for a specific command or operation to complete. This is commonly used in command implementations to notify other DIL programs that an operation has finished, allowing them to resume execution or perform cleanup tasks.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| c || string || Command string that identifies the completed operation
|-
| a || unitptr || Activator unit that triggered the operation
|-
| m || unitptr || Medium unit involved in the operation
|-
| t || unitptr || Target unit of the operation
|-
| p || integer || Power/parameter value for the message
|-
| arg || string || Argument string passed with the message
|-
| o || unitptr || Other unit to receive the message
|-
| i || integer || CMD_AUTO_XXX value or 0 for no auto command
|}

== Examples ==
=== Basic Command Completion ===
 dilbegin read_command(target_name : string);
 var
     board : unitptr;
 code
 {
     board := findunit(self, target_name, FIND_UNIT_SURRO, null);
     if (board == null)
     {
         sendtext(&quot;No board found.&amp;n&quot;, self);
         quit;
     }
     
     // Notify other programs that reading has started
     send_done(&quot;read&quot;, self, null, board, 0, argument, null, 0);
     
     // Notify completion
     send_done(&quot;read&quot;, self, null, board, 0, argument, null, 0);
 }
 dilend

=== Multi-Program Coordination ===
 dilbegin complex_operation(item : unitptr);
 var
     worker : unitptr;
 code
 {
     // Start operation and notify worker programs
     send_done(&quot;process&quot;, self, null, item, 1, &quot;start&quot;, null, 0);
     
     // Notify completion
     send_done(&quot;process&quot;, self, null, item, 1, &quot;complete&quot;, null, 0);
 }
 dilend

=== State Management ===
 dilbegin state_machine(target_state : string);
 code
 {
     // Transition to new state
     send_done(&quot;transition&quot;, self, null, null, 1, target_state, null, 0);
     
     // Notify state change complete
     send_done(&quot;state_change&quot;, self, null, null, 2, target_state, null, 0);
 }
 dilend

== Usage Notes ==
* The function sends SFB_DONE messages to waiting DIL programs
* Programs must be waiting with interrupt(SFB_DONE, ...) to receive these messages
* The command string &apos;c&apos; identifies the operation being completed
* Parameter &apos;i&apos; uses CMD_AUTO_* constants or 0 for no auto command
* The function is commonly used for multi-program coordination and command completion
* Messages are sent to all DIL programs in the surrounding area
* Use with [[Manual:DIL_Manual/interrupt|interrupt]] function to handle incoming completion messages

== Error Handling ==
* Function will fail if any required parameters are null or invalid
* Invalid command strings may cause unpredictable behavior
* No return value - function is void and cannot indicate success/failure
* Ensure target programs are properly waiting for SFB_DONE messages

== Related Functions/Fields ==
* [[Manual:DIL_Manual/interrupt|interrupt]] - Function to receive completion messages
* [[Manual:DIL_Manual/send_pre|send_pre]] - Function for sending command preparation messages
* [[Manual:DIL_Manual/exec|exec]] - Function for executing commands on units
* [[Manual:DIL_Manual/activator|activator]] - Built-in variable for operation trigger
* [[Manual:DIL_Manual/medium|medium]] - Built-in variable for operation context

== See Also ==
* DIL program coordination and synchronization
* Message passing between DIL programs
* Command implementation patterns</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/send_pre</title>
     <ns>0</ns>
     <id>1118209</id>
     <revision>
       <id>1179235</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of send_pre.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= send_pre =
 function: integer &apos;&apos;&apos;send_pre&apos;&apos;&apos;(c : string, a : unitptr, m : unitptr, t : unitptr, p : integer, arg : string, o : unitptr);

The &apos;&apos;&apos;send_pre&apos;&apos;&apos; function sends preparation messages to DIL programs that are waiting for specific commands to start, with optional blocking capabilities.

== Description ==
The send_pre function sends an SFB_PRE message to DIL programs in the surrounding area that are waiting for a specific command to be executed. This function is commonly used to coordinate between multiple DIL programs, allowing one program to notify others that it&apos;s about to execute a command. The function can either allow sharing (SFR_SHARE) or block the command (SFR_BLOCK) if another program is already handling it.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| c || string || Command string that is being prepared for execution
|-
| a || unitptr || Activator unit that is preparing the command
|-
| m || unitptr || Medium unit through which the command is being processed
|-
| t || unitptr || Target unit of the command preparation
|-
| p || integer || Power/parameter value for the message
|-
| arg || string || Argument string passed with the command
|-
| o || unitptr || Other unit to also receive the message
|}

== Return Values ==
The function returns an integer indicating the result:
* SFR_SHARE - Command can be shared/allowed to proceed
* SFR_BLOCK - Command is blocked by another program

== Examples ==
=== Basic Command Preparation ===
 dilbegin prepare_cast(spell_name : string, target : unitptr);
 var
     result : integer;
 code
 {
     result := send_pre(&quot;cast&quot;, self, null, target, 1, spell_name, null, 0);
     
     if (result == SFR_BLOCK)
     {
         sendtext(&quot;Another spellcaster is already preparing that spell.&amp;n&quot;, self);
         quit;
     }
     
     act(&quot;You begin preparing &quot; + spell_name + &quot; spell.&quot;, A_ALWAYS, self, target, null, TO_CHAR);
 }
 dilend

=== Command Blocking System ===
 dilbegin exclusive_command(command_name : string);
 var
     result : integer;
 code
 {
     result := send_pre(command_name, self, null, null, 1, argument, null, 0);
     
     if (result == SFR_BLOCK)
     {
         sendtext(&quot;The &quot; + command_name + &quot; command is already in use.&amp;n&quot;, self);
         quit;
     }
     
     act(&quot;You gain exclusive access to &quot; + command_name + &quot; command.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }
 dilend

=== Resource Management ===
 dilbegin use_resource(resource_type : string, amount : integer);
 var
     resource_manager : unitptr;
     result : integer;
 code
 {
     resource_manager := findunit(self, &quot;resource_mgr&quot;, FIND_UNIT_SURRO, null);
     if (resource_manager == null)
         quit;
     
     result := send_pre(&quot;allocate&quot;, self, null, resource_manager, 1, resource_type, itoa(amount), 0);
     
     if (result == SFR_BLOCK)
     {
         sendtext(&quot;Resource allocation denied by manager.&amp;n&quot;, self);
         quit;
     }
     
     act(&quot;You allocate &quot; + itoa(amount) + &quot; units of &quot; + resource_type + &quot;.&quot;, A_ALWAYS, self, null, null, TO_CHAR);
 }
 dilend

== Usage Notes ==
* The function sends SFB_PRE messages to waiting DIL programs
* Programs must be waiting with interrupt(SFB_PRE, ...) to receive these messages
* The command string &apos;c&apos; identifies the command being prepared
* Parameter &apos;p&apos; determines message priority and handling behavior
* Return value indicates whether command can proceed (SFR_SHARE) or is blocked (SFR_BLOCK)
* Commonly used for command coordination and resource management systems

== Return Value Meanings ==
; SFR_SHARE : Command preparation successful and can proceed
; SFR_BLOCK : Command is blocked by another program or system restriction

== Error Handling ==
* Function will fail if any required parameters are null or invalid
* Invalid command strings may cause unpredictable behavior
* Always check return value before proceeding with command execution
* Parameter validation occurs at runtime - invalid types cause execution errors

== Related Functions/Fields ==
* [[Manual:DIL_Manual/send_done|send_done]] - Function for sending completion messages
* [[Manual:DIL_Manual/interrupt|interrupt]] - Function to receive preparation messages
* [[Manual:DIL_Manual/exec|exec]] - Function for executing commands
* [[Manual:DIL_Manual/send|send]] - Function for sending messages to units
* [[Manual:DIL_Manual/wait|wait]] - Function for waiting with interrupt conditions

== See Also ==
* DIL program coordination and synchronization
* Command blocking and access control
* Message passing between DIL programs</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sendtext</title>
     <ns>0</ns>
     <id>1271162</id>
     <revision>
       <id>992071</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sendtext.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= sendtext =
 function: void &apos;&apos;&apos;sendtext&apos;&apos;&apos;(s : string, u : unitptr);

The &apos;&apos;&apos;sendtext&apos;&apos;&apos; function sends a text message to a specific unit, commonly used for player communication and feedback.

== Description ==
The sendtext function sends a text message directly to a specified unit. This is the primary method for delivering text output to player characters in DIL programs. The function handles special formatting for player characters, including automatic line breaks and proper text display. For non-player units, it functions as a simple message delivery mechanism.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The text message to send to the unit
|-
| u || unitptr || The unit that will receive the text message
|}

== Examples ==
=== Basic Message Sending ===
 dilbegin greet_player(player_name : string);
 var
     target : unitptr;
 code
 {
     target := findunit(self, player_name, FIND_UNIT_WORLD, null);
     if (target == null)
     {
         sendtext(&quot;Player not found.&amp;n&quot;, self);
         quit;
     }
     
     sendtext(&quot;Hello, &quot; + player_name + &quot;!&amp;n&quot;, target);
 }
 dilend

=== Status Display ===
 dilbegin show_status();
 var
     hp_percent : integer;
 code
 {
     hp_percent := (self.hp * 100) / self.max_hp;
     sendtext(&quot;Health: &quot; + itoa(hp_percent) + &quot;%&amp;n&quot;, self);
 }
 dilend

=== Error Messages ===
 dilbegin validate_input(input : string);
 var
     valid : integer;
 code
 {
     valid := TRUE;
     
     if (input == &quot;&quot;)
     {
         sendtext(&quot;Error: Empty input.&amp;n&quot;, self);
         valid := FALSE;
     }
     
     if (valid)
         sendtext(&quot;Input accepted: &quot; + input + &quot;&amp;n&quot;, self);
 }
 dilend

== Usage Notes ==
* The function automatically handles text formatting for player characters
* For non-player units, text is sent as a simple message
* No automatic line break - you must manually add &amp;n for new lines
* Commonly used for player feedback, status updates, and error messages
* More efficient than multiple [[Manual:DIL_Manual/act|act]] calls for simple text delivery
* Text is sent immediately - no queuing or delay

== Player-Specific Behavior ==
When sending to player characters (UNIT_ST_PC):
* Automatic line break handling for proper display
* Text appears in the player&apos;s message window/terminal
* Supports color codes and formatting if the MUD client supports them

== Error Handling ==
* Function will fail if the target unit is null
* No validation of text content - any string is accepted
* No return value - function cannot indicate success or failure
* Always validate target unit before calling sendtext

== Related Functions/Fields ==
* [[Manual:DIL_Manual/act|act]] - Function for sending formatted social messages
* [[Manual:DIL_Manual/send_done|send_done]] - Function for sending completion notifications
* [[Manual:DIL_Manual/send_pre|send_pre]] - Function for sending preparation messages
* [[Manual:DIL_Manual/pagestring|pagestring]] - Function for sending paginated output
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type and operations

== See Also ==
* Player communication and message systems
* Text output and display functions
* Unit interaction and feedback patterns</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sendto</title>
     <ns>0</ns>
     <id>341870</id>
     <revision>
       <id>1817708</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sendto.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= sendto =
 function: void &apos;&apos;&apos;sendto&apos;&apos;&apos;(s : string, u : unitptr);

The &apos;&apos;&apos;sendto&apos;&apos;&apos; function sends a message to all DIL programs within a specific unit.

== Description ==
The sendto function sends a message to all DIL programs that are currently inside the specified unit. This is commonly used to communicate with DIL programs that are running within objects, NPCs, or rooms. The message is sent with the SFB_MSG message class, allowing receiving programs to respond appropriately.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The message to send to all programs within the unit
|-
| u || unitptr || The unit containing the DIL programs to receive the message
|}

== Examples ==
=== Object Communication ===
 dilbegin magic_sword_speak();
 code
 {
     sendto(&quot;The sword glows with ancient power.&quot;, self);
     pause;
     sendto(&quot;The sword whispers: &apos;I am ready for battle!&apos;&quot;, self);
 }
 dilend

=== Room Messages ===
 dilbegin room_announcement();
 var
     message : string;
 code
 {
     message := &quot;The room begins to shake violently!&quot;;
     sendto(message, self.outside);
     
     pause;
     sendto(&quot;The shaking subsides.&quot;, self.outside);
 }
 dilend

=== Container Communication ===
 dilbegin chest_talk();
 var
     chest : unitptr;
 code
 {
     chest := findunit(self, &quot;chest&quot;, FIND_UNIT_SURRO, null);
     if (chest == null)
         quit;
     
     sendto(&quot;The chest rumbles: &apos;Who dares to open me?&apos;&quot;, chest);
     
     if (chest.inside != null)
         sendto(&quot;The chest speaks: &apos;Someone is already inside!&apos;&quot;, chest);
     else
         sendto(&quot;The chest speaks: &apos;I am empty and waiting.&apos;&quot;, chest);
 }
 dilend

== Usage Notes ==
* The function sends messages to all DIL programs within the target unit
* Messages are sent with the SFB_MSG message class
* Receiving programs must be waiting with interrupt(SFB_MSG, ...) to receive messages
* The target unit must contain DIL programs for the messages to be received
* Commonly used for object-NPC, object-room, and room-program communication
* No automatic formatting like [[Manual:DIL_Manual/sendtext|sendtext]] - messages are sent as-is

== Message Reception ==
DIL programs can receive sendto messages using:
 interrupt(SFB_MSG, condition, label)
The condition typically checks if the message is relevant to the receiving program.

== Error Handling ==
* Function will fail if the target unit is null
* No validation of message content - any string is accepted
* No return value - function cannot indicate success or failure
* Invalid unit pointers may cause runtime errors

== Related Functions/Fields ==
* [[Manual:DIL_Manual/sendtoall|sendtoall]] - Function for sending messages to all units globally
* [[Manual:DIL_Manual/sendtoalldil|sendtoalldil]] - Function for sending to specific DIL programs
* [[Manual:DIL_Manual/sendtext|sendtext]] - Function for sending text to specific units
* [[Manual:DIL_Manual/interrupt|interrupt]] - Function for receiving incoming messages
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type and operations
* [[Manual:DIL_Manual/inside|inside]] - Field for accessing units within containers

== See Also ==
* DIL program communication and coordination
* Message passing and synchronization
* Unit interaction and container systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sendtoall</title>
     <ns>0</ns>
     <id>1255074</id>
     <revision>
       <id>1362682</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sendtoall.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= sendtoall =
 function: void &apos;&apos;&apos;sendtoall&apos;&apos;&apos;(m : string, s : string);

The &apos;&apos;&apos;sendtoall&apos;&apos;&apos; function sends a message to all DIL programs that match a specific database name pattern.

== Description ==
The sendtoall function sends a message to all DIL programs in the entire MUD that have a specific database name matching the provided pattern. This is commonly used for global announcements, system-wide notifications, or communicating with specific types of DIL programs (like all programs with a certain zone or function). The message is sent with the SFB_MSG message class, allowing receiving programs to filter and respond appropriately.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| m || string || The message to send to all matching DIL programs
|-
| s || string || The database name pattern to match against DIL programs
|}

== Examples ==
=== Global Announcement ===
 dilbegin system_shutdown(minutes : integer);
 var
     message : string;
 code
 {
     message := &quot;SYSTEM SHUTDOWN IN &quot; + itoa(minutes) + &quot; MINUTES!&quot;;
     sendtoall(message, &quot;sys_control&quot;);
 }
 dilend

=== Zone-Wide Communication ===
 dilbegin zone_announcement(zone_name : string, announcement : string);
 var
     message : string;
 code
 {
     message := &quot;ZONE ANNOUNCEMENT: &quot; + zone_name + &quot; - &quot; + announcement;
     sendtoall(message, zone_name + &quot;_*&quot;);
 }
 dilend

=== Function-Type Communication ===
 dilbegin notify_all_wizards(spell_name : string);
 var
     message : string;
 code
 {
     message := &quot;NEW SPELL AVAILABLE: &quot; + spell_name;
     sendtoall(message, &quot;spell_*&quot;);
 }
 dilend

=== Emergency Broadcast ===
 dilbegin emergency_alert(alert_type : string, location : string);
 var
     message : string;
 code
 {
     message := &quot;EMERGENCY [&quot; + alert_type + &quot;] AT &quot; + location;
     sendtoall(message, &quot;emergency_*&quot;);
 }
 dilend

== Usage Notes ==
* The function sends messages to all DIL programs matching the database name pattern
* The pattern matching uses string comparison, not exact matching
* Wildcards (*) can be used in the database name pattern
* Messages are sent with SFB_MSG message class
* Receiving programs must be waiting with interrupt(SFB_MSG, ...) to receive messages

== Pattern Matching ==
The database name pattern matching follows these rules:
* Exact match: &quot;program_name&quot; matches only programs with that exact name
* Wildcard match: &quot;prefix_*&quot; matches all programs starting with &quot;prefix_&quot;
* Multiple wildcards: &quot;*_admin*&quot; matches all admin programs
* Case-sensitive matching applies to database names

== Error Handling ==
* Function will fail if either parameter is null or invalid
* No validation of message content - any string is accepted
* No return value - function is void and cannot indicate success or failure

== Related Functions/Fields ==
* [[Manual:DIL_Manual/sendto|sendto]] - Function for sending messages to specific units
* [[Manual:DIL_Manual/sendtoalldil|sendtoalldil]] - Function for sending to specific DIL programs
* [[Manual:DIL_Manual/interrupt|interrupt]] - Function for receiving incoming messages
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type and database name matching
* [[Manual:DIL_Manual/nameidx|nameidx]] - Field for unit&apos;s database name

== See Also ==
* DIL program communication and coordination
* Message passing and synchronization systems
* Database name patterns and matching</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sendtoalldil</title>
     <ns>0</ns>
     <id>518667</id>
     <revision>
       <id>950238</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sendtoalldil.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= sendtoalldil =
 function: void &apos;&apos;&apos;sendtoalldil&apos;&apos;&apos;(m : string, s : string);

The sendtoalldil function sends a message to all DIL programs matching a specific database name, with special handling for nested DIL programs.

== Description ==
The sendtoalldil function sends a message to all DIL programs in the entire MUD that have a specific database name matching the provided pattern. This function is commonly used for global announcements, system-wide notifications, or communicating with specific types of DIL programs (like all programs with a certain zone or function). The message is sent with the SFB_MSG message class, allowing receiving programs to filter and respond appropriately. The function includes special handling for nested DIL programs to prevent infinite recursion.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| m || string || The message to send to all matching DIL programs
|-
| s || string || The database name pattern to match against DIL programs
|}

== Examples ==
=== Global System Announcement ===
 dilbegin system_wide_alert(alert_message : string);
 var
     message : string;
 code
 {
     message := &quot;SYSTEM ALERT: &quot; + alert_message;
     
     // Send to all system programs
     sendtoalldil(message, &quot;sys_*&quot;);
     
     act(&quot;System alert broadcasted.&quot;, A_ALWAYS, self, null, TO_CHAR);
 }
 dilend

=== Zone-Specific Communication ===
 dilbegin zone_notification(zone_name : string, notification : string);
 var
     message : string;
 code
 {
     message := &quot;ZONE &quot; + zone_name.toUpperCase() + &quot;: &quot; + notification;
     
     // Send to all programs in specific zone
     sendtoalldil(message, zone_name + &quot;_*&quot;);
     
     act(&quot;Zone notification sent to &quot; + zone_name + &quot;.&quot;, A_ALWAYS, self, null, TO_CHAR);
 }
 dilend

=== Function-Type Coordination ===
 dilbegin notify_all_spellcasters(spell_name : string);
 var
     message : string;
 code
 {
     message := &quot;NEW SPELL: &quot; + spell_name + &quot; available for study.&quot;;
     
     // Send to all spell-related programs
     sendtoalldil(message, &quot;spell_*&quot;);
     
     act(&quot;All spellcasters notified.&quot;, A_ALWAYS, self, null, TO_CHAR);
 }
 dilend

=== Administrative Communication ===
 dilbegin admin_broadcast(admin_message : string);
 var
     message : string;
 code
 {
     message := &quot;ADMIN: &quot; + admin_message;
     
     // Send to all administrative programs
     sendtoalldil(message, &quot;admin_*&quot;);
     
     act(&quot;Administrative message sent.&quot;, A_ALWAYS, self, null, TO_CHAR);
 }
 dilend

=== Debug Communication ===
 dilbegin debug_system_wide(debug_info : string);
 var
     message : string;
 code
 {
     message := &quot;DEBUG: &quot; + debug_info;
     
     // Send to all debug programs
     sendtoalldil(message, &quot;debug_*&quot;);
     
     act(&quot;Debug information broadcasted.&quot;, A_ALWAYS, self, null, TO_CHAR);
 }
 dilend

=== Pattern Matching with Wildcards ===
 dilbegin notify_all_guards();
 var
     message : string;
 code
 {
     message := &quot;SECURITY ALERT: Suspicious activity detected.&quot;;
     
     // Send to all guard programs (using wildcard pattern)
     sendtoalldil(message, &quot;guard_*&quot;);
     
     // Also send to all security programs
     sendtoalldil(message, &quot;security_*&quot;);
 }
 dilend

=== Complex Nested Program Handling ===
 dilbegin complex_coordinator();
 var
     message : string;
 code
 {
     message := &quot;COORDINATION: System update complete.&quot;;
     
     // Send to all coordinator programs
     sendtoalldil(message, &quot;coordinator_*&quot;);
     
     // This demonstrates the special handling for nested programs
     // The C implementation shows it prevents infinite recursion
     // by checking for nested DIL programs before activation
 }
 dilend

== Usage Notes ==
* The function sends messages to all DIL programs matching a database name pattern
* The database name pattern matching uses string comparison, not exact matching
* Wildcards (*) can be used in the database name pattern
* Messages are sent with SFB_MSG message class
* Receiving programs must be waiting with interrupt(SFB_MSG, ...) to receive messages
* Special handling prevents infinite recursion with nested DIL programs
* Commonly used for global announcements and system-wide communication
* The database name pattern can be a full name or partial match with wildcards

== Message Reception ==
DIL programs can receive sendtoalldil messages using:
interrupt(SFB_MSG, condition, label)
The condition typically checks if the message is relevant to the receiving program.

== Database Name Pattern Matching ==
The database name pattern matching follows these rules:
* Exact match: &quot;program_name&quot; matches only programs with that exact name
* Wildcard match: &quot;prefix_*&quot; matches all programs starting with &quot;prefix_&quot;
* Multiple wildcards: &quot;*_admin*&quot; matches all admin programs
* Case-sensitive matching applies to database names
* The pattern is matched against each program&apos;s database name

== Error Handling ==
* Function will fail if either parameter is null or invalid
* No validation of message content - any string is accepted
* No return value - function is void and cannot indicate success or failure
* Messages may not be received if no programs are waiting for SFB_MSG messages
* Invalid database name patterns may cause unpredictable behavior
* Special handling for nested programs prevents runtime errors

== Common Use Cases ==
* Global system announcements and shutdowns
* Zone-specific communications and notifications
* Function-type program coordination (wizards, guards, etc.)
* Administrative messages and debug information
* Cross-zone communication and system synchronization
* Pattern matching with wildcards for flexible targeting

== Related Functions/Fields ==
* [[Manual:DIL_Manual/sendtoall|sendtoall]] - Function for sending messages to all units globally
* [[Manual:DIL_Manual/sendto|sendto]] - Function for sending messages to specific units
* [[Manual:DIL_Manual/interrupt|interrupt]] - Function for receiving incoming messages
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type and database name operations
* [[Manual:DIL_Manual/nameidx|nameidx]] - Field for unit&apos;s database name

== See Also ==
* DIL program communication and coordination
* Message passing and synchronization systems
* Database name patterns and matching
* Global and zone-specific messaging systems </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/set</title>
     <ns>0</ns>
     <id>477349</id>
     <revision>
       <id>1152492</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of set.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= set =
 function: void &apos;&apos;&apos;set&apos;&apos;&apos;(var : integer, bit : integer);

The &apos;&apos;&apos;set&apos;&apos;&apos; function is used to set specific bits in an integer variable using bitwise OR operations.

== Description ==
This function performs a bitwise OR operation between the integer variable and the bit mask, effectively setting the specified bits in the variable. The first parameter must be a variable (lvalue) that can be modified, while the second parameter is the bit mask to set.

The function supports various integer sizes including signed and unsigned 8-bit, 16-bit, and 32-bit integers. It&apos;s commonly used for manipulating flag fields and status bits in DIL programs.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| var || integer (variable) || The integer variable whose bits will be set (must be an lvalue)
|-
| bit || integer || The bit mask representing the bits to set
|}

The var parameter must be a modifiable integer variable, not a constant or expression result.

== Examples ==
=== Basic Flag Setting ===
 dilbegin set_player_flags();
 var
    flags : integer;
 code
 {
    flags := 0;
    
    // Set individual flags
    set(flags, 0x01);  // Set bit 0
    set(flags, 0x02);  // Set bit 1
    set(flags, 0x04);  // Set bit 2
    
    // flags now equals 0x07 (bits 0, 1, and 2 are set)
 } dilend

=== Character Flag Manipulation ===
 dilbegin toggle_wizard_mode();
 var
    pc : unitptr;
 code
 {
    pc := activator;
    
    if (pc.type != UNIT_ST_PC)
       quit;
    
    // Set the wizard mode flag
    set(pc.pcflags, PC_WIZARD);
    
    sendtext(&quot;You are now in wizard mode!&lt;br/&gt;&quot;, pc);
 } dilend

=== Multiple Flag Operations ===
 dilbegin configure_object();
 var
    obj : unitptr;
 code
 {
    obj := self;
    
    // Set multiple object flags at once
    set(obj.flags, UNIT_FL_MAGIC | UNIT_FL_GLOW | UNIT_FL_HUM);
    
    act(&quot;$1n begins to glow with magical energy.&quot;, A_SOMEONE, obj, null, null, TO_ROOM);
 } dilend

== Usage Notes ==
* The first parameter must be a variable (lvalue), not a constant or expression
* The function uses bitwise OR operation: result = var | bit
* Multiple bits can be set simultaneously using the bitwise OR operator in the bit parameter
* The function supports all standard integer sizes (8, 16, and 32-bit, both signed and unsigned)
* Commonly used with predefined flag constants (PC_*, CHAR_*, UNIT_*, ROOM_*, etc.)
* Setting a bit that is already set has no effect

== Error Handling ==
The function includes several validation checks:

* **Variable validation**: The first parameter must be a modifiable integer variable (lvalue)
* **Type validation**: Both parameters must be of integer type
* **Reference validation**: The variable must be a valid reference that can be modified

Common error scenarios:
* Passing a constant or expression result as the first parameter
* Using non-integer types
* Attempting to modify read-only variables or fields

== Related Functions/Fields ==
* [[Manual:DIL_Manual/unset()|unset()]] - Function to clear specific bits in an integer variable
* [[Manual:DIL_Manual/isset()|isset()]] - Function to test if specific bits are set in an integer
* [[Manual:DIL_Manual/pcflags|pcflags]] - Player character flags field
* [[Manual:DIL_Manual/charflags|charflags]] - Character flags field
* [[Manual:DIL_Manual/flags|flags]] - General unit flags field
* [[Manual:DIL_Manual/roomflags|roomflags]] - Room flags field

== See Also ==
* [[Manual:DIL_Manual/UNIT_FL_*|UNIT_FL_*]] - Unit flag constants
* [[Manual:DIL_Manual/PC_*|PC_*]] - Player character flag constants
* [[Manual:DIL_Manual/CHAR_*|CHAR_*]] - Character flag constants
* [[Manual:DIL_Manual/ROOM_*|ROOM_*]] - Room flag constants</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/set_fighting</title>
     <ns>0</ns>
     <id>1204339</id>
     <revision>
       <id>1629028</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of set_fighting.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= set_fighting =
function: void &apos;&apos;&apos;set_fighting&apos;&apos;&apos;(attacker : unitptr, target : unitptr);

The &apos;&apos;&apos;set_fighting&apos;&apos;&apos; function is used to initiate or modify combat between two character units in the game world.

== Description ==
This function establishes a combat relationship between two characters. The first parameter (attacker) will engage in combat with the second parameter (target). If the attacker is already fighting, the target will be added to their opponent list. If the attacker is not currently fighting, a new combat engagement will be initiated.

The function intelligently handles both new combat initiation and adding opponents to existing fights, making it versatile for various combat scenarios.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| attacker || unitptr || The character unit that will initiate or continue the attack
|-
| target || unitptr || The character unit that will be attacked
|}

Both parameters must be valid character units (PC or NPC). The function will fail if either parameter is not a character type.

== Examples ==
=== Basic Combat Initiation ===
 dilbegin initiate_combat();
 var
    guard : unitptr;
    intruder : unitptr;
 code
 {
    guard := self;
    intruder := findroom(&quot;guard_post@midgaard&quot;).contents;
    
    while (intruder != null)
    {
       if (intruder.type == UNIT_ST_PC and intruder.charflags &amp; CHAR_OUTLAW)
       {
          set_fighting(guard, intruder);
          sendtext(&quot;Guard attacks &quot; + intruder.name + &quot;!&quot;, guard);
          break;
       }
       intruder := intruder.next;
    }
 } dilend

=== Arrest Scenario ===
 dilbegin arrest_procedure();
 external
    check_outlaw@justice(char : unitptr) : integer;
 var
    outlaw_status : integer;
 code
 {
    on_activation((self.position &lt;= POSITION_SLEEPING), skip);
    
 :loop:
    wait(SFB_CMD, activator.charflags &amp; CHAR_OUTLAW);
    if (activator == self)
       goto loop;
    
    outlaw_status := check_outlaw@justice(activator);
    if (outlaw_status == 0)
       goto loop;
    
    // Remove self-defense protection and engage
    unset(activator.charflags, CHAR_SELF_DEFENCE);
    set_fighting(self, activator);
    
    goto loop;
 } dilend

=== Multiple Opponents ===
 dilbegin reinforcement_combat();
 var
    original_target : unitptr;
    new_target : unitptr;
 code
 {
    original_target := self.fighting;
    if (original_target == null)
       return;
    
    // Find another hostile character in the room
    new_target := findunit(self, &quot;goblin&quot;, UNIT_ST_NPC);
    if (new_target != null and new_target != original_target)
    {
       set_fighting(self, new_target);
       sendtext(&quot;You now fight multiple opponents!&quot;, self);
    }
 } dilend

== Usage Notes ==
* Both parameters must be character units (PC or NPC) - using objects or rooms will cause the function to fail
* If the attacker is already fighting, the target is added to their opponent list
* If the attacker is not fighting, a new combat engagement is started
* The function does not check for line of sight or range - it assumes both units can engage
* Combat positioning and facing are automatically handled by the game engine
* The function will not work if either unit is dead or in an invalid state

== Error Handling ==
The function includes type checking to ensure both parameters are valid character units. If either parameter is not a unitptr pointing to a character, the function will fail silently without modifying the combat state.

Common error scenarios:
* Passing an object or room instead of a character
* Using null or invalid unit pointers
* Attempting to set a character to fight themselves

== Related Functions/Fields ==
* [[Manual:DIL_Manual/fighting|fighting]] - Field to read current combat opponent
* [[Manual:DIL_Manual/stop_fighting()|stop_fighting()]] - Function to end combat between units
* [[Manual:DIL_Manual/opponentcount|opponentcount]] - Field showing number of opponents
* [[Manual:DIL_Manual/position|position]] - Field showing current position (affects combat ability)

== See Also ==
* [[Manual:DIL_Manual/SFB_COM|SFB_COM]] - Combat message flag for wait() statements
* [[Manual:DIL_Manual/CHAR_FIGHTING|CHAR_FIGHTING]] - Internal character fighting state
* [[Manual:DIL_Manual/meleedamage()|meleedamage()]] - Function for calculating melee damage </text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/set_password</title>
     <ns>0</ns>
     <id>622805</id>
     <revision>
       <id>1055608</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of set_password.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= set_password =
 function: void &apos;&apos;&apos;set_password&apos;&apos;&apos;(pc : unitptr, password : string);

The &apos;&apos;&apos;set_password&apos;&apos;&apos; function is used to set or change the password of a player character.

== Description ==
This function sets a new password for a player character. The password is encrypted using the system&apos;s crypt() function with the player&apos;s filename as the salt. This function only works on player characters (PC) and requires appropriate zone access level to execute.

The function includes security checks to prevent unauthorized password changes and will terminate the DIL program if access level requirements are not met.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| pc || unitptr || The player character whose password will be set
|-
| password || string || The new password to set (5-16 characters recommended)
|}

The pc parameter must be a valid player character unit. The password parameter should be a string containing the desired new password.

== Examples ==
=== Basic Password Change ===
 dilbegin change_my_password();
 var
    new_pwd : string;
 code
 {
    if (self.type != UNIT_ST_PC)
       quit;
    
    new_pwd := &quot;newsecret123&quot;;
    set_password(self, new_pwd);
     sendtext(&quot;Your password has been changed.&amp;n&quot;, self);
 } dilend

=== Password Change with Validation ===
 dilbegin secure_password_change();
 var
    first_pwd : string;
    second_pwd : string;
    original_prompt : string;
 code
 {
    if (self.type != UNIT_ST_PC)
       quit;
    
    original_prompt := self.prompt;
    
    // Get first password entry
    self.prompt := &quot;Enter new password: &quot;;
    wait(SFB_CMD, self == activator);
    block;
    
    first_pwd := excmdstr_case;
    
    // Validate password length
    if (length(first_pwd) &lt; 5)
    {
        sendtext(&quot;Password too short. Must be 5+ characters.&amp;n&quot;, self);
       self.prompt := original_prompt;
       quit;
    }
    
    if (length(first_pwd) &gt; 16)
    {
        sendtext(&quot;Password too long. Maximum 16 characters.&amp;n&quot;, self);
       self.prompt := original_prompt;
       quit;
    }
    
    // Get password confirmation
    self.prompt := &quot;Enter password again: &quot;;
    wait(SFB_CMD, self == activator);
    block;
    
    second_pwd := excmdstr_case;
    
    // Verify passwords match
    if (strcmp(first_pwd, second_pwd) != 0)
    {
        sendtext(&quot;Passwords do not match. Try again.&amp;n&quot;, self);
       self.prompt := original_prompt;
       quit;
    }
    
    // Set the new password
    set_password(self, first_pwd);
     sendtext(&quot;Password successfully changed.&amp;n&quot;, self);
    self.prompt := original_prompt;
 } dilend

=== Administrative Password Reset ===
 dilbegin admin_reset_password(target_name : string);
 external
    isplayer(name : string) : integer;
 var
    target_pc : unitptr;
 code
 {
    // Find the target player
    target_pc := findunit(self, target_name, UNIT_ST_PC);
    
    if (target_pc == null)
    {
        sendtext(&quot;Player &apos;&quot; + target_name + &quot;&apos; not found.&amp;n&quot;, self);
       quit;
    }
    
    // Reset to a temporary password
    set_password(target_pc, &quot;temp123&quot;);
     sendtext(&quot;Password for &quot; + target_pc.name + &quot; reset to &apos;temp123&apos;.&amp;n&quot;, self);
     sendtext(&quot;Please change it immediately.&amp;n&quot;, target_pc);
 } dilend

== Usage Notes ==
* This function only works on player characters (UNIT_ST_PC)
* The function requires zone access level 0 (no restrictions) to execute
* Passwords are automatically encrypted using the player&apos;s filename as salt
* Recommended password length is 5-16 characters
* The function will terminate the DIL program if access level is insufficient
* Password changes are permanent and take effect immediately
* No confirmation is provided by the function itself - implement validation as needed

== Error Handling ==
The function includes several error checks:

* **Type validation**: If the first parameter is not a unitptr, the function fails with a fatal error
* **Unit type validation**: If the unit is not a player character, the function fails with a type error
* **Access level validation**: If the zone access level is greater than 0, the function logs a security violation and terminates the DIL program
* **Null pointer validation**: If either parameter is null, the function fails silently

Common error scenarios:
* Attempting to set password on NPC or object units
* Running from a zone with restricted access level
* Passing invalid unit pointers or null values

== Related Functions/Fields ==
* [[Manual:DIL_Manual/check_password()|check_password()]] - Function to verify a player&apos;s password
* [[Manual:DIL_Manual/isplayer()|isplayer()]] - Function to check if a name belongs to a player
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/pcflags|pcflags]] - Player configuration flags

== See Also ==
* [[Manual:DIL_Manual/excmdstr|excmdstr]] - Command string input from player
* [[Manual:DIL_Manual/excmdstr_case|excmdstr_case]] - Case-sensitive command string input
* [[Manual:DIL_Manual/strcmp()|strcmp()]] - String comparison function
* [[Manual:DIL_Manual/length()|length()]] - String length function
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/set_weight</title>
     <ns>0</ns>
     <id>339770</id>
     <revision>
       <id>1624894</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of set_weight.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= set_weight =
 function: void &apos;&apos;&apos;set_weight&apos;&apos;&apos;(unit : unitptr, weight : integer);

The &apos;&apos;&apos;set_weight&apos;&apos;&apos; function is used to set the current total weight of a unit, including its contents.

== Description ==
This function sets the current total weight of a unit to the specified value in pounds ( kg units). Unlike [[Manual:DIL_Manual/set_weight_base()|set_weight_base()]], this function modifies the total weight including contents, not just the empty weight of the unit.

The function includes validation to ensure the weight is not set below the unit&apos;s base weight. If an attempt is made to set the weight below the base weight, a warning is logged to the zone but the operation still proceeds. The function automatically updates the weight of all containing units to maintain consistency.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit whose weight will be set
|-
| weight || integer || The new total weight in pounds ( kg units)
|}

The weight parameter should be a positive integer representing the desired total weight including contents.

== Examples ==
=== Basic Weight Setting ===
 dilbegin adjust_item_weight();
 var
    item : unitptr;
 code
 {
    item := self;
    
    // Set item to be heavier (perhaps it&apos;s soaked with water)
    set_weight(item, item.baseweight * 2);
    
     sendtext(&quot;The item becomes much heavier.&amp;n&quot;, self);
 } dilend

=== Container Weight Management ===
 dilbegin create_weightless_container();
 var
    container : unitptr;
    contents : unitptr;
 code
 {
    container := load(&quot;bag@general&quot;);
    if (container != null)
    {
       // Set both base weight and current weight to zero
       set_weight_base(container, 0);
       set_weight(container, 0);
       
        sendtext(&quot;You create a weightless container.&amp;n&quot;, self);
    }
 } dilend

=== Prisoner Possession Management ===
 dilbegin confiscate_items(prisoner : unitptr);
 var
    safe : unitptr;
    item : unitptr;
    next_item : unitptr;
 code
 {
    // Create a container for confiscated items
    safe := load(&quot;safe@justice&quot;);
    if (safe == null)
       quit;
    
    // Set safe to be weightless for easier handling
    set_weight_base(safe, 0);
    set_weight(safe, 0);
    
    // Move all visible items to safe
    item := prisoner.inside;
    while (item != null)
    {
       next_item := item.next;
       
       if (item.minv &lt; 1)  // Visible item
       {
          link(item, safe);
       }
       
       item := next_item;
    }
    
    // Give safe to prisoner
    link(safe, prisoner);
    
    act(&quot;$1n confiscates all your possessions and puts them in a safe.&quot;,
       A_SOMEONE, self, null, prisoner, TO_VICT);
 } dilend

=== Temporary Weight Modification ===
 dilbegin temporary_enchantment();
 var
    target : unitptr;
    original_weight : integer;
 code
 {
    target := activator;
    if (target == null or target.type != UNIT_ST_PC)
       quit;
    
    original_weight := target.weight;
    
    // Make target temporarily lighter (levitation effect)
    set_weight(target, target.baseweight / 2);
    
     sendtext(&quot;You feel as light as a feather!&amp;n&quot;, target);
    
    pause;
    pause;
    
    // Restore original weight
    set_weight(target, original_weight);
     sendtext(&quot;You return to your normal weight.&amp;n&quot;, target);
 } dilend

=== Weight Validation ===
 dilbegin validate_weight(item : unitptr);
 var
    min_weight : integer;
    max_weight : integer;
 code
 {
    if (item == null)
       quit;
    
    min_weight := item.baseweight;
    max_weight := item.baseweight * 10;  // Allow up to 10x base weight
    
    if (item.weight &lt; min_weight)
    {
       set_weight(item, min_weight);
        sendtext(&quot;Item weight corrected to minimum.&amp;n&quot;, self);
    }
    else if (item.weight &gt; max_weight)
    {
       set_weight(item, max_weight);
        sendtext(&quot;Item weight corrected to maximum.&amp;n&quot;, self);
    }
 } dilend

== Usage Notes ==
* Weight is measured in pounds where 1 unit = 0.5 kg
* The function sets total weight including contents, not just base weight
* Setting weight below base weight logs a warning but still executes
* The function automatically updates weight of all containing units
* Use [[Manual:DIL_Manual/set_weight_base()|set_weight_base()]] to modify the empty weight of an object
* Current weight can be read using the &apos;&apos;&apos;weight&apos;&apos;&apos; field
* Base weight can be read using the &apos;&apos;&apos;baseweight&apos;&apos;&apos; field
* Useful for implementing special effects like levitation, burden effects, or weight modifications

== Error Handling ==
The function includes validation checks:

* **Unit validation**: The first parameter must be a valid unitptr
* **Type validation**: The second parameter must be an integer
* **Null pointer validation**: The unit pointer must not be null
* **Weight validation**: Logs warning if weight is set below base weight

Common error scenarios:
* Passing null or invalid unit pointers
* Using non-integer weight values
* Attempting to modify destroyed units
* Setting negative weights (may cause undefined behavior)
* Setting weight below base weight (logs warning but proceeds)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/set_weight_base()|set_weight_base()]] - Function to set base weight (empty weight)
* [[Manual:DIL_Manual/weight|weight]] - Field to read current total weight
* [[Manual:DIL_Manual/baseweight|baseweight]] - Field to read current base weight
* [[Manual:DIL_Manual/capacity|capacity]] - Field for container capacity
* [[Manual:DIL_Manual/can_carry()|can_carry()]] - Function to check if character can carry weight

== See Also ==
* [[Manual:DIL_Manual/weight_change_unit()|weight_change_unit()]] - Internal weight management function
* [[Manual:DIL_Manual/UNIT_FL_*|UNIT_FL_*]] - Unit flags that may affect weight
* [[Manual:DIL_Manual/MANIPULATE_*|MANIPULATE_*]] - Manipulation flags for weight handling
* [[Manual:DIL_Manual/Object creation|Object creation]] - General object creation procedures
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/set_weight_base</title>
     <ns>0</ns>
     <id>1196232</id>
     <revision>
       <id>1564999</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of set_weight_base.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= set_weight_base =
 function: void &apos;&apos;&apos;set_weight_base&apos;&apos;&apos;(unit : unitptr, weight : integer);

The &apos;&apos;&apos;set_weight_base&apos;&apos;&apos; function is used to set the base weight of a unit and automatically adjusts the weight of all containing units to maintain consistency.

== Description ==
This function sets the base weight of a unit to the specified value in pounds ( kg units). The base weight represents the empty weight of the unit without any contents. When the base weight is changed, the function automatically calculates the difference and updates the weight of all units that contain this unit to maintain weight consistency throughout the game world.

The function is particularly useful for creating custom objects, modifying existing items, or implementing special weight-based mechanics.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit whose base weight will be set
|-
| weight || integer || The new base weight in pounds ( kg units)
|}

The weight parameter should be a positive integer representing the desired base weight.

== Examples ==
=== Basic Object Creation ===
 dilbegin create_custom_sword();
 var
    sword : unitptr;
 code
 {
    sword := load(&quot;sword@blacksmith&quot;);
    if (sword != null)
    {
       // Set a custom base weight for the sword
       set_weight_base(sword, 15);  // 7.5 kg
        sendtext(&quot;You create a heavy custom sword.&amp;n&quot;, self);
    }
 } dilend

=== Head Creation with Proportional Weight ===
 dilbegin create_head(corpse : unitptr);
 var
    head : unitptr;
    head_weight : integer;
 code
 {
    if (corpse == null or corpse.type != UNIT_ST_OBJ)
       quit;
    
    head := load(&quot;head@death&quot;);
    if (head != null)
    {
       // Set head weight to 1/30 of corpse base weight
       head_weight := corpse.baseweight / 30;
       
       // Ensure reasonable weight limits
       if (head_weight &gt; 100)
          head_weight := 100;
       if (head_weight &lt; 1)
          head_weight := 1;
       
       set_weight_base(head, head_weight);
       link(head, corpse.outside);
    }
 } dilend

=== Container Weight Management ===
 dilbegin create_weightless_container();
 var
    container : unitptr;
 code
 {
    container := load(&quot;bag@general&quot;);
    if (container != null)
    {
       // Create a weightless container for special purposes
       set_weight_base(container, 0);
       set_weight(container, 0);
       
        sendtext(&quot;You create a weightless container.&amp;n&quot;, self);
    }
 } dilend

=== Race-Specific Weight Calculation ===
 dilbegin set_race_weight(item : unitptr, race : integer);
 var
    weight_multiplier : integer;
    base_weight : integer;
 code
 {
    if (item == null)
       quit;
    
    // Different races have different weight characteristics
    if ((race &gt;= RACE_ARTHROPODA_MIN) and (race &lt;= RACE_ARTHROPODA_MAX))
    {
       // Arthropods are lighter
       weight_multiplier := 70;
    }
    else
    {
       // Default weight calculation
       weight_multiplier := 30;
    }
    
    base_weight := item.baseweight / weight_multiplier;
    
    // Apply reasonable limits
    if (base_weight &gt; 100)
       base_weight := 100;
    if (base_weight &lt; 1)
       base_weight := 1;
    
    set_weight_base(item, base_weight);
 } dilend

=== Temporary Weight Modification ===
 dilbegin temporary_weight_change();
 var
    obj : unitptr;
    original_weight : integer;
 code
 {
    obj := self;
    original_weight := obj.baseweight;
    
    // Temporarily make object heavier
    set_weight_base(obj, original_weight * 2);
    
    pause;
    
    // Restore original weight
    set_weight_base(obj, original_weight);
 } dilend

== Usage Notes ==
* Weight is measured in pounds where 1 unit = 0.5 kg
* The function automatically updates the weight of all containing units
* Base weight represents the empty weight of the unit
* Current weight includes base weight plus contents
* Setting weight to 0 creates weightless objects
* The function maintains weight consistency throughout the game world
* Useful for creating custom objects with specific weight characteristics
* Commonly used in object creation and modification procedures

== Error Handling ==
The function includes validation checks:

* **Unit validation**: The first parameter must be a valid unitptr
* **Type validation**: The second parameter must be an integer
* **Null pointer validation**: The unit pointer must not be null

Common error scenarios:
* Passing null or invalid unit pointers
* Using non-integer weight values
* Attempting to modify destroyed units
* Setting negative weights (may cause undefined behavior)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/set_weight()|set_weight()]] - Function to set current weight (not base weight)
* [[Manual:DIL_Manual/baseweight|baseweight]] - Field to read current base weight
* [[Manual:DIL_Manual/weight|weight]] - Field to read current total weight
* [[Manual:DIL_Manual/capacity|capacity]] - Field for container capacity
* [[Manual:DIL_Manual/can_carry()|can_carry()]] - Function to check if character can carry weight

== See Also ==
* [[Manual:DIL_Manual/weight_change_unit()|weight_change_unit()]] - Internal weight management function
* [[Manual:DIL_Manual/UNIT_FL_*|UNIT_FL_*]] - Unit flags that may affect weight
* [[Manual:DIL_Manual/MANIPULATE_*|MANIPULATE_*]] - Manipulation flags for weight handling
* [[Manual:DIL_Manual/Object creation|Object creation]] - General object creation procedures
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/setbright</title>
     <ns>0</ns>
     <id>1290554</id>
     <revision>
       <id>1254186</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of setbright.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= setbright =
 function: void &apos;&apos;&apos;setbright&apos;&apos;&apos;(unit : unitptr, brightness : integer);

The &apos;&apos;&apos;setbright&apos;&apos;&apos; function is used to set the light output brightness of a unit.

== Description ==
This function sets the amount of light that a unit emits into its environment. The brightness value determines how much the unit illuminates the surrounding area, allowing players to see in dark conditions. The function calculates the difference between the new brightness and current light output, then applies the change using the internal modify_bright() function.

Units with brightness values greater than zero will light up rooms and enable players to see in otherwise dark environments.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| unit || unitptr || The unit whose brightness will be set
|-
| brightness || integer || The new brightness value (light output level)
|}

The brightness parameter should be a positive integer representing the desired light output level.

== Examples ==
=== Basic Light Source Creation ===
 dilbegin create_torch();
 var
    torch : unitptr;
 code
 {
    torch := load(&quot;torch@general&quot;);
    if (torch != null)
    {
       // Set torch to emit light
       setbright(torch, 2);
        sendtext(&quot;The torch bursts into flame!&amp;n&quot;, self);
    }
 } dilend

=== Magical Light Enhancement ===
 dilbegin enhance_light(item : unitptr, bonus_level : integer);
 var
    current_bright : integer;
    new_bright : integer;
 code
 {
    if (item == null)
       quit;
    
    current_bright := item.bright;
    new_bright := current_bright + bonus_level;
    
    // Ensure reasonable brightness limits
    if (new_bright &gt; 10)
       new_bright := 10;
    if (new_bright &lt; 0)
       new_bright := 0;
    
    setbright(item, new_bright);
    
    if (new_bright &gt; current_bright)
        sendtext(&quot;The item glows more brightly.&amp;n&quot;, self);
    else
        sendtext(&quot;The item dims slightly.&amp;n&quot;, self);
 } dilend

=== Random Light Generation ===
 dilbegin integer create_random_light(base_item : unitptr);
 external
    integer successroll(chances : intlist, modifier : integer);
 var
    brightness_roll : integer;
    final_brightness : integer;
 code
 {
    // Roll for random brightness enhancement
    brightness_roll := successroll({50, 80, 95}, 25);
    
    if (brightness_roll == 0)
       return(0);  // No enhancement
    
    // Calculate final brightness (0-3 range)
    final_brightness := brightness_roll;
    if (final_brightness &gt; 3)
       final_brightness := 3;
    
    setbright(base_item, final_brightness);
    
    // Add identification information
    addextra(base_item.extra, {&quot;$identify&quot;}, &quot;Emits a magical light.&quot;);
    addextra(base_item.extra, {&quot;$identify_improved&quot;}, &quot;Emits a magical light +&quot; + itoa(final_brightness) + &quot;.&quot;);
    
    return(1);
 } dilend

=== Temporary Light Boost ===
 dilbegin temporary_illumination(target : unitptr, duration : integer);
 var
    original_bright : integer;
    i : integer;
 code
 {
    if (target == null)
       quit;
    
    original_bright := target.bright;
    
    // Boost brightness temporarily
    setbright(target, original_bright + 5);
     sendtext(&quot;The item flares with brilliant light!&amp;n&quot;, self);
    
    // Wait for duration
    for (i := 0; i &lt; duration; i := i + 1)
    {
       pause;
    }
    
    // Restore original brightness
    setbright(target, original_bright);
     sendtext(&quot;The light returns to normal.&amp;n&quot;, self);
 } dilend

=== Conditional Lighting ===
 dilbegin adaptive_light(item : unitptr);
 var
    room_light : integer;
    needed_bright : integer;
 code
 {
    if (item == null or item.outside == null)
       quit;
    
    // Check current room light level
    room_light := item.outside.light;
    
    // Adjust brightness based on room conditions
    if (room_light == 0)  // Dark room
    {
       needed_bright := 5;  // High brightness for darkness
    }
    else if (room_light &lt; 3)  // Dim room
    {
       needed_bright := 2;  // Medium brightness
    }
    else
    {
       needed_bright := 0;  // No extra light needed
    }
    
    setbright(item, needed_bright);
 } dilend

== Usage Notes ==
* Brightness values are typically in the range 0-10, where 0 means no light output
* The function modifies the unit&apos;s light output, not the light level inside the unit
* Use the &apos;&apos;&apos;bright&apos;&apos;&apos; field to read current brightness of a unit
* Use the &apos;&apos;&apos;light&apos;&apos;&apos; field to read light level inside a unit
* Use the &apos;&apos;&apos;illum&apos;&apos;&apos; field to read light created by contents of a transparent unit
* Units with brightness &gt; 0 will illuminate their surroundings
* The function automatically handles the difference calculation and applies the change
* Useful for creating light sources, magical items, and environmental effects

== Error Handling ==
The function includes validation checks:

* **Unit validation**: The first parameter must be a valid unitptr
* **Type validation**: The second parameter must be an integer
* **Null pointer validation**: The unit pointer must not be null

Common error scenarios:
* Passing null or invalid unit pointers
* Using non-integer brightness values
* Attempting to modify destroyed units
* Setting extremely high brightness values (may cause performance issues)

== Related Functions/Fields ==
* [[Manual:DIL_Manual/bright|bright]] - Field to read current brightness of a unit
* [[Manual:DIL_Manual/light|light]] - Field to read light level inside a unit
* [[Manual:DIL_Manual/illum|illum]] - Field to read light created by unit contents
* [[Manual:DIL_Manual/islight()|islight()]] - Function to check if a unit is a light source
* [[Manual:DIL_Manual/modify_bright()|modify_bright()]] - Internal brightness modification function

== See Also ==
* [[Manual:DIL_Manual/Light sources|Light sources]] - General information about light-emitting objects
* [[Manual:DIL_Manual/Room lighting|Room lighting]] - Information about room light levels
* [[Manual:DIL_Manual/UNIT_FL_*|UNIT_FL_*]] - Unit flags that may affect light behavior
* [[Manual:DIL_Manual/getNumberOfActiveLightSources()|getNumberOfActiveLightSources()]] - Internal light counting function
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/setroomexit</title>
     <ns>0</ns>
     <id>478477</id>
     <revision>
       <id>1653603</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of setroomexit.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= setroomexit =
 procedure: &apos;&apos;&apos;setroomexit&apos;&apos;&apos;(room : unitptr, direction : integer, roomto : unitptr);

The setroomexit procedure creates or modifies an exit from a room to another room in a specified direction.

== Description ==
The setroomexit procedure establishes a one-way exit connection between two rooms. If an exit in the specified direction already exists, it will be modified to point to the new destination room. If no exit exists in that direction, a new exit will be created. This procedure is essential for dynamic room creation, maze generation, and temporary exit modifications during special events or quests.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| room || unitptr || The source room where the exit will be created/modified
|-
| direction || integer || The direction for the exit (DIR_* constants from values.h and/or vme.h)
|-
| roomto || unitptr || The destination room the exit leads to (can be null to remove exit)
|}

== Examples ==
 dilbegin create_simple_exit();
 var
    room1 : unitptr;
    room2 : unitptr;
 code
 {
    room1 := findroom(&quot;start@myzone&quot;);
    room2 := findroom(&quot;finish@myzone&quot;);
    
    if (room1 and room2)
    {
       setroomexit(room1, DIR_NORTH, room2);
       setroomexit(room2, DIR_SOUTH, room1);
       sendtext(&quot;Created two-way exit between rooms.&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Could not find both rooms.&amp;n&quot;, self);
    }
    quit;
 } dilend

 dilbegin temporary_portal();
 var
    current_room : unitptr;
    portal_room : unitptr;
 code
 {
    current_room := self.outside;
    portal_room := findroom(&quot;portal_dest@special&quot;);
    
    if (current_room and portal_room)
    {
       // Create temporary portal exit
       setroomexit(current_room, DIR_UP, portal_room);
       sendtext(&quot;A magical portal appears!&amp;n&quot;, self);
       
       // Schedule removal after 30 seconds
       pause(30);
       setroomexit(current_room, DIR_UP, null);
       sendtext(&quot;The portal fades away.&amp;n&quot;, self);
    }
    quit;
 } dilend

 dilbegin maze_generator();
 var
    maze_room : unitptr;
    i : integer;
    random_dir : integer;
    next_room : unitptr;
 code
 {
    maze_room := findroom(&quot;maze_001@myzone&quot;);
    
    if (maze_room)
    {
       // Create random exits for maze room
       for (i := 0; i &lt; 4; i := i + 1)
       {
          random_dir := rnd(0, 3); // Random direction
          next_room := findroom(&quot;maze_&quot; + itoa(rnd(1, 10)) + &quot;@myzone&quot;);
          
          if (next_room)
          {
             setroomexit(maze_room, random_dir, next_room);
          }
       }
       sendtext(&quot;Maze room configured with random exits.&amp;n&quot;, self);
    }
    quit;
 } dilend

 dilbegin test_exit_functionality();
 var
    test_room : unitptr;
 code
 {
    test_room := findroom(&quot;testlabc@test&quot;);
    
    if (test_room == null)
    {
       sendtext(&quot;Test room not found.&amp;n&quot;, self);
       quit;
    }
    
    // Test setting exit to self
    setroomexit(test_room, DIR_NORTH, test_room);
    
    if (test_room.exit_to[DIR_NORTH] == test_room)
    {
       sendtext(&quot;Exit successfully set to point to self.&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Failed to set exit correctly.&amp;n&quot;, self);
    }
    
    // Test removing exit
    setroomexit(test_room, DIR_NORTH, null);
    
    if (test_room.exit_to[DIR_NORTH] == null)
    {
       sendtext(&quot;Exit successfully removed.&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Failed to remove exit.&amp;n&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* The direction parameter must be a valid DIR_* constant (0 to MAX_EXIT)
* Both room and roomto parameters must be valid room units
* Setting roomto to null removes the exit in that direction
* The procedure creates a one-way exit; create reciprocal exits manually if needed
* Existing exits in the specified direction will be overwritten
* This procedure modifies the room&apos;s exit data structure directly
* Commonly used for dynamic world building, temporary events, and maze generation
* The exit is immediately available to players in the room

== Error Handling ==
* If room parameter is null or not a room unit, the operation fails and logs an error
* If roomto parameter is not null and not a room unit, the operation fails and logs an error
* If direction is outside valid range (0 to MAX_EXIT), the operation fails and logs an error
* All errors are logged to the zone&apos;s log file for debugging

== Related Functions/Fields ==
* [[Manual:DIL_Manual/pathto|pathto]] - Get direction from one room to another
* .exit_to[] - Read-only access to room exits
* .exit_names[] - Access to exit names
* .exit_info[] - Access to exit flags and conditions
* [[Manual:DIL_Manual/findroom|findroom]] - Locate a room by name

== See Also ==
* Room system documentation
* Direction constants (DIR_* values)
* Dynamic world building
* Maze and dungeon generation techniques
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sex</title>
     <ns>0</ns>
     <id>1242139</id>
     <revision>
       <id>1327079</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sex.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= sex =
 field: integer &apos;&apos;&apos;.sex&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;sex&apos;&apos;&apos; field is used to get or set the gender of a character unit (PC or NPC).

== Description ==
This field provides access to the gender setting of character units. The field returns an integer value representing the character&apos;s sex, which can be read or modified as needed. The field is only available on character units (PC and NPC) and will fail when accessed on other unit types like objects or rooms.

The field uses standard gender constants defined in the game system to represent different gender states.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current gender value of the character
|-
| Write || integer || Sets the gender of the character to specified value
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
=== Basic Gender Check ===
 dilbegin gender_greeting();
 var
    greeting : string;
 code
 {
    if (activator.type != UNIT_ST_PC and activator.type != UNIT_ST_NPC)
       quit;
    
    // Set appropriate greeting based on gender
    if (activator.sex == SEX_MALE)
       greeting := &quot;Greetings, good sir!&quot;;
    else if (activator.sex == SEX_FEMALE)
       greeting := &quot;Greetings, good madam!&quot;;
    else
       greeting := &quot;Greetings, good traveler!&quot;;
    
    act(greeting, A_SOMEONE, self, null, null, TO_CHAR);
 } dilend

=== Gender-Based Responses ===
 dilbegin shopkeeper_response();
 var
    title : string;
    customer : unitptr;
 code
 {
    customer := activator;
    if (customer.type != UNIT_ST_PC)
       quit;
    
    // Use appropriate title based on customer gender
    if (customer.sex == SEX_MALE or customer.sex == SEX_NEUTRAL)
       title := &quot;sir&quot;;
    else if (customer.sex == SEX_FEMALE)
       title := &quot;madam&quot;;
    else
       title := &quot;friend&quot;;
    
    exec(&quot;say Welcome to my shop, &quot; + title + &quot;!&quot;, self);
 } dilend

=== Gender Assignment ===
 dilbegin create_custom_npc();
 var
    npc : unitptr;
 code
 {
    npc := load(&quot;guard@city&quot;);
    if (npc != null)
    {
       // Randomly assign gender
       if (rnd(1, 2) == 1)
          npc.sex := SEX_MALE;
       else
          npc.sex := SEX_FEMALE;
       
       // Set appropriate description based on gender
       if (npc.sex == SEX_MALE)
          npc.title := &quot;A tall, muscular guard&quot;;
       else
          npc.title := &quot;A tall, athletic guardess&quot;;
       
       link(npc, self.outside);
    }
 } dilend

=== Gender Validation ===
 dilbegin validate_character_gender(char : unitptr);
 var
    valid_gender : integer;
 code
 {
    if (char == null or (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC))
       quit;
    
    // Check if gender is valid
    valid_gender := (char.sex == SEX_MALE or char.sex == SEX_FEMALE or char.sex == SEX_NEUTRAL);
    
    if (not valid_gender)
    {
       // Reset to neutral if invalid
       char.sex := SEX_NEUTRAL;
        sendtext(&quot;Character gender reset to neutral.&amp;n&quot;, self);
    }
 } dilend

=== Gender-Specific Behavior ===
 dilbegin gender_specific_behavior();
 var
    target : unitptr;
 code
 {
    target := activator;
    if (target.type != UNIT_ST_PC)
       quit;
    
    // Different behavior based on gender
    if (target.sex == SEX_MALE)
    {
       act(&quot;$1n nods respectfully to the gentleman.&quot;, A_SOMEONE, self, target, null, TO_NOTVICT);
    }
    else if (target.sex == SEX_FEMALE)
    {
       act(&quot;$1n bows courteously to the lady.&quot;, A_SOMEONE, self, target, null, TO_NOTVICT);
    }
    else
    {
       act(&quot;$1n greets the traveler warmly.&quot;, A_SOMEONE, self, target, null, TO_NOTVICT);
    }
 } dilend

== Usage Notes ==
* The field only works on character units (PC and NPC)
* Gender constants are typically defined as SEX_MALE, SEX_FEMALE, and SEX_NEUTRAL
* The field is read-write and can be modified during gameplay
* Gender affects how NPCs respond to characters and can influence social interactions
* Some game mechanics may have gender-specific behaviors or restrictions
* The field value is stored as an integer, not a string
* Use appropriate gender constants rather than raw numeric values for clarity

== Error Handling ==
The field includes validation checks:

* **Unit type validation**: Only works on UNIT_ST_PC and UNIT_ST_NPC units
* **Null pointer validation**: Fails when accessed on null unit pointers
* **Type validation**: Returns fail state when accessed on non-character units

Common error scenarios:
* Accessing the field on objects or rooms (will return fail)
* Using invalid gender constants
* Attempting to modify gender on read-only units
* Accessing the field on destroyed units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/race|race]] - Field for character race
* [[Manual:DIL_Manual/position|position]] - Field for character position
* [[Manual:DIL_Manual/level|level]] - Field for character level
* [[Manual:DIL_Manual/charflags|charflags]] - Field for character flags
* [[Manual:DIL_Manual/act()|act()]] - Function for gender-specific messaging

== See Also ==
* [[Manual:DIL_Manual/SEX_*|SEX_*]] - Gender constants (SEX_MALE, SEX_FEMALE, SEX_NEUTRAL)
* [[Manual:DIL_Manual/Character creation|Character creation]] - Information about creating characters
* [[Manual:DIL_Manual/Social interactions|Social interactions]] - Gender-based interaction systems
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character unit type
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - Non-player character unit type
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sfb_cmd</title>
     <ns>0</ns>
     <id>652123</id>
     <revision>
       <id>1240393</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sfb_cmd.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= SFB_CMD =

 constant: &apos;&apos;&apos;SFB_CMD&apos;&apos;&apos;

Message flag that activates DIL programs when players or NPCs issue commands, including movement commands.

== Description ==
The &apos;&apos;&apos;SFB_CMD&apos;&apos;&apos; constant is a message flag used with &apos;&apos;&apos;wait()&apos;&apos;&apos; and &apos;&apos;&apos;interrupt()&apos;&apos;&apos; functions to trigger DIL program activation when any command is issued by a player character (PC) or non-player character (NPC). This includes both legal and illegal commands, as well as movement commands like north, south, east, west, etc.

When a DIL program is activated by SFB_CMD, several special variables become available:
* &apos;&apos;&apos;activator&apos;&apos;&apos; - unit pointer to the character who issued the command
* &apos;&apos;&apos;cmdstr&apos;&apos;&apos; - the full command string as entered by the player (with command expansion applied)
* &apos;&apos;&apos;excmdstr&apos;&apos;&apos; - the first word of the command in original case (not expanded)
* &apos;&apos;&apos;excmdstr_case&apos;&apos;&apos; - the first word of the command in original case (preserves player&apos;s typing)
* &apos;&apos;&apos;argument&apos;&apos;&apos; - the remainder of the command string after the first word

The command interpreter processes aliases and direction shortcuts before the DIL program receives the command, so &apos;&apos;&apos;cmdstr&apos;&apos;&apos; may contain expanded commands while &apos;&apos;&apos;excmdstr&apos;&apos;&apos; contains the original input.

== Examples ==
=== Basic Command Handler ===
 dilbegin shopkeeper();
 var
    customer : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;buy&quot;));
    customer := activator;
    
    if (customer == null)
    {
       exec(&quot;say I don&apos;t see anyone here to buy from.&quot;, self);
       goto start;
    }
    
    exec(&quot;say What would you like to buy today?&quot;, self);
    goto start;
 } dilend

=== Multiple Command Processing ===
 dilbegin command_router();
 var
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    if (command(&quot;help&quot;))
       exec(&quot;say Available commands: look, status, quit&quot;, self);
    else if (command(&quot;status&quot;))
       exec(&quot;say You are in good health.&quot;, self);
    else if (command(&quot;quit&quot;))
       quit;
    else
       exec(&quot;say Unknown command. Type &apos;help&apos; for assistance.&quot;, self);
    
    goto start;
 } dilend

=== Command with Arguments ===
 dilbegin gate_guard();
 var
    visitor : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;open&quot;) and (activator.type == UNIT_ST_PC));
    visitor := activator;
    
    if (argument == &quot;&quot;)
    {
       exec(&quot;say Open what?&quot;, self);
       goto start;
    }
    
    exec(&quot;say The gate is now open.&quot;, self);
    goto start;
 } dilend

=== Movement Command Handling ===
 dilbegin patrol_guard();
 var
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    // Handle movement commands
    if (command(&quot;north&quot;) or command(&quot;south&quot;) or 
        command(&quot;east&quot;) or command(&quot;west&quot;))
    {
       exec(&quot;say Continuing patrol in that direction.&quot;, self);
    }
    else if (command(&quot;rest&quot;))
    {
       exec(&quot;say Taking a short break.&quot;, self);
    }
    
    goto start;
 } dilend

=== Case-Sensitive Command Checking ===
 dilbegin precise_commands();
 var
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    // Using excmdstr_case preserves original typing
    if (excmdstr_case == &quot;HELP&quot;)
       exec(&quot;say Help system activated.&quot;, self);
    else if (excmdstr_case == &quot;Help&quot;)
       exec(&quot;say Help system activated (capital H).&quot;, self);
    else
       exec(&quot;say Unknown command. Type HELP for assistance.&quot;, self);
    
    goto start;
 } dilend

=== Command vs String Comparison ===
 dilbegin command_demo();
 var
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    // This is the RECOMMENDED way:
    if (command(&quot;look&quot;))
    {
       exec(&quot;say You looked around.&quot;, self);
    }
    
    // This works but is NOT recommended:
    if (cmdstr == &quot;look&quot;)
    {
       exec(&quot;say String comparison worked.&quot;, self);
    }
    
    // This may fail due to command expansion:
    if (cmdstr == &quot;n&quot;) // Player typed &quot;n&quot; but it expanded to &quot;north&quot;
    {
       exec(&quot;say This may not work!&quot;, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* SFB_CMD triggers on ALL commands, including movement (north, south, etc.)
* The command interpreter processes aliases and shortcuts before DIL activation
* Use &apos;&apos;&apos;command()&apos;&apos;&apos; function for reliable command checking instead of string comparison
* &apos;&apos;&apos;cmdstr&apos;&apos;&apos; contains the expanded command (e.g., &quot;n&quot; becomes &quot;north&quot;)
* &apos;&apos;&apos;excmdstr&apos;&apos;&apos; contains the original first word without expansion
* &apos;&apos;&apos;excmdstr_case&apos;&apos;&apos; preserves the original case of the first word
* &apos;&apos;&apos;argument&apos;&apos;&apos; contains everything after the first word of the command
* Movement commands are treated as commands and will trigger SFB_CMD
* Both legal and illegal commands can trigger SFB_CMD (use with care)

== Error Handling ==
* Always validate that &apos;&apos;&apos;activator&apos;&apos;&apos; is not null before using it
* Use &apos;&apos;&apos;command()&apos;&apos;&apos; function instead of direct string comparison to avoid issues with command expansion
* Be aware that &apos;&apos;&apos;cmdstr&apos;&apos;&apos; may contain expanded commands, making direct comparison unreliable
* Ensure proper error handling for unknown commands if implementing custom command processors
* Remember that SFB_CMD triggers on ALL commands unless filtered by expression

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Primary function used with SFB_CMD
* [[Manual:DIL_Manual/interrupt|interrupt]] - Alternative method for setting up command triggers
* [[Manual:DIL_Manual/command|command]] - Function for checking specific commands
* [[Manual:DIL_Manual/activator|activator]] - Unit pointer to command issuer
* [[Manual:DIL_Manual/cmdstr|cmdstr]] - Full command string with expansion
* [[Manual:DIL_Manual/excmdstr|excmdstr]] - Original command first word
* [[Manual:DIL_Manual/excmdstr_case|excmdstr_case]] - Original command first word with case preservation
* [[Manual:DIL_Manual/argument|argument]] - Command arguments after first word

== See Also ==
* [[Manual:DIL_Manual/SFB_TICK|SFB_TICK]] - Timer-based activation
* [[Manual:DIL_Manual/SFB_MSG|SFB_MSG]] - Message-based activation
* [[Manual:DIL_Manual/SFB_COM|SFB_COM]] - Combat event activation
* [[Manual:DIL_Manual/wait|wait]] - General wait function documentation
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sfb_com</title>
     <ns>0</ns>
     <id>923837</id>
     <revision>
       <id>1714762</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sfb_com.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= SFB_COM =

 constant: &apos;&apos;&apos;SFB_COM&apos;&apos;&apos;

Message flag that activates DIL programs during combat events.

== Description ==
The &apos;&apos;&apos;SFB_COM&apos;&apos;&apos; constant is a message flag used with &apos;&apos;&apos;wait()&apos;&apos;&apos; and &apos;&apos;&apos;interrupt()&apos;&apos;&apos; functions to trigger DIL program activation when combat-related events occur. The program does not need to be directly involved in combat to receive these messages - it will react to any combat happening in its local environment.

When a DIL program is activated by SFB_COM, the following global variable becomes available:
* &apos;&apos;&apos;activator&apos;&apos;&apos; - unit pointer to the character about to hit someone (the attacker)

The combat message is sent just prior to the actual hit occurring, allowing the DIL program to react to impending combat or modify combat behavior before damage is dealt.

== Examples ==
=== Basic Combat Detection ===
 dilbegin combat_watcher();
 var
 code
 {
    :start:
    wait(SFB_COM, TRUE);
    
    exec(&quot;say Combat detected nearby!&quot;, self);
    goto start;
 } dilend

=== Self-Combat Detection ===
 dilbegin self_combat_handler();
 var
 code
 {
    :start:
    wait(SFB_COM, activator == self);
    
    exec(&quot;say I am entering combat!&quot;, self);
    // Combat preparation logic here
    goto start;
 } dilend

=== Combat with Command Check ===
 dilbegin combat_command_checker();
 var
 code
 {
    :start:
    wait(SFB_COM, TRUE);
    
    if (command(CMD_AUTO_COMBAT))
    {
       exec(&quot;flee&quot;, self);
    }
    else
    {
       exec(&quot;say Combat detected but not auto-combat.&quot;, self);
    }
    
    goto start;
 } dilend

=== Combined Event Handling ===
 dilbegin multi_event_handler();
 var
 code
 {
    :start:
    wait(SFB_TICK | SFB_COM | SFB_MSG, TRUE);
    
    // Handle different event types
    if (command(CMD_AUTO_COMBAT))
    {
       exec(&quot;say Auto-combat triggered.&quot;, self);
    }
    else if (activator.type == UNIT_ST_PC)
    {
       exec(&quot;say Player activated combat event.&quot;, self);
    }
    else
    {
       exec(&quot;say Other combat event occurred.&quot;, self);
    }
    
    goto start;
 } dilend

=== Position-Based Combat Detection ===
 dilbegin position_combat_checker();
 var
 code
 {
    :start:
    wait(SFB_COM, self.position == POSITION_FIGHTING);
    
    exec(&quot;say I am now in combat position.&quot;, self);
    goto start;
 } dilend

=== Combat Interrupt with Cleanup ===
 dilbegin combat_cleanup();
 var
    interrupt_idx : integer;
 code
 {
    :start:
    interrupt_idx := interrupt(SFB_COM, activator == self, broken_equipment);
    
    wait(SFB_TICK, TRUE);
    
    goto start;
    
    :broken_equipment:
    exec(&quot;say My equipment broke during combat!&quot;, self);
    clear(interrupt_idx);
    goto start;
 } dilend

== Usage Notes ==
* SFB_COM triggers on combat events in the local environment, not just when the DIL program owner is fighting
* The combat message is sent just before the actual hit occurs
* &apos;&apos;&apos;activator&apos;&apos;&apos; points to the character who is about to attack someone
* Use &apos;&apos;&apos;command(CMD_AUTO_COMBAT)&apos;&apos;&apos; to check if the trigger is from auto-combat system
* Programs can receive SFB_COM messages even when not directly involved in the combat
* SFB_COM can be combined with other SFB_* flags using bitwise OR operator
* The flag is commonly used for combat AI, equipment checking, or combat-related triggers
* Combat events include both player vs NPC and NPC vs NPC combat

== Error Handling ==
* Always validate that &apos;&apos;&apos;activator&apos;&apos;&apos; is not null before using it in combat logic
* Ensure proper cleanup of interrupts when they&apos;re no longer needed
* Be careful with infinite loops when waiting for combat events
* Remember that SFB_COM can trigger frequently during intense combat situations
* Use appropriate position checks if you only want to react when the DIL owner is fighting
* Test combat handlers thoroughly as they can affect game balance

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Primary function used with SFB_COM
* [[Manual:DIL_Manual/interrupt|interrupt]] - Alternative method for setting up combat triggers
* [[Manual:DIL_Manual/command|command]] - Function for checking combat commands
* [[Manual:DIL_Manual/activator|activator]] - Unit pointer to combat participant
* [[Manual:DIL_Manual/self.position|self.position]] - Unit position field for combat state checking
* [[Manual:DIL_Manual/POSITION_FIGHTING|POSITION_FIGHTING]] - Constant for fighting position
* [[Manual:DIL_Manual/CMD_AUTO_COMBAT|CMD_AUTO_COMBAT]] - Command constant for auto-combat

== See Also ==
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command message documentation
* [[Manual:DIL_Manual/SFB_TICK|SFB_TICK]] - Timer-based activation
* [[Manual:DIL_Manual/SFB_MSG|SFB_MSG]] - Message-based activation
* [[Manual:DIL_Manual/SFB_DEAD|SFB_DEAD]] - Death event activation
* [[Manual:DIL_Manual/wait|wait]] - General wait function documentation
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sfb_dead</title>
     <ns>0</ns>
     <id>1224634</id>
     <revision>
       <id>1764418</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sfb_dead.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= SFB_DEAD =

 constant: &apos;&apos;&apos;SFB_DEAD&apos;&apos;&apos;

Message flag that activates DIL programs when a character dies.

== Description ==
The &apos;&apos;&apos;SFB_DEAD&apos;&apos;&apos; constant is a message flag used with &apos;&apos;&apos;wait()&apos;&apos;&apos; and &apos;&apos;&apos;interrupt()&apos;&apos;&apos; functions to trigger DIL program activation when a player character (PC) or non-player character (NPC) dies. The death message is sent just as the character dies, before the corpse is created and items are dropped.

When a DIL program is activated by SFB_DEAD, the following global variables become available:
* &apos;&apos;&apos;activator&apos;&apos;&apos; - unit pointer to the character who is dying

The death message is sent at the precise moment of death, allowing DIL programs to react to character death before the corpse is created and items are transferred to the appropriate location.

== Examples ==
=== Basic Death Detection ===
 dilbegin death_watcher();
 var
 code
 {
    :start:
    wait(SFB_DEAD, TRUE);
    
    exec(&quot;say Someone has died!&quot;, self);
    goto start;
 } dilend

=== Self-Death Detection ===
 dilbegin self_death_handler();
 var
 code
 {
    :start:
    wait(SFB_DEAD, activator == self);
    
    exec(&quot;say I am dying!&quot;, self);
    // Death cleanup logic here
    goto start;
 } dilend

=== Death with Action ===
 dilbegin death_action();
 var
 code
 {
    :start:
    wait(SFB_DEAD, TRUE);
    
    if (activator.type == UNIT_ST_PC)
    {
       exec(&quot;say A player has died!&quot;, self);
       // Handle player death
    }
    else
    {
       exec(&quot;say An NPC has died!&quot;, self);
       // Handle NPC death
    }
    
    goto start;
 } dilend

=== Death with Cleanup ===
 dilbegin death_cleanup();
 var
    interrupt_idx : integer;
 code
 {
    :start:
    interrupt_idx := interrupt(SFB_DEAD, activator == self, inventory_cleanup);
    
    wait(SFB_TICK, TRUE);
    
    goto start;
    
    :inventory_cleanup:
    exec(&quot;say Cleaning up inventory before death...&quot;, self);
    clear(interrupt_idx);
    goto start;
 } dilend

=== Combined Death and Combat Events ===
 dilbegin combat_death_monitor();
 var
 code
 {
    :start:
    wait(SFB_DEAD | SFB_COM, TRUE);
    
    if (activator == self)
    {
       exec(&quot;say I have died!&quot;, self);
    }
    else
    {
       exec(&quot;say Combat detected.&quot;, self);
    }
    
    goto start;
 } dilend

=== Death with Position Check ===
 dilbegin positional_death_handler();
 var
 code
 {
    :start:
    wait(SFB_DEAD, self.position == POSITION_DEAD);
    
    exec(&quot;say I am in death position!&quot;, self);
    goto start;
 } dilend

== Usage Notes ==
* SFB_DEAD triggers at the exact moment of character death, before corpse creation
* &apos;&apos;&apos;activator&apos;&apos;&apos; points to the character who is dying
* The death message is sent before items are dropped and corpse is created
* Programs can receive SFB_DEAD messages even when not directly involved in the death
* SFB_DEAD can be combined with other SFB_* flags using bitwise OR operator
* The death event allows for last-minute actions before final cleanup
* Commonly used for death-related cleanup, item transfers, or special death effects
* The &apos;&apos;&apos;argument&apos;&apos;&apos; variable is empty when SFB_DEAD triggers (as noted in help file)
* Use &apos;&apos;&apos;command(CMD_AUTO_DEATH)&apos;&apos;&apos; to check if the trigger is from the auto-death system

== Error Handling ==
* Always validate that &apos;&apos;&apos;activator&apos;&apos;&apos; is not null before using it in death logic
* Be careful with infinite loops when waiting for death events
* Remember that SFB_DEAD can trigger frequently during dangerous situations
* Ensure proper cleanup of interrupts when they&apos;re no longer needed
* Test death handlers thoroughly as they can affect game balance
* Use appropriate position checks if you only want to react when a character is actually dead

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Primary function used with SFB_DEAD
* [[Manual:DIL_Manual/interrupt|interrupt]] - Alternative method for setting up death triggers
* [[Manual:DIL_Manual/activator|activator]] - Unit pointer to the dying character
* [[Manual:DIL_Manual/self.position|self.position]] - Unit position field for death state checking
* [[Manual:DIL_Manual/POSITION_DEAD|POSITION_DEAD]] - Constant for dead position
* [[Manual:DIL_Manual/command|command]] - Function for checking death commands
* [[Manual:DIL_Manual/visible|visible]] - Function for checking unit visibility

== See Also ==
* [[Manual:DIL_Manual/SFB_COM|SFB_COM]] - Combat message documentation
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command message documentation
* [[Manual:DIL_Manual/SFB_TICK|SFB_TICK]] - Timer-based activation
* [[Manual:DIL_Manual/wait|wait]] - General wait function documentation
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sfb_done</title>
     <ns>0</ns>
     <id>581797</id>
     <revision>
       <id>1757680</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sfb_done.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= SFB_DONE =

 constant: &apos;&apos;&apos;SFB_DONE&apos;&apos;&apos;

Message flag that activates DIL programs when commands are successfully completed.

== Description ==
The &apos;&apos;&apos;SFB_DONE&apos;&apos;&apos; constant is a message flag used with &apos;&apos;&apos;wait()&apos;&apos;&apos; and &apos;&apos;&apos;interrupt()&apos;&apos;&apos; functions to trigger DIL program activation when a command is successfully executed and completed. This allows DIL programs to be notified when other DIL programs finish executing commands that were being waited on.

When a DIL program is activated by SFB_DONE, the following global variables become available:
* &apos;&apos;&apos;activator&apos;&apos;&apos; - unit pointer to the character who executed the completed command
* &apos;&apos;&apos;medium&apos;&apos;&apos; - unit pointer to the unit that was operated upon during the command
* &apos;&apos;&apos;target&apos;&apos;&apos; - unit pointer to the target of the operation

The SFB_DONE message is sent after a command has been successfully processed, allowing other waiting DIL programs to resume execution or perform cleanup tasks.

== Examples ==
=== Basic Command Completion ===
 dilbegin command_notifier();
 var
 code
 {
    :start:
    wait(SFB_DONE, TRUE);
    
    exec(&quot;say A command was completed!&quot;, self);
    goto start;
 } dilend

=== Item Transfer Detection ===
 dilbegin item_transfer_watcher();
 var
 code
 {
    :start:
    wait(SFB_DONE, (command(&quot;give&quot;) or command(&quot;get&quot;)) and (self == activator));
    
    exec(&quot;say Item transfer completed.&quot;, self);
    goto start;
 } dilend

=== Multi-Program Coordination ===
 dilbegin coordinator();
 var
 code
 {
    :start:
    wait(SFB_DONE, TRUE);
    
    // Notify another program that operation is done
    sendtext(&quot;Operation completed, you may proceed.&lt;br/&gt;&quot;, self);
    goto start;
 } dilend

=== Service Completion Handler ===
 dilbegin service_handler();
 var
 code
 {
    :start:
    wait(SFB_DONE, command(&quot;buy&quot;) or command(&quot;sell&quot;));
    
    if (command(&quot;buy&quot;))
    {
       exec(&quot;say Purchase completed.&quot;, self);
    }
    else
    {
       exec(&quot;say Sale completed.&quot;, self);
    }
    
    goto start;
 } dilend

=== Conditional Completion Detection ===
 dilbegin conditional_completion();
 var
 code
 {
    :start:
    wait(SFB_DONE, (command(&quot;repair&quot;) and (medium == activator)));
    
    exec(&quot;say Item repair completed.&quot;, self);
    goto start;
 } dilend

=== Combined Event Handling ===
 dilbegin multi_event_handler();
 var
 code
 {
    :start:
    wait(SFB_DONE | SFB_CMD, TRUE);
    
    if (command(&quot;give&quot;) or command(&quot;get&quot;))
    {
       exec(&quot;say Item operation completed.&quot;, self);
    }
    else if (activator.type == UNIT_ST_PC)
    {
       exec(&quot;say Player completed an action.&quot;, self);
    }
    else
    {
       exec(&quot;say Some event occurred.&quot;, self);
    }
    
    goto start;
 } dilend

=== Interrupt-Based Completion ===
 dilbegin completion_interrupt();
 var
    interrupt_idx : integer;
 code
 {
    :start:
    interrupt_idx := interrupt(SFB_DONE, (command(&quot;craft&quot;) and (self == medium)), crafting_complete);
    
    wait(SFB_TICK, TRUE);
    
    goto start;
    
    :crafting_complete:
    exec(&quot;say Crafting completed!&quot;, self);
    clear(interrupt_idx);
    goto start;
 } dilend

== Usage Notes ==
* SFB_DONE triggers after successful command completion, not command attempts
* The message is sent when the command has been fully processed and executed
* &apos;&apos;&apos;activator&apos;&apos;&apos; points to the character who executed the completed command
* &apos;&apos;&apos;medium&apos;&apos;&apos; points to the unit that was operated upon (target of the operation)
* &apos;&apos;&apos;target&apos;&apos;&apos; points to the target unit of the completed operation
* SFB_DONE can be combined with other SFB_* flags using bitwise OR operator
* Programs must be waiting with interrupt(SFB_DONE, ...) to receive these messages
* Commonly used for multi-program coordination and service completion notifications
* The flag allows for asynchronous program coordination and cleanup operations

== Error Handling ==
* Always validate that &apos;&apos;&apos;activator&apos;&apos;&apos; is not null before using it in completion logic
* Ensure proper cleanup of interrupts when they&apos;re no longer needed
* Be careful with infinite loops when waiting for completion events
* Remember that SFB_DONE only triggers on successful completion, not failed commands
* Test completion handlers thoroughly as they can affect game flow
* Use appropriate condition checks to filter which completions should trigger your program
* Ensure target programs are properly waiting for SFB_DONE messages

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Primary function used with SFB_DONE
* [[Manual:DIL_Manual/interrupt|interrupt]] - Alternative method for setting up completion triggers
* [[Manual:DIL_Manual/sendtext|sendtext]] / [[Manual:DIL_Manual/sendto|sendto]] - Send messages to other DIL programs
* [[Manual:DIL_Manual/activator|activator]] - Unit pointer to command executor
* [[Manual:DIL_Manual/medium|medium]] - Unit pointer to the operated-upon unit
* [[Manual:DIL_Manual/target|target]] - Unit pointer to the operation target
* [[Manual:DIL_Manual/command|command]] - Function for checking specific commands

== See Also ==
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command message documentation
* [[Manual:DIL_Manual/SFB_TICK|SFB_TICK]] - Timer-based activation
* [[Manual:DIL_Manual/SFB_MSG|SFB_MSG]] - Message-based activation
* [[Manual:DIL_Manual/SFB_PRE|SFB_PRE]] - Pre-command processing
* [[Manual:DIL_Manual/wait|wait]] - General wait function documentation
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sfb_msg</title>
     <ns>0</ns>
     <id>975279</id>
     <revision>
       <id>1338714</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sfb_msg.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= SFB_MSG =

 constant: &apos;&apos;&apos;SFB_MSG&apos;&apos;&apos;

Message flag that activates DIL programs when user messages are sent to them.

== Description ==
The &apos;&apos;&apos;SFB_MSG&apos;&apos;&apos; constant is a message flag used with &apos;&apos;&apos;wait()&apos;&apos;&apos; and &apos;&apos;&apos;interrupt()&apos;&apos;&apos; functions to trigger DIL program activation when messages are sent to units via the &apos;&apos;&apos;send()&apos;&apos;&apos; or &apos;&apos;&apos;sendto()&apos;&apos;&apos; functions. This allows DIL programs to communicate with each other, creating complex multi-program systems and message-based interactions.

When a DIL program is activated by SFB_MSG, the following global variables become available:
* &apos;&apos;&apos;activator&apos;&apos;&apos; - unit pointer to the unit who sent the message
* &apos;&apos;&apos;argument&apos;&apos;&apos; - string containing the message content or data

The SFB_MSG flag enables DIL programs to receive messages from other DIL programs, players, or system commands, facilitating inter-program communication and event-driven behavior.

== Examples ==
=== Basic Message Reception ===
 dilbegin message_receiver();
 var
    message_content : string;
 code
 {
    :start:
    wait(SFB_MSG, TRUE);
    
    message_content := argument;
    exec(&quot;say I received: &quot; + message_content, self);
    goto start;
 } dilend

=== Conditional Message Handling ===
 dilbegin conditional_messenger();
 var
 code
 {
    :start:
    wait(SFB_MSG, TRUE);
    
    if (argument == &quot;hello&quot;)
    {
       exec(&quot;say Hello to you too!&quot;, self);
    }
    else if (argument == &quot;goodbye&quot;)
    {
       exec(&quot;say Goodbye!&quot;, self);
    }
    else
    {
       exec(&quot;say Unknown message.&quot;, self);
    }
    
    goto start;
 } dilend

=== Command Coordination ===
 dilbegin command_coordinator();
 var
 code
 {
    :start:
    wait(SFB_MSG, TRUE);
    
    if (argument == &quot;ready&quot;)
    {
       sendto(activator, &quot;Command completed, proceed.&quot;);
    }
    else if (argument == &quot;stop&quot;)
    {
       sendto(activator, &quot;Command stopped.&quot;);
    }
    
    goto start;
 } dilend

=== Priority Message Handling ===
 dilbegin priority_handler();
 var
    interrupt_idx : integer;
 code
 {
    :start:
    interrupt_idx := interrupt(SFB_MSG, argument == &quot;urgent&quot;, urgent_handler);
    
    wait(SFB_TICK, TRUE);
    
    goto start;
    
    :urgent_handler:
    exec(&quot;say URGENT: &quot; + argument, self);
    clear(interrupt_idx);
    goto start;
 } dilend

=== Multi-Program Communication ===
 dilbegin program_communicator();
 var
 code
 {
    :start:
    wait(SFB_MSG, TRUE);
    
    // Forward messages to different handlers based on content
    if (left(argument, 4) == &quot;help&quot;)
    {
       sendto(activator, &quot;Help requested.&quot;);
    }
    else if (left(argument, 6) == &quot;status&quot;)
    {
       sendto(activator, &quot;Status update.&quot;);
    }
    else
    {
       sendto(activator, &quot;Unknown command.&quot;);
    }
    
    goto start;
 } dilend

=== Service Notification ===
 dilbegin service_notifier();
 var
 code
 {
    :start:
    wait(SFB_MSG, TRUE);
    
    if (argument == &quot;service_complete&quot;)
    {
       exec(&quot;say Service has been completed.&quot;, self);
       // Notify other programs
       sendto(self.outside, &quot;service_ready&quot;);
    }
    
    goto start;
 } dilend

=== Message Broadcasting ===
 dilbegin message_broadcaster();
 var
 code
 {
    :start:
    wait(SFB_MSG, TRUE);
    
    // Send message to all programs in the room
    sendto(self.outside, &quot;Announcement: &quot; + argument);
    
    goto start;
 } dilend

=== Event-Driven Messaging ===
 dilbegin event_responder();
 var
    event_type : string;
 code
 {
    :start:
    wait(SFB_MSG, TRUE);
    
    // Parse event type from message
    if (argument == &quot;combat_start&quot;)
    {
       event_type := &quot;combat&quot;;
    }
    else if (argument == &quot;combat_end&quot;)
    {
       event_type := &quot;peace&quot;;
    }
    
    exec(&quot;say Event type: &quot; + event_type, self);
    goto start;
 } dilend

== Usage Notes ==
* SFB_MSG triggers when messages are sent to units via &apos;&apos;&apos;send()&apos;&apos;&apos; or &apos;&apos;&apos;sendto()&apos;&apos;&apos; functions
* The message is received by all DIL programs in the target unit that have SFB_MSG enabled
* &apos;&apos;&apos;activator&apos;&apos;&apos; points to the unit who sent the message
* &apos;&apos;&apos;argument&apos;&apos;&apos; contains the full message content that was sent
* SFB_MSG enables inter-program communication and message-based event systems
* Programs must be waiting with interrupt(SFB_MSG, ...) to receive these messages
* The flag is commonly used for creating responsive NPCs, service systems, and complex interactions
* SFB_MSG can be combined with other SFB_* flags using bitwise OR operations
* Message content can be parsed and used for conditional logic within the receiving program

== Error Handling ==
* Always validate that &apos;&apos;&apos;activator&apos;&apos;&apos; is not null before using it in message handling
* Ensure proper message format and content validation
* Be careful with infinite loops when waiting for messages
* Remember that SFB_MSG can trigger frequently in busy environments
* Test message handlers thoroughly as they can affect game performance
* Use appropriate filtering to prevent message spam or unwanted triggers
* Ensure target programs are properly waiting for SFB_MSG messages

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Primary function used with SFB_MSG
* [[Manual:DIL_Manual/interrupt|interrupt]] - Alternative method for setting up message triggers
* [[Manual:DIL_Manual/send|send]] / [[Manual:DIL_Manual/sendto|sendto]] - Functions for sending messages
* [[Manual:DIL_Manual/activator|activator]] - Unit pointer to message sender
* [[Manual:DIL_Manual/argument|argument]] - Message content variable
* [[Manual:DIL_Manual/priority|priority]] - Function for setting message priority
* [[Manual:DIL_Manual/sendtoall|sendtoall]] - Send messages to all DIL programs globally

== See Also ==
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command message documentation
* [[Manual:DIL_Manual/SFB_TICK|SFB_TICK]] - Timer-based activation
* [[Manual:DIL_Manual/SFB_DONE|SFB_DONE]] - Command completion documentation
* [[Manual:DIL_Manual/SFB_PRE|SFB_PRE]] - Pre-command processing
* [[Manual:DIL_Manual/wait|wait]] - General wait function documentation
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sfb_pre</title>
     <ns>0</ns>
     <id>820381</id>
     <revision>
       <id>1866661</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sfb_pre.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= SFB_PRE =

 constant: &apos;&apos;&apos;SFB_PRE&apos;&apos;&apos;

Message flag that activates DIL programs before command processing.

== Description ==
The &apos;&apos;&apos;SFB_PRE&apos;&apos;&apos; constant is a message flag used with &apos;&apos;&apos;wait()&apos;&apos;&apos; and &apos;&apos;&apos;interrupt()&apos;&apos;&apos; functions to trigger DIL program activation just before commands are processed by the game interpreter. This allows DIL programs to intercept, modify, or block commands before they reach the normal command processing pipeline.

When a DIL program is activated by SFB_PRE, the following global variables become available:
* &apos;&apos;&apos;cmdstr&apos;&apos;&apos; - The full command string as entered by the player
* &apos;&apos;&apos;excmdstr&apos;&apos;&apos; - The first word of the command in original case (not expanded)
* &apos;&apos;&apos;excmdstr_case&apos;&apos;&apos; - The first word of the command preserving original case

The SFB_PRE event is triggered just before the command interpreter processes the command, giving DIL programs the opportunity to:
* Modify or block commands before they&apos;re executed
* Change command arguments or parameters
* Perform custom command validation or routing
* Implement special command aliases or shortcuts
* Log or monitor command attempts for debugging

== Examples ==
=== Basic Command Interception ===
 dilbegin command_interceptor();
 var
    original_cmd : string;
 code
 {
    :start:
    wait(SFB_PRE, TRUE);
    
    // Store original command for comparison
    original_cmd := cmdstr;
    
    // Modify all &quot;north&quot; commands to &quot;go north&quot;
    if (cmdstr == &quot;north&quot;)
    {
       exec(&quot;go north&quot;, self);
    }
    // Let other commands pass through normally
    goto start;
 } dilend

=== Command Validation ===
 dilbegin command_validator();
 var
    command_name : string;
 code
 {
    :start:
    wait(SFB_PRE, TRUE);
    
    // Get the command name for validation
    command_name := excmdstr;
    
    // Block dangerous commands for non-wizards
    if (command_name == &quot;quit&quot;)
    {
       exec(&quot;say Quit command is not allowed here.&quot;, self);
       block;
    }
    else if (command_name == &quot;shutdown&quot;)
    {
       exec(&quot;say Shutdown command is not allowed here.&quot;, self);
       block;
    }
    else
    {
       exec(&quot;say Command &apos;&quot; + command_name + &quot;&apos; accepted.&quot;, self);
    }
    
    goto start;
 } dilend

=== Custom Command Processing ===
 dilbegin custom_processor();
 var
    parts : stringlist;
    i : integer;
 code
 {
    :start:
    wait(SFB_PRE, TRUE);
    
    // Parse command into parts
    parts := split(argument, &quot; &quot;);
    
    // Process each part
    for (i := 0; i &lt; length(parts); i := i + 1)
    {
       if (parts.[i] == &quot;north&quot;)
       {
          exec(&quot;go north&quot;, self);
       }
       else if (parts.[i] == &quot;east&quot;)
       {
          exec(&quot;go east&quot;, self);
       }
       else if (parts.[i] == &quot;south&quot;)
       {
          exec(&quot;go south&quot;, self);
       }
       else if (parts.[i] == &quot;west&quot;)
       {
          exec(&quot;go west&quot;, self);
       }
    }
    
    goto start;
 } dilend

=== Command Logging ===
 dilbegin command_logger();
 var
    log_file : string;
 code
 {
    :start:
    wait(SFB_PRE, TRUE);
    
    // Log all commands to a file
    log_file := &quot;commands.log&quot;;
    
    // Append command with timestamp
    exec(&quot;log &quot; + log_file + &quot; &quot; + asctime() + &quot;: &quot; + cmdstr + &quot; by &quot; + activator.name, self);
    
    goto start;
 } dilend

=== Command Blocking with Conditions ===
 dilbegin conditional_blocker();
 var
 code
 {
    :start:
    wait(SFB_PRE, (command(&quot;kill&quot;) and (activator.level &lt; 200)));
    
    // Block dangerous commands from low-level players
    exec(&quot;say You are not allowed to use that command.&quot;, self);
    block;
    
    goto start;
 } dilend

=== Command Argument Modification ===
 dilbegin argument_modifier();
 var
    new_arg : string;
 code
 {
    :start:
    wait(SFB_PRE, TRUE);
    
    // Add a prefix to all &quot;tell&quot; commands
    if (left(argument, 4) == &quot;tell&quot;)
    {
       new_arg := &quot;whisper &quot; + substring(argument, 5);
       exec(new_arg, self);
    }
    else
    {
       exec(argument, self);
    }
    
    goto start;
 } dilend

=== Multi-Command Router ===
 dilbegin command_router();
 var
    command_type : integer;
 code
 {
    :start:
    wait(SFB_PRE, TRUE);
    
    // Route commands based on first word
    if (left(argument, 4) == &quot;look&quot;)
    {
       command_type := 1; // Look command
    }
    else if (left(argument, 6) == &quot;attack&quot;)
    {
       command_type := 2; // Attack command
    }
    else if (left(argument, 4) == &quot;get&quot;)
    {
       command_type := 3; // Get command
    }
    else
    {
       command_type := 0; // Unknown command
    }
    
    // Execute based on command type
    if (command_type == 1)
    {
       exec(&quot;look&quot;, self);
    }
    else if (command_type == 2)
    {
       exec(&quot;attack &quot; + substring(argument, 7), self);
    }
    else if (command_type == 3)
    {
       exec(&quot;get &quot; + substring(argument, 4), self);
    }
    else
    {
       exec(argument, self);
    }
    
    goto start;
 } dilend

=== Spell Casting Interception ===
 dilbegin spell_interceptor();
 var
    spell_name : string;
 code
 {
    :start:
    wait(SFB_PRE, command(&quot;cast&quot;));
    
    // Log all spell casting attempts
    spell_name := getword(argument);
    
    // Check for dangerous spells
    if (spell_name == &quot;fireball&quot; and (activator.level &lt; 50))
    {
       exec(&quot;say You are not experienced enough for that spell.&quot;, self);
       block;
    }
    else
    {
       exec(&quot;cast &quot; + argument, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* SFB_PRE triggers before command interpretation, giving DIL programs first access to commands
* The command string variables contain different levels of processing:
** &apos;&apos;&apos;cmdstr&apos;&apos;&apos; - Full command after interpreter processing (aliases expanded, shortcuts applied)
** &apos;&apos;&apos;excmdstr&apos;&apos;&apos; - First word only, not expanded by interpreter
** &apos;&apos;&apos;excmdstr_case&apos;&apos;&apos; - First word only, preserves original case
* SFB_PRE can be used to implement custom command validation, security checks, or routing
* Programs can modify commands using &apos;&apos;&apos;exec()&apos;&apos;&apos; before they reach the interpreter
* The &apos;&apos;&apos;block&apos;&apos;&apos; command prevents the original command from being processed
* Multiple SFB_PRE handlers can be used to create complex command processing systems
* SFB_PRE is commonly used for command logging, debugging, and security systems

== Error Handling ==
* Always validate command strings before processing or modifying them
* Be careful with infinite loops when using SFB_PRE without proper exit conditions
* Remember that &apos;&apos;&apos;block&apos;&apos;&apos; only prevents the original command - the DIL program remains active
* Use appropriate conditional logic to determine when to intercept vs when to allow commands
* Test command interception thoroughly as it can affect all command processing
* Ensure proper cleanup of any temporary states or variables
* Be aware that SFB_PRE triggers for ALL commands unless filtered by expression

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Primary function used with SFB_PRE
* [[Manual:DIL_Manual/interrupt|interrupt]] - Alternative method for setting up pre-command triggers
* [[Manual:DIL_Manual/cmdstr|cmdstr]] - Full command string after interpreter processing
* [[Manual:DIL_Manual/excmdstr|excmdstr]] - Original command first word
* [[Manual:DIL_Manual/excmdstr_case|excmdstr_case]] - Original command first word with case preservation
* [[Manual:DIL_Manual/exec|exec]] - Execute commands and optionally block them
* [[Manual:DIL_Manual/block|block]] - Prevent command execution
* [[Manual:DIL_Manual/send|send]] / [[Manual:DIL_Manual/sendto|sendto]] - Send messages to other DIL programs

== See Also ==
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command message documentation
* [[Manual:DIL_Manual/SFB_DONE|SFB_DONE]] - Command completion documentation
* [[Manual:DIL_Manual/SFB_MSG|SFB_MSG]] - Message-based activation
* [[Manual:DIL_Manual/wait|wait]] - General wait function documentation
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/sfb_tick</title>
     <ns>0</ns>
     <id>912884</id>
     <revision>
       <id>1438329</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of sfb_tick.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= SFB_TICK =

 constant: &apos;&apos;&apos;SFB_TICK&apos;&apos;&apos;

Message flag that activates DIL programs on timer events.

== Description ==
The &apos;&apos;&apos;SFB_TICK&apos;&apos;&apos; constant is a message flag used with &apos;&apos;&apos;wait()&apos;&apos;&apos; and &apos;&apos;&apos;interrupt()&apos;&apos;&apos; functions to trigger DIL program activation based on timer events. The timing of these events is controlled by the &apos;&apos;&apos;heartbeat&apos;&apos;&apos; variable, which determines how frequently the program receives timer ticks.

When a DIL program is activated by SFB_TICK, the following global variables become available:
* &apos;&apos;&apos;activator&apos;&apos;&apos; - unit pointer to the unit that triggered the timer event (typically null for timer events)
* &apos;&apos;&apos;argument&apos;&apos;&apos; - string containing any data from the timer event (typically empty for timer events)

The SFB_TICK flag enables DIL programs to perform periodic actions, countdowns, or time-based behaviors without requiring external triggers.

== Examples ==
=== Basic Timer ===
 dilbegin basic_timer();
 var
    counter : integer;
 code
 {
    counter := 0;
    
    :start:
    wait(SFB_TICK, TRUE);
    
    counter := counter + 1;
    exec(&quot;say Timer tick #&quot; + itoa(counter) + &quot;!&quot;, self);
    goto start;
 } dilend

=== Periodic Action ===
 dilbegin periodic_cleaner();
 var
 code
 {
    :start:
    wait(SFB_TICK, TRUE);
    
    // Perform cleaning action every 10 seconds
    exec(&quot;emote sweeps the area clean.&quot;, self);
    goto start;
 } dilend

=== Countdown Timer ===
 dilbegin countdown();
 var
    time_left : integer;
 code
 {
    time_left := 30; // 30 ticks = 30 seconds
    
    :start:
    wait(SFB_TICK, TRUE);
    
    time_left := time_left - 1;
    exec(&quot;say &quot; + itoa(time_left) + &quot; seconds remaining!&quot;, self);
    
    if (time_left &lt;= 0)
    {
       exec(&quot;say Time&apos;s up!&quot;, self);
       quit;
    }
    
    goto start;
 } dilend

=== Heartbeat Control ===
 dilbegin heartbeat_controller();
 var
    tick_rate : integer;
 code
 {
    // Set heartbeat to tick every 5 seconds
    heartbeat := PULSE_SEC * 5;
    
    :start:
    wait(SFB_TICK, TRUE);
    
    exec(&quot;say Heartbeat tick received.&quot;, self);
    goto start;
 } dilend

=== Combined Event Handling ===
 dilbegin multi_event_handler();
 var
    event_count : integer;
 code
 {
    event_count := 0;
    
    :start:
    wait(SFB_TICK | SFB_CMD, TRUE);
    
    if (command(&quot;reset&quot;))
    {
       exec(&quot;say Resetting event counter.&quot;, self);
       event_count := 0;
    }
    else
    {
       event_count := event_count + 1;
       exec(&quot;say Event #&quot; + itoa(event_count) + &quot; occurred.&quot;, self);
    }
    
    goto start;
 } dilend

=== Timer with Conditions ===
 dilbegin conditional_timer();
 var
 code
 {
    :start:
    wait(SFB_TICK, (self.position == POSITION_STANDING));
    
    exec(&quot;say Standing guard on duty.&quot;, self);
    goto start;
 } dilend

=== Long-Running Process ===
 dilbegin long_process();
 var
    process_time : integer;
 code
 {
    process_time := 0;
    
    :start:
    wait(SFB_TICK, TRUE);
    
    process_time := process_time + 1;
    
    // Perform action every 100 ticks (100 seconds)
    if (process_time &gt;= 100)
    {
       exec(&quot;say Performing periodic maintenance.&quot;, self);
       process_time := 0;
    }
    
    goto start;
 } dilend

=== Timer Interrupt ===
 dilbegin timer_interrupt();
 var
    interrupt_idx : integer;
 code
 {
    :start:
    interrupt_idx := interrupt(SFB_TICK, (self.position &lt;= POSITION_SLEEPING), sleep_handler);
    
    wait(SFB_TICK, TRUE);
    
    goto start;
    
    :sleep_handler:
    exec(&quot;say Entering sleep mode - pausing timer.&quot;, self);
    clear(interrupt_idx);
    goto start;
 } dilend

== Usage Notes ==
* SFB_TICK triggers based on the &apos;&apos;&apos;heartbeat&apos;&apos;&apos; variable timing
* The &apos;&apos;&apos;heartbeat&apos;&apos;&apos; variable controls the frequency of timer events (in 1/4th second units)
* Use &apos;&apos;&apos;PULSE_SEC&apos;&apos;&apos; constant to convert between seconds and pulse units
* Timer events are independent of player actions or game events
* &apos;&apos;&apos;activator&apos;&apos;&apos; is typically null for pure timer events
* &apos;&apos;&apos;argument&apos;&apos;&apos; is usually empty for timer events
* SFB_TICK can be combined with other SFB_* flags using bitwise OR operations
* Commonly used for periodic maintenance, countdowns, or time-based behaviors
* The heartbeat can be changed at runtime to adjust timer frequency

== Error Handling ==
* Always validate that the &apos;&apos;&apos;heartbeat&apos;&apos;&apos; variable is set to a reasonable value
* Be careful with infinite loops when using SFB_TICK without proper exit conditions
* Remember that very fast heartbeat rates can impact game performance
* Test timer handlers thoroughly as timing is critical for time-based behaviors
* Ensure proper cleanup of timer interrupts when they&apos;re no longer needed
* Use appropriate time calculations to avoid off-by-one errors in timing

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Primary function used with SFB_TICK
* [[Manual:DIL_Manual/interrupt|interrupt]] - Alternative method for setting up timer triggers
* [[Manual:DIL_Manual/heartbeat|heartbeat]] - Variable that controls timer frequency
* [[Manual:DIL_Manual/PULSE_SEC|PULSE_SEC]] - Constant for time unit conversion
* [[Manual:DIL_Manual/pause|pause]] - Function that waits for specified time periods
* [[Manual:DIL_Manual/activator|activator]] - Unit pointer to timer trigger source
* [[Manual:DIL_Manual/argument|argument]] - Timer event data variable

== See Also ==
* [[Manual:DIL_Manual/SFB_CMD|SFB_CMD]] - Command message documentation
* [[Manual:DIL_Manual/SFB_DONE|SFB_DONE]] - Command completion documentation
* [[Manual:DIL_Manual/SFB_MSG|SFB_MSG]] - Message-based activation
* [[Manual:DIL_Manual/SFB_PRE|SFB_PRE]] - Pre-command processing
* [[Manual:DIL_Manual/wait|wait]] - General wait function documentation
* [[Manual:DIL_Manual/interrupt|interrupt]] - General interrupt system
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/shell</title>
     <ns>0</ns>
     <id>368492</id>
     <revision>
       <id>1609627</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of shell.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= shell =
function: integer &apos;&apos;&apos;shell&apos;&apos;&apos;(command : string);

The &apos;&apos;&apos;shell&apos;&apos;&apos; function is used to execute system commands by creating a separate thread to run the specified command.

== Description ==
This function executes a system command in a separate thread, allowing DIL programs to run external commands and scripts. The function creates a new thread to execute the specified command string and returns an integer indicating whether the thread was successfully created (0 for success, non-zero for thread creation error).

The function requires appropriate zone access level - only zones with access level 0 (highest access) can use this function. Attempting to use it from restricted zones will result in a security violation and terminate the DIL program.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| command || string || The system command to execute with its parameters
|}

The command parameter should be a complete command string including any arguments or parameters.

== Examples ==
=== Basic System Command ===
 dilbegin system_info();
 var
    result : integer;
 code
 {
    // Execute a system command to get information
    result := shell(&quot;uname -a&quot;);
    
    if (result == 0)
       sendtext(&quot;System command executed successfully.&lt;br/&gt;&quot;, self);
    else
       sendtext(&quot;Failed to execute system command.&lt;br/&gt;&quot;, self);
 } dilend

=== File Operations ===
 dilbegin backup_player_data();
 var
    player_name : string;
    backup_cmd : string;
    result : integer;
 code
 {
    player_name := activator.name;
    backup_cmd := &quot;cp /mud/save/&quot; + player_name + &quot; /mud/backup/&quot;;
    
    result := shell(backup_cmd);
    
    if (result == 0)
    {
       sendtext(&quot;Your character data has been backed up.&lt;br/&gt;&quot;, activator);
       log(&quot;Backup completed for &quot; + player_name);
    }
    else
    {
       sendtext(&quot;Backup failed. Please contact administration.&lt;br/&gt;&quot;, activator);
       log(&quot;Backup failed for &quot; + player_name + &quot; with error &quot; + itoa(result));
    }
 } dilend

=== Game Management ===
 dilbegin restart_game_service();
 var
    restart_cmd : string;
    result : integer;
 code
 {
    restart_cmd := &quot;/mud/bin/restart_service.sh&quot;;
    
    result := shell(restart_cmd);
    
    if (result == 0)
    {
       sendtext(&quot;Game service restart initiated.&lt;br/&gt;&quot;, self);
       log(&quot;Service restart command executed by DIL&quot;);
    }
    else
    {
       sendtext(&quot;Failed to restart service.&lt;br/&gt;&quot;, self);
       log(&quot;Service restart failed with error &quot; + itoa(result));
    }
 } dilend

=== Command Testing ===
 dilbegin test_system_command();
 var
    test_cmd : string;
    result : integer;
 code
 {
    test_cmd := &quot;test.sh olle golle&quot;;
    
    result := shell(test_cmd);
    
    log(&quot;Shell command &apos;&quot; + test_cmd + &quot;&apos; returned: &quot; + itoa(result));
    
    // Note: We can&apos;t determine if the command itself succeeded,
    // only if the thread was created successfully
    if (result == 0)
       sendtext(&quot;Test command thread created.&lt;br/&gt;&quot;, self);
    else
       sendtext(&quot;Failed to create thread for test command.&lt;br/&gt;&quot;, self);
 } dilend

=== Security Check ===
 dilbegin security_test();
 var
    result : integer;
 code
 {
    // This will fail if zone doesn&apos;t have access level 0
    result := shell(&quot;whoami&quot;);
    
    if (result == 0)
       sendtext(&quot;Security check passed.&lt;br/&gt;&quot;, self);
    else
       sendtext(&quot;Security check failed - insufficient privileges.&lt;br/&gt;&quot;, self);
 } dilend

== Usage Notes ==
* The function executes commands in a separate thread, not blocking the DIL program
* Only zones with access level 0 (highest access) can use this function
* The function returns 0 if the thread was created successfully
* A non-zero return value indicates thread creation failure, not command failure
* The DIL program cannot determine if the actual command succeeded
* Commands are executed with the same permissions as the MUD server process
* Only commands in the allow/ directory can be executed for security reasons
* Use this function sparingly as it can impact server performance and security

== Error Handling ==
The function includes several validation and security checks:

* **Access level validation**: Only works in zones with access level 0
* **Type validation**: The parameter must be a string
* **Security violation**: Attempts from restricted zones terminate the DIL program
* **Thread creation failure**: Returns non-zero if thread cannot be created
* **Command validation**: Only allows commands in the allow/ directory

Common error scenarios:
* Attempting to use from zones with restricted access
* Passing non-string command parameters
* Trying to execute commands outside the allow/ directory
* Server resource limitations preventing thread creation
* Invalid command syntax or non-existent commands

== Related Functions/Fields ==
* [[Manual:DIL_Manual/exec()|exec()]] - Function to execute commands as a specific unit
* [[Manual:DIL_Manual/command()|command()]] - Function to check if a command was entered
* [[Manual:DIL_Manual/cmdstr|cmdstr]] - Field containing the command string entered
* [[Manual:DIL_Manual/excmdstr|excmdstr]] - Field containing the full command string with arguments

== See Also ==
* [[Manual:DIL_Manual/System commands|System commands]] - Information about available system commands
* [[Manual:DIL_Manual/Zone access levels|Zone access levels]] - Security and permission system
* [[Manual:DIL_Manual/Thread management|Thread management]] - Information about multi-threading in DIL
* [[Manual:DIL_Manual/Security restrictions|Security restrictions]] - Command execution security policies
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/skill_costs</title>
     <ns>0</ns>
     <id>571850</id>
     <revision>
       <id>1855774</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of skill_costs.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= skill_costs =
field: integer &apos;&apos;&apos;.skill_costs&apos;&apos;&apos;[index] (Read-only)

The &apos;&apos;&apos;skill_costs&apos;&apos;&apos; field is used to get the skill cost in experience points for a specific skill index.

== Description ==
This field provides access to the experience point cost required to learn or improve a specific skill. The field takes an integer index parameter and returns the cost in experience points for that skill. The field is only available on player characters and requires appropriate zone access level to read.

The field uses the game&apos;s internal skill cost system, which may be modified by racial bonuses or other game mechanics.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the experience point cost for the specified skill index
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Skill Cost Lookup ===
 dilbegin check_skill_cost();
 var
    skill_index : integer;
    cost : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Check cost of skill at index 5 (e.g., SKI_SWORD)
    skill_index := 5;
    cost := activator.skill_costs[skill_index];
    
    sendtext(&quot;Skill cost: &quot; + itoa(cost) + &quot; experience points.&lt;br/&gt;&quot;, activator);
 } dilend

=== Skill Affordability Check ===
 dilbegin can_afford_skill(skill_idx : integer);
 var
    skill_cost : integer;
    player_exp : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    skill_cost := activator.skill_costs[skill_idx];
    player_exp := activator.exp;
    
    if (player_exp &gt;= skill_cost)
    {
       sendtext(&quot;You can afford this skill.&lt;br/&gt;&quot;, activator);
       return(1);
    }
    else
    {
       sendtext(&quot;You need &quot; + itoa(skill_cost - player_exp) + &quot; more experience points.&lt;br/&gt;&quot;, activator);
       return(0);
    }
 } dilend

=== Skill Cost Comparison ===
 dilbegin compare_skill_costs();
 var
    i : integer;
    skill1_cost : integer;
    skill2_cost : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Compare costs of two different skills
    skill1_cost := activator.skill_costs[SKI_SWORD];
    skill2_cost := activator.skill_costs[SKI_SHIELD];
    
    sendtext(&quot;Sword skill cost: &quot; + itoa(skill1_cost) + &quot; XP&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Shield skill cost: &quot; + itoa(skill2_cost) + &quot; XP&lt;br/&gt;&quot;, activator);
    
    if (skill1_cost &lt; skill2_cost)
       sendtext(&quot;Sword skill is cheaper to learn.&lt;br/&gt;&quot;, activator);
    else if (skill2_cost &lt; skill1_cost)
       sendtext(&quot;Shield skill is cheaper to learn.&lt;br/&gt;&quot;, activator);
    else
       sendtext(&quot;Both skills cost the same.&lt;br/&gt;&quot;, activator);
 } dilend

=== Skill Cost Display ===
 dilbegin show_all_skill_costs();
 var
    i : integer;
    skill_name : string;
    cost : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Skill Costs:&lt;br/&gt;&quot;, activator);
    
    // Display costs for first 10 skills
    for (i := 0; i &lt; 10; i := i + 1)
    {
       if (i &lt; SKI_TREE_MAX)
       {
          cost := activator.skill_costs[i];
          skill_name := skill_name(i);
          
          if (skill_name != &quot;&quot;)
             sendtext(skill_name + &quot;: &quot; + itoa(cost) + &quot; XP&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Racial Bonus Calculation ===
 dilbegin calculate_racial_skill_cost(base_skill : integer, race : integer);
 external
    integer get_racial_skill_bonus(race : integer, skill : integer);
 var
    racial_bonus : integer;
    final_cost : integer;
 code
 {
    // Get base cost (this would be from a table or calculation)
    final_cost := base_skill;
    
    // Apply racial bonus (negative bonus reduces cost)
    racial_bonus := get_racial_skill_bonus(race, base_skill);
    final_cost := final_cost + racial_bonus;
    
    // Ensure cost doesn&apos;t go below 1
    if (final_cost &lt; 1)
       final_cost := 1;
    
    return(final_cost);
 } dilend

== Usage Notes ==
* The field is read-only and cannot be modified directly
* Only available on player characters (UNIT_ST_PC)
* Requires zone access level 0 to read skill costs
* Skill indices correspond to SKI_* constants defined in the game system
* The field returns experience point costs, not skill levels or proficiency
* Skill costs may be modified by racial bonuses, class bonuses, or other game mechanics
* The field is commonly used with [[Manual:DIL_Manual/skill_name()|skill_name()]] to get skill names
* Skill costs are typically used in character creation, training, and advancement systems

== Error Handling ==
The field includes several validation checks:

* **Unit type validation**: Only works on UNIT_ST_PC units
* **Access level validation**: Requires zone access level 0
* **Index validation**: Skill index must be within valid range (0 to SKI_TREE_MAX - 1)
* **Null pointer validation**: Fails when accessed on null unit pointers

Common error scenarios:
* Accessing the field on NPCs or objects (will return fail)
* Using invalid skill indices
* Attempting to access from zones with restricted permissions
* Accessing the field on destroyed units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/skill_name()|skill_name()]] - Function to get the name of a skill from its index
* [[Manual:DIL_Manual/skill_levels|skill_levels]] - Field to get the current level of a skill
* [[Manual:DIL_Manual/skills|skills]] - Field array to access all skill values
* [[Manual:DIL_Manual/exp|exp]] - Field to get current experience points
* [[Manual:DIL_Manual/skill_points|skill_points]] - Field to get available skill points

== See Also ==
* [[Manual:DIL_Manual/SKI_*|SKI_*]] - Skill index constants
* [[Manual:DIL_Manual/Character advancement|Character advancement]] - Information about skill progression
* [[Manual:DIL_Manual/Experience system|Experience system]] - Experience point and skill cost mechanics
* [[Manual:DIL_Manual/Racial bonuses|Racial bonuses]] - Racial modifications to skill costs
* [[Manual:DIL_Manual/Training systems|Training systems]] - Skill training and advancement procedures
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/skill_levels</title>
     <ns>0</ns>
     <id>1291774</id>
     <revision>
       <id>1787262</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of skill_levels.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= skill_levels =
field: integer &apos;&apos;&apos;.skill_levels&apos;&apos;&apos;[index] (Read-only)

The &apos;&apos;&apos;skill_levels&apos;&apos;&apos; field is used to get the current level of a specific skill for a player character.

== Description ==
This field provides access to the current skill level for a specific skill index on a player character. The field takes an integer index parameter and returns the current level of that skill. The field is only available on player characters and requires appropriate zone access level to read.

The field uses the game&apos;s internal skill system to track character progression in different abilities and skills.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current level of the specified skill index
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Skill Level Check ===
 dilbegin check_skill_level();
 var
    skill_index : integer;
    current_level : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Check current level of sword skill (SKI_SWORD)
    skill_index := 5;  // Assuming SKI_SWORD = 5
    current_level := activator.skill_levels[skill_index];
    
    sendtext(&quot;Your sword skill level is: &quot; + itoa(current_level) + &quot;&lt;br/&gt;&quot;, activator);
 } dilend

=== Skill Progression Display ===
 dilbegin show_skill_progress();
 var
    i : integer;
    skill_name : string;
    skill_level : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Your Skill Levels:&lt;br/&gt;&quot;, activator);
    
    // Display levels for first 10 skills
    for (i := 0; i &lt; 10; i := i + 1)
    {
       if (i &lt; SKI_TREE_MAX)
       {
          skill_level := activator.skill_levels[i];
          skill_name := skill_name(i);
          
          if (skill_name != &quot;&quot;)
             sendtext(skill_name + &quot;: &quot; + itoa(skill_level) + &quot;&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Skill Mastery Check ===
 dilbegin check_skill_mastery();
 var
    weapon_level : integer;
    shield_level : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    weapon_level := activator.skill_levels[SKI_SWORD];
    shield_level := activator.skill_levels[SKI_SHIELD];
    
    if (weapon_level &gt;= 10 and shield_level &gt;= 10)
    {
       sendtext(&quot;You have mastered both weapon and shield skills.&lt;br/&gt;&quot;, activator);
    }
    else if (weapon_level &gt;= 10)
    {
       sendtext(&quot;You have mastered weapon skills.&lt;br/&gt;&quot;, activator);
    }
    else if (shield_level &gt;= 10)
    {
       sendtext(&quot;You have mastered shield skills.&lt;br/&gt;&quot;, activator);
    }
    else
    {
       sendtext(&quot;You still have much to learn.&lt;br/&gt;&quot;, activator);
    }
 } dilend

=== Skill Requirement Validation ===
 dilbegin validate_skill_requirements();
 var
    required_level : integer;
    player_level : integer;
    skill_index : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Check if player meets skill requirements for advanced training
    required_level := 15;
    player_level := activator.level;
    
    // Check specific skill (e.g., advanced sword techniques)
    skill_index := 5;  // SKI_SWORD
    
    if (activator.skill_levels[skill_index] &gt;= required_level)
    {
       sendtext(&quot;You meet the requirements for advanced training.&lt;br/&gt;&quot;, activator);
       return(1);
    }
    else
    {
       sendtext(&quot;You need to be at least level &quot; + itoa(required_level) + &quot; for this training.&lt;br/&gt;&quot;, activator);
       return(0);
    }
 } dilend

=== Skill Comparison ===
 dilbegin compare_skills(target : unitptr);
 var
    i : integer;
    my_level : integer;
    target_level : integer;
    skill_name : string;
 code
 {
    if (activator.type != UNIT_ST_PC or target.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Skill Comparison:&lt;br/&gt;&quot;, activator);
    
    // Compare levels for several key skills
    for (i := 0; i &lt; 5; i := i + 1)
    {
       if (i &lt; SKI_TREE_MAX)
       {
          my_level := activator.skill_levels[i];
          target_level := target.skill_levels[i];
          skill_name := skill_name(i);
          
          if (skill_name != &quot;&quot;)
          {
             sendtext(skill_name + &quot; - You: &quot; + itoa(my_level) + &quot;, Target: &quot; + itoa(target_level) + &quot;&lt;br/&gt;&quot;, activator);
          }
       }
    }
 } dilend

=== Skill-Based Abilities ===
 dilbegin skill_based_abilities();
 var
    magic_level : integer;
    weapon_level : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    magic_level := activator.skill_levels[SKI_MAGIC];
    weapon_level := activator.skill_levels[SKI_SWORD];
    
    // Unlock abilities based on skill levels
    if (magic_level &gt;= 5)
    {
       sendtext(&quot;You can cast advanced spells.&lt;br/&gt;&quot;, activator);
    }
    
    if (weapon_level &gt;= 7)
    {
       sendtext(&quot;You can use special weapon techniques.&lt;br/&gt;&quot;, activator);
    }
    
    if (magic_level &gt;= 5 and weapon_level &gt;= 7)
    {
       sendtext(&quot;You can combine magic and weapon skills.&lt;br/&gt;&quot;, activator);
    }
 } dilend

== Usage Notes ==
* The field is read-only and cannot be modified directly
* Only available on player characters (UNIT_ST_PC)
* Requires zone access level 0 to read skill levels
* Skill indices correspond to SKI_* constants defined in the game system
* The field returns current skill level, not skill cost or proficiency
* Skill levels typically range from 0 to a maximum (often 100 or higher)
* The field is commonly used with [[Manual:DIL_Manual/skill_name()|skill_name()]] to get skill names
* Skill levels are used in character advancement and ability calculations
* The field is often used in training, guild, and progression systems

== Error Handling ==
The field includes several validation checks:

* **Unit type validation**: Only works on UNIT_ST_PC units
* **Access level validation**: Requires zone access level 0
* **Index validation**: Skill index must be within valid range (0 to SKI_TREE_MAX - 1)
* **Null pointer validation**: Fails when accessed on null unit pointers

Common error scenarios:
* Accessing the field on NPCs or objects (will return fail)
* Using invalid skill indices
* Attempting to access from zones with restricted permissions
* Accessing the field on destroyed units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/skill_name()|skill_name()]] - Function to get the name of a skill from its index
* [[Manual:DIL_Manual/skill_costs|skill_costs]] - Field to get the experience point cost of a skill
* [[Manual:DIL_Manual/skills|skills]] - Field array to access all skill values
* [[Manual:DIL_Manual/skill_points|skill_points]] - Field to get available skill points
* [[Manual:DIL_Manual/exp|exp]] - Field to get current experience points

== See Also ==
* [[Manual:DIL_Manual/SKI_*|SKI_*]] - Skill index constants
* [[Manual:DIL_Manual/Character advancement|Character advancement]] - Information about skill progression systems
* [[Manual:DIL_Manual/Training systems|Training systems]] - Skill training and improvement procedures
* [[Manual:DIL_Manual/Experience system|Experience system]] - Experience point and skill level mechanics
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/skill_name</title>
     <ns>0</ns>
     <id>949433</id>
     <revision>
       <id>1528697</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of skill_name.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= skill_name =
function: string &apos;&apos;&apos;skill_name&apos;&apos;&apos;(skill_index : integer);

The &apos;&apos;&apos;skill_name&apos;&apos;&apos; function is used to get the name of a skill from its index number.

== Description ==
This function returns the name of a skill corresponding to the provided skill index. The function uses the game&apos;s internal skill name table to convert numeric skill indices to their readable string names. This is useful for displaying skill information to players or for debugging skill-related code.

The function returns an empty string if the skill index is invalid or out of range.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| skill_index || integer || The numeric index of the skill to get the name for
|}

The skill_index parameter should be a valid skill index constant (SKI_*).

== Examples ==
=== Basic Skill Name Lookup ===
 dilbegin show_skill_name();
 var
    skill_index : integer;
    skill_name : string;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Get name of skill at index 5 (e.g., SKI_SWORD)
    skill_index := 5;
    skill_name := skill_name(skill_index);
    
    if (skill_name != &quot;&quot;)
       sendtext(&quot;Skill &quot; + itoa(skill_index) + &quot; is: &quot; + skill_name + &quot;&lt;br/&gt;&quot;, activator);
    else
       sendtext(&quot;Invalid skill index.&lt;br/&gt;&quot;, activator);
 } dilend

=== Skill Information Display ===
 dilbegin show_all_skill_names();
 var
    i : integer;
    skill_name : string;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Available Skills:&lt;br/&gt;&quot;, activator);
    
    // Display names for first 10 skills
    for (i := 0; i &lt; 10; i := i + 1)
    {
       if (i &lt; SKI_TREE_MAX)
       {
          skill_name := skill_name(i);
          
          if (skill_name != &quot;&quot;)
             sendtext(itoa(i) + &quot;: &quot; + skill_name + &quot;&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Skill Validation ===
 dilbegin validate_skill_index(skill_idx : integer);
 var
    skill_name : string;
 code
 {
    // Check if skill index is valid
    if (skill_idx &lt; 0 or skill_idx &gt;= SKI_TREE_MAX)
    {
       sendtext(&quot;Invalid skill index: &quot; + itoa(skill_idx) + &quot;&lt;br/&gt;&quot;, self);
       return(&quot;&quot;);
    }
    
    skill_name := skill_name(skill_idx);
    
    if (skill_name == &quot;&quot;)
    {
       sendtext(&quot;Skill index &quot; + itoa(skill_idx) + &quot; does not exist.&lt;br/&gt;&quot;, self);
       return(&quot;&quot;);
    }
    
    sendtext(&quot;Skill &quot; + itoa(skill_idx) + &quot; (&quot; + skill_name + &quot;) is valid.&lt;br/&gt;&quot;, self);
    return(skill_name);
 } dilend

=== Skill Menu System ===
 dilbegin skill_menu();
 var
    i : integer;
    skill_name : string;
    choice : string;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Select a skill to view:&lt;br/&gt;&quot;, activator);
    
    // Display numbered menu of available skills
    for (i := 0; i &lt; SKI_TREE_MAX; i := i + 1)
    {
       skill_name := skill_name(i);
       
       if (skill_name != &quot;&quot;)
          sendtext(itoa(i) + &quot;. &quot; + skill_name + &quot;&lt;br/&gt;&quot;, activator);
    }
    
    sendtext(&quot;Enter skill number (or &apos;quit&apos; to exit): &quot;, activator);
    
    wait(SFB_CMD, TRUE);
    
    choice := excmdstr;
    
    if (choice == &quot;quit&quot;)
       quit;
    
    // Validate and display chosen skill
    skill_name := validate_skill_index(atoi(choice));
    
    if (skill_name != &quot;&quot;)
    {
       sendtext(&quot;You selected: &quot; + skill_name + &quot;&lt;br/&gt;&quot;, activator);
       // Display detailed information about the skill
       // (could call other functions here)
    }
    else
    {
       sendtext(&quot;Invalid selection.&lt;br/&gt;&quot;, activator);
       goto skill_menu;
    }
 } dilend

=== Dynamic Skill Information ===
 dilbegin dynamic_skill_info();
 var
    skill_list : stringlist;
    skill_name : string;
    skill_index : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Create a list of skills to check dynamically
    skill_list := {5, 10, 15, 20};  // Example skill indices
    
    sendtext(&quot;Checking specific skills...&lt;br/&gt;&quot;, activator);
    
    // Check each skill in the list
    foreach skill_index in skill_list
    {
       skill_name := skill_name(skill_index);
       
       if (skill_name != &quot;&quot;)
       {
          sendtext(&quot;Skill &quot; + itoa(skill_index) + &quot;: &quot; + skill_name + &quot;&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

== Usage Notes ==
* The function returns an empty string for invalid skill indices
* Skill indices correspond to SKI_* constants defined in the game system
* The function is commonly used for displaying skill information to players
* Useful for creating skill menus, character sheets, and debugging
* The function does not require any special permissions or access levels
* Skill names are typically stored in internal game tables
* The function is read-only and cannot modify skill names

== Error Handling ==
The function includes validation checks:

* **Index validation**: Skill index must be within valid range
* **Type validation**: The parameter must be an integer
* **Return value**: Returns empty string for invalid indices

Common error scenarios:
* Using skill indices outside the valid range (0 to SKI_TREE_MAX - 1)
* Passing non-integer skill indices
* The function will return empty string rather than failing for invalid inputs

== Related Functions/Fields ==
* [[Manual:DIL_Manual/skill_levels|skill_levels]] - Field to get the current level of a skill
* [[Manual:DIL_Manual/skill_costs|skill_costs]] - Field to get the experience point cost of a skill
* [[Manual:DIL_Manual/skills|skills]] - Field array to access all skill values
* [[Manual:DIL_Manual/SKI_*|SKI_*]] - Skill index constants
* [[Manual:DIL_Manual/Character advancement|Character advancement]] - Information about skill progression systems

== See Also ==
* [[Manual:DIL_Manual/Skill system|Skill system]] - General information about skills and abilities
* [[Manual:DIL_Manual/Character creation|Character creation]] - Information about creating characters with skills
* [[Manual:DIL_Manual/Training systems|Training systems]] - Skill training and advancement procedures
* [[Manual:DIL_Manual/Experience system|Experience system]] - Experience point and skill cost mechanics

</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/skill_points</title>
     <ns>0</ns>
     <id>883202</id>
     <revision>
       <id>1076891</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of skill_points.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= skill_points =
field: integer &apos;&apos;&apos;.skill_points&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;skill_points&apos;&apos;&apos; field is used to get the number of unused skill points available to a player character.

== Description ==
This field provides access to the current amount of unused skill points that a player character has available for learning or improving skills. The field returns an integer representing the pool of skill points that can be spent on new abilities or skill advancements.

The field is read-only and reflects the character&apos;s current available skill points, which are typically gained through experience accumulation or other game mechanics.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current number of unused skill points
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Skill Points Display ===
 dilbegin show_skill_points();
 var
    available_points : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    available_points := activator.skill_points;
    
    sendtext(&quot;You have &quot; + itoa(available_points) + &quot; unused skill points.&lt;br/&gt;&quot;, activator);
 } dilend

=== Skill Points Check ===
 dilbegin can_afford_training(cost : integer);
 var
    available_points : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    available_points := activator.skill_points;
    
    if (available_points &gt;= cost)
    {
       sendtext(&quot;You have enough skill points for this training.&lt;br/&gt;&quot;, activator);
       return(1);
    }
    else
    {
       sendtext(&quot;You need &quot; + itoa(cost - available_points) + &quot; more skill points.&lt;br/&gt;&quot;, activator);
       return(0);
    }
 } dilend

=== Skill Points Management ===
 dilbegin skill_point_transaction();
 var
    current_points : integer;
    spent_points : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    current_points := activator.skill_points;
    
    // Simulate spending 5 skill points
    spent_points := 5;
    
    // Note: This is just a simulation - actual spending
    // would use game mechanics or other functions
    sendtext(&quot;You had &quot; + itoa(current_points) + &quot; skill points.&lt;br/&gt;&quot;, activator);
    sendtext(&quot;You spent &quot; + itoa(spent_points) + &quot; skill points.&lt;br/&gt;&quot;, activator);
    sendtext(&quot;You now have &quot; + itoa(current_points - spent_points) + &quot; skill points.&lt;br/&gt;&quot;, activator);
 } dilend

=== Character Status Display ===
 dilbegin character_status();
 var
    skill_points : integer;
    ability_points : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    skill_points := activator.skill_points;
    ability_points := activator.ability_points;
    
    sendtext(&quot;Character Status:&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Skill Points: &quot; + itoa(skill_points) + &quot;&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Ability Points: &quot; + itoa(ability_points) + &quot;&lt;br/&gt;&quot;, activator);
    
    // Check if character has points to spend
    if (skill_points &gt; 0 or ability_points &gt; 0)
    {
       sendtext(&quot;You can improve your abilities. Type &apos;practice&apos; to train.&lt;br/&gt;&quot;, activator);
    }
    else
    {
       sendtext(&quot;You have no points to spend. Gain more experience to earn points.&lt;br/&gt;&quot;, activator);
    }
 } dilend

=== Points Validation ===
 dilbegin validate_skill_points();
 var
    skill_points : integer;
    ability_points : integer;
    total_points : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    skill_points := activator.skill_points;
    ability_points := activator.ability_points;
    total_points := skill_points + ability_points;
    
    sendtext(&quot;Skill Points: &quot; + itoa(skill_points) + &quot;&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Ability Points: &quot; + itoa(ability_points) + &quot;&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Total Points: &quot; + itoa(total_points) + &quot;&lt;br/&gt;&quot;, activator);
    
    if (total_points &lt; 0)
    {
       sendtext(&quot;Warning: Negative point total detected.&lt;br/&gt;&quot;, activator);
    }
    else if (total_points &gt; 100)
    {
       sendtext(&quot;Warning: Very high point total.&lt;br/&gt;&quot;, activator);
    }
 } dilend

=== Level Up Check ===
 dilbegin check_level_up();
 var
    skill_points : integer;
    exp_needed : integer;
    current_exp : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    skill_points := activator.skill_points;
    current_exp := activator.exp;
    exp_needed := activator.exptol;
    
    sendtext(&quot;Experience to next level: &quot; + itoa(exp_needed - current_exp) + &quot;&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Current skill points: &quot; + itoa(skill_points) + &quot;&lt;br/&gt;&quot;, activator);
    
    if (skill_points &gt;= 10)
    {
       sendtext(&quot;You have enough points to train multiple skills!&lt;br/&gt;&quot;, activator);
    }
    else
    {
       sendtext(&quot;You need more skill points for advanced training.&lt;br/&gt;&quot;, activator);
    }
 } dilend

== Usage Notes ==
* The field is read-only and cannot be modified directly
* Only available on player characters (UNIT_ST_PC)
* Skill points are typically earned through experience gain
* Points are spent on learning new skills or improving existing ones
* The field works with [[Manual:DIL_Manual/ability_points|ability_points]] for total character development points
* Skill points are separate from ability points in most game systems
* The field is commonly used in character creation, training, and advancement systems
* Point values are typically non-negative integers

== Error Handling ==
The field includes validation checks:

* **Unit type validation**: Only works on UNIT_ST_PC units
* **Null pointer validation**: Fails when accessed on null unit pointers
* **Read-only access**: Cannot be modified directly

Common error scenarios:
* Accessing the field on NPCs or objects (will return fail)
* Attempting to modify the field (it&apos;s read-only)
* Accessing the field on destroyed units
* Using the field for non-player characters

== Related Functions/Fields ==
* [[Manual:DIL_Manual/ability_points|ability_points]] - Field to get unused ability points
* [[Manual:DIL_Manual/skill_costs|skill_costs]] - Field to get the cost of skills
* [[Manual:DIL_Manual/skill_levels|skill_levels]] - Field to get the current level of skills
* [[Manual:DIL_Manual/exp|exp]] - Field to get current experience points
* [[Manual:DIL_Manual/exptol|exptol]] - Field to get experience needed for next level
* [[Manual:DIL_Manual/practice|practice]] - Command to train skills using points

== See Also ==
* [[Manual:DIL_Manual/Character advancement|Character advancement]] - Information about skill progression systems
* [[Manual:DIL_Manual/Experience system|Experience system]] - Experience point and skill point mechanics
* [[Manual:DIL_Manual/Training systems|Training systems]] - Skill training and improvement procedures

* [[Manual:DIL_Manual/Character creation|Character creation]] - Information about creating characters with skills
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/skills</title>
     <ns>0</ns>
     <id>1240224</id>
     <revision>
       <id>1016340</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of skills.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= skills =
field: integer &apos;&apos;&apos;.skills&apos;&apos;&apos;[index] (Read-only)

The &apos;&apos;&apos;skills&apos;&apos;&apos; field is used to get the current value of a specific skill for a player character.

== Description ==
This field provides access to the current value or proficiency level of a specific skill for a player character. The field takes an integer index parameter and returns the current skill value at that index. The field is only available on player characters and requires appropriate zone access level to read.

The field uses the game&apos;s internal skill system to track character abilities and proficiencies in various skill areas.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current value of the specified skill index
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Skill Value Check ===
 dilbegin check_skill_value();
 var
    skill_index : integer;
    skill_value : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Check current value of sword skill (SKI_SWORD)
    skill_index := 5;  // Assuming SKI_SWORD = 5
    skill_value := activator.skills[skill_index];
    
    sendtext(&quot;Your sword skill value is: &quot; + itoa(skill_value) + &quot;&lt;br/&gt;&quot;, activator);
 } dilend

=== Skill Proficiency Display ===
 dilbegin show_skill_proficiencies();
 var
    i : integer;
    skill_value : integer;
    skill_name : string;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Your Skill Proficiencies:&lt;br/&gt;&quot;, activator);
    
    // Display values for first 10 skills
    for (i := 0; i &lt; 10; i := i + 1)
    {
       if (i &lt; SKI_TREE_MAX)
       {
          skill_value := activator.skills[i];
          skill_name := skill_name(i);
          
          if (skill_name != &quot;&quot;)
             sendtext(skill_name + &quot;: &quot; + itoa(skill_value) + &quot;&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Skill Comparison ===
 dilbegin compare_skills(target : unitptr);
 var
    i : integer;
    my_value : integer;
    target_value : integer;
    skill_name : string;
 code
 {
    if (activator.type != UNIT_ST_PC or target.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Skill Comparison:&lt;br/&gt;&quot;, activator);
    
    // Compare values for several key skills
    for (i := 0; i &lt; 5; i := i + 1)
    {
       my_value := activator.skills[i];
       target_value := target.skills[i];
       skill_name := skill_name(i);
       
       if (skill_name != &quot;&quot;)
       {
          sendtext(skill_name + &quot; - You: &quot; + itoa(my_value) + &quot;, Target: &quot; + itoa(target_value) + &quot;&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Skill Validation ===
 dilbegin validate_skill_range();
 var
    i : integer;
    skill_value : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Validating skill ranges...&lt;br/&gt;&quot;, activator);
    
    // Check if all skills are within reasonable range
    for (i := 0; i &lt; SKI_TREE_MAX; i := i + 1)
    {
       skill_value := activator.skills[i];
       
       if (skill_value &lt; 0 or skill_value &gt; 100)
       {
          skill_name := skill_name(i);
          
          if (skill_name != &quot;&quot;)
             sendtext(&quot;Warning: &quot; + skill_name + &quot; has unusual value: &quot; + itoa(skill_value) + &quot;&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Skill-Based Abilities ===
 dilbegin skill_based_abilities();
 var
    magic_skill : integer;
    weapon_skill : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    magic_skill := activator.skills[SKI_MAGIC];
    weapon_skill := activator.skills[SKI_SWORD];
    
    // Unlock abilities based on skill values
    if (magic_skill &gt;= 50)
    {
       sendtext(&quot;You can cast advanced spells.&lt;br/&gt;&quot;, activator);
    }
    
    if (weapon_skill &gt;= 75)
    {
       sendtext(&quot;You can master weapon techniques.&lt;br/&gt;&quot;, activator);
    }
    
    if (magic_skill &gt;= 50 and weapon_skill &gt;= 75)
    {
       sendtext(&quot;You are a true battle mage.&lt;br/&gt;&quot;, activator);
    }
 } dilend

=== Skill Progress Tracking ===
 dilbegin track_skill_progress();
 var
    old_value : integer;
    new_value : integer;
    skill_name : string;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Track improvement in a specific skill
    old_value := activator.skills[SKI_SWORD];
    
    // Simulate skill improvement (would use game mechanics)
    new_value := old_value + 5;
    
     // Note: skills field is read-only, cannot be modified directly
     // This would typically be done through game mechanics
     // activator.skills[SKI_SWORD] := new_value;  // This would fail
    
    skill_name := skill_name(SKI_SWORD);
    
     sendtext(&quot;Your &quot; + skill_name + &quot; skill value is &quot; + itoa(old_value) + &quot; (read-only).&lt;br/&gt;&quot;, activator);
 } dilend

== Usage Notes ==
* The field is read-only and cannot be modified directly
* Only available on player characters (UNIT_ST_PC)
* Requires zone access level 0 to read skill values
* Skill indices correspond to SKI_* constants defined in the game system
* The field returns current skill values, not skill levels or costs
* Skill values typically represent proficiency or ability levels
* The field is commonly used with [[Manual:DIL_Manual/skill_name()|skill_name()]] to get skill names
* Skill values are used in combat calculations, ability checks, and character advancement
* The field is often used in character creation, training, and progression systems

== Error Handling ==
The field includes several validation checks:

* **Unit type validation**: Only works on UNIT_ST_PC units
* **Access level validation**: Requires zone access level 0
* **Index validation**: Skill index must be within valid range (0 to SKI_TREE_MAX - 1)
* **Null pointer validation**: Fails when accessed on null unit pointers

Common error scenarios:
* Accessing the field on NPCs or objects (will return fail)
* Using invalid skill indices
* Attempting to access from zones with restricted permissions
* Accessing the field on destroyed units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/skill_name()|skill_name()]] - Function to get the name of a skill from its index
* [[Manual:DIL_Manual/skill_levels|skill_levels]] - Field to get the current level of a skill
* [[Manual:DIL_Manual/skill_costs|skill_costs]] - Field to get the experience point cost of a skill
* [[Manual:DIL_Manual/skill_points|skill_points]] - Field to get available skill points
* [[Manual:DIL_Manual/abilities|abilities]] - Field array to access character abilities
* [[Manual:DIL_Manual/practice|practice]] - Command to train skills using points

== See Also ==
* [[Manual:DIL_Manual/SKI_*|SKI_*]] - Skill index constants
* [[Manual:DIL_Manual/Character advancement|Character advancement]] - Information about skill progression systems
* [[Manual:DIL_Manual/Experience system|Experience system]] - Experience point and skill value mechanics
* [[Manual:DIL_Manual/Training systems|Training systems]] - Skill training and improvement procedures
* [[Manual:DIL_Manual/Ability system|Ability system]] - Information about character abilities and attributes</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/speed</title>
     <ns>0</ns>
     <id>426852</id>
     <revision>
       <id>1508033</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of speed.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= speed =
 field: integer &apos;&apos;&apos;.speed&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;speed&apos;&apos;&apos; field is used to get or set the current combat speed of a character unit.

== Description ==
This field provides access to the current combat speed value of a character. The field returns an integer representing the character&apos;s speed in combat situations. The field is only available on character units (PC and NPC) and requires appropriate zone access level to read.

The field uses the game&apos;s internal speed system to determine combat initiative and action timing.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current combat speed value of the character
|-
| Write || integer || Sets the combat speed value of the character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Examples ==
=== Basic Speed Check ===
 dilbegin check_speed();
 var
    current_speed : integer;
 code
 {
    if (activator.type != UNIT_ST_PC and activator.type != UNIT_ST_NPC)
       quit;
    
    current_speed := activator.speed;
    
    sendtext(&quot;Your current combat speed is: &quot; + itoa(current_speed) + &quot;&lt;br/&gt;&quot;, activator);
 } dilend

=== Speed Comparison ===
 dilbegin compare_speeds(target : unitptr);
 var
    my_speed : integer;
    target_speed : integer;
 code
 {
    if (activator.type != UNIT_ST_PC and activator.type != UNIT_ST_NPC or
       target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
       quit;
    
    my_speed := activator.speed;
    target_speed := target.speed;
    
    sendtext(&quot;Speed Comparison:&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Your speed: &quot; + itoa(my_speed) + &quot;&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Target speed: &quot; + itoa(target_speed) + &quot;&lt;br/&gt;&quot;, activator);
    
    if (my_speed &gt; target_speed)
       sendtext(&quot;You are faster than your target.&lt;br/&gt;&quot;, activator);
    else if (my_speed &lt; target_speed)
       sendtext(&quot;Your target is faster than you.&lt;br/&gt;&quot;, activator);
    else
       sendtext(&quot;You have equal speed.&lt;br/&gt;&quot;, activator);
 } dilend

=== Speed Modification ===
 dilbegin modify_character_speed();
 var
    original_speed : integer;
    new_speed : integer;
 code
 {
    if (activator.type != UNIT_ST_PC and activator.type != UNIT_ST_NPC)
       quit;
    
    original_speed := activator.speed;
    
    // Increase speed by 25%
    new_speed := original_speed + (original_speed / 4);
    
    // Ensure reasonable speed limits
    if (new_speed &gt; 100)
       new_speed := 100;
    
    activator.speed := new_speed;
    
    sendtext(&quot;Your speed has been increased from &quot; + itoa(original_speed) + &quot; to &quot; + itoa(new_speed) + &quot;!&lt;br/&gt;&quot;, activator);
 } dilend

=== Temporary Speed Boost ===
 dilbegin haste_spell();
 var
    original_speed : integer;
    boosted_speed : integer;
 code
 {
    if (activator.type != UNIT_ST_PC and activator.type != UNIT_ST_NPC)
       quit;
    
    original_speed := activator.speed;
    
    // Double speed temporarily
    boosted_speed := original_speed * 2;
    
    activator.speed := boosted_speed;
    
    sendtext(&quot;You feel incredibly fast!&lt;br/&gt;&quot;, activator);
    
    // Wait for effect duration
    pause;
    pause;
    
    // Restore original speed
    activator.speed := original_speed;
    
    sendtext(&quot;You return to normal speed.&lt;br/&gt;&quot;, activator);
 } dilend

=== Speed-Based Combat ===
 dilbegin speed_combat_check();
 var
    my_speed : integer;
    opponent_speed : integer;
 code
 {
    if (activator.type != UNIT_ST_PC and activator.type != UNIT_ST_NPC)
       quit;
    
    my_speed := activator.speed;
    
    // Check if we can act before opponent
    if (self.fighting != null)
    {
       opponent_speed := self.fighting.speed;
       
       if (my_speed &gt; opponent_speed)
       {
          sendtext(&quot;You strike first with your superior speed!&lt;br/&gt;&quot;, self);
       }
       else if (my_speed &lt; opponent_speed)
       {
          sendtext(&quot;Your opponent strikes first with superior speed!&lt;br/&gt;&quot;, self);
       }
       else
       {
          sendtext(&quot;You and your opponent strike simultaneously!&lt;br/&gt;&quot;, self);
       }
    }
    else
    {
       sendtext(&quot;You are not currently in combat.&lt;br/&gt;&quot;, self);
    }
 } dilend

=== Speed Validation ===
 dilbegin validate_speed();
 var
    character_speed : integer;
 code
 {
    if (activator.type != UNIT_ST_PC and activator.type != UNIT_ST_NPC)
       quit;
    
    character_speed := activator.speed;
    
    // Check if speed is within reasonable bounds
    if (character_speed &lt; 0)
    {
       sendtext(&quot;Warning: Invalid negative speed detected.&lt;br/&gt;&quot;, self);
       activator.speed := 0;
    }
    else if (character_speed &gt; 200)
    {
       sendtext(&quot;Warning: Speed exceeds maximum limit.&lt;br/&gt;&quot;, self);
       activator.speed := 200;
    }
    else
    {
       sendtext(&quot;Speed is within acceptable range.&lt;br/&gt;&quot;, self);
    }
 } dilend

== Usage Notes ==
* The field is read-write and can be modified directly
* Only available on character units (PC and NPC)
* Requires zone access level 0 to read speed values
* Speed values affect combat initiative and action order
* Higher speed values mean the character acts more frequently in combat
* Speed is typically calculated as base speed plus modifiers
* The field is commonly used with [[Manual:DIL_Manual/change_speed()|change_speed()]] function for temporary modifications
* Speed values are often used in spell effects, magical items, and character creation

== Error Handling ==
The field includes several validation checks:

* **Unit type validation**: Only works on UNIT_ST_PC and UNIT_ST_NPC units
* **Access level validation**: Requires zone access level 0
* **Value validation**: Speed values should be within reasonable game limits
* **Null pointer validation**: Fails when accessed on null unit pointers

Common error scenarios:
* Accessing the field on objects or rooms (will return fail)
* Using invalid speed values (negative or extremely high)
* Attempting to access from zones with restricted permissions
* Accessing the field on destroyed units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/change_speed()|change_speed()]] - Function to modify character speed temporarily
* [[Manual:DIL_Manual/position|position]] - Field for character position state
* [[Manual:DIL_Manual/fighting|fighting]] - Field to check current combat opponent
* [[Manual:DIL_Manual/charflags|charflags]] - Field for character flags and states
* [[Manual:DIL_Manual/combat_speed|combat_speed]] - Internal speed calculation system

== See Also ==
* [[Manual:DIL_Manual/Combat system|Combat system]] - Information about combat mechanics and initiative
* [[Manual:DIL_Manual/Character attributes|Character attributes]] - General character statistics and properties
* [[Manual:DIL_Manual/Movement and speed|Movement and speed]] - Speed-related game mechanics
* [[Manual:DIL_Manual/Spells and effects|Spells and effects]] - Information about magical speed modifications</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/spell_costs</title>
     <ns>0</ns>
     <id>330839</id>
     <revision>
       <id>924354</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of spell_costs.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= spell_costs =
field: integer &apos;&apos;&apos;.spell_costs&apos;&apos;&apos;[index] (Read-only)

The &apos;&apos;&apos;spell_costs&apos;&apos;&apos; field is used to get the mana cost of a specific spell for a player character.

== Description ==
This field provides access to the mana cost required to cast a specific spell. The field takes an integer index parameter and returns the mana cost in experience points for that spell. The field is only available on player characters and requires appropriate zone access level to read.

The field uses the game&apos;s internal spell cost system, which may be modified by racial bonuses, class bonuses, or other game mechanics.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the mana cost in experience points for the specified spell index
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Spell Cost Lookup ===
 dilbegin check_spell_cost();
 var
    spell_index : integer;
    mana_cost : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Check cost of spell at index 10 (e.g., SPL_FIREBALL)
    spell_index := 10;
    mana_cost := activator.spell_costs[spell_index];
    
    sendtext(&quot;Spell cost: &quot; + itoa(mana_cost) + &quot; experience points.&lt;br/&gt;&quot;, activator);
 } dilend

=== Spell Affordability Check ===
 dilbegin can_afford_spell(spell_idx : integer);
 var
    mana_cost : integer;
    player_exp : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    mana_cost := activator.spell_costs[spell_idx];
    player_exp := activator.exp;
    
    if (player_exp &gt;= mana_cost)
    {
       sendtext(&quot;You can afford this spell.&lt;br/&gt;&quot;, activator);
       return(1);
    }
    else
    {
       sendtext(&quot;You need &quot; + itoa(mana_cost - player_exp) + &quot; more experience points.&lt;br/&gt;&quot;, activator);
       return(0);
    }
 } dilend

=== Spell Cost Comparison ===
 dilbegin compare_spell_costs();
 var
    spell1_cost : integer;
    spell2_cost : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Compare costs of two different spells
    spell1_cost := activator.spell_costs[SPL_FIREBALL];
    spell2_cost := activator.spell_costs[SPL_HEAL];
    
    sendtext(&quot;Fireball cost: &quot; + itoa(spell1_cost) + &quot; XP&lt;br/&gt;&quot;, activator);
    sendtext(&quot;Heal cost: &quot; + itoa(spell2_cost) + &quot; XP&lt;br/&gt;&quot;, activator);
    
    if (spell1_cost &lt; spell2_cost)
       sendtext(&quot;Fireball is cheaper to learn.&lt;br/&gt;&quot;, activator);
    else if (spell2_cost &lt; spell1_cost)
       sendtext(&quot;Heal is cheaper to learn.&lt;br/&gt;&quot;, activator);
    else
       sendtext(&quot;Both spells cost the same.&lt;br/&gt;&quot;, activator);
 } dilend

=== Spell Cost Display ===
 dilbegin show_all_spell_costs();
 var
    i : integer;
    spell_name : string;
    mana_cost : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Spell Costs:&lt;br/&gt;&quot;, activator);
    
    // Display costs for first 10 spells
    for (i := 0; i &lt; 10; i := i + 1)
    {
       if (i &lt; SPL_TREE_MAX)
       {
          mana_cost := activator.spell_costs[i];
          spell_name := spell_name(i);
          
          if (spell_name != &quot;&quot;)
             sendtext(spell_name + &quot;: &quot; + itoa(mana_cost) + &quot; XP&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Racial Bonus Calculation ===
 dilbegin calculate_racial_spell_cost(base_spell : integer, race : integer);
 external
    integer get_racial_spell_bonus(race : integer, spell : integer);
 var
    racial_bonus : integer;
    final_cost : integer;
 code
 {
    // Get base cost (this would be from a table or calculation)
    final_cost := base_spell;
    
    // Apply racial bonus (negative bonus reduces cost)
    racial_bonus := get_racial_spell_bonus(race, base_spell);
    final_cost := final_cost + racial_bonus;
    
    // Ensure cost doesn&apos;t go below 1
    if (final_cost &lt; 1)
       final_cost := 1;
    
    return(final_cost);
 } dilend

=== Spell Cost Validation ===
 dilbegin validate_spell_cost(spell_idx : integer);
 var
    mana_cost : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Check if spell index is valid
    if (spell_idx &lt; 0 or spell_idx &gt;= SPL_TREE_MAX)
    {
       sendtext(&quot;Invalid spell index: &quot; + itoa(spell_idx) + &quot;&lt;br/&gt;&quot;, activator);
       return(-1);
    }
    
    mana_cost := activator.spell_costs[spell_idx];
    
    if (mana_cost &lt; 0)
    {
       sendtext(&quot;Warning: Negative spell cost detected.&lt;br/&gt;&quot;, activator);
    }
    else if (mana_cost &gt; 1000)
    {
       sendtext(&quot;Warning: Extremely high spell cost.&lt;br/&gt;&quot;, activator);
    }
    else
    {
       sendtext(&quot;Spell &quot; + itoa(spell_idx) + &quot; costs &quot; + itoa(mana_cost) + &quot; XP.&lt;br/&gt;&quot;, activator);
    }
    
    return(mana_cost);
 } dilend

== Usage Notes ==
* The field is read-only and cannot be modified directly
* Only available on player characters (UNIT_ST_PC)
* Requires zone access level 0 to read spell costs
* Spell indices correspond to SPL_* constants defined in the game system
* The field returns experience point costs, not spell levels or proficiency
* Spell costs may be modified by racial bonuses, class bonuses, or other game mechanics
* The field is commonly used with [[Manual:DIL_Manual/spell_name()|spell_name()]] to get spell names
* Spell costs are typically used in character creation, training, and advancement systems

== Error Handling ==
The field includes several validation checks:

* **Unit type validation**: Only works on UNIT_ST_PC units
* **Access level validation**: Requires zone access level 0
* **Index validation**: Spell index must be within valid range (0 to SPL_TREE_MAX - 1)
* **Null pointer validation**: Fails when accessed on null unit pointers

Common error scenarios:
* Accessing the field on NPCs or objects (will return fail)
* Using invalid spell indices
* Attempting to access from zones with restricted permissions
* Accessing the field on destroyed units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/spell_name()|spell_name()]] - Function to get the name of a spell from its index
* [[Manual:DIL_Manual/spell_levels|spell_levels]] - Field to get the current level of a spell
* [[Manual:DIL_Manual/spells|spells]] - Field array to access all spell values
* [[Manual:DIL_Manual/exp|exp]] - Field to get current experience points
* [[Manual:DIL_Manual/skill_points|skill_points]] - Field to get available skill points

== See Also ==
* [[Manual:DIL_Manual/SPL_*|SPL_*]] - Spell index constants
* [[Manual:DIL_Manual/Character advancement|Character advancement]] - Information about spell progression systems
* [[Manual:DIL_Manual/Experience system|Experience system]] - Experience point and spell cost mechanics
* [[Manual:DIL_Manual/Racial bonuses|Racial bonuses]] - Racial modifications to spell costs

* [[Manual:DIL_Manual/Training systems|Training systems]] - Spell training and advancement procedures
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/spell_levels</title>
     <ns>0</ns>
     <id>842465</id>
     <revision>
       <id>1028422</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of spell_levels.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= spell_levels =
field: integer &apos;&apos;&apos;.spell_levels&apos;&apos;&apos;[index] (Read-only)

The &apos;&apos;&apos;spell_levels&apos;&apos;&apos; field is used to get the current level of a specific spell for a player character.

== Description ==
This field provides access to the current level of a specific spell for a player character. The field takes an integer index parameter and returns the current level of that spell. The field is only available on player characters and requires appropriate zone access level to read.

The field uses the game&apos;s internal spell system to track character progression in magical abilities and spellcasting proficiency.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current level of the specified spell index
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Spell Level Check ===
 dilbegin check_spell_level();
 var
    spell_index : integer;
    current_level : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Check current level of fireball spell (SPL_FIREBALL)
    spell_index := 1;  // Assuming SPL_FIREBALL = 1
    current_level := activator.spell_levels[spell_index];
    
    sendtext(&quot;Your fireball spell level is: &quot; + itoa(current_level) + &quot;&lt;br/&gt;&quot;, activator);
 } dilend

=== Spell Progression Display ===
 dilbegin show_spell_progress();
 var
    i : integer;
    spell_name : string;
    spell_level : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Your Spell Levels:&lt;br/&gt;&quot;, activator);
    
    // Display levels for first 10 spells
    for (i := 0; i &lt; 10; i := i + 1)
    {
       if (i &lt; SPL_TREE_MAX)
       {
          spell_level := activator.spell_levels[i];
          spell_name := spell_name(i);
          
          if (spell_name != &quot;&quot;)
             sendtext(spell_name + &quot;: &quot; + itoa(spell_level) + &quot;&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Spell Mastery Check ===
 dilbegin check_spell_mastery();
 var
    fire_level : integer;
    heal_level : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    fire_level := activator.spell_levels[SPL_FIREBALL];
    heal_level := activator.spell_levels[SPL_HEAL];
    
    if (fire_level &gt;= 10 and heal_level &gt;= 10)
    {
       sendtext(&quot;You have mastered both offensive and defensive magic.&lt;br/&gt;&quot;, activator);
    }
    else if (fire_level &gt;= 10)
    {
       sendtext(&quot;You have mastered offensive magic.&lt;br/&gt;&quot;, activator);
    }
    else if (heal_level &gt;= 10)
    {
       sendtext(&quot;You have mastered defensive magic.&lt;br/&gt;&quot;, activator);
    }
    else
    {
       sendtext(&quot;You still have much to learn.&lt;br/&gt;&quot;, activator);
    }
 } dilend

=== Spell Requirement Validation ===
 dilbegin validate_spell_requirements();
 var
    required_level : integer;
    player_level : integer;
    spell_index : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    // Check if player meets spell requirements for advanced training
    required_level := 15;
    player_level := activator.level;
    
    // Check specific spell (e.g., advanced fire techniques)
    spell_index := 1;  // SPL_FIREBALL
    
    if (activator.spell_levels[spell_index] &gt;= required_level)
    {
       sendtext(&quot;You meet the requirements for advanced spell training.&lt;br/&gt;&quot;, activator);
       return(1);
    }
    else
    {
       sendtext(&quot;You need to be at least level &quot; + itoa(required_level) + &quot; for this training.&lt;br/&gt;&quot;, activator);
       return(0);
    }
 } dilend

=== Spell Comparison ===
 dilbegin compare_spells(target : unitptr);
 var
    i : integer;
    my_level : integer;
    target_level : integer;
    spell_name : string;
 code
 {
    if (activator.type != UNIT_ST_PC or target.type != UNIT_ST_PC)
       quit;
    
    sendtext(&quot;Spell Level Comparison:&lt;br/&gt;&quot;, activator);
    
    // Compare levels for several key spells
    for (i := 0; i &lt; 5; i := i + 1)
    {
       my_level := activator.spell_levels[i];
       target_level := target.spell_levels[i];
       spell_name := spell_name(i);
       
       if (spell_name != &quot;&quot;)
       {
          sendtext(spell_name + &quot; - You: &quot; + itoa(my_level) + &quot;, Target: &quot; + itoa(target_level) + &quot;&lt;br/&gt;&quot;, activator);
       }
    }
 } dilend

=== Spell-Based Abilities ===
 dilbegin spell_based_abilities();
 var
    fire_level : integer;
    magic_level : integer;
 code
 {
    if (activator.type != UNIT_ST_PC)
       quit;
    
    fire_level := activator.spell_levels[SPL_FIREBALL];
    magic_level := activator.spell_levels[SPL_MAGIC_MISSILE];
    
    // Unlock abilities based on spell levels
    if (fire_level &gt;= 5)
    {
       sendtext(&quot;You can cast advanced fire spells.&lt;br/&gt;&quot;, activator);
    }
    
    if (magic_level &gt;= 5)
    {
       sendtext(&quot;You can cast advanced magic spells.&lt;br/&gt;&quot;, activator);
    }
    
    if (fire_level &gt;= 5 and magic_level &gt;= 5)
    {
       sendtext(&quot;You can combine fire and magic spells.&lt;br/&gt;&quot;, activator);
    }
 } dilend

== Usage Notes ==
* The field is read-only and cannot be modified directly
* Only available on player characters (UNIT_ST_PC)
* Requires zone access level 0 to read spell levels
* Spell indices correspond to SPL_* constants defined in the game system
* The field returns current spell level, not spell cost or mana cost
* Spell levels typically range from 0 to a maximum (often 100 or higher)
* The field is commonly used with [[Manual:DIL_Manual/spell_name()|spell_name()]] to get spell names
* Spell levels are used in character advancement and magical ability calculations
* The field is often used in training, guild, and progression systems

== Error Handling ==
The field includes several validation checks:

* **Unit type validation**: Only works on UNIT_ST_PC units
* **Access level validation**: Requires zone access level 0
* **Index validation**: Spell index must be within valid range (0 to SPL_TREE_MAX - 1)
* **Null pointer validation**: Fails when accessed on null unit pointers

Common error scenarios:
* Accessing the field on NPCs or objects (will return fail)
* Using invalid spell indices
* Attempting to access from zones with restricted permissions
* Accessing the field on destroyed units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/spell_name()|spell_name()]] - Function to get the name of a spell from its index
* [[Manual:DIL_Manual/spell_costs|spell_costs]] - Field to get the mana cost of a spell
* [[Manual:DIL_Manual/spells|spells]] - Field array to access all spell values
* [[Manual:DIL_Manual/exp|exp]] - Field to get current experience points
* [[Manual:DIL_Manual/spell_points|spell_points]] - Field to get available spell points

== See Also ==
* [[Manual:DIL_Manual/SPL_*|SPL_*]] - Spell index constants
* [[Manual:DIL_Manual/Character advancement|Character advancement]] - Information about spell progression systems
* [[Manual:DIL_Manual/Experience system|Experience system]] - Experience point and spell level mechanics
* [[Manual:DIL_Manual/Training systems|Training systems]] - Spell training and advancement procedures

* [[Manual:DIL_Manual/Magical abilities|Magical abilities]] - Information about spell systems and magic
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/spellindex</title>
     <ns>0</ns>
     <id>1036425</id>
     <revision>
       <id>1570266</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of spellindex.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= spellindex =
function: integer &apos;&apos;&apos;spellindex&apos;&apos;&apos;(s : string);

The &apos;&apos;&apos;spellindex&apos;&apos;&apos; function converts a spell name or abbreviation to its corresponding spell index number.

== Description ==
This function searches for a spell name in the spell collection and returns its numerical index. It accepts either full spell names or abbreviated spell names as input. The function uses the spell collection database to match the provided string against known spells.

If the spell is found, the function returns the spell index (SPL_XXX constant) which can be used with other spell-related functions like [[Manual:DIL_Manual/spellinfo|spellinfo]], [[Manual:DIL_Manual/cast_spell|cast_spell]], and [[Manual:DIL_Manual/attack_spell|attack_spell]]. If no matching spell is found, the function returns -1.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The abbreviated or full spell name to search for
|}

== Return Value ==
The function returns an integer value:
* Valid spell index (0 or greater) if the spell is found
* -1 if no matching spell is found or if the input string is empty/null

== Examples ==
=== Basic Usage ===
 dilbegin test_spellindex();
 var
   spell_idx : integer;
   spell_name : string;
 code
 {
   // Find spell index using abbreviation
   spell_idx := spellindex(&quot;cu li wo&quot;);  // &quot;cure light wounds&quot;
   
   if (spell_idx != -1)
     exec(&quot;say Found cure light wounds at index &quot; + itoa(spell_idx), self);
   else
     exec(&quot;say Spell not found&quot;, self);
   
   // Find spell index using full name
   spell_idx := spellindex(&quot;fireball&quot;);
   
   if (spell_idx != -1)
     exec(&quot;say Found fireball at index &quot; + itoa(spell_idx), self);
 }
 dilend

=== Spell Validation ===
 dilbegin validate_spell(spell_name : string);
 var
   idx : integer;
   real_name : string;
   realm, sphere, mana, offensive, resist, medium, target : integer;
 code
 {
   idx := spellindex(spell_name);
   
   if (idx == -1)
   {
     sendtext(&quot;Spell &apos;&quot; + spell_name + &quot;&apos; not found.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Get detailed spell information
   real_name := spellinfo(idx, realm, sphere, mana, offensive, resist, medium, target);
   
   sendtext(&quot;Spell: &quot; + real_name + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Index: &quot; + itoa(idx) + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Mana cost: &quot; + itoa(mana) + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Offensive: &quot; + (offensive != 0 ? &quot;Yes&quot; : &quot;No&quot;) + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

=== Dynamic Spell Assignment ===
 dilbegin assign_spell(pc : unitptr, spell_input : string);
 var
   spell_idx : integer;
 code
 {
   if (pc.type != UNIT_ST_PC)
   {
     sendtext(&quot;Target must be a player character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   spell_idx := spellindex(spell_input);
   
   if (spell_idx == -1)
   {
     sendtext(&quot;Unknown spell: &quot; + spell_input + &quot;&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Assign spell at maximum proficiency
   pc.spells[spell_idx] := 100;
   
   sendtext(&quot;Assigned spell at index &quot; + itoa(spell_idx) + &quot; to &quot; + pc.name + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

== Usage Notes ==
* The function accepts both abbreviated spell names (using spaces or underscores) and full spell names
* Spell matching is case-insensitive
* Abbreviations can use spaces (e.g., &quot;cu li wo&quot;) or underscores (e.g., &quot;cu_li_wo&quot;)
* The returned index corresponds to SPL_XXX constants defined in the game&apos;s spell system
* This function is commonly used to validate user input before performing spell operations

== Error Handling ==
The function handles errors gracefully:
* Empty or null strings return -1
* Non-existent spell names return -1
* No runtime errors are generated for invalid input

Always check the return value against -1 before using the index with other functions.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/spellinfo|spellinfo]] - Get detailed information about a spell using its index
* [[Manual:DIL_Manual/cast_spell|cast_spell]] - Cast a spell using its index
* [[Manual:DIL_Manual/attack_spell|attack_spell]] - Cast an offensive spell using its index
* unitptr.spells[] - Array field for storing character spell proficiencies

== See Also ==
* [[Manual:DIL_Manual/skillindex|skillindex]] - Similar function for skill indices
* [[Manual:DIL_Manual/weaponindex|weaponindex]] - Similar function for weapon indices

* DIL Spell System Documentation
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/spellinfo</title>
     <ns>0</ns>
     <id>318491</id>
     <revision>
       <id>1399127</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of spellinfo.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= spellinfo =
function: string &apos;&apos;&apos;spellinfo&apos;&apos;&apos;(idx : integer, i1 : integer, i2 : integer, i3 : integer, i4 : integer, i5 : integer, i6 : integer, i7 : integer);

The &apos;&apos;&apos;spellinfo&apos;&apos;&apos; function retrieves detailed information about a spell given its index number.

== Description ==
This function returns comprehensive information about a spell based on its numerical index. The function takes a spell index as the first parameter and seven integer variables as output parameters that will be populated with various spell attributes. The function returns the full name of the spell as a string.

The seven output parameters are set to specific spell attributes:
* Spell realm (magical or divine)
* Spell sphere (spell category)
* Mana cost
* Offensive flag
* Resistance type required
* Valid casting mediums
* Valid targets

This function is commonly used in conjunction with [[Manual:DIL_Manual/spellindex|spellindex]] to validate spells and retrieve their properties for display or processing purposes.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| idx || integer || The spell index (SPL_XXX). Use [[Manual:DIL_Manual/spellindex|spellindex]] to find this value
|-
| i1 || integer || Output variable for spell realm (MAG/DIC)
|-
| i2 || integer || Output variable for spell sphere (SPL_XXX)
|-
| i3 || integer || Output variable for mana usage
|-
| i4 || integer || Output variable for offensive flag (0 = non-offensive, non-zero = offensive)
|-
| i5 || integer || Output variable for resistance required (SPLCST_XXX)
|-
| i6 || integer || Output variable for valid mediums (MEDIA_XXX)
|-
| i7 || integer || Output variable for valid targets (FIND_UNIT_XXX &amp; TAR_XXX)
|}

== Return Value ==
The function returns a string containing:
* The full name of the spell if the index is valid
* Empty string if no such spell exists or if the index is out of range

== Examples ==
=== Basic Usage ===
 dilbegin test_spellinfo();
 var
   spell_idx : integer;
   spell_name : string;
   realm, sphere, mana, offensive, resist, medium, target : integer;
 code
 {
   // Get spell index for fireball
   spell_idx := spellindex(&quot;fireball&quot;);
   
   if (spell_idx != -1)
   {
     spell_name := spellinfo(spell_idx, realm, sphere, mana, offensive, resist, medium, target);
     
     sendtext(&quot;Spell: &quot; + spell_name + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Realm: &quot; + (realm == 0 ? &quot;Magical&quot; : &quot;Divine&quot;) + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Mana: &quot; + itoa(mana) + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Offensive: &quot; + (offensive != 0 ? &quot;Yes&quot; : &quot;No&quot;) + &quot;&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Spell Listing ===
 dilbegin list_spells();
 var
   i : integer;
   spell_name : string;
   realm, sphere, mana, offensive, resist, medium, target : integer;
 code
 {
   sendtext(&quot;Available spells:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; SPL_TREE_MAX)
   {
     spell_name := spellinfo(i, realm, sphere, mana, offensive, resist, medium, target);
     
     if (spell_name == &quot;&quot;)
       break;
     
     sendtext(itoa(i) + &quot;: &quot; + spell_name + &quot; (Mana: &quot; + itoa(mana) + &quot;)&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Spell Validation ===
 dilbegin validate_spell_requirements(spell_idx : integer, caster : unitptr);
 var
   spell_name : string;
   realm, sphere, mana, offensive, resist, medium, target : integer;
   can_cast : integer;
 code
 {
   spell_name := spellinfo(spell_idx, realm, sphere, mana, offensive, resist, medium, target);
   
   if (spell_name == &quot;&quot;)
   {
     sendtext(&quot;Invalid spell index.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   can_cast := 1;
   
   // Check mana
   if (caster.mana &lt; mana)
   {
     sendtext(&quot;Not enough mana (need &quot; + itoa(mana) + &quot;).&lt;br/&gt;&quot;, self);
     can_cast := 0;
   }
   
   // Check realm compatibility
   if (realm == 1 and caster.class != &quot;cleric&quot;)
   {
     sendtext(&quot;Divine spell - requires cleric class.&lt;br/&gt;&quot;, self);
     can_cast := 0;
   }
   else if (realm == 0 and caster.class != &quot;mage&quot;)
   {
     sendtext(&quot;Magical spell - requires mage class.&lt;br/&gt;&quot;, self);
     can_cast := 0;
   }
   
   if (can_cast)
     sendtext(&quot;Can cast &quot; + spell_name + &quot;.&lt;br/&gt;&quot;, self);
 }
 dilend

=== Dynamic Spell Information ===
 dilbegin spell_info_command(arg : string);
 var
   spell_idx : integer;
   spell_name : string;
   realm, sphere, mana, offensive, resist, medium, target : integer;
   realm_str, sphere_str : string;
 code
 {
   if (arg == &quot;&quot;)
   {
     sendtext(&quot;Usage: spellinfo &lt;spell name&gt;&lt;br/&gt;&quot;, self);
     quit;
   }
   
   spell_idx := spellindex(arg);
   
   if (spell_idx == -1)
   {
     sendtext(&quot;Spell &apos;&quot; + arg + &quot;&apos; not found.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   spell_name := spellinfo(spell_idx, realm, sphere, mana, offensive, resist, medium, target);
   
   // Format realm
   if (realm == 0)
     realm_str := &quot;Magical&quot;;
   else
     realm_str := &quot;Divine&quot;;
   
   sendtext(&quot;Spell Information for: &quot; + spell_name + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Index: &quot; + itoa(spell_idx) + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Realm: &quot; + realm_str + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Sphere: &quot; + itoa(sphere) + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Mana Cost: &quot; + itoa(mana) + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Type: &quot; + (offensive != 0 ? &quot;Offensive&quot; : &quot;Non-offensive&quot;) + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Resistance: &quot; + itoa(resist) + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Mediums: &quot; + itoa(medium) + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Targets: &quot; + itoa(target) + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

== Usage Notes ==
* The first parameter (idx) must be a valid spell index between SPL_ALL and SPL_TREE_MAX - 1
* Parameters i1 through i7 must be integer variables (not constants) as they are used as output parameters
* The function validates the spell index range and returns an empty string for invalid indices
* Spell realm values: 0 = Magical (MAG), 1 = Divine (DIC)
* The offensive flag is non-zero for offensive spells and zero for non-offensive spells
* This function is essential for creating spell lists, validation systems, and spell information displays

== Error Handling ==
The function handles errors in the following ways:
* Invalid spell indices (outside range SPL_ALL to SPL_TREE_MAX - 1) return empty string
* Non-integer first parameter causes compilation error
* Non-variable parameters for i1-i7 cause compilation error
* No runtime errors are generated for valid input within range

Always check the return string for emptiness before using the output parameter values.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/spellindex|spellindex]] - Convert spell name to index
* [[Manual:DIL_Manual/cast_spell|cast_spell]] - Cast a spell using its index
* [[Manual:DIL_Manual/attack_spell|attack_spell]] - Cast offensive spell using its index
* unitptr.spells[] - Array field for character spell proficiencies
* [[Manual:DIL_Manual/findunit|findunit]] - Function using FIND_UNIT_XXX constants for target searching

== See Also ==
* DIL Spell System Documentation
* SPL_XXX Constants (defined in values.h/vme.h)
* FIND_UNIT_XXX Constants for target specification

* MEDIA_XXX Constants for casting mediums

* SPLCST_XXX Constants for resistance types</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/spells</title>
     <ns>0</ns>
     <id>541020</id>
     <revision>
       <id>980930</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of spells.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= spells =
field: integer &apos;&apos;&apos;.spells&apos;&apos;&apos;[index] (Read-only)

The &apos;&apos;&apos;spells&apos;&apos;&apos; field provides access to spell proficiency values for characters and magical resistance for rooms and objects.

== Description ==
The &apos;&apos;&apos;spells&apos;&apos;&apos; field is an array that behaves differently depending on the unit type:

* For PCs (Player Characters): Returns spell proficiency values (0-100) for individual spells
* For NPCs (Non-Player Characters): Returns spell proficiency values (0-100) for spell groups only
* For Rooms: Returns magical resistance value
* For Objects: Returns magical resistance value

The field uses spell indices (SPL_XXX constants) to access specific spell data. The valid index range depends on the unit type and whether it&apos;s a PC or NPC.

== Field Access ==
{| class=&quot;wikitable&quot;
! Unit Type !! Index Range !! Access Type !! Description
|-
| UNIT_ST_PC || 0 to SPL_TREE_MAX-1 || Read/Write* || Individual spell proficiencies (0-100)
|-
| UNIT_ST_NPC || 0 to SPL_GROUP_MAX-1 || Read/Write* || Spell group proficiencies (0-100)
|-
| UNIT_ST_ROOM || 0 || Read-only || Magical resistance value
|-
| UNIT_ST_OBJ || 0 || Read-only || Magical resistance value
|}

*Write access is restricted by zone access level for PCs

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
=== Reading Spell Proficiency ===
 dilbegin check_spell_proficiency(pc : unitptr, spell_name : string);
 var
   spell_idx : integer;
   proficiency : integer;
 code
 {
   if (pc.type != UNIT_ST_PC)
   {
     sendtext(&quot;Target must be a player character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   spell_idx := spellindex(spell_name);
   
   if (spell_idx == -1)
   {
     sendtext(&quot;Unknown spell: &quot; + spell_name + &quot;&lt;br/&gt;&quot;, self);
     quit;
   }
   
   proficiency := pc.spells[spell_idx];
   sendtext(pc.name + &quot;&apos;s proficiency in &quot; + spell_name + &quot;: &quot; + itoa(proficiency) + &quot;%&lt;br/&gt;&quot;, self);
 }
 dilend

=== Setting Spell Proficiency ===
 dilbegin teach_spell(pc : unitptr, spell_name : string, level : integer);
 var
   spell_idx : integer;
 code
 {
   if (pc.type != UNIT_ST_PC)
   {
     sendtext(&quot;Can only teach spells to player characters.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   spell_idx := spellindex(spell_name);
   
   if (spell_idx == -1)
   {
     sendtext(&quot;Unknown spell: &quot; + spell_name + &quot;&lt;br/&gt;&quot;, self);
     quit;
   }
   
   if (level &lt; 0 or level &gt; 100)
   {
     sendtext(&quot;Proficiency must be between 0 and 100.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   pc.spells[spell_idx] := level;
   sendtext(&quot;Taught &quot; + pc.name + &quot; &quot; + spell_name + &quot; at &quot; + itoa(level) + &quot;% proficiency.&lt;br/&gt;&quot;, self);
 }
 dilend

=== NPC Spell Groups ===
 dilbegin check_npc_spells(npc : unitptr);
 var
   i : integer;
   proficiency : integer;
 code
 {
   if (npc.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a non-player character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   sendtext(&quot;Spell groups for &quot; + npc.name + &quot;:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; SPL_GROUP_MAX)
   {
     proficiency := npc.spells[i];
     
     if (proficiency &gt; 0)
       sendtext(&quot;Group &quot; + itoa(i) + &quot;: &quot; + itoa(proficiency) + &quot;%&lt;br/&gt;&quot;, self);
     
     i := i + 1;
   }
 }
 dilend

=== Magical Resistance ===
 dilbegin check_magical_resistance(unit : unitptr);
 var
   resistance : integer;
   unit_type : string;
 code
 {
   if (unit.type == UNIT_ST_ROOM)
   {
     resistance := unit.spells[0];
     sendtext(&quot;Room magical resistance: &quot; + itoa(resistance) + &quot;&lt;br/&gt;&quot;, self);
   }
   else if (unit.type == UNIT_ST_OBJ)
   {
     resistance := unit.spells[0];
     sendtext(&quot;Object magical resistance: &quot; + itoa(resistance) + &quot;&lt;br/&gt;&quot;, self);
   }
   else
   {
     sendtext(&quot;This unit type doesn&apos;t have magical resistance.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Spell List Display ===
 dilbegin show_character_spells(pc : unitptr);
 var
   i : integer;
   spell_name : string;
   proficiency : integer;
   realm, sphere, mana, offensive, resist, medium, target : integer;
 code
 {
   if (pc.type != UNIT_ST_PC)
   {
     sendtext(&quot;Target must be a player character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   sendtext(&quot;Spell list for &quot; + pc.name + &quot;:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; SPL_TREE_MAX)
   {
     proficiency := pc.spells[i];
     
     if (proficiency &gt; 0)
     {
       spell_name := spellinfo(i, realm, sphere, mana, offensive, resist, medium, target);
       
       if (spell_name != &quot;&quot;)
         sendtext(itoa(i) + &quot;: &quot; + spell_name + &quot; (&quot; + itoa(proficiency) + &quot;%)&lt;br/&gt;&quot;, self);
     }
     
     i := i + 1;
   }
 }
 dilend

== Usage Notes ==
* For PCs, valid indices are 0 to SPL_TREE_MAX-1 (individual spells)
* For NPCs, valid indices are 0 to SPL_GROUP_MAX-1 (spell groups only)
* For rooms and objects, only index 0 is valid (magical resistance)
* Spell proficiency values typically range from 0 (no knowledge) to 100 (master)
* Write access for PCs is restricted by the zone&apos;s access level
* Use [[Manual:DIL_Manual/spellindex|spellindex]] to convert spell names to indices
* Use [[Manual:DIL_Manual/spellinfo|spellinfo]] to get spell names from indices

== Error Handling ==
The field handles errors in the following ways:
* Invalid indices return DILV_FAIL (no value)
* Null unit pointers return DILV_FAIL
* Write access violations return DILV_FAIL
* Index out of range for the unit type returns DILV_FAIL

Always validate the unit type and index range before accessing the field.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/spellindex|spellindex]] - Convert spell name to index
* [[Manual:DIL_Manual/spellinfo|spellinfo]] - Get spell information from index
* [[Manual:DIL_Manual/abilities|abilities]] - Similar field for ability scores
* [[Manual:DIL_Manual/skills|skills]] - Similar field for skill proficiencies
* [[Manual:DIL_Manual/weapons|weapons]] - Similar field for weapon proficiencies

== See Also ==
* DIL Spell System Documentation
* SPL_XXX Constants (defined in values.h/vme.h)
* SPL_GROUP_MAX and SPL_TREE_MAX constants

* Magical Resistance System Documentation
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/split</title>
     <ns>0</ns>
     <id>918111</id>
     <revision>
       <id>1127524</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of split.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= split =
function: stringlist &apos;&apos;&apos;split&apos;&apos;&apos;(s : string, t : string);

The &apos;&apos;&apos;split&apos;&apos;&apos; function divides a string into a list of substrings based on a specified delimiter.

== Description ==
This function takes a source string and a delimiter string, then returns a stringlist containing all substrings that were separated by the delimiter in the original string. The function searches for all occurrences of the delimiter and splits the string at each location.

The resulting stringlist contains each segment as a separate string element. If the delimiter is not found in the source string, the function returns a stringlist containing the original string as its single element.

A common use case is splitting text by line breaks using the &apos;&amp;x&apos; character, which is particularly useful when processing files read with the [[Manual:DIL_Manual/loadstr|loadstr]] function.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The source string to be split
|-
| t || string || The delimiter string used to separate the source string
|}

== Return Value ==
The function returns a stringlist containing:
* All substrings that were separated by the delimiter
* The original string as a single element if delimiter is not found
* Empty stringlist if either parameter is null or empty

== Examples ==
=== Basic Word Splitting ===
 dilbegin split_words();
 var
   text : string;
   words : stringlist;
   i : integer;
 code
 {
   text := &quot;hello world this is a test&quot;;
   words := split(text, &quot; &quot;);
   
   sendtext(&quot;Split words:&lt;br/&gt;&quot;, self);
   i := 0;
   while (i &lt; length(words))
   {
     sendtext(itoa(i) + &quot;: &apos;&quot; + words.[i] + &quot;&apos;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Line Splitting ===
 dilbegin process_lines();
 var
   multiline_text : string;
   lines : stringlist;
   i : integer;
 code
 {
   multiline_text := &quot;First line&amp;xSecond line&amp;xThird line&quot;;
   lines := split(multiline_text, &quot;&amp;x&quot;);
   
   sendtext(&quot;Processed lines:&lt;br/&gt;&quot;, self);
   i := 0;
   while (i &lt; length(lines))
   {
     sendtext(&quot;Line &quot; + itoa(i + 1) + &quot;: &quot; + lines.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Command Argument Parsing ===
 dilbegin parse_command_args(command : string);
 var
   args : stringlist;
   i : integer;
 code
 {
   if (command == &quot;&quot;)
   {
     sendtext(&quot;No command to parse.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   args := split(command, &quot; &quot;);
   
   sendtext(&quot;Command arguments:&lt;br/&gt;&quot;, self);
   i := 0;
   while (i &lt; length(args))
   {
     sendtext(&quot;Arg &quot; + itoa(i) + &quot;: &apos;&quot; + args.[i] + &quot;&apos;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
   
   if (length(args) &gt; 0)
     sendtext(&quot;First argument: &quot; + args.[0] + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

== Usage Notes ==
* The delimiter can be any string, not just a single character
* Empty strings between delimiters are included in the result
* The function is case-sensitive for delimiter matching
* Use &apos;&amp;x&apos; to split by line breaks when working with file content
* The resulting stringlist can be accessed using array notation: result.[index]
* Use [[Manual:DIL_Manual/length|length]]() to get the number of elements in the resulting stringlist
* Stringlist elements are indexed starting from 0

== Error Handling ==
The function handles errors in the following ways:
* Null or empty source string returns empty stringlist
* Null or empty delimiter returns empty stringlist
* No runtime errors are generated for valid string inputs
* Always check the length of the returned stringlist before accessing elements

== Related Functions/Fields ==
* [[Manual:DIL_Manual/length|length]] - Get the number of elements in a stringlist
* [[Manual:DIL_Manual/addstring|addstring]] - Add a string to a stringlist
* [[Manual:DIL_Manual/substring|substring]] - Remove a string from a stringlist
* [[Manual:DIL_Manual/getwords|getwords]] - Split string into words (space-delimited)
* [[Manual:DIL_Manual/loadstr|loadstr]] - Load file content (often used with split and &apos;&amp;x&apos;)
* [[Manual:DIL_Manual/insert|insert]] - Insert element into stringlist at specific position
* [[Manual:DIL_Manual/remove|remove]] - Remove element from stringlist at specific position

== See Also ==
* Stringlist data type documentation
* String manipulation functions
* File processing functions
* DIL string operations documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/stop_fighting</title>
     <ns>0</ns>
     <id>807994</id>
     <revision>
       <id>968678</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of stop_fighting.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= stop_fighting =
function: &apos;&apos;&apos;stop_fighting&apos;&apos;&apos;(ch : unitptr, vict : unitptr);

The &apos;&apos;&apos;stop_fighting&apos;&apos;&apos; function terminates combat between characters or stops all combat for a specific character.

== Description ==
This function is used to cancel combat engagements in the game. It can either stop combat between two specific characters or stop all combat for a particular character. The function removes the specified combat relationships and updates the combat state accordingly.

When called with a specific target (vict), it stops combat between the two characters. When called with null as the second parameter, it stops all combat engagements for the first character (ch). This function is commonly used in death sequences, area peace effects, teleportation, and other situations where combat should be terminated.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| ch || unitptr || The character to stop fighting for
|-
| vict || unitptr || The specific opponent to stop fighting with, or null to stop all combat
|}

== Return Value ==
The function does not return a value.

== Examples ==
=== Stop All Combat ===
 dilbegin peace_room();
 var
   u : unitptr;
 code
 {
   // Stop all combat in the room
   foreach (u, self.inside)
   {
     if (u.type == UNIT_ST_PC or u.type == UNIT_ST_NPC)
     {
       stop_fighting(u, null);
       sendtext(&quot;Combat has been stopped.&lt;br/&gt;&quot;, u);
     }
   }
 }
 dilend

=== Stop Combat Between Two Characters ===
 dilbegin separate_fighters(attacker : unitptr, defender : unitptr);
 code
 {
   if (opponent(attacker, defender))
   {
     stop_fighting(attacker, defender);
     stop_fighting(defender, attacker);
     
     act(&quot;$1n and $2n stop fighting.&quot;, A_SOMEONE, attacker, defender, null, TO_ALL);
   }
 }
 dilend

=== Death Sequence ===
 dilbegin character_death();
 var
   corpse : unitptr;
 code
 {
   // Stop all combat for the dying character
   stop_fighting(self, null);
   
   // Set position to dead
   self.position := POSITION_DEAD;
   
   // Create corpse
   corpse := make_corpse(&quot;corpse@death&quot;);
   
   // Handle player vs NPC differences
   if (self.type == UNIT_ST_NPC)
     destroy(self);
   else
   {
     link(self, findroom(&quot;death_room@basis&quot;));
     dilcopy(&quot;death_sequence@death&quot;, self);
   }
 }
 dilend

== Usage Notes ==
* The first parameter (ch) must be a character (PC or NPC)
* The second parameter (vict) can be a specific character or null to stop all combat
* When vict is null, all combat engagements for ch are terminated
* When vict is specified, only combat between ch and vict is stopped
* The function automatically handles both sides of the combat relationship
* Use [[Manual:DIL_Manual/opponent|opponent]]() to check if two characters are in combat
* The [[Manual:DIL_Manual/fighting|fighting]] field can be used to check current combat status
* Combat is automatically stopped when characters die or leave the area

== Error Handling ==
The function handles errors in the following ways:
* Null or invalid first parameter causes no action
* Non-character units are ignored
* Invalid second parameter (non-unitptr) causes compilation error
* No runtime errors are generated for valid character parameters

Always validate that parameters are valid characters before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/set_fighting|set_fighting]] - Start combat between two characters
* [[Manual:DIL_Manual/opponent|opponent]] - Check if two characters are in combat
* [[Manual:DIL_Manual/fighting|fighting]] - Field showing current combat target
* [[Manual:DIL_Manual/opponentcount|opponentcount]] - Field showing number of opponents
* [[Manual:DIL_Manual/position|position]] - Field for character position (useful for checking death)

== See Also ==
* DIL Combat System Documentation
* POSITION_* constants for character positions
* SFB_COM flag for combat message detection
* Combat-related DIL functions and fields</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/store</title>
     <ns>0</ns>
     <id>674332</id>
     <revision>
       <id>1660426</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of store.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= store =
function: &apos;&apos;&apos;store&apos;&apos;&apos;(u : unitptr, filename : string, container : integer);

The &apos;&apos;&apos;store&apos;&apos;&apos; function saves a unit and its contents to a file for later restoration.

== Description ==
This function saves a copy of a unit to a file on disk, allowing it to be restored later using the [[Manual:DIL_Manual/restore|restore]] function. The function can save either just the contents of a unit or the unit itself along with its contents, depending on the container parameter.

When container is TRUE, the unit itself and all its contents are saved. When container is FALSE, only the contents of the unit are saved, not the unit itself. This makes the function versatile for different storage needs like saving player inventories, room contents, or storage containers.

The function requires zone access level 10 or lower to execute successfully. Files are stored in the DIL file directory under a &quot;units/&quot; subdirectory.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit to be stored (cannot be a room or PC)
|-
| filename || string || The name of the file to store the unit in
|-
| container || integer || TRUE to save unit and contents, FALSE to save only contents
|}

== Return Value ==
The function does not return a value.

== Examples ==
=== Save Container Contents Only ===
 dilbegin save_chest_contents();
 var
   chest : unitptr;
 code
 {
   chest := self;
   
   if (chest.type != UNIT_ST_OBJ)
   {
     sendtext(&quot;This command only works on container objects.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Save only the contents, not the chest itself
   store(chest, &quot;chest.&quot; + chest.zoneidx, FALSE);
   
   sendtext(&quot;Chest contents have been saved.&lt;br/&gt;&quot;, self);
 }
 dilend

=== Save Container and Contents ===
 dilbegin save_storage_chest();
 var
   chest : unitptr;
 code
 {
   chest := self;
   
   if (chest.type != UNIT_ST_OBJ)
   {
     sendtext(&quot;This command only works on container objects.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Save the chest and everything inside it
   store(chest, &quot;storage_chest.&quot; + chest.zoneidx, TRUE);
   
   sendtext(&quot;Storage chest and its contents have been saved.&lt;br/&gt;&quot;, self);
 }
 dilend

=== Player Inventory Storage ===
 dilbegin save_player_inventory();
 var
   pc : unitptr;
   storage_box : unitptr;
 code
 {
   pc := activator;
   
   if (pc.type != UNIT_ST_PC)
   {
     sendtext(&quot;This command only works on players.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Create temporary storage box
   storage_box := load(&quot;temp_storage_box@storage&quot;);
   
   if (storage_box == null)
   {
     sendtext(&quot;Storage system unavailable.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Move all player items to storage box
   while (pc.inside)
   {
     link(pc.inside, storage_box);
   }
   
   // Save the storage box with player&apos;s inventory
   store(storage_box, &quot;player_backup.&quot; + pc.name, TRUE);
   
   sendtext(&quot;Your inventory has been safely stored.&lt;br/&gt;&quot;, pc);
   
   // Clean up
   destroy(storage_box);
 }
 dilend

== Usage Notes ==
* The function requires zone access level 10 or lower
* Units of type UNIT_ST_ROOM and UNIT_ST_PC cannot be stored
* Files are saved in the DIL file directory under &quot;units/&quot; subdirectory
* Use TRUE for container parameter to save unit and its contents
* Use FALSE for container parameter to save only contents
* The filename should not include path or extension
* Use [[Manual:DIL_Manual/restore|restore]] function to load previously stored units
* Disk access is slow - use sparingly to avoid server performance issues
* Player inventories are automatically saved, so explicit storage is only needed for special cases

== Error Handling ==
The function handles errors in the following ways:
* Invalid unit types (rooms, PCs) cause security violation log
* Null or invalid unit pointer causes no action
* Invalid filename causes security violation log
* Insufficient zone access level causes security violation log
* No runtime errors are generated for valid parameters

Always validate unit type and access level before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/restore|restore]] - Load a previously stored unit
* [[Manual:DIL_Manual/delunit|delunit]] - Delete a stored unit file
* [[Manual:DIL_Manual/load|load]] - Load a unit from main database
* [[Manual:DIL_Manual/findunit|findunit]] - Find a unit in the game world

== See Also ==
* DIL File System Documentation
* Zone Access Level Documentation
* Unit Storage and Retrieval Systems
* DIL Security and Access Control</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/strcmp</title>
     <ns>0</ns>
     <id>982876</id>
     <revision>
       <id>1307578</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of strcmp.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= strcmp =
function: integer &apos;&apos;&apos;strcmp&apos;&apos;&apos;(s1 : string, s2 : string);

The &apos;&apos;&apos;strcmp&apos;&apos;&apos; function performs case-sensitive string comparison and returns the lexical relationship between two strings.

== Description ==
This function compares two strings lexicographically (character by character) and returns an integer indicating their relationship. The comparison is case-sensitive, meaning &quot;Hello&quot; and &quot;hello&quot; are considered different strings.

The function follows standard C library strcmp behavior:
* Returns -1 if first string (s1) is lexicographically less than second string (s2)
* Returns 0 if both strings are identical
* Returns 1 if first string (s1) is lexicographically greater than second string (s2)

Lexicographic comparison means strings are compared character by character using their ASCII values. This is different from simple equality comparison and is useful for sorting strings or determining alphabetical order.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s1 || string || The first string to compare
|-
| s2 || string || The second string to compare
|}

== Return Value ==
The function returns an integer:
* -1 if s1 &lt; s2 (s1 comes before s2 alphabetically)
* 0 if s1 == s2 (strings are identical)
* 1 if s1 &gt; s2 (s1 comes after s2 alphabetically)

== Examples ==
=== Basic String Comparison ===
 dilbegin test_comparison();
 var
   result : integer;
 code
 {
   result := strcmp(&quot;apple&quot;, &quot;banana&quot;);
   // result will be -1 (apple &lt; banana)
   
   if (result &lt; 0)
     sendtext(&quot;apple comes before banana&lt;br/&gt;&quot;, self);
   
   result := strcmp(&quot;zebra&quot;, &quot;yak&quot;);
   // result will be 1 (zebra &gt; yak)
   
   if (result &gt; 0)
     sendtext(&quot;zebra comes after yak&lt;br/&gt;&quot;, self);
   
   result := strcmp(&quot;hello&quot;, &quot;hello&quot;);
   // result will be 0 (strings are equal)
   
   if (result == 0)
     sendtext(&quot;hello equals hello&lt;br/&gt;&quot;, self);
 }
 dilend

=== Case Sensitivity Demonstration ===
 dilbegin case_sensitive_test();
 var
   result : integer;
 code
 {
   result := strcmp(&quot;Hello&quot;, &quot;hello&quot;);
   // result will be non-zero (different case)
   
   if (result != 0)
     sendtext(&quot;Hello and hello are different (case sensitive)&lt;br/&gt;&quot;, self);
   
   result := strcmp(&quot;hello&quot;, &quot;hello&quot;);
   // result will be 0 (same case)
   
   if (result == 0)
     sendtext(&quot;hello and hello are identical&lt;br/&gt;&quot;, self);
 }
 dilend

=== Password Verification ===
 dilbegin verify_password(attempt : string, stored : string);
 var
   result : integer;
 code
 {
   result := strcmp(attempt, stored);
   
   if (result == 0)
   {
     sendtext(&quot;Password correct!&lt;br/&gt;&quot;, self);
     // Grant access or proceed with login
   }
   else
   {
     sendtext(&quot;Password incorrect.&lt;br/&gt;&quot;, self);
     // Deny access or retry
   }
 }
 dilend

 }
 dilend

== Usage Notes ==
* The function performs case-sensitive comparison
* Comparison is lexicographic, not based on string length
* Use standard equality operators (==, !=) for case-insensitive comparison when needed
* The function is useful for sorting algorithms and alphabetical ordering
* Lexicographic order follows ASCII character values
* Empty strings are valid inputs and can be compared

== Error Handling ==
The function handles errors in the following ways:
* Null or invalid string parameters may cause runtime errors
* No specific error return values - always returns -1, 0, or 1
* Function does not generate runtime errors for valid string inputs

Always ensure both parameters are valid strings before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/strncmp|strncmp]] - Compare strings with length limit
* [[Manual:DIL_Manual/string|string]] data type and operations
* [[Manual:DIL_Manual/getwords|getwords]] - Split string into words for comparison
* [[Manual:DIL_Manual/length|length]] - Get string length for validation
* String comparison operators (==, !=, &lt;, &gt;, &lt;=, &gt;=)

== See Also ==
* DIL String Operations Documentation
* String comparison and sorting algorithms
* Lexicographic ordering principles
* ASCII character encoding reference</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/strdir</title>
     <ns>0</ns>
     <id>612458</id>
     <revision>
       <id>1266131</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of strdir.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= strdir =
 function: stringlist &apos;&apos;&apos;strdir&apos;&apos;&apos;(match : string);

The &apos;&apos;&apos;strdir&apos;&apos;&apos; function returns a list of filenames from the DIL strings directory that match a specified pattern.

== Description ==
This function searches the DIL strings directory for files that match a wildcard pattern and returns them as a stringlist. The function uses the same wildcard patterns as the Linux &apos;ls&apos; command, making it useful for finding specific groups of files or all files in the directory.

The match parameter supports standard wildcard patterns:
* Asterisk (*) matches any sequence of characters
* Question mark (?) matches any single character
* Character sets ([abc]) match any character in the brackets

The function searches for files with .dil extension in the DIL strings directory.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| match || string || The wildcard pattern to match filenames against
|}

== Return Value ==
The function returns a stringlist containing:
* All matching filenames from the DIL strings directory
* Empty stringlist if no files match the pattern
* Files are returned without the .dil extension

== Examples ==
=== Find All DIL Files ===
 dilbegin list_all_dil_files();
 var
    files : stringlist;
    i : integer;
 code
 {
    files := strdir(&quot;*&quot;);
    
    sendtext(&quot;All DIL files:&lt;br/&gt;&quot;, self);
    
    i := 0;
    while (i &lt; length(files))
    {
      sendtext(itoa(i + 1) + &quot;: &quot; + files.[i] + &quot;.dil&lt;br/&gt;&quot;, self);
      i := i + 1;
    }
 } dilend

=== Find Specific Pattern ===
 dilbegin find_spell_files();
 var
    files : stringlist;
    i : integer;
 code
 {
    // Find all files starting with &quot;spell_&quot;
    files := strdir(&quot;spell_*&quot;);
    
    sendtext(&quot;Spell-related DIL files:&lt;br/&gt;&quot;, self);
    
    i := 0;
    while (i &lt; length(files))
    {
      sendtext(itoa(i + 1) + &quot;: &quot; + files.[i] + &quot;.dil&lt;br/&gt;&quot;, self);
      i := i + 1;
    }
 } dilend

=== Find Files with Character Set ===
 dilbegin find_command_files();
 var
    files : stringlist;
    i : integer;
 code
 {
    // Find files with names containing only lowercase letters
    files := strdir(&quot;[a-z]*&quot;);
    
    sendtext(&quot;Command files (lowercase only):&lt;br/&gt;&quot;, self);
    
    i := 0;
    while (i &lt; length(files))
    {
      sendtext(itoa(i + 1) + &quot;: &quot; + files.[i] + &quot;.dil&lt;br/&gt;&quot;, self);
      i := i + 1;
    }
 } dilend

=== Multiple Pattern Search ===
 dilbegin search_patterns();
 var
    spell_files : stringlist;
    combat_files : stringlist;
    i : integer;
 code
 {
    // Find spell files
    spell_files := strdir(&quot;spell_*&quot;);
    
    // Find combat-related files
    combat_files := strdir(&quot;*combat*&quot;);
    
    sendtext(&quot;Spell files:&lt;br/&gt;&quot;, self);
    i := 0;
    while (i &lt; length(spell_files))
    {
      sendtext(&quot;  &quot; + spell_files.[i] + &quot;.dil&lt;br/&gt;&quot;, self);
      i := i + 1;
    }
    
    sendtext(&quot;Combat files:&lt;br/&gt;&quot;, self);
    i := 0;
    while (i &lt; length(combat_files))
    {
      sendtext(&quot;  &quot; + combat_files.[i] + &quot;.dil&lt;br/&gt;&quot;, self);
      i := i + 1;
    }
 } dilend

=== Dynamic File Loading ===
 dilbegin dynamic_loader(pattern : string);
 var
    files : stringlist;
    i : integer;
    filename : string;
    program : unitptr;
 code
 {
    files := strdir(pattern);
    
    if (length(files) == 0)
    {
      sendtext(&quot;No files match pattern: &quot; + pattern + &quot;&lt;br/&gt;&quot;, self);
      quit;
    }
    
    sendtext(&quot;Files matching &apos;&quot; + pattern + &quot;&apos;:&lt;br/&gt;&quot;, self);
    
    i := 0;
    while (i &lt; length(files))
    {
      filename := files.[i] + &quot;.dil&quot;;
      sendtext(&quot;Loading: &quot; + filename + &quot;&lt;br/&gt;&quot;, self);
      
      // Load the DIL program
      program := load(filename);
      
      if (program)
      {
        sendtext(&quot;Successfully loaded: &quot; + filename + &quot;&lt;br/&gt;&quot;, self);
        // Execute or process the loaded program
        dilcopy(filename, self);
      }
      else
      {
        sendtext(&quot;Failed to load: &quot; + filename + &quot;&lt;br/&gt;&quot;, self);
      }
      
      i := i + 1;
    }
 } dilend

=== Wildcard Pattern Examples ===
 dilbegin demonstrate_wildcards();
 var
    files : stringlist;
    i : integer;
 code
 {
    sendtext(&quot;Wildcard pattern examples:&lt;br/&gt;&quot;, self);
    
    // Match any single character
    files := strdir(&quot;?&quot;);
    sendtext(&quot;? (single char): &quot; + itoa(length(files)) + &quot; files&lt;br/&gt;&quot;, self);
    
    // Match files ending with specific suffix
    files := strdir(&quot;*_test&quot;);
    sendtext(&quot;*_test: &quot; + itoa(length(files)) + &quot; files&lt;br/&gt;&quot;, self);
    
    // Match files with specific prefix and any extension
    files := strdir(&quot;guild_*&quot;);
    sendtext(&quot;guild_*: &quot; + itoa(length(files)) + &quot; files&lt;br/&gt;&quot;, self);
    
    // Match files containing specific characters
    files := strdir(&quot;*[abc]*&quot;);
    sendtext(&quot;*[abc]*: &quot; + itoa(length(files)) + &quot; files&lt;br/&gt;&quot;, self);
 } dilend

=== File System Operations ===
 dilbegin file_operations();
 var
    all_files : stringlist;
    temp_files : stringlist;
    backup_files : stringlist;
    i : integer;
 code
 {
    // Get all files
    all_files := strdir(&quot;*&quot;);
    
    // Filter for temporary files
    temp_files := strdir(&quot;temp*&quot;);
    
    // Filter for backup files
    backup_files := strdir(&quot;*backup*&quot;);
    
    sendtext(&quot;Total DIL files: &quot; + itoa(length(all_files)) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Temporary files: &quot; + itoa(length(temp_files)) + &quot;&lt;br/&gt;&quot;, self);
    sendtext(&quot;Backup files: &quot; + itoa(length(backup_files)) + &quot;&lt;br/&gt;&quot;, self);
 } dilend

=== Competition Board Example ===
 dilbegin boot_competition();
 var
    rm : unitptr;
    flist : stringlist;
    i : integer;
    ln : integer;
    nl : stringlist;
 code
 {
    heartbeat := 5 * 60 * PULSE_SEC;
    rm := restore(&quot;comp_obj&quot;, null);
    
    if (rm == null)
    {
      log(&quot;Competition board_obj error.&lt;br&gt;&quot;);
      goto xp_load;
    }
    
    link(rm, self);
    
    // Get all competition files
    flist := strdir(&quot;*.comp&quot;);
    i := 0;
    ln := length(flist);
    
    while (i &lt; ln)
    {
      if (flist.[i] == &quot;&quot;)
      {
        i := i + 1;
        continue;
      }
      
      nl := split(flist.[i], &quot;.&quot;);
      if (length(nl) &lt; 2)
      {
        i := i + 1;
        continue;
      }
      
      // Load the competition file
      load_file(nl.[0]);
      i := i + 1;
    }
    
    pause;
    addextra(self.extra, {&quot;competition loaded&quot;}, &quot;Extra to fix quick reboot log on problem&quot;);
 } dilend

=== Wildcard Pattern Examples ===
 dilbegin demonstrate_wildcards();
 var
    files : stringlist;
    i : integer;
 code
 {
    sendtext(&quot;Wildcard pattern examples:&lt;br/&gt;&quot;, self);
    
    // Match any single character
    files := strdir(&quot;?&quot;);
    sendtext(&quot;? (single char): &quot; + itoa(length(files)) + &quot; files&lt;br/&gt;&quot;, self);
    
    // Match files ending with specific suffix
    files := strdir(&quot;*_test&quot;);
    sendtext(&quot;*_test: &quot; + itoa(length(files)) + &quot; files&lt;br/&gt;&quot;, self);
    
    // Match files with specific prefix and any extension
    files := strdir(&quot;guild_*&quot;);
    sendtext(&quot;guild_*: &quot; + itoa(length(files)) + &quot; files&lt;br/&gt;&quot;, self);
    
    // Match files containing specific characters
    files := strdir(&quot;*[abc]*&quot;);
    sendtext(&quot;*[abc]*: &quot; + itoa(length(files)) + &quot; files&lt;br/&gt;&quot;, self);
 } dilend

== Usage Notes ==
* The function searches the DIL strings directory for .dil files
* Wildcard patterns follow Linux/Unix shell conventions
* Asterisk (*) matches any sequence of characters
* Question mark (?) matches any single character
* Character sets ([abc]) match any character in the brackets
* Returned filenames do not include the .dil extension
* Use [[Manual:DIL_Manual/load|load]] function to load the returned filenames as DIL programs
* The function returns an empty stringlist if no files match the pattern

== Error Handling ==
The function handles errors in the following ways:
* Null or invalid pattern parameter returns empty stringlist
* File system access errors return empty stringlist
* Invalid wildcard patterns may cause unexpected behavior
* No runtime errors are generated for valid string patterns

Always check if the returned stringlist has elements before attempting to access them.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/load|load]] - Load a DIL program from filename
* [[Manual:DIL_Manual/dilcopy|dilcopy]] - Copy and execute a DIL program
* [[Manual:DIL_Manual/stringlist|stringlist]] - Data type for handling filename lists
* [[Manual:DIL_Manual/length|length]] - Get number of files in returned list
* [[Manual:DIL_Manual/split|split]] - Split filenames for processing

== See Also ==
* DIL File System Documentation
* Wildcard Pattern Matching Documentation
* File Loading and Management Functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/string</title>
     <ns>0</ns>
     <id>1147542</id>
     <revision>
       <id>1295973</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of string.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= string =
 type: &apos;&apos;&apos;string&apos;&apos;&apos;

The &apos;&apos;&apos;string&apos;&apos;&apos; type represents text data in DIL, used for command arguments, descriptions, and various text operations.

== Description ==
A string is a sequence of characters used for text manipulation in DIL. String variables are automatically resized and allocated when assigned, eliminating the need for manual memory management. Strings support comparison operators, concatenation, character access, and search operations.

Strings are saved with DIL programs when attached to saved units, making them persistent across game sessions.

== String Operations ==
=== Comparison Operators ===
Strings can be compared using the following operators:
* `==` (equal to)
* `!=` (not equal to)
* `&lt;=` (less than or equal to)
* `&gt;=` (greater than or equal to)
* `&lt;` (less than)
* `&gt;` (greater than)

=== Concatenation ===
Strings can be combined using the `+` operator:
 &quot;say &quot;+itoa(42)+&quot; is the answer!&quot;

=== Character Access ===
Individual characters can be accessed by their position (0-based indexing):
 if (str.[3]==&quot;f&quot;)
 {
   exec (&quot;say The 4th element is a F.&quot;,self);
 }

=== Search Operations ===
The `in` operator can be used to search for substrings within strings.

== String Declaration ==
Static strings are defined within double quotations:
 &quot;This is a static string&quot;

String variables are declared using the `var` keyword:
 var
   mystring : string;

 mystring := &quot;Hello World&quot;;

== Examples ==
=== Basic String Operations ===
 dilbegin string_operations();
 var
   text1 : string;
   text2 : string;
   result : string;
 code
 {
   text1 := &quot;Hello&quot;;
   text2 := &quot;World&quot;;
   result := text1 + &quot; &quot; + text2;
   
   if (result == &quot;Hello World&quot;)
     sendtext(&quot;Strings match perfectly!&lt;br/&gt;&quot;, self);
   else
     sendtext(&quot;Strings do not match.&lt;br/&gt;&quot;, self);
 }
 dilend

=== Character Access and Checking ===
 dilbegin check_characters();
 var
   test_string : string;
   i : integer;
 code
 {
   test_string := &quot;DikuMUD&quot;;
   
   i := 0;
   while (i &lt; length(test_string))
   {
     if (test_string.[i] == &quot;M&quot;)
       sendtext(&quot;Found &apos;M&apos; at position &quot; + itoa(i) + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== String Comparison ===
 dilbegin string_comparison();
 var
   name1 : string;
   name2 : string;
 code
 {
   name1 := self.name;
   name2 := self.names.[1];
   
   if (name1 == name2)
     sendtext(&quot;Primary name matches first alias.&lt;br/&gt;&quot;, self);
   else
     sendtext(&quot;Primary name differs from first alias.&lt;br/&gt;&quot;, self);
 }
 dilend

=== Dynamic String Building ===
 dilbegin build_message();
 var
   message : string;
   player_name : string;
   health : integer;
 code
 {
   player_name := self.name;
   health := self.hp;
   
   message := player_name + &quot; has &quot; + itoa(health) + &quot; health points.&quot;;
   sendtext(message + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

=== Character Replacement Workaround ===
 dilbegin replace_characters();
 var
   original : string;
   modified : string;
   i : integer;
   ln : integer;
 code
 {
   original := &quot;DikuMUD Framework&quot;;
   modified := &quot;&quot;;
   
   i := 0;
   ln := length(original);
   while (i &lt; ln)
   {
     if (original.[i] == &quot;u&quot;)
       modified := modified + &quot;o&quot;;
     else
       modified := modified + original.[i];
     i := i + 1;
   }
   
   sendtext(&quot;Original: &quot; + original + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Modified: &quot; + modified + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

=== String Search ===
 dilbegin search_strings();
 var
   text : string;
   search_term : string;
 code
 {
   text := &quot;The quick brown fox jumps over the lazy dog&quot;;
   search_term := &quot;fox&quot;;
   
   if (search_term in text)
     sendtext(&quot;Found &apos;&quot; + search_term + &quot;&apos; in the text.&lt;br/&gt;&quot;, self);
   else
     sendtext(&quot;Could not find &apos;&quot; + search_term + &quot;&apos; in the text.&lt;br/&gt;&quot;, self);
 }
 dilend

== Usage Notes ==
* String variables are automatically managed - no manual allocation needed
* Character indexing is 0-based (first character is at position 0)
* String comparison is case-sensitive
* Direct character assignment is not supported - use the workaround method shown in examples
* Strings are persistent when attached to saved units
* The `in` operator provides convenient substring searching
* String concatenation uses the `+` operator

== Error Handling ==
* Accessing characters beyond string length returns null
* Invalid string operations may cause runtime errors
* Always check string length before accessing specific character positions
* String comparisons require exact matches unless using search functions

== Related Functions/Fields ==
* [[Manual:DIL_Manual/stringlist|stringlist]] - List of strings data type
* [[Manual:DIL_Manual/length|length]] - Get string length
* [[Manual:DIL_Manual/atoi|atoi]] - Convert string to integer
* [[Manual:DIL_Manual/itoa|itoa]] - Convert integer to string
* [[Manual:DIL_Manual/split|split]] - Split string into stringlist
* [[Manual:DIL_Manual/getwords|getwords]] - Split string into word list
* [[Manual:DIL_Manual/addstring|addstring]] - Add string to stringlist
* [[Manual:DIL_Manual/substring|substring]] - Remove string from stringlist

* [[Manual:DIL_Manual/left|left]] - Get leftmost characters
* [[Manual:DIL_Manual/right|right]] - Get rightmost characters
* [[Manual:DIL_Manual/toupper|toupper]] - Convert to uppercase

== See Also ==
* DIL String Operations Documentation
* String manipulation and parsing functions
* Text processing and formatting functions

* Input validation and string handling</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/stringlist</title>
     <ns>0</ns>
     <id>600388</id>
     <revision>
       <id>1259540</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of stringlist.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= stringlist =

 type: &apos;&apos;&apos;stringlist&apos;&apos;&apos;

List data type that stores multiple strings in a comma-separated format.

== Description ==
The &apos;&apos;&apos;stringlist&apos;&apos;&apos; type is a specialized data structure that stores multiple strings in a comma-separated format. This type is commonly used for storing lists of names, keywords, or other string collections that need to be processed as a group.

Stringlists are defined using curly braces with elements separated by commas, similar to array initialization syntax. They can be accessed by numeric index (0-based) and support various string manipulation operations for adding, removing, and searching elements.

== Examples ==
=== Basic Stringlist Definition ===
 dilbegin basic_stringlist();
 var
    names : stringlist;
 code
 {
    // Define a stringlist with common names
    names := {&quot;Alice&quot;,&quot;Bob&quot;,&quot;Charlie&quot;,&quot;Diana&quot;};
    
    // Access elements by index
    exec(&quot;say First name: &quot; + names.[0], self);
    exec(&quot;say Second name: &quot; + names.[1], self);
    exec(&quot;say Third name: &quot; + names.[2], self);
    
    // Check if a name exists in the list
    if (&quot;Eve&quot; in names)
    {
       exec(&quot;say Eve is in the list!&quot;, self);
    }
    
    goto start;
 } dilend

=== Dynamic Stringlist Operations ===
 dilbegin dynamic_strings();
 var
    commands : stringlist;
    i : integer;
 code
 {
    // Start with an empty stringlist
    commands := {};
    
    :start:
    wait(SFB_CMD, TRUE);
    
    // Add command to the list
    if (argument != &quot;&quot;)
    {
       addstring(commands, argument);
    }
    
    // Display all commands in the list
    for (i := 0; i &lt; length(commands); i := i + 1)
    {
       exec(&quot;say Command #&quot; + itoa(i) + &quot;: &quot; + commands.[i], self);
    }
    
    goto start;
 } dilend

=== Stringlist Searching ===
 dilbegin string_searcher();
 var
    spell_names : stringlist;
    target_spell : string;
 code
 {
    // Define available spells
    spell_names := {&quot;fireball&quot;,&quot;lightning&quot;,&quot;heal&quot;,&quot;teleport&quot;};
    
    :start:
    wait(SFB_CMD, command(&quot;checkspell&quot;));
    target_spell := argument;
    
    // Check if spell exists in the list
    if (target_spell in spell_names)
    {
       exec(&quot;say Spell &apos;&quot; + target_spell + &quot;&apos; is available!&quot;, self);
    }
    else
    {
       exec(&quot;say Spell &apos;&quot; + target_spell + &quot;&apos; is not available.&quot;, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* Stringlists are defined using curly braces with comma-separated elements
* Elements are accessed by 0-based numeric index using square bracket notation
* The &apos;&apos;&apos;length()&apos;&apos;&apos; function returns the number of elements in a stringlist
* Stringlists support &apos;&apos;&apos;addstring()&apos;&apos;&apos; and &apos;&apos;&apos;substring()&apos;&apos;&apos; operations for modification
* The &apos;&apos;&apos;in&apos;&apos;&apos; operator checks if a string exists within the stringlist
* Stringlists can be modified directly, affecting the original data structure
* Stringlists are commonly used for storing names, keywords, or collections of related strings
* When accessing elements by index, ensure the index is within bounds (0 to length-1)
* Stringlists are saved with DIL programs and restored when the program loads

== Error Handling ==
* Always validate that the index is within bounds before accessing stringlist elements
* Be careful with infinite loops when iterating through stringlist elements
* Remember that stringlist operations modify the original data structure
* Check if stringlist is null before performing operations on it
* Use appropriate bounds checking to prevent runtime errors
* Test stringlist operations thoroughly as they can affect game data
* Ensure proper initialization of stringlists before use

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addstring|addstring]] - Add strings to a stringlist
* [[Manual:DIL_Manual/substring|substring]] - Extract substrings from stringlist elements
* [[Manual:DIL_Manual/in|in]] - Check if string exists in stringlist
* [[Manual:DIL_Manual/length|length]] - Get number of elements in stringlist
* [[Manual:DIL_Manual/split|split]] - Split strings into stringlist
* [[Manual:DIL_Manual/stringlist|stringlist]] - String list data type
* [[Manual:DIL_Manual/string|string]] - String data type for individual elements

== See Also ==
* [[Manual:DIL_Manual/string|string]] - String data type documentation
* [[Manual:DIL_Manual/integer|integer]] - Integer data type documentation
* [[Manual:DIL_Manual/stringlist|stringlist]] - String list data type documentation
* [[Manual:DIL_Manual/substring|substring]] - Substring extraction documentation
* [[Manual:DIL_Manual/addstring|addstring]] - String modification documentation
* [[Manual:DIL_Manual/in|in]] - String existence checking documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/strncmp</title>
     <ns>0</ns>
     <id>628552</id>
     <revision>
       <id>1003591</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of strncmp.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= strncmp =
function: integer &apos;&apos;&apos;strncmp&apos;&apos;&apos;(s1 : string, s2 : string, l : integer);

The &apos;&apos;&apos;strncmp&apos;&apos;&apos; function performs case-sensitive string comparison with a specified length limit.

== Description ==
This function compares up to a specified number of characters from two strings and returns an integer indicating their relationship. The comparison is case-sensitive and only compares the first &apos;l&apos; characters of each string.

The function follows standard C library strncmp behavior:
* Returns -1 if first string (s1) is lexicographically less than second string (s2) in first &apos;l&apos; characters
* Returns 0 if both strings are identical in first &apos;l&apos; characters
* Returns 1 if first string (s1) is lexicographically greater than second string (s2) in first &apos;l&apos; characters

This function is useful when you need to compare only the beginning portions of strings, such as command prefixes, file extensions, or when you want to limit comparison to avoid unnecessary processing.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s1 || string || The first string to compare
|-
| s2 || string || The second string to compare
|-
| l || integer || The maximum number of characters to compare
|}

== Return Value ==
The function returns an integer:
* -1 if s1 &lt; s2 (s1 comes before s2 alphabetically in first &apos;l&apos; characters)
* 0 if s1 == s2 (strings are identical in first &apos;l&apos; characters)
* 1 if s1 &gt; s2 (s1 comes after s2 alphabetically in first &apos;l&apos; characters)

== Examples ==
=== Command Prefix Comparison ===
 dilbegin check_command_prefix(cmd : string);
 var
   result : integer;
 code
 {
   // Check if command starts with &quot;get&quot;
   result := strncmp(cmd, &quot;get&quot;, 3);
   
   if (result == 0)
     sendtext(&quot;Command starts with &apos;get&apos;&lt;br/&gt;&quot;, self);
   else
     sendtext(&quot;Command does not start with &apos;get&apos;&lt;br/&gt;&quot;, self);
 }
 dilend

=== File Extension Check ===
 dilbegin check_file_extension(filename : string);
 var
   result : integer;
 code
 {
   // Check if file has .dil extension (only first 4 chars)
   result := strncmp(filename, &quot;.dil&quot;, 4);
   
   if (result == 0)
     sendtext(&quot;File has .dil extension&lt;br/&gt;&quot;, self);
   else
     sendtext(&quot;File does not have .dil extension&lt;br/&gt;&quot;, self);
 }
 dilend

=== Limited String Comparison ===
 dilbegin limited_comparison();
 var
   result : integer;
 code
 {
   // Compare only first 2 characters of each string
   result := strncmp(&quot;hello&quot;, &quot;help&quot;, 2);
   
   if (result == 0)
     sendtext(&quot;First 2 characters match: &apos;he&apos;&lt;br/&gt;&quot;, self);
   else
     sendtext(&quot;First 2 characters differ&lt;br/&gt;&quot;, self);
   
   // Compare with longer limit
   result := strncmp(&quot;testing&quot;, &quot;test&quot;, 3);
   
   if (result == 0)
     sendtext(&quot;First 3 characters match: &apos;tes&apos;&lt;br/&gt;&quot;, self);
   else
     sendtext(&quot;First 3 characters differ&lt;br/&gt;&quot;, self);
 }
 dilend

== Usage Notes ==
* The function performs case-sensitive comparison
* Only the first &apos;l&apos; characters are compared, regardless of total string length
* Use standard equality operators (==, !=) for full string comparison when needed
* The function is more efficient than [[Manual:DIL_Manual/strcmp|strcmp]] when you only need to compare prefixes
* Lexicographic comparison follows ASCII character values
* Length parameter of 0 is valid and will always return 0 (equal)
* The function is commonly used for command validation and prefix checking

== Error Handling ==
The function handles errors in the following ways:
* Null or invalid string parameters may cause runtime errors
* Negative length values may cause undefined behavior
* No specific error return values - always returns -1, 0, or 1
* Function does not generate runtime errors for valid string inputs

Always ensure both parameters are valid strings and length is non-negative before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/strcmp|strcmp]] - Compare complete strings
* [[Manual:DIL_Manual/string|string]] data type and operations
* [[Manual:DIL_Manual/getwords|getwords]] - Split string into words for comparison
* [[Manual:DIL_Manual/length|length]] - Get string length for validation
* [[Manual:DIL_Manual/left|left]] - Extract string prefix for comparison
* String comparison operators (==, !=, &lt;, &gt;, &lt;=, &gt;=)

== See Also ==
* DIL String Operations Documentation
* String comparison and sorting algorithms
* Lexicographic ordering principles
* ASCII character encoding reference
* C library function documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/subaff</title>
     <ns>0</ns>
     <id>579197</id>
     <revision>
       <id>1626247</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of subaff.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= subaff =
function: &apos;&apos;&apos;subaff&apos;&apos;&apos;(u : unitptr, i : integer);

The &apos;&apos;&apos;subaff&apos;&apos;&apos; function removes the first affect with a specified ID from a unit.

== Description ==
This function searches through a unit&apos;s affects and removes the first affect that matches the specified ID. The function operates on the affect list in order, removing only the first occurrence found with the matching ID.

The function is commonly used to remove specific spell effects, status conditions, or temporary modifications from characters. It&apos;s particularly useful in spell removal systems, cure effects, and affect management routines.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit to remove the affect from
|-
| i || integer || The affect ID to remove (see ID_* constants in values.h/vme.h)
|}

== Return Value ==
The function does not return a value.

== Examples ==
=== Remove Blindness Effect ===
 dilbegin cure_blindness(pc : unitptr);
 var
   i : integer;
 code
 {
   if (pc.type != UNIT_ST_PC and pc.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Remove blindness affect
   subaff(pc, ID_BLIND_CHAR);
   
   sendtext(&quot;Blindness effect removed.&lt;br/&gt;&quot;, pc);
 }
 dilend

=== Remove Multiple Effects ===
 dilbegin remove_spell_effects(pc : unitptr);
 var
   i : integer;
 code
 {
   if (pc.type != UNIT_ST_PC and pc.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Remove various spell effects
   subaff(pc, ID_SPL_POISON);
   subaff(pc, ID_SPL_CURSE);
   subaff(pc, ID_SPL_SLEEP);
   
   sendtext(&quot;Multiple spell effects removed.&lt;br/&gt;&quot;, pc);
 }
 dilend

=== Conditional Affect Removal ===
 dilbegin conditional_removal(pc : unitptr);
 var
   i : integer;
 code
 {
   if (pc.type != UNIT_ST_PC and pc.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Remove affects based on conditions
   i := 0;
   while (i &lt; 100)
   {
     if (isaff(pc, ID_SPL_POISON + i))
     {
       subaff(pc, ID_SPL_POISON + i);
       sendtext(&quot;Removed poison effect &quot; + itoa(i) + &quot;&lt;br/&gt;&quot;, self);
     }
     
     i := i + 1;
   }
 }
 dilend

== Usage Notes ==
* The function removes only the first matching affect found
* Use [[Manual:DIL_Manual/isaff|isaff]]() to check if a specific affect is present
* Use [[Manual:DIL_Manual/getaffects|getaffects]]() to get a list of all current affects
* Affect IDs are defined as ID_* constants in values.h/vme.h
* The function operates on the affect list in order (first match first)
* Common affect IDs include: ID_BLIND_CHAR, ID_SPL_POISON, ID_SPL_CURSE, etc.
* The function is commonly used in cure spells, effect removal, and status management

== Error Handling ==
The function handles errors in the following ways:
* Invalid unit type (not PC/NPC) causes no action
* Invalid affect ID causes no action
* Null unit pointer causes no action
* No runtime errors are generated for valid parameters

Always validate that the target is a character and the affect ID is valid before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/isaff|isaff]] - Check if a unit has a specific affect
* [[Manual:DIL_Manual/addaff|addaff]] - Add an affect to a unit
* [[Manual:DIL_Manual/getaffects|getaffects]] - Get a list of all affects on a unit
* [[Manual:DIL_Manual/subextra|subextra]] - Remove extra descriptions from units
* unitptr.affected field - Access to affect system

== See Also ==
* DIL Affect System Documentation
* ID_* constants for affect identification
* Spell and effect management systems
* Character status and condition systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/subextra</title>
     <ns>0</ns>
     <id>862620</id>
     <revision>
       <id>1442658</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of subextra.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= subextra =
function: &apos;&apos;&apos;subextra&apos;&apos;&apos;(e : extraptr, s : string);

The &apos;&apos;&apos;subextra&apos;&apos;&apos; function removes the first extra description element with a matching name from a unit&apos;s extra description list.

== Description ==
This function searches through a unit&apos;s extra description list and removes the first element whose name matches the specified string. The function operates on the extra description list in order, removing only the first occurrence found with the matching name.

The function is commonly used to remove specific extra descriptions from units, such as quest markers, temporary flags, or custom attributes. It&apos;s particularly useful for managing dynamic extra descriptions that are added during gameplay.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| e || extraptr || The extra description list to remove the element from
|-
| s || string || The name of the extra description element to remove
|}

== Return Value ==
The function does not return a value.

== Examples ==
=== Remove Quest Marker ===
 dilbegin remove_quest_marker(pc : unitptr);
 var
   quest_extra : extraptr;
 code
 {
   if (pc.type != UNIT_ST_PC)
   {
     sendtext(&quot;Target must be a player character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Remove quest completion marker
   subextra(pc.extra, &quot;completed_quest&quot;);
   
   sendtext(&quot;Quest marker removed.&lt;br/&gt;&quot;, pc);
 }
 dilend

=== Remove Temporary Flag ===
 dilbegin clear_temp_flag(target : unitptr);
 var
   temp_extra : extraptr;
 code
 {
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Remove temporary effect flag
   subextra(target.extra, &quot;temporary_effect&quot;);
   
   sendtext(&quot;Temporary flag cleared.&lt;br/&gt;&quot;, target);
 }
 dilend

=== Dynamic Extra Management ===
 dilbegin manage_dynamic_extras(item : unitptr, action : string);
 var
   extra_list : stringlist;
   i : integer;
 code
 {
   if (item.type != UNIT_ST_OBJ)
   {
     sendtext(&quot;This command only works on objects.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Get all extra names
   extra_list := item.extra.names;
   
   if (action == &quot;clear&quot;)
   {
     // Remove all dynamic extras
     i := 0;
     while (i &lt; length(extra_list))
     {
       subextra(item.extra, extra_list.[i]);
       i := i + 1;
     }
     
     sendtext(&quot;All dynamic extras cleared.&lt;br/&gt;&quot;, self);
   }
   else if (action == &quot;remove&quot;)
   {
     // Remove specific extra
     subextra(item.extra, action);
     
     sendtext(&quot;Removed extra: &quot; + action + &quot;&lt;br/&gt;&quot;, self);
   }
   else
   {
     sendtext(&quot;Usage: manage_dynamic_extras &lt;clear|remove&gt;&lt;br/&gt;&quot;, self);
   }
 }
 dilend

== Usage Notes ==
* The function removes only the first matching extra found
* Extra descriptions are accessed via the unitptr.extra field
* The function operates on the extra description list in order
* Use [[Manual:DIL_Manual/addextra|addextra]] to add new extra descriptions
* Common extra names include quest markers, status flags, and temporary effects
* The function is commonly used for cleanup operations and state management

== Error Handling ==
The function handles errors in the following ways:
* Null or invalid extraptr parameter causes no action
* Null or empty string parameter causes no action
* Invalid unit type causes no action
* No runtime errors are generated for valid parameters
* If no matching extra is found, no action is taken

Always validate that the target is a valid character and that the extra exists before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addextra|addextra]] - Add an extra description to a unit
* [[Manual:DIL_Manual/subextra|subextra]] - Remove an extra description (this function)
* unitptr.extra - Field for accessing extra description list
* extraptr.names - Field for getting list of extra names
* [[Manual:DIL_Manual/in|in]] operator - Check if an extra exists in the list

== See Also ==
* DIL Extra Description System Documentation
* Quest and Achievement Systems
* Character Status and Effect Management
* Dynamic Attribute Management</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/substring</title>
     <ns>0</ns>
     <id>355209</id>
     <revision>
       <id>1565361</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of substring.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= substring =
function: &apos;&apos;&apos;substring&apos;&apos;&apos;(l : stringlist, s : string);

The &apos;&apos;&apos;substring&apos;&apos;&apos; function removes the first occurrence of a specified string from a stringlist.

== Description ==
This function searches through a stringlist and removes the first element that matches the specified string. The function operates on the stringlist in order, removing only the first occurrence found with the matching string.

The function is commonly used to remove specific words, commands, or values from lists of strings, particularly when processing user input or managing dynamic string collections.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| l || stringlist || The stringlist to remove the string from
|-
| s || string || The string to remove from the stringlist
|}

== Return Value ==
The function does not return a value.

== Examples ==
=== Remove Specific Word ===
 dilbegin remove_command(commands : stringlist, word : string);
 var
   i : integer;
 code
 {
   // Remove &quot;quit&quot; command from available commands
   substring(commands, &quot;quit&quot;);
   
   sendtext(&quot;Available commands after removal:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(commands))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + commands.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Remove User Input Words ===
 dilbegin filter_input(user_input : string);
 var
   words : stringlist;
   filtered_words : stringlist;
   i : integer;
 code
 {
   // Split input into words
   words := getwords(user_input);
   
   // Remove unwanted words
   filtered_words := words;
   substring(filtered_words, &quot;the&quot;);
   substring(filtered_words, &quot;a&quot;);
   substring(filtered_words, &quot;an&quot;);
   
   sendtext(&quot;Filtered words:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(filtered_words))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + filtered_words.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Remove Multiple Occurrences ===
 dilbegin remove_all_occurrences(items : stringlist, target : string);
 var
   i : integer;
 code
 {
   // Remove all occurrences of target string
   while (substring(items, target) == 0)
   {
     // Keep removing until substring returns non-zero (not found)
     i := i + 1;
   }
   
   sendtext(&quot;Removed all occurrences of &apos;&quot; + target + &quot;&apos;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Final list length: &quot; + itoa(length(items)) + &quot;&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(items))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + items.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Remove User Input Words ===
 dilbegin filter_input(user_input : string);
 var
   words : stringlist;
   filtered_words : stringlist;
   i : integer;
 code
 {
   // Split input into words
   words := getwords(user_input);
   
   // Remove unwanted words
   filtered_words := words;
   substring(filtered_words, &quot;the&quot;);
   substring(filtered_words, &quot;a&quot;);
   substring(filtered_words, &quot;an&quot;);
   
   sendtext(&quot;Filtered words:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(filtered_words))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + filtered_words.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Remove Multiple Occurrences ===
 dilbegin remove_all_occurrences(items : stringlist, target : string);
 var
   i : integer;
 code
 {
   // Remove all occurrences of target string
   while (substring(items, target) == 0)
   {
     // Keep removing until substring returns non-zero (not found)
   i := i + 1;
   }
   
   sendtext(&quot;Removed all occurrences of &apos;&quot; + target + &quot;&apos;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Final list length: &quot; + itoa(length(items)) + &quot;&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(items))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + items.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Command Processing ===
 dilbegin process_command_line(command_line : string);
 var
   parts : stringlist;
   command : string;
   arguments : stringlist;
   i : integer;
 code
 {
   // Remove command keyword from line
   parts := split(command_line, &quot; &quot;);
   
   if (length(parts) &gt; 0)
   {
     command := parts.[0];
     
     // Remove all command words from arguments
     arguments := parts;
     substring(arguments, command);
     
     // Rebuild arguments list
     arguments := parts;
     i := 1;
     while (i &lt; length(parts))
     {
       if (i &gt; 0)
         addstring(arguments, &quot; &quot;);
       addstring(arguments, parts.[i]);
     }
     
     sendtext(&quot;Command: &quot; + command + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Arguments: &quot;, self);
     
     i := 0;
     while (i &lt; length(arguments))
     {
       sendtext(arguments.[i] + &quot;&lt;br/&gt;&quot;, self);
       i := i + 1;
     }
   }
 }
 dilend

=== Text Cleanup ===
 dilbegin cleanup_text(text : string);
 var
   words : stringlist;
   cleaned_text : stringlist;
   i : integer;
 code
 {
   // Split text into words
   words := getwords(text);
   
   // Remove common filler words
   cleaned_text := words;
   substring(cleaned_text, &quot;the&quot;);
   substring(cleaned_text, &quot;a&quot;);
   substring(cleaned_text, &quot;an&quot;);
   substring(cleaned_text, &quot;and&quot;);
   
   sendtext(&quot;Cleaned text:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(cleaned_text))
   {
     sendtext(cleaned_text.[i] + &quot; &quot;, self);
     i := i + 1;
   }
 }
 dilend

=== List Management ===
 dilbegin manage_string_list();
 var
   items : stringlist;
   i : integer;
 code
 {
   // Initialize list
   items := {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;, &quot;duplicate&quot;, &quot;test&quot;};
   
   sendtext(&quot;Original list:&lt;br/&gt;&quot;, self);
   i := 0;
   while (i &lt; length(items))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + items.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
   
   // Remove first &quot;apple&quot; occurrence
   substring(items, &quot;apple&quot;);
   
   sendtext(&quot;After removing first &apos;apple&apos;:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(items))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + items.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Pattern Matching ===
 dilbegin pattern_removal();
 var
   filenames : stringlist;
   i : integer;
 code
 {
   // Create list of filenames
   filenames := {&quot;document.txt&quot;, &quot;backup.txt&quot;, &quot;temp_file.tmp&quot;, &quot;config.xml&quot;, &quot;another_file.txt&quot;};
   
   sendtext(&quot;Original filenames:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(filenames))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + filenames.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
   
   // Remove all .tmp files
   while (substring(filenames, &quot;.tmp&quot;) == 0)
   {
     substring(filenames, &quot;.tmp&quot;);
     i := i + 1;
   }
   
   sendtext(&quot;After removing .tmp files:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(filenames))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + filenames.[i] + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

== Usage Notes ==
* The function removes only the first matching occurrence
* The function modifies the original stringlist directly
* Use [[Manual:DIL_Manual/getwords|getwords]] to split text into word lists for processing
* The function is commonly used for input filtering and command parsing
* Multiple calls may be needed to remove all occurrences of a target string
* The function is case-sensitive in its matching

== Error Handling ==
The function handles errors in the following ways:
* Null or invalid stringlist parameter causes no action
* Null or empty string parameter causes no action
* Invalid stringlist parameter causes no action
* No runtime errors are generated for valid parameters
* If no matching string is found, the original stringlist remains unchanged

Always ensure that both parameters are valid before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addstring|addstring]] - Add a string to a stringlist
* [[Manual:DIL_Manual/getwords|getwords]] - Split a string into words
* [[Manual:DIL_Manual/stringlist|stringlist]] data type and operations
* [[Manual:DIL_Manual/split|split]] - Split a string into a stringlist
* [[Manual:DIL_Manual/in|in]] operator - Check if a string exists in a stringlist

== See Also ==
* DIL String Operations Documentation
* String manipulation and parsing functions
* Input filtering and validation systems
* Text processing and cleanup functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/switch</title>
     <ns>0</ns>
     <id>950696</id>
     <revision>
       <id>1428413</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of switch.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= switch =
function: &apos;&apos;&apos;switch&apos;&apos;&apos;(vict : unitptr);

The &apos;&apos;&apos;switch&apos;&apos;&apos; function changes the character that a player is currently controlling.

== Description ==
This function switches the controlling character from the current player to the specified target character. The player takes control of the target character, effectively switching their perspective in the game world.

The function is commonly used for possession systems, polymorph effects, or character control mechanics. When a player switches to another character, they lose control of their current character and gain control of the target.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| vict || unitptr || The target character to switch control to
|}

== Return Value ==
The function does not return a value.

== Examples ==
=== Basic Character Switch ===
 dilbegin switch_character(target : unitptr);
 var
   old_char : unitptr;
 code
 {
   if (self.type != UNIT_ST_PC)
   {
     sendtext(&quot;Only players can use this command.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   old_char := self;
   
   // Perform the switch
   switch(old_char, target);
   
   sendtext(&quot;You have switched to &quot; + target.name + &quot;.&lt;br/&gt;&quot;, self);
 }
 dilend

=== Polymorph Switch ===
 dilbegin polymorph_control();
 var
   target : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Switch to the target character
   switch(self, target);
   
   sendtext(&quot;You have polymorphed into &quot; + target.name + &quot;.&lt;br/&gt;&quot;, self);
   
   // Now control the target character
   // The player now controls the target character
 }
 dilend

=== Possession System ===
 dilbegin possession_switch();
 var
   target : unitptr;
   old_char : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   old_char := self;
   
   // Switch to target character
   switch(old_char, target);
   
   sendtext(&quot;You now control &quot; + target.name + &quot;.&lt;br/&gt;&quot;, self);
   
   // Store old character reference for later restoration
   old_char.extra := {&quot;old_character&quot;, old_char.name};
 }
 dilend

== Usage Notes ==
* The function can only be called by players (UNIT_ST_PC)
* The target must be a valid character (UNIT_ST_PC or UNIT_ST_NPC)
* The current player loses control of their current character
* The function does not return a value
* The switch is immediate and affects the game world state
* Common use cases include possession systems, polymorph spells, and character control mechanics

== Error Handling ==
The function handles errors in the following ways:
* Invalid caller (not a player) causes no action
* Invalid target (not a character) causes no action
* Null target causes no action
* No runtime errors are generated for valid parameters

Always validate that both the caller is a player and the target is a valid character before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/switched|switched]] - Field to check if a character is currently switched
* unitptr.type - Field to check unit type
* unitptr.name - Field to get character name
* [[Manual:DIL_Manual/log|log]] - Function for logging switch operations
* [[Manual:DIL_Manual/addextra|addextra]] - Function for storing character references

== See Also ==
* DIL Character Control Systems Documentation
* Possession and Switching Mechanics
* Character State Management
* Player vs NPC Control Systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/switched</title>
     <ns>0</ns>
     <id>1106541</id>
     <revision>
       <id>1542219</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of switched.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= switched =
field: unitptr &apos;&apos;&apos;.switched&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;switched&apos;&apos;&apos; field indicates which character a player is currently controlling.

== Description ==
This field provides access to the character that the current player has switched into using the [[Manual:DIL_Manual/switch|switch]] function. When a player switches to another character, this field points to the character they are now controlling.

The field is read-only and automatically updated by the game engine when character switching occurs. It&apos;s commonly used in possession systems, polymorph effects, and character control mechanics to track which character is currently being controlled.

== Field Access ==
{| class=&quot;wikitable&quot;
! Field !! Type !! Access !! Description
|-
| switched || unitptr || Read-only || Points to the character currently being controlled
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Check Current Control ===
 dilbegin check_control_status();
 var
   controlled_char : unitptr;
 code
 {
   controlled_char := self.switched;
   
   if (controlled_char)
   {
     sendtext(&quot;You are currently controlling: &quot; + controlled_char.name + &quot;&lt;br/&gt;&quot;, self);
   }
   else
   {
     sendtext(&quot;You are not controlling any character.&lt;br/&gt;&quot;, self);
   sendtext(&quot;You are in your original body.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Control History ===
 dilbegin show_control_history();
 var
   i : integer;
 code
 {
   sendtext(&quot;Control history:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; 10)
   {
     if (self.switched)
     {
       sendtext(itoa(i + 1) + &quot;: You controlled &quot; + self.switched.name + &quot;&lt;br/&gt;&quot;, self);
     }
     else
     {
       sendtext(itoa(i + 1) + &quot;: You were in your original body&lt;br/&gt;&quot;, self);
     }
     
     i := i + 1;
   }
 }
 dilend

=== Switch Notification ===
 dilbegin notify_switch(old_char : unitptr, new_char : unitptr);
 var
   msg : string;
 code
 {
   if (self.type != UNIT_ST_PC)
   {
     sendtext(&quot;Only players can receive switch notifications.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Check if player is switching to a valid character
   if (new_char.type != UNIT_ST_PC and new_char.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Invalid target character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Create notification message
   msg := &quot;You have switched from &quot; + old_char.name + &quot; to &quot; + new_char.name + &quot;.&quot;;
   
   // Send notification to old character
   act(&quot;$1n has switched control to you.&quot;, A_SOMEONE, old_char, null, new_char, TO_CHAR);
   
   // Send notification to new character
   act(&quot;$1n has switched control to you.&quot;, A_SOMEONE, new_char, null, old_char, TO_CHAR);
   
   // Send notification to room
   act(&quot;$1n switches bodies.&quot;, A_SOMEONE, old_char, null, new_char, TO_REST);
 }
 dilend

=== Possession System Integration ===
 dilbegin possession_system();
 var
   target : unitptr;
   old_controlled : unitptr;
 code
 {
   target := activator;
   
   if (target.type != UNIT_ST_PC and target.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   old_controlled := self.switched;
   
   // Switch to target
   switch(self, target);
   
   // Check if switch was successful
   if (self.switched == target)
   {
     sendtext(&quot;You are now controlling &quot; + target.name + &quot;.&lt;br/&gt;&quot;, self);
     
     // Store old character reference
     if (old_controlled)
     {
       addextra(self.extra, {&quot;previous_character&quot;}, old_controlled.name);
     }
     
     // Update possession system
     update_possession_data(target);
   }
   else
   {
     sendtext(&quot;Switch failed.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Polymorph Recovery ===
 dilbegin polymorph_recovery();
 var
   original_char : unitptr;
 code
 {
   // Check if player has a switched character stored
   original_char := (&quot;previous_character&quot; in self.extra) in self.extra;
   
   if (original_char)
   {
     // Switch back to original character
     switch(self, original_char);
     
     sendtext(&quot;You have returned to your original form.&lt;br/&gt;&quot;, self);
     
     // Clean up the stored reference
     subextra(self.extra, &quot;previous_character&quot;);
   }
   else
   {
     sendtext(&quot;No original character found to recover.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Character State Check ===
 dilbegin check_character_state();
 var
   controlled_char : unitptr;
   controller : unitptr;
 code
 {
   controlled_char := self.switched;
   
   if (controlled_char)
   {
     // Find who is controlling this character
     controller := controlled_char.outside;
     
     if (controller &amp;&amp; controller == self)
     {
       sendtext(&quot;You are controlling yourself.&lt;br/&gt;&quot;, self);
     }
     else if (controller)
     {
       sendtext(&quot;You are being controlled by &quot; + controller.name + &quot;.&lt;br/&gt;&quot;, self);
     }
     else
     {
       sendtext(&quot;No one is controlling you.&lt;br/&gt;&quot;, self);
     }
   }
   else
   {
     sendtext(&quot;You are not being controlled.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

== Usage Notes ==
* The field is read-only and automatically managed by the game engine
* The field points to the character currently being controlled
* When a player switches characters, the field updates automatically
* The field is null when the player is not controlling any character
* This field is only available for player characters (UNIT_ST_PC)
* Common use cases include possession systems, polymorph recovery, and control state checking

== Error Handling ==
The field handles errors in the following ways:
* Accessing the field on non-player units returns null
* The field is read-only - attempts to modify it will fail
* The field automatically updates when valid character switches occur
* No runtime errors are generated when accessing the field

Always check that the unit is a player character before accessing this field.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/switch|switch]] - Function to switch character control
* [[Manual:DIL_Manual/addextra|addextra]] - Function to store character references
* unitptr.outside - Field to find the character&apos;s environment
* unitptr.type - Field to check unit type
* [[Manual:DIL_Manual/isaff|isaff]] - Function to check character affects


== See Also ==
* DIL Character Control Systems Documentation
* Possession and Switching Mechanics
* Character State Management
* Player Control Systems
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/symname</title>
     <ns>0</ns>
     <id>684166</id>
     <revision>
       <id>1494000</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of symname.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= symname =
function: string &apos;&apos;&apos;symname&apos;&apos;&apos;(u : unitptr);

The &apos;&apos;&apos;symname&apos;&apos;&apos; function returns the symbolic name of a unit as used in the game world.

== Description ==
This function retrieves the symbolic name that uniquely identifies a unit in the game world. The symbolic name is used with functions like [[Manual:DIL_Manual/findsymbolic|findsymbolic]] to locate specific units across the entire game world, regardless of their current location.

The symbolic name is different from the regular unit name (unit.name) and provides a persistent identifier that can be used to reference the unit even after reboots or when the unit moves between different zones.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit to get the symbolic name of
|}

== Return Value ==
The function returns a string containing:
* The symbolic name of the specified unit
* Empty string if the unit is null or invalid
* Empty string if the unit has no symbolic name

== Examples ==
=== Basic Symbolic Name Retrieval ===
 dilbegin get_unit_symname();
 var
   target : unitptr;
   sym_name : string;
 code
 {
   target := activator;
   
   if (target == null)
   {
     sendtext(&quot;No target specified.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   sym_name := symname(target);
   
   if (sym_name == &quot;&quot;)
   {
     sendtext(&quot;Target has no symbolic name.&lt;br/&gt;&quot;, self);
   }
   else
   {
     sendtext(&quot;Symbolic name: &quot; + sym_name + &quot;&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== City Guard Tracking ===
 dilbegin track_city_guard();
 var
   guard : unitptr;
   sym_name : string;
 code
 {
   guard := findunit(&quot;guard@midgaard&quot;);
   
   if (guard)
   {
     sym_name := symname(guard);
     
     if (sym_name != &quot;&quot;)
     {
       sendtext(&quot;City guard symbolic name: &quot; + sym_name + &quot;&lt;br/&gt;&quot;, self);
       
       // Store the symbolic name for later reference
       addextra(self.extra, {&quot;guard_symname&quot;}, sym_name);
     }
     else
     {
       sendtext(&quot;City guard not found.&lt;br/&gt;&quot;, self);
     }
   }
 }
 dilend

=== Bounty Hunter System ===
 dilbegin bounty_hunter_system();
 var
   criminal : unitptr;
   sym_name : string;
 code
 {
   criminal := activator;
   
   if (criminal.type != UNIT_ST_PC)
   {
     sendtext(&quot;This command only works on players.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Get criminal&apos;s symbolic name
   sym_name := symname(criminal);
   
   if (sym_name == &quot;&quot;)
   {
     sendtext(&quot;Target has no symbolic name.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Check if criminal is wanted
   if (sym_name != &quot;bounty_target&quot;)
   {
     sendtext(&quot;You are not wanted for bounty hunting.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Find bounty hunter
   hunter := findsymbolic(&quot;bounty_hunter&quot;);
   
   if (hunter)
   {
     sendtext(&quot;Bounty hunter found: &quot; + symname(hunter) + &quot;&lt;br/&gt;&quot;, self);
     
     // Notify bounty hunter
     act(&quot;$1n has been notified that $2n is wanted for bounty hunting.&quot;, A_SOMEONE, criminal, null, hunter, TO_CHAR);
   }
   else
   {
     sendtext(&quot;No bounty hunter available.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Unique Item Identification ===
 dilbegin identify_unique_item();
 var
   item : unitptr;
   sym_name : string;
   unique_id : string;
 code
 {
   item := activator;
   
   if (item.type != UNIT_ST_OBJ)
   {
     sendtext(&quot;This command only works on objects.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   sym_name := symname(item);
   unique_id := item.nameidx + &quot;_&quot; + item.zoneidx;
   
   sendtext(&quot;Item symbolic name: &quot; + sym_name + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Unique ID: &quot; + unique_id + &quot;&lt;br/&gt;&quot;, self);
   
   // Store symbolic name for tracking
   addextra(item.extra, {&quot;item_symname&quot;}, sym_name);
 }
 dilend

=== Zone-based Search ===
 dilbegin search_by_symbolic_name();
 var
   units : stringlist;
   target_sym : string;
   i : integer;
 code
 {
   target_sym := argument;
   
   // Find all units with matching symbolic name
   units := findsymbolic(target_sym);
   
   sendtext(&quot;Found &quot; + itoa(length(units)) + &quot; units with symbolic name &apos;&quot; + target_sym + &quot;&apos;:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(units))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + symname(units.[i]) + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Persistent Reference Storage ===
 dilbegin store_persistent_reference();
 var
   target : unitptr;
   sym_name : string;
   reference : string;
 code
 {
   target := activator;
   
   if (target == null)
   {
     sendtext(&quot;No target specified.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   sym_name := symname(target);
   
   if (sym_name != &quot;&quot;)
   {
     // Create persistent reference using name and zone
     reference := sym_name + &quot;@&quot; + target.zoneidx;
     
     sendtext(&quot;Stored reference: &quot; + reference + &quot;&lt;br/&gt;&quot;, self);
     
     // Store in extra description for later retrieval
     addextra(self.extra, {&quot;persistent_ref&quot;}, reference);
   }
   else
   {
     sendtext(&quot;Target has no symbolic name.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Character Identification System ===
 dilbegin character_identification();
 var
   char : unitptr;
   sym_name : string;
   char_type : string;
 code
 {
   char := activator;
   
   if (char.type != UNIT_ST_PC and char.type != UNIT_ST_NPC)
   {
     sendtext(&quot;Target must be a character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   sym_name := symname(char);
   
   if (sym_name == &quot;&quot;)
   {
     sendtext(&quot;Character has no symbolic name.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Determine character type based on symbolic name
   if (sym_name == &quot;player_character&quot;)
     char_type := &quot;Player&quot;;
   else if (sym_name == &quot;city_guard&quot;)
     char_type := &quot;City Guard&quot;;
   else if (sym_name == &quot;shopkeeper&quot;)
     char_type := &quot;Shopkeeper&quot;;
   else
     char_type := &quot;Unknown&quot;;
   
   sendtext(&quot;Character type: &quot; + char_type + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Symbolic name: &quot; + sym_name + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

== Usage Notes ==
* The symbolic name is different from the regular unit name
* Symbolic names are persistent across reboots and zone changes
* The function is commonly used with [[Manual:DIL_Manual/findsymbolic|findsymbolic]] for global unit searches
* Symbolic names are typically in the format &quot;name@zone&quot; or descriptive names
* The function returns empty string for null units or units without symbolic names
* Use [[Manual:DIL_Manual/addextra|addextra]] to store symbolic names for later reference

== Error Handling ==
The function handles errors in the following ways:
* Null or invalid unitptr parameter returns empty string
* No runtime errors are generated for valid unit parameters
* The function may return empty string if the unit has no symbolic name assigned

Always validate that the target is a valid unit before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findsymbolic|findsymbolic]] - Find units by symbolic name globally
* [[Manual:DIL_Manual/addextra|addextra]] - Store symbolic names in extra descriptions
* unitptr.symname - Field to access symbolic name

* unitptr.nameidx - Field for unit name index
* unitptr.zoneidx - Field for unit zone index

== See Also ==
* DIL Symbolic Name System Documentation
* Global Unit Search and Tracking
* Character Identification Systems
* Persistent Reference Systems
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/target</title>
     <ns>0</ns>
     <id>1095964</id>
     <revision>
       <id>1238795</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of target.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= target =
function: unitptr &apos;&apos;&apos;target&apos;&apos;&apos;(s : string);

The &apos;&apos;&apos;target&apos;&apos;&apos; function returns a unit pointer to a unit with a specified symbolic name.

== Description ==
This function searches the entire game world for a unit with the specified symbolic name. The function uses the symbolic name system to locate units globally, regardless of their current location or zone.

The symbolic name system allows units to be uniquely identified across the entire game world using names in the format &quot;name@zone&quot; or descriptive names. This is particularly useful for finding specific NPCs, objects, or players that need to be referenced globally.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The symbolic name of the unit to find
|}

== Return Value ==
The function returns a unitptr:
* Pointer to the unit with the matching symbolic name
* Null if no matching unit is found
* Null if the symbolic name parameter is empty

== Examples ==
=== Find Specific Player ===
 dilbegin find_player_by_name(player_name : string);
 var
   target : unitptr;
 code
 {
   target := target(player_name + &quot;@global&quot;);
   
   if (target)
   {
     sendtext(&quot;Found player: &quot; + target.name + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Location: &quot; + target.outside.title + &quot;&lt;br/&gt;&quot;, self);
   }
   else
   {
     sendtext(&quot;Player &apos;&quot; + player_name + &quot;&apos; not found.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Find City Guard ===
 dilbegin find_guard();
 var
   guard : unitptr;
 code
 {
   guard := findsymbolic(&quot;guard@midgaard&quot;);
   
   if (guard)
   {
     sendtext(&quot;Found city guard: &quot; + guard.name + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Location: &quot; + guard.outside.title + &quot;&lt;br/&gt;&quot;, self);
   }
   else
   {
     sendtext(&quot;City guard not found.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Bounty Hunter System ===
 dilbegin bounty_check();
 var
   criminal : unitptr;
   hunter : unitptr;
 code
 {
   criminal := activator;
   hunter := findsymbolic(&quot;bounty_hunter&quot;);
   
   if (criminal &amp;&amp; hunter)
   {
     sendtext(&quot;Criminal: &quot; + criminal.name + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Hunter: &quot; + hunter.name + &quot;&lt;br/&gt;&quot;, self);
     
     // Notify hunter of criminal
     act(&quot;$1n has been notified that $2n is wanted for bounty hunting.&quot;, A_SOMEONE, criminal, null, hunter, TO_CHAR);
   }
   else
   {
     sendtext(&quot;Either criminal or hunter not available.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Global Item Search ===
 dilbegin find_unique_item();
 var
   item : unitptr;
   sym_name : string;
 code
 {
   // Create symbolic name for unique item
   sym_name := &quot;unique_sword_&quot; + itoa(realtime);
   
   // Find the item
   item := findsymbolic(sym_name);
   
   if (item)
   {
     sendtext(&quot;Found unique item: &quot; + item.name + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Symbolic name: &quot; + sym_name + &quot;&lt;br/&gt;&quot;, self);
   }
   else
   {
     sendtext(&quot;Unique item not found.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

=== Zone-based Search ===
 dilbegin search_zone_items(zone_name : string);
 var
   units : stringlist;
   i : integer;
 code
 {
   // Find all units in specific zone
   units := findsymbolic(&quot;*@&quot; + zone_name);
   
   sendtext(&quot;Units in zone &apos;&quot; + zone_name + &quot;&apos;:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(units))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + symname(units.[i]) + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Character Tracking ===
 dilbegin track_character();
 var
   char : unitptr;
   sym_name : string;
 code
 {
   char := activator;
   
   if (char.type != UNIT_ST_PC)
   {
     sendtext(&quot;Target must be a player character.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Create unique symbolic name for tracking
   sym_name := &quot;tracked_char_&quot; + char.name + &quot;_&quot; + itoa(realtime);
   
   // Store tracking reference
   addextra(char.extra, {&quot;character_tracking&quot;}, sym_name);
   
   sendtext(&quot;Character &quot; + char.name + &quot; is now being tracked.&lt;br/&gt;&quot;, self);
 }
 dilend

=== Multiple Target Search ===
 dilbegin find_multiple_targets();
 var
   targets : stringlist;
   i : integer;
 code
 {
   // Define symbolic names to search for
   targets := findsymbolic(&quot;wizard@global&quot;);
   targets := findsymbolic(&quot;guard@midgaard&quot;);
   targets := findsymbolic(&quot;healer@global&quot;);
   
   sendtext(&quot;Found targets:&lt;br/&gt;&quot;, self);
   
   i := 0;
   while (i &lt; length(targets))
   {
     sendtext(itoa(i + 1) + &quot;: &quot; + symname(targets.[i]) + &quot;&lt;br/&gt;&quot;, self);
     i := i + 1;
   }
 }
 dilend

=== Safe Target Validation ===
 dilbegin safe_target_search(target_name : string);
 var
   target : unitptr;
   sym_name : string;
 code
 {
   // Validate input
   if (target_name == &quot;&quot;)
   {
     sendtext(&quot;Please specify a target name.&lt;br/&gt;&quot;, self);
     quit;
   }
   
   // Create safe symbolic name
   sym_name := &quot;search_&quot; + target_name + &quot;_&quot; + itoa(realtime);
   
   // Search for target
   target := findsymbolic(sym_name);
   
   if (target)
   {
     sendtext(&quot;Found target: &quot; + target.name + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Safe symbolic name: &quot; + sym_name + &quot;&lt;br/&gt;&quot;, self);
   }
   else
   {
     sendtext(&quot;Target &apos;&quot; + target_name + &quot;&apos; not found.&lt;br/&gt;&quot;, self);
   }
 }
 dilend

== Usage Notes ==
* The symbolic name system uses the format &quot;name@zone&quot; for global references
* Descriptive names can also be used and will be matched by the function
* The function searches the entire game world, which can be resource-intensive
* Common symbolic name formats include:
** &quot;player_name@global&quot; - for tracking specific players
** &quot;unique_item_12345@global&quot; - for unique items
** &quot;guard@midgaard&quot; - for city guards
* The function returns null if no matching unit is found
* Use [[Manual:DIL_Manual/findunit|findunit]] for local searches when possible instead of global searches

== Error Handling ==
The function handles errors in the following ways:
* Empty symbolic name returns null
* Null or invalid unit parameter returns null
* No runtime errors are generated for valid parameters
* The function may be resource-intensive for complex searches

Always validate that the symbolic name parameter is not empty before calling the function.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/findsymbolic|findsymbolic]] - Find unit by symbolic name globally
* [[Manual:DIL_Manual/findunit|findunit]] - Find unit locally
* [[Manual:DIL_Manual/symname|symname]] - Get symbolic name of a unit
* [[Manual:DIL_Manual/addextra|addextra]] - Store symbolic names in extra descriptions
* unitptr.symname - Field to access symbolic name

== See Also ==
* DIL Symbolic Name System Documentation
* Global Unit Search and Tracking
* Character Identification Systems
* Zone-based Search Systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/textformat</title>
     <ns>0</ns>
     <id>977183</id>
     <revision>
       <id>1455597</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of textformat.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= textformat =
function: string &apos;&apos;&apos;textformat&apos;&apos;&apos;(s : string);

The &apos;&apos;&apos;textformat&apos;&apos;&apos; function formats a string according to escape format codes, adapting the output to each individual player&apos;s settings.

== Description ==
This function processes a string and returns a formatted version that includes escape format codes. The function automatically adapts the output to each individual player&apos;s settings, making it useful for personalized messages, terminal interfaces, and dynamic content generation.

The escape format system uses codes starting with &apos;&amp;&apos; to provide special formatting:
* &amp;n - New line
* &amp;r - Carriage return
* &amp;g - Global message
* &amp;y - Player-specific message
* &amp;c - Color code
* &amp;b - Bold text

The function is particularly useful for creating personalized messages, terminal interfaces, and content that adapts to each player&apos;s individual preferences and display settings.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The text string to be formatted
|}

== Return Value ==
The function returns a string containing:
* The formatted text with escape codes applied
* The original string if no formatting is needed

== Examples ==
=== Basic Text Formatting ===
 dilbegin basic_formatting();
 var
   message : string;
   formatted_text : string;
 code
 {
   message := &quot;Hello &amp;nWelcome to the game!&quot;;
   formatted_text := textformat(message);
   
   sendtext(&quot;Original: &quot; + message + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Formatted: &quot; + formatted_text + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

=== Player-Specific Messages ===
 dilbegin player_messaging();
 var
   player_name : string;
   health_percent : integer;
   message : string;
   formatted_text : string;
 code
 {
   player_name := self.name;
   
   // Calculate health percentage
   health_percent := (self.hp * 100) / self.max_hp;
   
   // Create health-based message
   if (health_percent &gt; 75)
     message := &quot;&amp;yYour health is excellent!&amp;nYou are at full health.&quot;;
   else if (health_percent &gt; 50)
     message := &quot;&amp;yYour health is good.&amp;nYou have some wounds.&quot;;
   else if (health_percent &gt; 25)
     message := &quot;&amp;yYour health is poor.&amp;nYou are heavily wounded.&quot;;
   else
     message := &quot;&amp;yYour health is critical.&amp;nYou are near death!&quot;;
   
   formatted_text := textformat(message);
   
   sendtext(&quot;&amp;gHello &quot; + player_name + &quot;!&amp;n&quot; + message + &quot;&amp;n&amp;nPress &apos;h&apos; for help...&amp;n&quot;);
   sendtext(&quot;Formatted: &quot; + formatted_text + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

=== Color Integration ===
 dilbegin color_system();
 var
   message : string;
   formatted_text : string;
 code
 {
   message := &quot;&amp;cYour name is &amp;r&quot; + self.name + &quot;&amp;c.&amp;nWhat color would you like?&quot;;
   
   formatted_text := textformat(message);
   
   sendtext(&quot;Original: &quot; + message + &quot;&lt;br/&gt;&quot;, self);
   sendtext(&quot;Formatted: &quot; + formatted_text + &quot;&lt;br/&gt;&quot;, self);
 }
 dilend

=== Terminal Interface ===
 dilbegin terminal_interface();
 var
   settings : string;
   formatted_text : string;
 code
 {
   // Create terminal-style interface
   settings := &quot;&amp;gMain Menu&amp;n&amp;n1. Start Game&amp;n&amp;n2. Options&amp;n&amp;n3. Quit&amp;n&amp;n&amp;nPress &apos;q&apos; to exit&quot;;
   
   formatted_text := textformat(settings);
   
   sendtext(&quot;&amp;gTerminal Interface&amp;n&amp;n&quot; + formatted_text + &quot;&amp;n&amp;nPress any key to continue...&quot;);
   
   // Wait for player input
   pause;
 }
 dilend

=== Dynamic Content Generation ===
 dilbegin dynamic_content_generator();
 var
   player_name : string;
   content : string;
   formatted_content : string;
 code
 {
   // Generate personalized content
   content := &quot;&amp;yHello &quot; + player_name + &quot;!&amp;nHere is your personalized content for today:&amp;n&amp;n&quot;;
   
   // Add dynamic elements based on player state
   if (self.position == POSITION_FIGHTING)
     content := content + &quot;&amp;nYou are currently in combat!&quot;;
   else if (self.position == POSITION_SLEEPING)
     content := content + &quot;&amp;nYou are currently resting.&quot;;
   else
     content := content + &quot;&amp;nYou are ready for adventure!&quot;;
   
   formatted_content := textformat(content);
   
   sendtext(&quot;&amp;gDynamic Content&amp;n&amp;n&quot; + formatted_content + &quot;&amp;n&amp;n&quot;);
 }
 dilend

=== Multiple Player Support ===
 dilbegin multi_player_system();
 var
   players : stringlist;
   i : integer;
   message : string;
   formatted_text : string;
 code
 {
   // Get all players
   players := unitdir(&quot;*@global&quot;);
   
   message := &quot;&amp;gBroadcasting to all players:&amp;n&amp;n&quot;;
   
   i := 0;
   while (i &lt; length(players))
   {
     message := &quot;&amp;y&quot; + players.[i].name + &quot;!&amp;n&quot;;
     formatted_text := textformat(message);
     
     sendtext(formatted_text, players.[i]);
     i := i + 1;
   }
 }
 dilend

== Usage Notes ==
* The function processes escape format codes starting with &apos;&amp;&apos;
* Common escape codes include:
** &amp;n - New line
** &amp;r - Carriage return
** &amp;g - Global message
** &amp;y - Player-specific message
** &amp;c - Color code
** &amp;b - Bold text
* The function automatically adapts to each player&apos;s settings
* Use for personalized messages, terminal interfaces, and dynamic content
* The formatted output will contain escape codes that work with most MUD clients

== Error Handling ==
The function handles errors in the following ways:
* Null or invalid string parameter returns empty string
* Invalid escape format codes may cause unexpected behavior
* No runtime errors are generated for valid string inputs

Always ensure that the input string is valid and contains appropriate escape codes for the intended use case.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/textformat|textformat]] - Format text with escape codes
* [[Manual:DIL_Manual/sendtext|sendtext]] - Send formatted text to players
* [[Manual:DIL_Manual/note|note]] - Store player-specific notes

* [[Manual:DIL_Manual/unitdir|unitdir]] - Get list of all players globally
* [[Manual:DIL_Manual/addextra|addextra]] - Store player-specific data


== See Also ==
* DIL Text Formatting Documentation
* Escape Code Systems
* Player Communication Systems
* Terminal Interface Documentation

* Dynamic Content Generation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/thirst</title>
     <ns>0</ns>
     <id>790382</id>
     <revision>
       <id>1424383</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of thirst.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= thirst =
 field: integer &apos;&apos;&apos;.thirst&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;thirst&apos;&apos;&apos; field accesses the thirst condition of a player character, indicating how thirsty the character is.

== Description ==
This field provides access to the thirst level of a player character. It represents the character&apos;s current thirst status, which affects gameplay mechanics related to dehydration and thirst management. The field is both readable and writable, allowing DIL programs to check current thirst levels or modify them.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the current thirst value of the player character
|-
| Write || integer || Sets the thirst value of the player character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Thirst Check ===
 dilbegin thirst_check();
 var
     pc : unitptr;
     thirst_level : integer;
 code
 {
     // Get player character
     pc := self;
     
     // Check current thirst level
     thirst_level := pc.thirst;
     
     if (thirst_level &lt; 5)
     {
         sendtext(&quot;You are extremely thirsty!&lt;br/&gt;&quot;, pc);
     }
     else if (thirst_level &lt; 10)
     {
         sendtext(&quot;You are quite thirsty.&lt;br/&gt;&quot;, pc);
     }
     else
     {
         sendtext(&quot;You feel reasonably hydrated.&lt;br/&gt;&quot;, pc);
     }
 } dilend

=== Quench Thirst ===
 dilbegin quench_thirst();
 var
     pc : unitptr;
 code
 {
     // Fully quench thirst (value 24 appears to be maximum)
     pc := self;
     pc.thirst := 24;
     sendtext(&quot;You feel completely refreshed and hydrated!&lt;br/&gt;&quot;, pc);
 } dilend

dilbegin unique quench_thirst();
var
    pc : unitptr;
code
{
    // Fully quench thirst (value 24 appears to be maximum)
    pc := self;
    pc.thirst := 24;
    sendto(&quot;You feel completely refreshed and hydrated!&amp;n&quot;, pc);
} dilend

== Usage Notes ==
* The thirst field only works on player characters (UNIT_ST_PC). Attempting to access it on NPCs, objects, or rooms will result in failure.
* The typical range appears to be 0-24, where 24 represents a fully quenched state and lower values indicate increasing thirst.
* This field is often used in conjunction with the &apos;&apos;&apos;full&apos;&apos;&apos; field to manage both hunger and thirst conditions.
* Thirst levels typically decrease over time through natural game mechanics and may affect character performance when too low.

== Error Handling ==
* Attempting to access the &apos;&apos;&apos;thirst&apos;&apos;&apos; field on a non-player character unit will result in a DILV_FAIL condition.
* The field will return DILV_ERR if accessed on an invalid unit pointer or inappropriate unit type.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/full|full]] - The hunger condition field for player characters
* [[Manual:DIL_Manual/drunk|drunk]] - The intoxication level field for player characters

== See Also ==
* [[Manual:DIL_Manual/unit_st_pc|unit_st_pc]] - Player character unit type documentation
* [[Manual:DIL_Manual/pcflags|pcflags]] - Player character flags and options</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/title</title>
     <ns>0</ns>
     <id>1287515</id>
     <revision>
       <id>1588872</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of title.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= title =
 field: string &apos;&apos;&apos;.title&apos;&apos;&apos; (Read/Write)

The &apos;&apos;&apos;title&apos;&apos;&apos; field accesses the title of a unit or zone, providing a descriptive name or label.

== Description ==
This field provides access to the title string of either a unit or a zone. For units, it represents the descriptive title that appears in various game contexts (such as room descriptions, character information, and object identification). For zones, it represents the zone&apos;s title used in zone management and listing functions. The field is both readable and writable, allowing DIL programs to retrieve current titles or modify them.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || string || Returns the current title of the unit or zone
|-
| Write || string || Sets the title of the unit or zone
|}

== Availability ==
This field is available on the following types:
* unitptr (All unit types: UNIT_ST_PC, UNIT_ST_NPC, UNIT_ST_OBJ, UNIT_ST_ROOM)
* zoneptr (Zone pointer)

== Examples ==
=== Show Room Title ===
 dilbegin show_room_title();
 var
     room : unitptr;
 code
 {
     // Get current room&apos;s title
     room := self.outside;
     sendtext(&quot;You are in: &quot; + room.title + &quot;&lt;br/&gt;&quot;, self);
 } dilend

=== Set Custom Title ===
 dilbegin set_custom_title(new_title : string);
 var
     pc : unitptr;
 code
 {
     // Set a custom title for a player
     pc := self;
     pc.title := new_title;
     sendtext(&quot;Your title has been changed to: &quot; + pc.title + &quot;&lt;br/&gt;&quot;, pc);
 } dilend

=== Zone Information ===
 dilbegin zone_info();
 var
     z : zoneptr;
 code
 {
     // Display zone information
     z := zhead();
     while (z)
     {
         sendtext(&quot;Zone: &quot; + z.name + &quot; - &quot; + z.title + &quot;&lt;br/&gt;&quot;, self);
         z := z.next;
     }
 } dilend

=== Engrave Item ===
 dilbegin engrave_item(item : unitptr, engraving : string);
 var
     current_title : string;
 code
 {
     // Add engraving to an item&apos;s title
     current_title := item.title;
     item.title := current_title + &quot; (engraved: &apos;&quot; + engraving + &quot;&apos;)&quot;;
     act(&quot;$1n engraves something on $2n.&quot;, A_ALWAYS, self, item, null, TO_ROOM);
 } dilend

dilbegin unique set_custom_title(new_title : string);
var
    pc : unitptr;
code
{
    // Set a custom title for a player
    pc := self;
    pc.title := new_title;
    sendto(&quot;Your title has been changed to: &quot; + pc.title + &quot;&amp;n&quot;, pc);
} dilend

dilbegin unique zone_info();
var
    z : zoneptr;
code
{
    // Display zone information
    z := zhead();
    while (z)
    {
        sendto(&quot;Zone: &quot; + z.name + &quot; - &quot; + z.title + &quot;&amp;n&quot;, self);
        z := z.next;
    }
} dilend

dilbegin unique engrave_item(item : unitptr, engraving : string);
var
    current_title : string;
    parts : stringlist;
code
{
    // Add engraving to an item&apos;s title
    current_title := item.title;
    item.title := current_title + &quot; (engraved: &apos;&quot; + engraving + &quot;&apos;)&quot;;
    act(&quot;$1n engraves something on $2n.&quot;, A_ALWAYS, self, item, null, TO_ROOM);
} dilend

== Usage Notes ==
* The &apos;&apos;&apos;title&apos;&apos;&apos; field works on all unit types (PCs, NPCs, objects, and rooms) as well as zone pointers.
* For player characters, the title often appears alongside their name in various game outputs.
* For rooms, the title is typically what players see when they enter or look around.
* For objects, the title appears in inventory lists and when examining items.
* For zones, the title is used in zone listing commands and administrative functions.
* When modifying titles, be mindful of length limitations and formatting conventions.
* Titles can contain special formatting and color codes in some implementations.

== Error Handling ==
* Attempting to access the &apos;&apos;&apos;title&apos;&apos;&apos; field on a null or invalid pointer will result in a DILV_FAIL condition.
* The field will return DILV_ERR if accessed on an inappropriate type that doesn&apos;t support titles.
* When setting titles, extremely long strings may be truncated or rejected by the system.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/name|name]] - The primary name field of units
* [[Manual:DIL_Manual/names|names]] - The list of names that match a unit
* [[Manual:DIL_Manual/outside_descr|outside_descr]] - The description of a unit from the outside
* [[Manual:DIL_Manual/inside_descr|inside_descr]] - The description of a unit from the inside
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type documentation

== See Also ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type documentation
* [[Manual:DIL_Manual/sact|sact]] - String activation function for formatting titles</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/tolower</title>
     <ns>0</ns>
     <id>883032</id>
     <revision>
       <id>1071154</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of tolower.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= tolower =
 function: string &apos;&apos;&apos;tolower&apos;&apos;&apos;(s : string);

The &apos;&apos;&apos;tolower&apos;&apos;&apos; function converts all characters in a string to lowercase.

== Description ==
This function returns a new string with all alphabetic characters converted to their lowercase equivalents. The original string is not modified; instead, a new lowercase copy is created and returned. This function is commonly used for case-insensitive string comparisons, normalization, and text processing.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The input string to be converted to lowercase
|}

== Examples ==
=== Case Insensitive Check ===
 dilbegin case_insensitive_check(input : string);
 var
     lower_input : string;
 code
 {
     // Convert input to lowercase for comparison
     lower_input := tolower(input);
     
     if (lower_input == &quot;yes&quot;)
     {
         sendtext(&quot;You answered YES!&lt;br/&gt;&quot;, self);
     }
     else if (lower_input == &quot;no&quot;)
     {
         sendtext(&quot;You answered NO!&lt;br/&gt;&quot;, self);
     }
     else
     {
         sendtext(&quot;You answered: &quot; + input + &quot;&lt;br/&gt;&quot;, self);
     }
 } dilend

=== Normalize Name ===
 dilbegin normalize_name(name : string);
 var
     normal_name : string;
 code
 {
     // Normalize a name to lowercase for storage/lookup
     normal_name := tolower(name);
     sendtext(&quot;Normalized name: &quot; + normal_name + &quot;&lt;br/&gt;&quot;, self);
     
     // Example usage with restore function (from mail system)
     // ml := restore(normal_name, null);
 } dilend

=== String Processing ===
 dilbegin string_processing();
 var
     mixed_case : string;
     lower_case : string;
 code
 {
     mixed_case := &quot;Hello WORLD! 123&quot;;
     lower_case := tolower(mixed_case);
     
     sendtext(&quot;Original: &quot; + mixed_case + &quot;&lt;br/&gt;&quot;, self);
     sendtext(&quot;Lowercase: &quot; + lower_case + &quot;&lt;br/&gt;&quot;, self);
     // Output: &quot;hello world! 123&quot;
 } dilend

== Usage Notes ==
* The function only affects alphabetic characters; numbers, symbols, and whitespace remain unchanged.
* Non-alphabetic characters are passed through unchanged.
* The function returns a new string; the original input string is not modified.
* Empty strings return empty strings (null pointer in C implementation).
* This function is useful for case-insensitive comparisons and text normalization.
* The function handles null input gracefully by returning a fail condition.

== Error Handling ==
* If the input parameter is not a string, a DIL fatal error occurs: &quot;Arg 1 of &apos;tolower&apos; not a string.&quot;
* If the input string is null or empty, the function returns a null/empty string.
* The function will fail gracefully if memory allocation for the new string fails.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/toupper|toupper]] - Converts all characters in a string to uppercase
* [[Manual:DIL_Manual/restore|restore]] - Restores data from storage (often used with tolower for filename normalization)
* [[Manual:DIL_Manual/savestr|savestr]] - Saves strings to disk for later retrieval

== See Also ==
* String manipulation functions
* Case conversion functions
* File system functions (for filename normalization)</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/toupper</title>
     <ns>0</ns>
     <id>1273610</id>
     <revision>
       <id>1883851</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of toupper.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= toupper =
 function: string &apos;&apos;&apos;toupper&apos;&apos;&apos;(s : string);

The &apos;&apos;&apos;toupper&apos;&apos;&apos; function converts all characters in a string to uppercase.

== Description ==
This function returns a new string with all alphabetic characters converted to their uppercase equivalents. The original string is not modified; instead, a new uppercase copy is created and returned. This function is commonly used for text formatting, emphasis, and case-insensitive string comparisons.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| s || string || The input string to be converted to uppercase
|}

== Examples ==
=== Capitalize First Letter ===
 dilbegin capitalize_first_letter(text : string);
 var
     first_char : string;
     rest : string;
     result : string;
 code
 {
     // Capitalize first letter only (common pattern from graffiti example)
     first_char := toupper(left(text, 1));
     rest := right(text, length(text) - 1);
     result := first_char + rest;
     
     sendtext(&quot;Capitalized: &quot; + result + &quot;&lt;br/&gt;&quot;, self);
 } dilend

=== Emphasize Text ===
 dilbegin emphasize_text(input : string);
 var
     emphasized : string;
 code
 {
     // Convert entire string to uppercase for emphasis
     emphasized := toupper(input);
     sendtext(&quot;EMPHASIZED: &quot; + emphasized + &quot;&lt;br/&gt;&quot;, self);
 } dilend

=== Graffiti Format ===
 dilbegin graffiti_format(color : string, style : string);
 var
     formatted_text : string;
 code
 {
     // Format graffiti text (from example)
     formatted_text := toupper(left(style, 1)) + right(style, length(style) - 1);
     sendtext(&quot;&lt;div class=&apos;&quot; + color + &quot;&apos;&gt;&quot; + formatted_text + &quot; graffiti is painted all over!&lt;/div&gt;&lt;br/&gt;&quot;, self);
 } dilend

=== Case Insensitive Compare ===
 dilbegin case_insensitive_compare(input1 : string, input2 : string);
 var
     upper1 : string;
     upper2 : string;
 code
 {
     // Case-insensitive comparison using toupper
     upper1 := toupper(input1);
     upper2 := toupper(input2);
     
     if (upper1 == upper2)
     {
         sendtext(&quot;The strings match (case-insensitive)!&lt;br/&gt;&quot;, self);
     }
     else
     {
         sendtext(&quot;The strings do not match.&lt;br/&gt;&quot;, self);
     }
 } dilend

dilbegin unique emphasize_text(input : string);
var
    emphasized : string;
code
{
    // Convert entire string to uppercase for emphasis
    emphasized := toupper(input);
    sendto(&quot;EMPHASIZED: &quot; + emphasized + &quot;&amp;n&quot;, self);
} dilend

dilbegin unique graffiti_format(color : string, style : string);
var
    formatted_text : string;
code
{
    // Format graffiti text (from the example)
    formatted_text := toupper(left(style, 1)) + right(style, length(style) - 1);
    sendto(&quot;&lt;div class=&apos;&quot; + color + &quot;&apos;&gt;&quot; + formatted_text + &quot; graffiti is painted all over!&lt;/div&gt;&amp;n&quot;, self);
} dilend

dilbegin unique case_insensitive_compare(input1 : string, input2 : string);
var
    upper1 : string;
    upper2 : string;
code
{
    // Case-insensitive comparison using toupper
    upper1 := toupper(input1);
    upper2 := toupper(input2);
    
    if (upper1 == upper2)
    {
        sendto(&quot;The strings match (case-insensitive)!&amp;n&quot;, self);
    }
    else
    {
        sendto(&quot;The strings do not match.&amp;n&quot;, self);
    }
} dilend

== Usage Notes ==
* The function only affects alphabetic characters; numbers, symbols, and whitespace remain unchanged.
* Non-alphabetic characters are passed through unchanged.
* The function returns a new string; the original input string is not modified.
* Empty strings return empty strings (null pointer in C implementation).
* This function is useful for text formatting, emphasis, and case-insensitive comparisons.
* The function handles null input gracefully by returning a fail condition.
* Common pattern: `toupper(left(text, 1)) + right(text, length(text) - 1)` to capitalize only the first letter.

== Error Handling ==
* If the input parameter is not a string, a DIL fatal error occurs: &quot;Arg 1 of &apos;toupper&apos; not a string.&quot;
* If the input string is null or empty, the function returns a null/empty string.
* The function will fail gracefully if memory allocation for the new string fails.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/tolower|tolower]] - Converts all characters in a string to lowercase
* [[Manual:DIL_Manual/left|left]] - Extracts left portion of a string
* [[Manual:DIL_Manual/right|right]] - Extracts right portion of a string
* [[Manual:DIL_Manual/length|length]] - Returns the length of a string

== See Also ==
* String manipulation functions
* Case conversion functions
* Text formatting functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/transfermoney</title>
     <ns>0</ns>
     <id>1045838</id>
     <revision>
       <id>1403378</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of transfermoney.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= transfermoney =
 function: integer &apos;&apos;&apos;transfermoney&apos;&apos;&apos;(f : unitptr, t : unitptr, amount : integer);

The &apos;&apos;&apos;transfermoney&apos;&apos;&apos; function transfers money between characters or creates/destroys money.

== Description ==
This function transfers a specified amount of money from one character to another. Both parameters must be character units (PCs or NPCs). The function returns 1 if the transfer was successful, or 0 if it failed (typically due to insufficient funds). Special behavior allows money creation or destruction when one of the character parameters is null.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| f || unitptr || The character to take money from (can be null to create money)
|-
| t || unitptr || The character to give money to (can be null to destroy money)
|-
| amount || integer || The amount of money to transfer (in base currency units)
|}

== Examples ==
=== Shop Transaction ===
 dilbegin shop_transaction(pc : unitptr, cost : integer);
 var
     success : integer;
 code
 {
     // Transfer money from player to shopkeeper (self)
     success := transfermoney(pc, self, cost);
     
     if (success)
     {
         sendtext(&quot;Thank you for your payment!&lt;br/&gt;&quot;, pc);
         // Process sale...
     }
     else
     {
         sendtext(&quot;You can&apos;t afford that!&lt;br/&gt;&quot;, pc);
     }
 } dilend

=== Reward Player ===
 dilbegin reward_player(pc : unitptr, reward : integer);
 var
     success : integer;
 code
 {
     // Create money and give to player (from null)
     success := transfermoney(null, pc, reward);
     
     if (success)
     {
         sendtext(&quot;You have been rewarded!&lt;br/&gt;&quot;, pc);
         act(&quot;$1n receives a reward!&quot;, A_ALWAYS, pc, null, null, TO_ROOM);
     }
 } dilend

=== Fine Player ===
 dilbegin fine_player(pc : unitptr, fine : integer);
 var
     success : integer;
 code
 {
     // Take money from player and destroy it (to null)
     success := transfermoney(pc, null, fine);
     
     if (success)
     {
         sendtext(&quot;You have paid your fine of &quot; + moneystring(fine, 0) + &quot;&lt;br/&gt;&quot;, pc);
         sendtext(&quot;Your fine has been collected.&lt;br/&gt;&quot;, pc);
     }
     else
     {
         sendtext(&quot;You can&apos;t afford to pay fine!&lt;br/&gt;&quot;, pc);
     }
 } dilend

=== Player Trade ===
 dilbegin player_trade(pc1 : unitptr, pc2 : unitptr, amount : integer);
 var
     success : integer;
 code
 {
     // Transfer money between two players
     success := transfermoney(pc1, pc2, amount);
     
     if (success)
     {
         sendtext(&quot;You transfer &quot; + moneystring(amount, 0) + &quot; to &quot; + pc2.name + &quot;&lt;br/&gt;&quot;, pc1);
         sendtext(pc1.name + &quot; transfers &quot; + moneystring(amount, 0) + &quot; to you&lt;br/&gt;&quot;, pc2);
     }
     else
     {
         sendtext(&quot;Transfer failed - insufficient funds!&lt;br/&gt;&quot;, pc1);
     }
 } dilend

dilbegin unique reward_player(pc : unitptr, reward : integer);
var
    success : integer;
code
{
    // Create money and give to player (from null)
    success := transfermoney(null, pc, reward);
    
    if (success)
    {
        sendto(&quot;You have been rewarded!&amp;n&quot;, pc);
        act(&quot;$1n receives a reward!&quot;, A_ALWAYS, pc, null, null, TO_ROOM);
    }
} dilend

dilbegin unique fine_player(pc : unitptr, fine : integer);
var
    success : integer;
code
{
    // Take money from player and destroy it (to null)
    success := transfermoney(pc, null, fine);
    
    if (success)
    {
        sendto(&quot;You have paid your fine of &quot; + moneystring(fine, 0) + &quot;&amp;n&quot;, pc);
        sendto(&quot;Your fine has been collected.&amp;n&quot;, pc);
    }
    else
    {
        sendto(&quot;You can&apos;t afford to pay the fine!&amp;n&quot;, pc);
    }
} dilend

dilbegin unique player_trade(pc1 : unitptr, pc2 : unitptr, amount : integer);
var
    success : integer;
code
{
    // Transfer money between two players
    success := transfermoney(pc1, pc2, amount);
    
    if (success)
    {
        sendto(&quot;You transfer &quot; + moneystring(amount, 0) + &quot; to &quot; + pc2.name + &quot;&amp;n&quot;, pc1);
        sendto(pc1.name + &quot; transfers &quot; + moneystring(amount, 0) + &quot; to you&amp;n&quot;, pc2);
    }
    else
    {
        sendto(&quot;Transfer failed - insufficient funds!&amp;n&quot;, pc1);
    }
} dilend

== Usage Notes ==
* Both character parameters must be valid character units (PC or NPC). Using objects or rooms will result in failure.
* The amount parameter must be a positive integer.
* When &apos;f&apos; is null and &apos;t&apos; is not null, money is created and given to &apos;t&apos; (used for rewards).
* When &apos;t&apos; is null and &apos;f&apos; is not null, money is removed from &apos;f&apos; and destroyed (used for fines).
* When both are non-null, money is transferred between characters if the source can afford it.
* The function uses the local currency system of the target character.
* All transactions are logged for security and auditing purposes.
* Commonly used in shops, guilds, service providers, and reward systems.

== Error Handling ==
* If either character parameter is not a unitptr, a DIL fatal error occurs.
* If character parameters are not character types (PC/NPC), the function returns 0 (failure).
* If the amount parameter is not an integer, a DIL fatal error occurs.
* If the source character cannot afford the transfer amount, the function returns 0 (failure).
* If memory allocation fails during the transfer, the function returns 0 (failure).

== Related Functions/Fields ==
* [[Manual:DIL_Manual/moneystring|moneystring]] - Formats money amounts into readable strings
* [[Manual:DIL_Manual/char_can_afford|char_can_afford]] - Checks if a character can afford a specific amount
* [[Manual:DIL_Manual/purse|purse]] - Access to character&apos;s money purse information

== See Also ==
* Money and currency functions
* Economic system functions
* Character transaction functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/type</title>
     <ns>0</ns>
     <id>506390</id>
     <revision>
       <id>997791</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of type.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= type =
 field: integer &apos;&apos;&apos;.type&apos;&apos;&apos; (Read-only)

The &apos;&apos;&apos;type&apos;&apos;&apos; field returns the type identifier of a unit or command.

== Description ==
This field provides access to the type identifier of a unit or command. For units, it returns one of the UNIT_ST_* constants indicating whether the unit is a player character, non-player character, object, or room. For commands, it returns the command type identifier. This field is read-only and is commonly used for type checking and conditional logic in DIL programs.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| Read || integer || Returns the type identifier of the unit or command
|}

== Availability ==
This field is available on the following types:
* unitptr (All unit types: UNIT_ST_PC, UNIT_ST_NPC, UNIT_ST_OBJ, UNIT_ST_ROOM)
* cmdptr (Command pointer)

== Examples ==
=== Check Unit Type ===
 dilbegin check_unit_type(u : unitptr);
 var
     unit_type : integer;
 code
 {
     unit_type := u.type;
     
     if (unit_type == UNIT_ST_PC)
     {
         sendtext(&quot;This is a player character.&lt;br/&gt;&quot;, self);
     }
     else if (unit_type == UNIT_ST_NPC)
     {
         sendtext(&quot;This is a non-player character.&lt;br/&gt;&quot;, self);
     }
     else if (unit_type == UNIT_ST_OBJ)
     {
         sendtext(&quot;This is an object.&lt;br/&gt;&quot;, self);
     }
     else if (unit_type == UNIT_ST_ROOM)
     {
         sendtext(&quot;This is a room.&lt;br/&gt;&quot;, self);
     }
 } dilend

=== Validate Target ===
 dilbegin validate_target(tgt : unitptr);
 code
 {
     // Only allow targeting of characters
     if (not (tgt.type &amp; (UNIT_ST_PC | UNIT_ST_NPC)))
     {
         sendtext(&quot;You can only target characters!&lt;br/&gt;&quot;, self);
         quit;
     }
     
     // Continue with valid target...
     sendtext(&quot;Target validated: &quot; + tgt.name + &quot;&lt;br/&gt;&quot;, self);
 } dilend

=== Command Information ===
 dilbegin command_info(cmd : cmdptr);
 var
     cmd_type : integer;
 code
 {
     cmd_type := cmd.type;
     sendtext(&quot;Command: &quot; + cmd.name + &quot; Type: &quot; + itoa(cmd_type) + &quot;&lt;br/&gt;&quot;, self);
 } dilend

=== Room Validation ===
 dilbegin room_validation(room : unitptr);
 code
 {
     // Ensure we&apos;re in a room
     if (room.type != UNIT_ST_ROOM)
     {
         act(&quot;$1n looks confused about $1s surroundings.&quot;,
             A_ALWAYS, self, null, null, TO_ALL);
         quit;
     }
     
     sendtext(&quot;Room confirmed: &quot; + room.title + &quot;&lt;br/&gt;&quot;, self);
 } dilend

== Usage Notes ==
* For unitptr, the field returns one of the UNIT_ST_* constants:
** UNIT_ST_PC - Player Character
** UNIT_ST_NPC - Non-Player Character  
** UNIT_ST_OBJ - Object
** UNIT_ST_ROOM - Room
* For cmdptr, the field returns command-specific type information.
* The field is read-only; attempts to modify it will fail.
* Commonly used in conditional statements to determine unit behavior.
* Essential for type validation before accessing unit-specific fields.
* Often used with bitwise operations to check multiple unit types simultaneously.

== Error Handling ==
* Attempting to access the &apos;&apos;&apos;type&apos;&apos;&apos; field on a null or invalid pointer will result in a DILV_FAIL condition.
* The field will return DILV_ERR if accessed on an inappropriate type that doesn&apos;t support type checking.
* No error occurs for valid unitptr or cmdptr types.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/unitptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/cmdptr|cmdptr]] - Command pointer type documentation
* [[Manual:DIL_Manual/findrndunit|findrndunit]] - Function that uses unit type filtering
* [[Manual:DIL_Manual/foreach|foreach]] - Function that can iterate by unit type

== See Also ==
* Unit type constants (UNIT_ST_*)
* Command type documentation
* Type checking and validation functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unequip</title>
     <ns>0</ns>
     <id>1007489</id>
     <revision>
       <id>1722135</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unequip.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= unequip =
 procedure: &apos;&apos;&apos;unequip&apos;&apos;&apos;(u : unitptr);

The &apos;&apos;&apos;unequip&apos;&apos;&apos; procedure removes an equipped item from a character.

== Description ==
This procedure removes an item from a character&apos;s equipment slots and returns it to their inventory. The unit parameter must be an object that is currently equipped by a character (PC or NPC). The procedure is commonly used for disarming, removing restraints, or changing equipment.

== Parameters ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The equipped object to be unequipped
|}

== Examples ==
=== Remove Weapon ===
 dilbegin remove_weapon();
 var
     weapon : unitptr;
 code
 {
     // Get currently wielded weapon
     weapon := equipment(self, WEAR_WIELD);
     
     if (weapon != null)
     {
         unequip(weapon);
         act(&quot;You unequip $2n.&quot;, A_ALWAYS, self, weapon, null, TO_CHAR);
         act(&quot;$1n unequips $2n.&quot;, A_ALWAYS, self, weapon, null, TO_ROOM);
     }
     else
     {
         sendtext(&quot;You are not wielding anything.&lt;br/&gt;&quot;, self);
     }
 } dilend

=== Handcuff Target ===
 dilbegin handcuff_target(deputy : unitptr, target : unitptr, cuffs : unitptr);
 var
     deputy_name : string;
 code
 {
     act(&quot;You cuff $3n.&quot;, A_SOMEONE, deputy, null, target, TO_CHAR);
     act(&quot;$1n surprises you and put $2n around your wrists.&quot;, A_SOMEONE, deputy, cuffs, target, TO_VICT);
     act(&quot;$1n puts $2n around $3N&apos;s wrists.&quot;, A_SOMEONE, deputy, cuffs, target, TO_NOTVICT);

     // Remove any existing wrist equipment and add cuffs
     unequip(equipment(target, WEAR_WRIST_R));
     addequip(cuffs, WEAR_WRIST_R);
     
     deputy_name := deputy.name;
     dilcopy(&quot;cuffed@midgaard(&quot; + deputy_name + &quot;)&quot;, target);
 } dilend

=== Strip Character ===
 dilbegin strip_character(victim : unitptr);
 var
     i : integer;
     item : unitptr;
 code
 {
     // Remove all equipment from victim
     for (i := 0; i &lt; 20; i := i + 1)
     {
         item := equipment(victim, i);
         if (item != null)
         {
             unequip(item);
             act(&quot;$2n falls from $1n&apos;s body.&quot;, A_ALWAYS, victim, item, null, TO_ROOM);
         }
     }
 } dilend

=== Unequip Specific Item ===
 dilbegin unequip_specific(item_name : string);
 var
     item : unitptr;
     i : integer;
 code
 {
     // Search inventory for specific item and unequip if equipped
     for (i := 0; i &lt; 20; i := i + 1)
     {
         item := equipment(self, i);
         if ((item != null) and (item.nameidx == item_name))
         {
             unequip(item);
             sendtext(&quot;You remove &quot; + item.title + &quot;.&lt;br/&gt;&quot;, self);
             act(&quot;$1n removes $2n.&quot;, A_ALWAYS, self, item, null, TO_ROOM);
             quit;
         }
     }
     sendtext(&quot;You are not wearing any &quot; + item_name + &quot;.&lt;br/&gt;&quot;, self);
 } dilend

== Usage Notes ==
* The unit parameter must be an object that is currently equipped by a character.
* Only works on objects that are in valid equipment positions (defined by WEAR_* constants).
* The unequipped item is returned to the character&apos;s inventory.
* Commonly used with the [[Manual:DIL_Manual/equipment|equipment]]() function to find specific equipped items.
* Often paired with [[Manual:DIL_Manual/addequip|addequip]]() for equipment management.
* The procedure will fail silently if the item is not equipped or is not an object.
* Equipment positions are defined by WEAR_* constants in values.h and/or vme.h.

== Error Handling ==
* If the unit parameter is not a unitptr, a DIL fatal error occurs: &quot;Arg 1 of &apos;unequip&apos; not a unit&quot;.
* If the unit is null or not an object, the procedure fails silently.
* If the object is not currently equipped, the procedure fails silently.
* If the object is not in a valid equipment position, the procedure fails.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/addequip|addequip]] - Equips an item to a character
* [[Manual:DIL_Manual/equipment|equipment]] - Returns the unit equipped at a specific position
* [[Manual:DIL_Manual/OBJ_EQP_POS|OBJ_EQP_POS]] - Internal check for equipment position validity

== See Also ==
* Equipment management functions
* WEAR_* constants for equipment positions
* Character inventory functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unit_st_npc</title>
     <ns>0</ns>
     <id>775135</id>
     <revision>
       <id>1750506</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unit_st_npc.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= UNIT_ST_NPC =

 constant: &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos;

Unit type constant that identifies non-player characters.

== Description ==
The &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; constant is used to identify units that are non-player characters (NPCs) in the DikuMUD3 system. This constant is commonly used in type checking operations to distinguish between player characters (PCs) and computer-controlled characters.

When checking unit types, the &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; constant is used to determine if a unit pointer refers to an NPC rather than a player character. This is essential for implementing different behaviors, restrictions, or capabilities based on whether a character is player-controlled or computer-controlled.

== Examples ==
=== Basic Type Checking ===
 dilbegin npc_checker();
 var
    target : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    target := activator;
    
    if (target.type == UNIT_ST_NPC)
    {
       exec(&quot;say Target is an NPC.&quot;, self);
    }
    else if (target.type == UNIT_ST_PC)
    {
       exec(&quot;say Target is a player character.&quot;, self);
    }
    else
    {
       exec(&quot;say Target is of unknown type.&quot;, self);
    }
    
    goto start;
 } dilend

=== NPC-Specific Behavior ===
 dilbegin npc_behavior();
 var
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    if (activator.type == UNIT_ST_NPC)
    {
       exec(&quot;say I am an NPC with special behavior.&quot;, self);
       // NPC-specific logic here
    }
    else
    {
       exec(&quot;say I am a player character.&quot;, self);
       // Player-specific logic here
    }
    
    goto start;
 } dilend

=== Type Validation in Functions ===
 dilbegin type_validator();
 var
    unit : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;examine&quot;));
    unit := activator;
    
    // Only allow NPCs to be examined
    if (unit.type == UNIT_ST_NPC)
    {
       exec(&quot;say This NPC can be examined.&quot;, self);
    }
    else
    {
       exec(&quot;say Only NPCs can be examined.&quot;, self);
       block;
    }
    
    goto start;
 } dilend

=== Combined Type Checking ===
 dilbegin multi_type_check();
 var
    unit : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    unit := activator;
    
    // Handle different types differently
    if (unit.type == UNIT_ST_PC)
    {
       exec(&quot;say Player character detected.&quot;, self);
    }
    else if (unit.type == UNIT_ST_NPC)
    {
       exec(&quot;say NPC detected.&quot;, self);
    }
    else if (unit.type == UNIT_ST_OBJ)
    {
       exec(&quot;say Object detected.&quot;, self);
    }
    else
    {
       exec(&quot;say Unknown unit type.&quot;, self);
    }
    
    goto start;
 } dilend

=== Type-Based Command Processing ===
 dilbegin type_command_handler();
 var
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    if (activator.type == UNIT_ST_NPC)
    {
       exec(&quot;say NPC command: &quot; + argument, self);
    }
    else if (activator.type == UNIT_ST_PC)
    {
       exec(&quot;say Player command: &quot; + argument, self);
    }
    else
    {
       exec(&quot;say Unknown unit type.&quot;, self);
       block;
    }
    
    goto start;
 } dilend

=== NPC List Processing ===
 dilbegin npc_list_processor();
 var
    npc_list : stringlist;
    i : integer;
 code
 {
    // Get all NPCs in the room
    npc_list := {&quot;guard&quot;,&quot;merchant&quot;,&quot;healer&quot;,&quot;trainer&quot;};
    
    :start:
    wait(SFB_CMD, command(&quot;listnpcs&quot;));
    
    exec(&quot;say NPCs in this area:&quot;, self);
    for (i := 0; i &lt; length(npc_list); i := i + 1)
    {
       exec(&quot;say - &quot; + npc_list.[i], self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; is used to distinguish NPCs from player characters
* The constant is essential for implementing different behaviors for PCs vs NPCs
* Type checking is commonly done using bitwise operations with other unit type constants
* Many functions and game mechanics have different behaviors based on whether a unit is an NPC
* The constant is read-only and cannot be modified at runtime
* &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; is the complementary constant for player characters
* &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; and &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; are other common unit type constants

== Error Handling ==
* Always validate that unit pointers are not null before checking their type
* Remember that &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; is a constant, not a variable that can be changed
* Use proper type checking to avoid runtime errors
* Be careful with assumptions about unit types - always validate using the constants
* Test type checking logic thoroughly with all possible unit types
* Consider edge cases where unit type might be unknown or invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/type|type]] - Function to get the type of a unit
* [[Manual:DIL_Manual/activator|activator]] - Unit pointer to the unit performing an action
* [[Manual:DIL_Manual/foreach|foreach]] - Loop construct for iterating through units
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant
* [[Manual:DIL_Manual/type|type]] - Unit type checking function

</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unit_st_obj</title>
     <ns>0</ns>
     <id>1092878</id>
     <revision>
       <id>1602201</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unit_st_obj.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= UNIT_ST_OBJ =

 constant: &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos;

Unit type constant that identifies objects.

== Description ==
The &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; constant is used to identify units that are objects rather than characters or rooms. This constant is commonly used in type checking operations to determine if a unit pointer refers to an object, allowing DIL programs to implement object-specific behaviors and restrictions.

When checking unit types, the following constants are commonly used:
* &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; - Player characters
* &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; - Non-player characters  
* &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; - Objects
* &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; - Rooms

The &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; constant is read-only and cannot be modified at runtime. It&apos;s primarily used with the &apos;&apos;&apos;type&apos;&apos;&apos; function to determine the actual type of a unit.

== Examples ==
=== Basic Object Type Check ===
 dilbegin object_checker();
 var
    item : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;examine&quot;));
    item := activator;
    
    if (item.type == UNIT_ST_OBJ)
    {
       exec(&quot;say This is an object.&quot;, self);
    }
    else
    {
       exec(&quot;say This is not an object.&quot;, self);
    }
    
    goto start;
 } dilend

=== Object-Specific Behavior ===
 dilbegin object_handler();
 var
    container : unitptr;
    item : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;get&quot;) or command(&quot;drop&quot;));
    item := activator;
    
    if (item.type == UNIT_ST_OBJ)
    {
       // Object-specific behavior
       if (command(&quot;get&quot;))
       {
          exec(&quot;say You pick up the &quot; + item.title + &quot;.&quot;, self);
       }
       else if (command(&quot;drop&quot;))
       {
          exec(&quot;say You drop the &quot; + item.title + &quot;.&quot;, self);
       }
    }
    else
    {
       exec(&quot;say You can&apos;t do that with &quot; + item.title + &quot;.&quot;, self);
       block;
    }
    
    goto start;
 } dilend

=== Container Object Handling ===
 dilbegin container_manager();
 var
    container : unitptr;
    item : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;put&quot;));
    container := activator;
    item := medium;
    
    // Only allow putting items in containers
    if (container.type == UNIT_ST_OBJ)
    {
       exec(&quot;say You put &quot; + item.title + &quot; in the &quot; + container.title + &quot;.&quot;, self);
    }
    else
    {
       exec(&quot;say You can only put items in containers.&quot;, self);
       block;
    }
    
    goto start;
 } dilend

=== Equipment Object Processing ===
 dilbegin equipment_handler();
 var
    character : unitptr;
    equipment : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;wear&quot;) or command(&quot;remove&quot;));
    equipment := activator;
    
    if (equipment.type == UNIT_ST_OBJ)
    {
       exec(&quot;say You &quot; + command + &quot; the &quot; + equipment.title + &quot;.&quot;, self);
    }
    else
    {
       exec(&quot;say You can only &quot; + command + &quot; equipment.&quot;, self);
       block;
    }
    
    goto start;
 } dilend

=== Type Validation in Functions ===
 dilbegin type_validator();
 var
    unit : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;checktype&quot;));
    unit := activator;
    
    // Validate unit type before processing
    if (unit.type == UNIT_ST_OBJ)
    {
       exec(&quot;say Unit is an object of type: &quot; + itoa(unit.objecttype) + &quot;.&quot;, self);
    }
    else if (unit.type == UNIT_ST_PC)
    {
       exec(&quot;say Unit is a player character.&quot;, self);
    }
    else if (unit.type == UNIT_ST_NPC)
    {
       exec(&quot;say Unit is an NPC.&quot;, self);
    }
    else
    {
       exec(&quot;say Unit is of unknown type.&quot;, self);
    }
    
    goto start;
 } dilend

=== Combined Type Checking ===
 dilbegin multi_type_checker();
 var
    unit : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    unit := activator;
    
    // Handle different types appropriately
    if (unit.type == UNIT_ST_OBJ)
    {
       exec(&quot;say Processing object: &quot; + unit.title, self);
       // Object-specific logic
    }
    else if (unit.type == UNIT_ST_PC)
    {
       exec(&quot;say Processing player: &quot; + unit.name, self);
       // Player-specific logic
    }
    else if (unit.type == UNIT_ST_NPC)
    {
       exec(&quot;say Processing NPC: &quot; + unit.name, self);
       // NPC-specific logic
    }
    else if (unit.type == UNIT_ST_ROOM)
    {
       exec(&quot;say Processing room: &quot; + unit.title, self);
       // Room-specific logic
    }
    else
    {
       exec(&quot;say Unknown unit type.&quot;, self);
    }
    
    goto start;
 } dilend

=== Object Property Access ===
 dilbegin object_properties();
 var
    item : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;info&quot;));
    item := activator;
    
    if (item.type == UNIT_ST_OBJ)
    {
       exec(&quot;say Object type: &quot; + itoa(item.objecttype), self);
       exec(&quot;say Object value: &quot; + itoa(item.value[0]), self);
       exec(&quot;say Object flags: &quot; + itoa(item.objectflags), self);
       exec(&quot;say Object cost: &quot; + itoa(item.cost), self);
       exec(&quot;say Object rent: &quot; + itoa(item.rent), self);
    }
    else
    {
       exec(&quot;say Target is not an object.&quot;, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; is used to distinguish objects from characters and rooms
* The constant is read-only and cannot be modified at runtime
* Type checking is commonly done using the &apos;&apos;&apos;type&apos;&apos;&apos; function with &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; constant
* Objects have special properties like &apos;&apos;&apos;objecttype&apos;&apos;&apos;, &apos;&apos;&apos;value[]&apos;&apos;&apos;, &apos;&apos;&apos;objectflags&apos;&apos;&apos;, &apos;&apos;&apos;cost&apos;&apos;&apos;, &apos;&apos;&apos;rent&apos;&apos;&apos;, and &apos;&apos;&apos;equip&apos;&apos;&apos;
* The constant is essential for implementing object-specific behaviors and restrictions
* Type checking prevents inappropriate operations on non-objects
* &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; is complementary to &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; and &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; constants

== Error Handling ==
* Always validate that unit pointers are not null before checking their type
* Remember that &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; is a constant, not a variable that can be changed
* Use proper bounds checking when accessing object properties by index
* Be careful with assumptions about unit types - always validate using the &apos;&apos;&apos;type&apos;&apos;&apos; function
* Test type checking logic thoroughly with all possible unit types
* Consider edge cases where unit type might be unknown or invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/type|type]] - Function to get the type of a unit
* [[Manual:DIL_Manual/objecttype|objecttype]] - Object type field (read-only)
* [[Manual:DIL_Manual/value|value]] - Object values array (read/write)
* [[Manual:DIL_Manual/objectflags|objectflags]] - Object flags field (read/write)
* [[Manual:DIL_Manual/cost|cost]] - Object cost field (read/write)
* [[Manual:DIL_Manual/rent|rent]] - Object rent field (read/write)
* [[Manual:DIL_Manual/equip|equip]] - Equipment position field (read/write)
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant
* [[Manual:DIL_Manual/type|type]] - Unit type checking function

* [[Manual:DIL_Manual/objecttype|objecttype]] - Object type field documentation
* [[Manual:DIL_Manual/value|value]] - Object values array documentation
* [[Manual:DIL_Manual/objectflags|objectflags]] - Object flags field documentation
* [[Manual:DIL_Manual/cost|cost]] - Object cost field documentation
* [[Manual:DIL_Manual/rent|rent]] - Object rent field documentation
* [[Manual:DIL_Manual/equip|equip]] - Equipment position field documentation
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unit_st_pc and unit_st_npc</title>
     <ns>0</ns>
     <id>753463</id>
     <revision>
       <id>1134032</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unit_st_pc and unit_st_npc.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= UNIT_ST_PC =

 constant: &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos;

Unit type constant that identifies player characters.

== Description ==
The &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; constant is used to identify units that are player characters (PCs) in the DikuMUD3 system. This constant is commonly used in type checking operations to distinguish between player-controlled characters and non-player characters (NPCs), or to implement player-specific behaviors and restrictions.

When checking unit types, the following constants are commonly used together:
* &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; - Player characters
* &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; - Non-player characters
* &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; - Objects
* &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; - Rooms

The &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; constant is read-only and cannot be modified at runtime. It&apos;s primarily used with the &apos;&apos;&apos;type&apos;&apos;&apos; function to determine the actual type of a unit pointer, and in conditional statements to implement player-specific logic.

== Examples ==
=== Basic Type Checking ===
 dilbegin player_checker();
 var
    target : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    target := activator;
    
    if (target.type == UNIT_ST_PC)
    {
       exec(&quot;say Target is a player character.&quot;, self);
    }
    else if (target.type == UNIT_ST_NPC)
    {
       exec(&quot;say Target is an NPC.&quot;, self);
    }
    else
    {
       exec(&quot;say Target is of unknown type.&quot;, self);
    }
    
    goto start;
 } dilend

=== Player-Specific Behavior ===
 dilbegin player_only_logic();
 var
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    if (activator.type == UNIT_ST_PC)
    {
       exec(&quot;say Player-specific action executed.&quot;, self);
       // Player-specific logic here
    }
    else
    {
       exec(&quot;say Non-player cannot use this action.&quot;, self);
    }
    
    goto start;
 } dilend

=== Combined Type Checking ===
 dilbegin multi_type_handler();
 var
    unit : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    unit := activator;
    
    // Handle different types appropriately
    if (unit.type == UNIT_ST_PC)
    {
       exec(&quot;say Processing player character.&quot;, self);
    }
    else if (unit.type == UNIT_ST_NPC)
    {
       exec(&quot;say Processing NPC.&quot;, self);
    }
    else if (unit.type == UNIT_ST_OBJ)
    {
       exec(&quot;say Processing object.&quot;, self);
    }
    else if (unit.type == UNIT_ST_ROOM)
    {
       exec(&quot;say Processing room.&quot;, self);
    }
    else
    {
       exec(&quot;say Unknown unit type.&quot;, self);
    }
    
    goto start;
 } dilend

=== Type Validation with Constants ===
 dilbegin type_validation();
 var
    unit : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;checktype&quot;));
    unit := activator;
    
    // Use constants for comparison
    if (unit.type == UNIT_ST_PC)
    {
       exec(&quot;say Valid player character type.&quot;, self);
    }
    else if (unit.type == UNIT_ST_NPC)
    {
       exec(&quot;say Valid NPC type.&quot;, self);
    }
    else
    {
       exec(&quot;say Invalid type for this operation.&quot;, self);
    }
    
    goto start;
 } dilend

=== Player Data Access ===
 dilbegin player_data_access();
 var
    player : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;getstats&quot;));
    player := activator;
    
    if (player.type == UNIT_ST_PC)
    {
       exec(&quot;say Accessing player data: birth=&quot; + itoa(player.birth) + &quot;, skills=&quot; + itoa(player.skill_points), self);
    }
    else
    {
       exec(&quot;say Only players have birth data.&quot;, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; is used to distinguish player characters from other unit types
* The constant is read-only and cannot be modified at runtime
* Type checking is commonly done using the &apos;&apos;&apos;type&apos;&apos;&apos; function with &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; constant
* Player characters have access to special fields like &apos;&apos;&apos;birth&apos;&apos;&apos;, &apos;&apos;&apos;skills&apos;&apos;&apos;, &apos;&apos;&apos;skill_points&apos;&apos;&apos;, etc.
* The constant is essential for implementing player-specific features, restrictions, and behaviors
* Type checking prevents NPCs from accessing player-only data or performing player-only actions
* The constant works with other unit type constants for comprehensive type handling

== Error Handling ==
* Always validate that unit pointers are not null before checking their type
* Remember that &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; is a constant, not a variable that can be changed
* Use proper type checking to avoid runtime errors
* Be careful with assumptions about unit types - always validate using constants
* Test type checking logic with all possible unit types (PC, NPC, OBJ, ROOM)
* Consider edge cases where unit type might be unknown or invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/type|type]] - Function to get the type of a unit
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant
* [[Manual:DIL_Manual/activator|activator]] - Unit pointer to the unit performing an action
* [[Manual:DIL_Manual/birth|birth]] - Player birth field (PC only)
* [[Manual:DIL_Manual/skills|skills]] - Player skills field (PC only)
* [[Manual:DIL_Manual/skill_points|skill_points]] - Player skill points field (PC only)

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant
* [[Manual:DIL_Manual/type|type]] - Unit type checking function

</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unit_st_pc</title>
     <ns>0</ns>
     <id>457572</id>
     <revision>
       <id>1541526</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unit_st_pc.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= UNIT_ST_PC =

 constant: &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos;

Unit type constant that identifies player characters.

== Description ==
The &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; constant is used to identify units that are player characters (PCs) in the DikuMUD3 system. This constant is commonly used in type checking operations to distinguish between player-controlled characters and non-player characters (NPCs), or to implement player-specific behaviors and restrictions.

When checking unit types, the following constants are commonly used together:
* &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; - Player characters
* &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; - Non-player characters
* &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; - Objects
* &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; - Rooms

The &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; constant is read-only and cannot be modified at runtime. It&apos;s primarily used with the &apos;&apos;&apos;type&apos;&apos;&apos; function to determine the actual type of a unit pointer, and in conditional statements to implement different behaviors based on whether a unit is a player character or not.

== Examples ==
=== Basic Type Checking ===
 dilbegin player_detector();
 var
    target : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    target := activator;
    
    if (target.type == UNIT_ST_PC)
    {
       exec(&quot;say Target is a player character.&quot;, self);
    }
    else
    {
       exec(&quot;say Target is not a player character.&quot;, self);
    }
    
    goto start;
 } dilend

=== Player-Specific Behavior ===
 dilbegin player_only_action();
 var
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    if (activator.type == UNIT_ST_PC)
    {
       exec(&quot;say Player-specific action executed.&quot;, self);
    }
    else
    {
       exec(&quot;say Non-players cannot use this action.&quot;, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; is used to distinguish player characters from other unit types
* The constant is read-only and cannot be modified at runtime
* Type checking is commonly done using the &apos;&apos;&apos;type&apos;&apos;&apos; function with &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; constant
* Player characters have access to special fields like &apos;&apos;&apos;birth&apos;&apos;&apos;, &apos;&apos;&apos;skills&apos;&apos;&apos;, &apos;&apos;&apos;skill_points&apos;&apos;&apos;, etc.
* The constant is essential for implementing player-specific features and restrictions
* Type checking prevents NPCs from accessing player-only data or performing player-only actions
* Always validate unit pointers before checking their type
* Use proper bounds checking when accessing player data by index
* The constant works with other unit type constants for comprehensive type handling

== Error Handling ==
* Always validate that unit pointers are not null before checking their type
* Remember that &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; is a constant, not a variable that can be changed
* Use proper type checking to avoid runtime errors
* Be careful with assumptions about unit types - always validate using constants
* Test type checking logic thoroughly with all possible unit types
* Consider edge cases where unit type might be unknown or invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/type|type]] - Function to get the type of a unit
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant
* [[Manual:DIL_Manual/birth|birth]] - Player birth field (PC only)
* [[Manual:DIL_Manual/skills|skills]] - Player skills field (PC only)
* [[Manual:DIL_Manual/skill_points|skill_points]] - Player skill points field (PC only)
* [[Manual:DIL_Manual/ability_points|ability_points]] - Player ability points field (PC only)
* [[Manual:DIL_Manual/pcflags|pcflags]] - Player flags field (PC only)
* [[Manual:DIL_Manual/playtime|playtime]] - Player play time field (PC only)
* [[Manual:DIL_Manual/exptol|exptol]] - Player experience points field (PC only)
* [[Manual:DIL_Manual/guild|guild]] - Player guild field (PC only)
* [[Manual:DIL_Manual/prompt|prompt]] - Player prompt field (PC only)
* [[Manual:DIL_Manual/crimes|crimes]] - Player crimes field (PC only)
* [[Manual:DIL_Manual/full|full]] - Player full field (PC only)
* [[Manual:DIL_Manual/thirst|thirst]] - Player thirst field (PC only)
* [[Manual:DIL_Manual/drunk|drunk]] - Player drunk field (PC only)
* [[Manual:DIL_Manual/quests|quests]] - Player quests field (PC only)
* [[Manual:DIL_Manual/info|info]] - Player info field (PC only)
* [[Manual:DIL_Manual/acc_balance|acc_balance]] - Player account balance field (PC only)
* [[Manual:DIL_Manual/acc_total|acc_total]] - Player account total field (PC only)

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant
* [[Manual:DIL_Manual/type|type]] - Unit type checking function
* [[Manual:DIL_Manual/birth|birth]] - Player birth field documentation
* [[Manual:DIL_Manual/skills|skills]] - Player skills field documentation
* [[Manual:DIL_Manual/skill_points|skill_points]] - Player skill points field documentation
* [[Manual:DIL_Manual/ability_points|ability_points]] - Player ability points field documentation
* [[Manual:DIL_Manual/pcflags|pcflags]] - Player flags field documentation
* [[Manual:DIL_Manual/playtime|playtime]] - Player play time field documentation
* [[Manual:DIL_Manual/exptol|exptol]] - Player experience points field documentation
* [[Manual:DIL_Manual/guild|guild]] - Player guild field documentation
* [[Manual:DIL_Manual/prompt|prompt]] - Player prompt field documentation
* [[Manual:DIL_Manual/crimes|crimes]] - Player crimes field documentation
* [[Manual:DIL_Manual/full|full]] - Player full field documentation
* [[Manual:DIL_Manual/thirst|thirst]] - Player thirst field documentation
* [[Manual:DIL_Manual/drunk|drunk]] - Player drunk field documentation
* [[Manual:DIL_Manual/quests|quests]] - Player quests field documentation
* [[Manual:DIL_Manual/info|info]] - Player info field documentation
* [[Manual:DIL_Manual/acc_balance|acc_balance]] - Player account balance field documentation
* [[Manual:DIL_Manual/acc_total|acc_total]] - Player account total field documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unit_st_room</title>
     <ns>0</ns>
     <id>366384</id>
     <revision>
       <id>930707</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unit_st_room.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= UNIT_ST_ROOM =

 constant: &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos;

Unit type constant that identifies rooms.

== Description ==
The &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; constant is used to identify units that are rooms in the DikuMUD3 system. This constant is commonly used in type checking operations to distinguish between rooms and other unit types like characters, objects, or NPCs.

When checking unit types, the following constants are commonly used together:
* &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; - Rooms
* &apos;&apos;&apos;UNIT_ST_PC&apos;&apos;&apos; - Player characters
* &apos;&apos;&apos;UNIT_ST_NPC&apos;&apos;&apos; - Non-player characters
* &apos;&apos;&apos;UNIT_ST_OBJ&apos;&apos;&apos; - Objects

The &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; constant is read-only and cannot be modified at runtime. It&apos;s primarily used with the &apos;&apos;&apos;type&apos;&apos;&apos; function to determine the actual type of a unit pointer and in conditional statements to implement room-specific behaviors.

== Examples ==
=== Basic Room Type Check ===
 dilbegin room_checker();
 var
    target : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    target := activator;
    
    if (target.type == UNIT_ST_ROOM)
    {
       exec(&quot;say Target is a room.&quot;, self);
    }
    else
    {
       exec(&quot;say Target is not a room.&quot;, self);
    }
    
    goto start;
 } dilend

=== Room Property Access ===
 dilbegin room_properties();
 var
    room : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;roominfo&quot;));
    room := activator;
    
    if (room.type == UNIT_ST_ROOM)
    {
       exec(&quot;say Room name: &quot; + room.name, self);
       exec(&quot;say Room description: &quot; + room.descr, self);
       exec(&quot;say Room flags: &quot; + itoa(room.roomflags), self);
    }
    else
    {
       exec(&quot;say Target is not a room.&quot;, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; is used to distinguish rooms from other unit types
* The constant is read-only and cannot be modified at runtime
* Type checking is commonly done using bitwise operations with other unit type constants
* Rooms have special properties like &apos;&apos;&apos;roomflags&apos;&apos;&apos;, &apos;&apos;&apos;movement&apos;&apos;&apos;, and &apos;&apos;&apos;exit_names[]&apos;&apos;&apos;
* The constant is essential for implementing room-specific behaviors and restrictions
* Type checking prevents inappropriate operations on non-room units
* Always validate unit pointers before checking their type
* Use proper bounds checking when accessing room properties by index

== Error Handling ==
* Always validate that unit pointers are not null before checking their type
* Remember that &apos;&apos;&apos;UNIT_ST_ROOM&apos;&apos;&apos; is a constant, not a variable that can be changed
* Use proper type checking to avoid runtime errors
* Be careful with assumptions about unit types - always validate using constants
* Test type checking logic thoroughly with all possible unit types
* Consider edge cases where unit type might be unknown or invalid
* Use appropriate bounds checking when accessing room properties by index

== Related Functions/Fields ==
* [[Manual:DIL_Manual/type|type]] - Function to get the type of a unit
* [[Manual:DIL_Manual/roomflags|roomflags]] - Room flags field (room only)
* [[Manual:DIL_Manual/movement|movement]] - Room movement field (room only)
* [[Manual:DIL_Manual/exit_names|exit_names]] - Room exit names field (room only)
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant
* [[Manual:DIL_Manual/type|type]] - Unit type checking function
* [[Manual:DIL_Manual/roomflags|roomflags]] - Room flags field documentation
* [[Manual:DIL_Manual/movement|movement]] - Room movement field documentation
* [[Manual:DIL_Manual/exit_names|exit_names]] - Room exit names field documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unitdir</title>
     <ns>0</ns>
     <id>773615</id>
     <revision>
       <id>1706539</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unitdir.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= unitdir =
 function: stringlist &apos;&apos;&apos;unitdir&apos;&apos;&apos;(match : string);

The &apos;&apos;&apos;unitdir&apos;&apos;&apos; function returns a list of unit files matching a pattern.

== Description ==
This function searches the units directory for files matching the specified pattern and returns them as a stringlist. The pattern parameter supports Linux-style wildcards including asterisk (*) for any characters, question mark (?) for single characters, and character classes ([...]). This function is commonly used for finding and loading unit files based on naming patterns.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| match || string || The wildcard pattern to match against filenames in the units directory
|}

== Examples ==
=== Basic Pattern Matching ===
dilbegin unique find_corpses();
var
    corpselist : stringlist;
    i : integer;
code
{
    // Find all files starting with &quot;corpse&quot;
    corpselist := unitdir(&quot;corpse*&quot;);
    
    sendto(&quot;Found &quot; + itoa(length(corpselist)) + &quot; corpse files:&amp;n&quot;, self);
    
    // Process each corpse file
    for (i := 0; i &lt; length(corpselist); i := i + 1)
    {
        sendto(&quot;  &quot; + corpselist.[i] + &quot;&amp;n&quot;, self);
    }
} dilend

=== Load by Pattern ===
dilbegin unique load_by_pattern(pattern : string);
var
    filelist : stringlist;
    i : integer;
    unit : unitptr;
code
{
    // Get all files matching the pattern
    filelist := unitdir(pattern);
    
    if (length(filelist) == 0)
    {
        sendto(&quot;No files found matching pattern: &quot; + pattern + &quot;&amp;n&quot;, self);
        quit;
    }
    
    sendto(&quot;Files matching &apos;&quot; + pattern + &quot;&apos;:&amp;n&quot;, self);
    for (i := 0; i &lt; length(filelist); i := i + 1)
    {
        sendto(&quot;  &quot; + filelist.[i] + &quot;&amp;n&quot;, self);
        
        // Restore the first matching file
        if (i == 0)
        {
            unit := restore(filelist.[i], null);
            if (unit != null)
            {
                sendto(&quot;  Restored: &quot; + unit.name + &quot;&amp;n&quot;, self);
            }
        }
    }
} dilend

== Usage Notes ==
* The function searches the units subdirectory of the current zone&apos;s DIL file path.
* Pattern matching follows Linux shell wildcard rules:
** * - Matches any sequence of characters
** ? - Matches any single character  
** [...] - Matches any one of the enclosed characters
* The function returns a stringlist containing only the matching filenames (not full paths).
* Commonly used with [[Manual:DIL_Manual/restore|restore]]() function to load matching unit files.
* If no files match the pattern, an empty stringlist is returned.
* The pattern matching is case-sensitive.
* Useful for batch operations on groups of related unit files.

== Error Handling ==
* If the match parameter is not a string, a DIL fatal error occurs: &quot;Arg 1 of &apos;unitdir&apos; not string&quot;.
* If the units directory doesn&apos;t exist or is inaccessible, the function returns an empty stringlist.
* If the pattern contains invalid regex syntax, the function may fail or return unexpected results.
* File system errors (permissions, etc.) will result in an empty stringlist being returned.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/restore|restore]] - Loads a unit from a file
* [[Manual:DIL_Manual/savestr|savestr]] - Saves string data to files
* [[Manual:DIL_Manual/loadstr|loadstr]] - Loads string data from files
* [[Manual:DIL_Manual/delstr|delstr]] - Deletes files

== See Also ==
* File system functions
* Pattern matching functions
* Unit management functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unitptr</title>
     <ns>0</ns>
     <id>1159803</id>
     <revision>
       <id>1561494</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unitptr.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= unitptr =

 type: &apos;&apos;&apos;unitptr&apos;&apos;&apos;

Pointer type that references units in the DikuMUD3 system.

== Description ==
The &apos;&apos;&apos;unitptr&apos;&apos;&apos; type is a pointer type that can reference any unit in the game world, including player characters (PCs), non-player characters (NPCs), objects, or rooms. This type is fundamental to DIL programming as it allows programs to interact with and manipulate any unit in the game world.

The &apos;&apos;&apos;unitptr&apos;&apos;&apos; type is used throughout DIL to:
* Reference specific units for actions, combat, or interactions
* Store unit references for later use
* Pass units as parameters to functions
* Check unit types and properties before performing operations
* Navigate unit hierarchies (inside/outside relationships)
* Access unit fields and properties for reading or modification

== Examples ==
=== Basic Unit Reference ===
 dilbegin unit_reference();
 var
    target : unitptr;
    player : unitptr;
    npc : unitptr;
    item : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    target := activator;
    
    // Store different unit references
    player := target;
    npc := findunit(&quot;guard&quot;, UNIT_ST_NPC);
    item := findunit(&quot;sword&quot;, UNIT_ST_OBJ);
    
    // Use the references
    exec(&quot;say Target is: &quot; + target.name, self);
    exec(&quot;say NPC reference: &quot; + npc.name, self);
    exec(&quot;say Item reference: &quot; + item.title, self);
    
    goto start;
 } dilend

=== Unit Type Checking ===
 dilbegin type_checker();
 var
    unit : unitptr;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;examine&quot;));
    unit := activator;
    
    if (unit.type == UNIT_ST_PC)
    {
       exec(&quot;say Target is a player character.&quot;, self);
    }
    else if (unit.type == UNIT_ST_NPC)
    {
       exec(&quot;say Target is an NPC.&quot;, self);
    }
    else if (unit.type == UNIT_ST_OBJ)
    {
       exec(&quot;say Target is an object.&quot;, self);
    }
    else
    {
       exec(&quot;say Target is of unknown type.&quot;, self);
    }
    
    goto start;
 } dilend

=== Unit Property Access ===
 dilbegin property_reader();
 var
    unit : unitptr;
    hp : integer;
    name : string;
 code
 {
    :start:
    wait(SFB_CMD, command(&quot;getstats&quot;));
    unit := activator;
    
    if (unit.type == UNIT_ST_PC)
    {
       name := unit.name;
       hp := unit.hp;
       exec(&quot;say Player &quot; + name + &quot; has &quot; + itoa(hp) + &quot; hitpoints.&quot;, self);
    }
    else
    {
       exec(&quot;say Target is not a player character.&quot;, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;unitptr&apos;&apos;&apos; type is the fundamental way to reference units in DIL
* Always validate that unit pointers are not null before using them
* Use the &apos;&apos;&apos;type&apos;&apos;&apos; function to determine the actual type of a unit before operations
* Unit pointers can reference any unit type (PC, NPC, OBJ, ROOM)
* The type is commonly used for storing unit references in variables
* Unit pointers can be passed as parameters to functions that expect unitptr types
* Be careful with unit pointer arithmetic - it&apos;s not supported for navigation or positioning
* Use proper type checking to ensure operations are valid for the specific unit type

== Error Handling ==
* Always validate that unit pointers are not null before dereferencing
* Remember that unit pointers reference actual units, not copies
* Use proper bounds checking when accessing unit arrays or properties
* Be careful with assumptions about unit types - always validate using constants
* Test unit pointer operations thoroughly with all possible unit types
* Consider edge cases where unit pointers might be null or invalid

== Related Functions/Fields ==
* [[Manual:DIL_Manual/type|type]] - Function to get the type of a unit
* [[Manual:DIL_Manual/findunit|findunit]] - Function to find a unit by name and type
* [[Manual:DIL_Manual/addequip|addequip]] / [[Manual:DIL_Manual/unequip|unequip]] - Equipment management functions
* [[Manual:DIL_Manual/inside|inside]] / [[Manual:DIL_Manual/outside|outside]] - Unit hierarchy navigation
* [[Manual:DIL_Manual/names|names]] - Unit name list field
* [[Manual:DIL_Manual/title|title]] - Unit title field
* [[Manual:DIL_Manual/extra|extra]] - Unit extra descriptions field
* [[Manual:DIL_Manual/hp|hp]] - Unit hitpoints field
* [[Manual:DIL_Manual/max_hp|max_hp]] - Unit maximum hitpoints field
* [[Manual:DIL_Manual/alignment|alignment]] - Unit alignment field
* [[Manual:DIL_Manual/openflags|openflags]] - Unit open flags field
* [[Manual:DIL_Manual/light|light]] - Unit light level field
* [[Manual:DIL_Manual/bright|bright]] - Unit brightness level field
* [[Manual:DIL_Manual/illum|illum]] - Unit illumination level field
* [[Manual:DIL_Manual/minv|minv]] - Unit minimum visibility level field
* [[Manual:DIL_Manual/spells|spells]] - Unit spells array field
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - Unit zone index field
* [[Manual:DIL_Manual/nameidx|nameidx]] - Unit name index field
* [[Manual:DIL_Manual/symname|symname]] - Unit symbolic name field
* [[Manual:DIL_Manual/idx|idx]] - Unit constant ID field
* [[Manual:DIL_Manual/hasfunc|hasfunc]] - Unit function presence field
* [[Manual:DIL_Manual/manipulate|manipulate]] - Unit manipulation procedure
* [[Manual:DIL_Manual/setweight|setweight]] - Unit weight setting procedure
* [[Manual:DIL_Manual/weight|weight]] - Unit weight field
* [[Manual:DIL_Manual/height|height]] - Unit height field
* [[Manual:DIL_Manual/capacity|capacity]] - Unit capacity field
* [[Manual:DIL_Manual/lifespan|lifespan]] - Unit lifespan field
* [[Manual:DIL_Manual/key|key]] - Unit key field
* [[Manual:DIL_Manual/gnext|gnext]] / [[Manual:DIL_Manual/gprevious|gprevious]] - Unit navigation fields
* [[Manual:DIL_Manual/master|master]] - Unit master field
* [[Manual:DIL_Manual/loadcount|loadcount]] - Unit load count field

== See Also ==
* [[Manual:DIL_Manual/UNIT_ST_PC|UNIT_ST_PC]] - Player character type constant
* [[Manual:DIL_Manual/UNIT_ST_NPC|UNIT_ST_NPC]] - NPC type constant
* [[Manual:DIL_Manual/UNIT_ST_OBJ|UNIT_ST_OBJ]] - Object type constant
* [[Manual:DIL_Manual/UNIT_ST_ROOM|UNIT_ST_ROOM]] - Room type constant
* [[Manual:DIL_Manual/type|type]] - Unit type checking function
* [[Manual:DIL_Manual/findunit|findunit]] - Unit finding function
* [[Manual:DIL_Manual/addequip|addequip]] - Equipment management
* [[Manual:DIL_Manual/inside|inside]] / [[Manual:DIL_Manual/outside|outside]] - Unit hierarchy
* [[Manual:DIL_Manual/names|names]] - Unit name list
* [[Manual:DIL_Manual/title|title]] - Unit title field
* [[Manual:DIL_Manual/extra|extra]] - Unit extra descriptions
* [[Manual:DIL_Manual/hp|hp]] - Unit hitpoints field
* [[Manual:DIL_Manual/alignment|alignment]] - Unit alignment field
* [[Manual:DIL_Manual/openflags|openflags]] - Unit open flags field
* [[Manual:DIL_Manual/light|light]] - Unit light level field
* [[Manual:DIL_Manual/bright|bright]] - Unit brightness level field
* [[Manual:DIL_Manual/illum|illum]] - Unit illumination level field
* [[Manual:DIL_Manual/minv|minv]] - Unit minimum visibility level field
* [[Manual:DIL_Manual/spells|spells]] - Unit spells field
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - Unit zone index field
* [[Manual:DIL_Manual/nameidx|nameidx]] - Unit name index field
* [[Manual:DIL_Manual/symname|symname]] - Unit symbolic name field
* [[Manual:DIL_Manual/idx|idx]] - Unit constant ID field
* [[Manual:DIL_Manual/hasfunc|hasfunc]] - Unit function presence field
* [[Manual:DIL_Manual/manipulate|manipulate]] - Unit manipulation procedure
* [[Manual:DIL_Manual/setweight|setweight]] - Unit weight setting procedure
* [[Manual:DIL_Manual/weight|weight]] - Unit weight field
* [[Manual:DIL_Manual/height|height]] - Unit height field
* [[Manual:DIL_Manual/capacity|capacity]] - Unit capacity field
* [[Manual:DIL_Manual/lifespan|lifespan]] - Unit lifespan field
* [[Manual:DIL_Manual/key|key]] - Unit key field
* [[Manual:DIL_Manual/gnext|gnext]] / [[Manual:DIL_Manual/gprevious|gprevious]] - Unit navigation fields
* [[Manual:DIL_Manual/master|master]] - Unit master field
* [[Manual:DIL_Manual/loadcount|loadcount]] - Unit load count field</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unsecure</title>
     <ns>0</ns>
     <id>828860</id>
     <revision>
       <id>1355830</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unsecure.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= unsecure =
 procedure: &apos;&apos;&apos;unsecure&apos;&apos;&apos;(u : unitptr);

The &apos;&apos;&apos;unsecure&apos;&apos;&apos; procedure removes secure protection from a previously secured unit.

== Description ==
This procedure removes the secure protection that was placed on a unit using the [[Manual:DIL_Manual/secure|secure]]() procedure. Once a unit is unsecured, it can be modified, destroyed, or moved by other DIL programs. The secure/unsecure mechanism is used to prevent race conditions and protect units during critical operations.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| u || unitptr || The unit to remove secure protection from
|}

== Examples ==
=== Basic Item Processing ===
dilbegin unique process_item(item : unitptr);
var
    original_owner : unitptr;
code
{
    // Secure the item to prevent interference
    secure(item, :item_lost);
    
    // Process the item safely
    original_owner := item.outside;
    sendto(&quot;Processing &quot; + item.title + &quot;...&amp;n&quot;, self);
    
    // Remove secure protection when done
    unsecure(item);
    
    // Continue with normal operations
    act(&quot;$1n finishes processing $2n.&quot;, A_ALWAYS, self, item, null, TO_ROOM);
} dilend

=== Temporary Protection ===
dilbegin unique temporary_protection();
var
    protected_unit : unitptr;
code
{
    protected_unit := self;
    
    // Secure the unit
    secure(protected_unit, :protection_active);
    sendto(&quot;You are now protected from interference.&amp;n&quot;, protected_unit);
    
    // Simulate some processing time
    heartbeat := PULSE_SEC * 5;
    pause;
    
    // Remove protection
    unsecure(protected_unit);
    sendto(&quot;Protection removed.&amp;n&quot;, protected_unit);
} dilend

== Usage Notes ==
* The unit parameter must have been previously secured using the [[Manual:DIL_Manual/secure|secure]]() procedure.
* Each call to [[Manual:DIL_Manual/secure|secure]]() should have a corresponding call to &apos;&apos;&apos;unsecure&apos;&apos;&apos;() to avoid leaving units permanently secured.
* The secure/unsecure mechanism prevents other DIL programs from modifying the unit during critical operations.
* Commonly used when:
** Processing items that might be targeted by other programs
** Transferring items between characters
** Performing complex operations that shouldn&apos;t be interrupted
** Temporarily protecting units during calculations or modifications
* If the unit leaves the local environment (destroyed, moved to different location, etc.), the secure is automatically broken and execution jumps to the specified label.
* The procedure is essential for proper resource management and preventing deadlocks.

== Error Handling ==
* If the unit parameter is not a unitptr, a DIL fatal error occurs: &quot;Arg 1 of &apos;unsecure&apos; not a unit&quot;.
* If the unit was not previously secured, the procedure has no effect but does not cause an error.
* If the unit pointer is null, the procedure fails silently.
* The procedure will fail if the unit is not in the current DIL program&apos;s local environment.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/secure|secure]] - Secures a unit and sets up protection monitoring
* [[Manual:DIL_Manual/dil_sub_secure|dil_sub_secure]] - Internal function called by unsecure
* [[Manual:DIL_Manual/findsymbolic|findsymbolic]] - Used to check if units are in local environment

== See Also ==
* DIL program security mechanisms
* Resource management functions
* Unit protection and synchronization</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/unset</title>
     <ns>0</ns>
     <id>1191915</id>
     <revision>
       <id>1686329</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of unset.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= unset =
 procedure: &apos;&apos;&apos;unset&apos;&apos;&apos;(var : integer, bit : integer);

The &apos;&apos;&apos;unset&apos;&apos;&apos; procedure clears specific bits in an integer variable.

== Description ==
This procedure removes (clears) specific bits from an integer variable by setting them to 0. It supports various integer types including signed and unsigned integers of different sizes (8-bit, 16-bit, 32-bit). This is commonly used for clearing status flags, protection flags, and other bit-based properties in DIL programs.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| var || integer || The integer variable to modify
|-
| bit || integer || The bit position to clear (0-based)
|}

== Examples ==
=== Clear Character Flag ===
dilbegin unique clear_defence();
var
    defence_flags : integer;
code
{
    // Clear self-defence flag
    defence_flags := self.charflags;
    unset(defence_flags, CHAR_SELF_DEFENCE);
    self.charflags := defence_flags;
    
    sendto(&quot;Self-defence flag cleared.&amp;n&quot;, self);
} dilend

=== Clear Multiple Flags ===
dilbegin unique remove_protection();
var
    protection_flags : integer;
code
{
    // Clear multiple protection flags
    protection_flags := self.pcflags;
    unset(protection_flags, PC_SPIRIT);
    unset(protection_flags, PC_PK_RELAXED);
    unset(protection_flags, PC_INFORM);
    self.pcflags := protection_flags;
    
    sendto(&quot;Protection flags cleared.&amp;n&quot;, self);
} dilend

=== Unlock Door ===
dilbegin unique unlock_door(door : unitptr);
var
    door_flags : integer;
code
{
    // Clear locked flag on door
    door_flags := door.openflags;
    unset(door_flags, EX_LOCKED);
    door.openflags := door_flags;
    
    act(&quot;$1n unlocks $2n.&quot;, A_ALWAYS, self, door, null, TO_ROOM);
    sendto(&quot;Door unlocked.&amp;n&quot;, self);
} dilend

== Usage Notes ==
* The procedure works on integer variables of various sizes:
** sbit8 - 8-bit signed integer
** sbit16 - 16-bit signed integer  
** sbit32 - 32-bit signed integer
** ubit8 - 8-bit unsigned integer
** ubit16 - 16-bit unsigned integer
** ubit32 - 32-bit unsigned integer
* The bit parameter is 0-based (bit 0 clears the least significant bit).
* Commonly used for clearing flag bits in character flags, door flags, and other status properties.
* The procedure modifies the variable in-place; the original variable is updated.
* Often used in conjunction with [[Manual:DIL_Manual/setbit|setbit]] or bitwise operations for flag management.
* Bit positions are typically defined by constants in values.h and/or vme.h (e.g., CHAR_SELF_DEFENCE, PC_SPIRIT, EX_LOCKED).

== Error Handling ==
* If the first parameter is not an integer variable, a DIL fatal error occurs: &quot;Arg 1 of &apos;unset&apos; not an integer variable&quot;.
* If the second parameter is not an integer, a DIL fatal error occurs: &quot;Arg 2 of &apos;unset&apos; not an integer&quot;.
* If the first parameter is not an lvalue (assignable), a DIL type error occurs: &quot;lvalue unset&quot;.
* The procedure will fail if the bit position is out of range for the integer type.

== Related Functions/Fields ==
* [[Manual:DIL_Manual/setbit|setbit]] - Sets specific bits in an integer variable
* [[Manual:DIL_Manual/is_set|is_set]] - Checks if specific bits are set in an integer variable
* [[Manual:DIL_Manual/charflags|charflags]] - Character flags field (common target for unset operations)
* [[Manual:DIL_Manual/pcflags|pcflags]] - Player character flags field
* [[Manual:DIL_Manual/openflags|openflags]] - Door/container open flags field

== See Also ==
* Bit manipulation functions
* Flag management functions
* Character status and property management</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/vals</title>
     <ns>0</ns>
     <id>346422</id>
     <revision>
       <id>1302499</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of vals.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= vals =
 field: {integerlist} &apos;&apos;&apos;.vals&apos;&apos;&apos; (Read/Write)
 
The &apos;&apos;&apos;vals&apos;&apos;&apos; field provides access to the integer list associated with an extra description structure.

== Description ==
The &apos;&apos;&apos;vals&apos;&apos;&apos; field is an integerlist that stores numeric values associated with an extra description. Each extra description can have parallel arrays of names (stringlist) and values (integerlist), allowing for structured data storage where each name corresponds to a numeric value.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| extra.vals || {integerlist} || Returns the integer list associated with the extra description
|}

== Availability ==
This field is available on the following unit types:
* extraptr (Extra description pointer)

== Examples ==
=== Basic Usage ===
 dilbegin process_donations();
 var
     i : integer;
     total : integer;
     extra : extraptr;
 
 code
 {
     extra := self.extra.[&quot;$dlist&quot;];
     total := 0;
     i := 0;
     while (i &lt; length(extra.vals))
     {
       total := total + extra.vals.[i];
       i := i + 1;
     }
     sendtext(&quot;Total donations: &quot; + itoa(total) + &quot;&lt;br/&gt;&quot;, activator);
 } dilend

=== Adding Values ===
 dilbegin add_value(name : string, value : integer);
 var
     extra : extraptr;
 
 code
 {
     extra := self.extra.[&quot;$stats&quot;];
     addstring(extra.names, name);
     insert(extra.vals, length(extra.vals), value);
 } dilend

=== Parallel Access ===
 dilbegin show_pairs();
 var
     i : integer;
     extra : extraptr;
     buf : string;
 
 code
 {
     extra := self.extra.[&quot;$pairs&quot;];
     buf := &quot;Name-Value Pairs:&lt;br/&gt;&quot;;
     i := 0;
     while (i &lt; length(extra.names) and i &lt; length(extra.vals))
     {
       buf := buf + extra.names.[i] + &quot;: &quot; + itoa(extra.vals.[i]) + &quot;&lt;br/&gt;&quot;;
       i := i + 1;
     }
     sendtext(buf, activator);
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;vals&apos;&apos;&apos; field is parallel to the [[Manual:DIL_Manual/#eptr|names]] field - they should have corresponding indices
* When accessing by index, ensure the index is within bounds using the [[Manual:DIL_Manual/#length|length()]] function
* The integerlist is saved with the unit if the extra description is on a savable unit
* If the extra description has no values, the field returns NULL

== Error Handling ==
* Accessing an out-of-bounds index will return NULL
* Attempting to access &apos;&apos;&apos;vals&apos;&apos;&apos; on a NULL extraptr will result in a runtime error
* The field automatically handles memory management for the integerlist

== Related Functions/Fields ==
* [[Manual:DIL_Manual/#eptr|extraptr.names]] - Corresponding stringlist for names
* [[Manual:DIL_Manual/#length|length()]] - Get the number of elements in the vals list
* [[Manual:DIL_Manual/#insert|insert()]] - Insert values into the integerlist
* [[Manual:DIL_Manual/#remove|remove()]] - Remove values from the integerlist

== See Also ==
* [[Manual:DIL_Manual/#eptr|extraptr]] - Extra description pointer type
* [[Manual:DIL_Manual/#intlist|intlist]] - Integer list type documentation

* [[Manual:DIL_Manual/#strl|stringlist]] - String list type documentation
</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/value</title>
     <ns>0</ns>
     <id>685172</id>
     <revision>
       <id>1685317</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of value.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= value =
 field: integer &apos;&apos;&apos;.value&apos;&apos;&apos;[index] (Read/Write)
 
The &apos;&apos;&apos;value&apos;&apos;&apos; field provides indexed access to an object&apos;s value array, which contains object-specific numeric data.

== Description ==
The &apos;&apos;&apos;value&apos;&apos;&apos; field is an array of 5 integers (indices 0-4) that stores object-specific data. The meaning and usage of each value index varies depending on the object&apos;s [[Manual:DIL_Manual/#uobj|objecttype]]. This field allows direct access to modify or read object properties such as weapon damage, armor protection, food nutrition, spell power, and other type-specific attributes.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| obj.value[index] || integer || Returns the integer value at the specified index (0-4)
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_OBJ (Object)

== Examples ==
=== Basic Weapon Usage ===
 dilbegin check_weapon_damage();
 var
   weapon : unitptr;
   damage : integer;
 
 code
 {
   weapon := self.equipment[WEAR_WIELD];
   if (weapon != null and weapon.objecttype == ITEM_WEAPON)
   {
     damage := weapon.value[1]; // Get weapon damage
     sendtext(&quot;Weapon damage: &quot; + itoa(damage) + &quot;&lt;br/&gt;&quot;, activator);
   }
 } dilend

=== Food Quality Check ===
 dilbegin check_food_quality();
 var
   food : unitptr;
   quality : integer;
 
 code
 {
   food := self.inside;
   if (food != null and food.objecttype == ITEM_FOOD)
   {
     quality := food.value[0]; // Get food quality/nutrition
     if (quality &gt; 0)
     {
       sendtext(&quot;This food looks fresh and nutritious.&lt;br/&gt;&quot;, activator);
     }
     else
     {
       sendtext(&quot;This food appears to be spoiled.&lt;br/&gt;&quot;, activator);
     }
   }
 } dilend

=== Container Status ===
 dilbegin check_container_status();
 var
   container : unitptr;
 
 code
 {
   container := self;
   if (container.objecttype == ITEM_CONTAINER)
   {
     if (container.value[0] == 1) // Check if container is closable
     {
       sendtext(&quot;This container can be opened and closed.&lt;br/&gt;&quot;, activator);
     }
     if (container.value[1] == 1) // Check if container is closed
     {
       sendtext(&quot;The container is currently closed.&lt;br/&gt;&quot;, activator);
     }
   }
 } dilend

== Usage Notes ==
* Valid indices are 0 through 4 (inclusive)
* The meaning of each index depends on the object&apos;s [[Manual:DIL_Manual/#uobj|objecttype]]
* Common uses include:
** Weapons: value[0] = weapon type, value[1] = damage, value[2] = bonus damage
** Armor: value[0] = armor type, value[1] = protection, value[2] = enchantment
** Food/Drink: value[0] = quality/nutrition, value[1] = poison strength, value[2] = hunger/thirst satisfaction
** Containers: value[0] = closable flag, value[1] = closed flag, value[2] = pick-proof flag
** Lights: value[0] = hours remaining, value[1] = illumination level
** Spell items: value[0] = spell power, value[1] = spell number, value[2] = charges
* Always check the object&apos;s [[Manual:DIL_Manual/#uobj|objecttype]] before interpreting values
* Values are saved with the object if it&apos;s a savable item

== Error Handling ==
* Accessing an index outside 0-4 will result in a runtime error
* Accessing &apos;&apos;&apos;value&apos;&apos;&apos; on a non-object unit will result in a runtime error
* The field automatically handles bounds checking based on the object&apos;s value array size
* Invalid object types may return unexpected values or cause errors

== Related Functions/Fields ==
* [[Manual:DIL_Manual/#uobj|objecttype]] - Determines how value array indices are interpreted
* [[Manual:DIL_Manual/#uobj|objectflags]] - Additional object properties and flags
* [[Manual:DIL_Manual/#uobj|cost]] - Object&apos;s monetary value
* [[Manual:DIL_Manual/#uobj|rent]] - Object&apos;s rental cost

== See Also ==
* [[Manual:DIL_Manual/#uobj|UNIT_ST_OBJ]] - Object unit type documentation
* [[Manual:DIL_Manual/#getaffects|getaffects()]] - Get object affects and properties
* [[Manual:DIL_Manual/#objectflags|objectflags]] - Object flag manipulation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/visible</title>
     <ns>0</ns>
     <id>1084026</id>
     <revision>
       <id>1635104</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of visible.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= visible =
 function: integer &apos;&apos;&apos;visible&apos;&apos;&apos;(viewer : unitptr, target : unitptr);
 
The &apos;&apos;&apos;visible&apos;&apos;&apos; function checks whether one character can see another unit in the game world.

== Description ==
The &apos;&apos;&apos;visible&apos;&apos;&apos; function determines if a character (viewer) can visually perceive another unit (target). This function takes into account various visibility factors including normal sight, darkness, invisibility spells, wizard invisibility levels, and other visibility modifiers. It returns a boolean value (1 for visible, 0 for not visible) indicating whether the viewer can see the target.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| viewer || unitptr || The character who is attempting to see the target. Must be a character (PC or NPC).
|-
| target || unitptr || The unit that the viewer is trying to see. Can be any unit type.
|}

== Examples ==
=== Basic Visibility Check ===
 dilbegin check_target_visibility();
 var
   target : unitptr;
 
 code
 {
   target := findunit(self, argument, FIND_UNIT_SURRO, null);
   if (target == null)
   {
     sendtext(&quot;You don&apos;t see that here.&lt;br/&gt;&quot;, activator);
     quit;
   }
   
   if (visible(self, target))
   {
     sendtext(&quot;You can see &quot; + target.name + &quot;.&lt;br/&gt;&quot;, activator);
   }
   else
   {
     sendtext(&quot;You can&apos;t see &quot; + target.name + &quot;.&lt;br/&gt;&quot;, activator);
   }
 } dilend

=== Combat Target Validation ===
 dilbegin attack_visible_target();
 var
   victim : unitptr;
 
 code
 {
   victim := findunit(self, argument, FIND_UNIT_SURRO, null);
   
   if ((victim == null) or not visible(self, victim))
   {
     sendtext(&quot;That person is not here!&lt;br/&gt;&quot;, activator);
     quit;
   }
   
   if (not (victim.type &amp; (UNIT_ST_PC | UNIT_ST_NPC)))
   {
     sendtext(&quot;You can only attack living things!&lt;br/&gt;&quot;, activator);
     quit;
   }
   
   exec(&quot;kill &quot; + victim.name, self);
 } dilend

=== NPC Object Collection ===
 dilbegin collect_visible_items();
 var
   item : unitptr;
 
 code
 {
   foreach (UNIT_ST_OBJ, item)
   {
     if (not visible(self, item)) continue;
     if (item.flags &amp; UNIT_FL_BURIED) continue;
     if (not isset(item.manipulate, MANIPULATE_TAKE)) continue;
     
     exec(&quot;get &quot; + item.name, self);
     sendtext(&quot;You pick up &quot; + item.name + &quot;.&lt;br/&gt;&quot;, activator);
   }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;viewer&apos;&apos;&apos; parameter must be a character (PC or NPC). Using other unit types will result in an error.
* The &apos;&apos;&apos;target&apos;&apos;&apos; parameter can be any unit type (character, object, or room).
* The function considers multiple visibility factors:
** Normal line of sight
** Light levels and darkness
** Invisibility spells and effects
** [[Manual:DIL_Manual/#uptr|minv]] wizard invisibility levels
** Blindness and other visual impairments
** Terrain and environmental obstacles
* Returns 1 (TRUE) if the target is visible, 0 (FALSE) if not visible
* Commonly used before combat, spellcasting, or interaction to ensure valid targeting
* Essential for NPCs to avoid interacting with invisible or hidden entities

== Error Handling ==
* If &apos;&apos;&apos;viewer&apos;&apos;&apos; is not a character unit, the function returns FAIL
* If either parameter is null, the function returns FAIL
* If either parameter is not a unitptr, a runtime error occurs
* The function gracefully handles edge cases like destroyed units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/#uptr|minv]] - Wizard invisibility level field
* [[Manual:DIL_Manual/#findunit|findunit()]] - Find units in the environment
* [[Manual:DIL_Manual/#act|act()]] - Perform actions with visibility checks
* [[Manual:DIL_Manual/#gamestate|gamestate()]] - Check game state including visibility

== See Also ==
* [[Manual:DIL_Manual/#uptr|unitptr]] - Unit pointer type documentation
* [[Manual:DIL_Manual/#sfb_dead|SFB_DEAD]] - Death and visibility considerations
* [[Manual:DIL_Manual/#logcrime|logcrime()]] - Crime logging with visibility checks</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/vlevel</title>
     <ns>0</ns>
     <id>461830</id>
     <revision>
       <id>1326324</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of vlevel.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= vlevel =
 field: integer &apos;&apos;&apos;.vlevel&apos;&apos;&apos; (Read-only or Read/Write)
 
The &apos;&apos;&apos;vlevel&apos;&apos;&apos; field provides access to a player&apos;s virtual level, which represents their effective level for game mechanics and access control.

== Description ==
The &apos;&apos;&apos;vlevel&apos;&apos;&apos; field returns the virtual level of a player character. This virtual level may differ from the character&apos;s actual [[Manual:DIL_Manual/#upc|level]] and is used for various game mechanics including access control, skill calculations, and content restrictions. The field&apos;s access permissions depend on the zone&apos;s access level - in high-access zones it&apos;s read-only, while in normal zones it may be read-write.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| pc.vlevel || integer || Returns the virtual level of the player character
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Examples ==
=== Basic Level Check ===
 dilbegin check_virtual_level();
 var
   player : unitptr;
 
 code
 {
   player := activator;
   if (player.vlevel &gt;= 50)
   {
     sendtext(&quot;You have sufficient virtual level for this area.&lt;br/&gt;&quot;, player);
   }
   else
   {
     sendtext(&quot;You need virtual level 50 to enter this area.&lt;br/&gt;&quot;, player);
   }
 } dilend

=== Virtual Level Comparison ===
 dilbegin compare_levels();
 var
   pc1 : unitptr;
   pc2 : unitptr;
 
 code
 {
   pc1 := self;
   pc2 := activator;
   
   if (pc1.vlevel &gt; pc2.vlevel)
   {
     sendtext(&quot;Your virtual level is higher than &quot; + pc2.name + &quot;.&lt;br/&gt;&quot;, pc1);
   }
   else if (pc1.vlevel &lt; pc2.vlevel)
   {
     sendtext(pc2.name + &quot; has a higher virtual level than you.&lt;br/&gt;&quot;, pc1);
   }
   else
   {
     sendtext(&quot;You and &quot; + pc2.name + &quot; have the same virtual level.&lt;br/&gt;&quot;, pc1);
   }
 } dilend

=== Level-Based Reward ===
 dilbegin virtual_level_reward();
 var
   player : unitptr;
   bonus : integer;
 
 code
 {
   player := activator;
   bonus := player.vlevel / 10; // Bonus based on virtual level
   
   if (bonus &gt; 0)
   {
     sendtext(&quot;You receive a bonus of &quot; + itoa(bonus) + &quot; gold coins!&lt;br/&gt;&quot;, player);
     // Add actual gold reward here
   }
   else
   {
     sendtext(&quot;Your virtual level is too low for a bonus.&lt;br/&gt;&quot;, player);
   }
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;vlevel&apos;&apos;&apos; field is only available on player characters (UNIT_ST_PC)
* Access permissions vary by zone access level:
** High-access zones: Read-only access
** Normal zones: May have read-write access
* Virtual level is used for:
** Access control to restricted areas
** Skill and ability calculations
** Combat and damage calculations
** Quest and content eligibility
* Virtual level can be modified independently of the character&apos;s actual level
* The field is commonly used in clan systems, guild systems, and area restrictions
* Virtual level is saved with the player character

== Error Handling ==
* Accessing &apos;&apos;&apos;vlevel&apos;&apos;&apos; on a non-player unit will result in FAIL
* Accessing &apos;&apos;&apos;vlevel&apos;&apos;&apos; on a null unit pointer will result in FAIL
* Write access may be restricted based on zone access permissions
* The field gracefully handles edge cases and invalid units

== Related Functions/Fields ==
* [[Manual:DIL_Manual/#upc|level]] - The character&apos;s actual level
* [[Manual:DIL_Manual/#bpresetvlevel|reset_vlevel()]] - Reset a player&apos;s virtual level
* [[Manual:DIL_Manual/#upc|hometown]] - Player&apos;s hometown for access control
* [[Manual:DIL_Manual/#access|access()]] - Zone access level checking

== See Also ==
* [[Manual:DIL_Manual/#upc|UNIT_ST_PC]] - Player character unit type documentation
* [[Manual:DIL_Manual/#bpresetlevel|reset_level()]] - Reset a player&apos;s actual level
* [[Manual:DIL_Manual/#bpresetrace|reset_race()]] - Reset a player&apos;s race information</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/wait</title>
     <ns>0</ns>
     <id>486469</id>
     <revision>
       <id>1160867</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of wait.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= wait =
 function: &apos;&apos;&apos;wait&apos;&apos;&apos;(flags : integer, expression : boolean);
 
The &apos;&apos;&apos;wait&apos;&apos;&apos; function pauses DIL execution until a specific type of event occurs and an optional condition is satisfied.

== Description ==
The &apos;&apos;&apos;wait&apos;&apos;&apos; function suspends DIL program execution until a message matching the specified flag set is received. The program will only resume if both the message type matches the flags parameter AND the optional expression evaluates to TRUE. This is the primary mechanism for DIL programs to respond to game events, player commands, timers, and inter-program communication.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| flags || integer || Bitwise combination of message flags to wait for (SFB_* constants)
|-
| expression || boolean || Optional condition that must be TRUE for program to resume
|}

== Examples ==
=== Basic Command Waiting ===
 dilbegin simple_shopkeeper();
 var
   customer : unitptr;
 
 code
 {
   :start:
   wait(SFB_CMD, command(&quot;buy&quot;));
   customer := activator;
   
   if (customer == null)
   {
     sendtext(&quot;I don&apos;t see anyone here to buy from me.&lt;br/&gt;&quot;, self);
     goto start;
   }
   
   exec(&quot;say What would you like to buy today?&quot;, self);
   goto start;
 } dilend

=== Timer-Based Processing ===
 dilbegin periodic_cleaner();
 var
   i : integer;
 
 code
 {
   heartbeat := PULSE_SEC * 30; // Every 30 seconds
   i := 0;
   
   :start:
   wait(SFB_TICK, TRUE);
   
   i := i + 1;
   exec(&quot;emote sweeps the floor clean.&quot;, self);
   
   if (i &lt; 5)
     goto start;
   
   exec(&quot;say All done cleaning for now.&quot;, self);
 } dilend

=== Message Communication ===
 dilbegin message_handler();
 var
   sender : unitptr;
   msg : string;
 
 code
 {
   :start:
   wait(SFB_MSG, TRUE);
   
   sender := activator;
   msg := argument;
   
   if (msg == &quot;status&quot;)
   {
     sendto(sender, &quot;I am operating normally.&quot;);
   }
   else if (msg == &quot;shutdown&quot;)
   {
     sendto(sender, &quot;Shutting down now.&quot;);
     quit;
   }
   else
   {
     sendto(sender, &quot;Unknown command: &quot; + msg);
   }
   
   goto start;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;flags&apos;&apos;&apos; parameter uses SFB_* constants which can be combined with bitwise OR (|)
* Common SFB flags include:
** [[Manual:DIL_Manual/#sfbcmd|SFB_CMD]] - Player/NPC commands
** [[Manual:DIL_Manual/#sfbtick|SFB_TICK]] - Timer events based on [[Manual:DIL_Manual/#heartbeat|heartbeat]]
** [[Manual:DIL_Manual/#sfbmsg|SFB_MSG]] - Inter-program messages
** [[Manual:DIL_Manual/#sfbdone|SFB_DONE]] - Completed command notifications
** SFB_COM - Combat events
** SFB_DEAD - Death events
** SFB_PRE - Pre-command processing
* The &apos;&apos;&apos;expression&apos;&apos;&apos; parameter is optional - if omitted, any matching message will resume execution
* When waiting, the program sets global variables like [[Manual:DIL_Manual/#activator|activator]], [[Manual:DIL_Manual/#medium|medium]], [[Manual:DIL_Manual/#target|target]], [[Manual:DIL_Manual/#argument|argument]], and [[Manual:DIL_Manual/#cmdstr|cmdstr]]
* Use [[Manual:DIL_Manual/#command|command()]] function to check specific commands within SFB_CMD events
* The [[Manual:DIL_Manual/#heartbeat|heartbeat]] variable controls timer frequency for SFB_TICK events
* Multiple wait statements can be used to create complex state machines

== Error Handling ==
* If &apos;&apos;&apos;flags&apos;&apos;&apos; parameter is not an integer, a runtime error occurs
* If the expression parameter is not boolean, a runtime error occurs
* Invalid flag combinations may cause the program to never resume
* Programs waiting indefinitely may impact game performance
* Always provide exit conditions or timeouts to prevent infinite waiting

== Related Functions/Fields ==
* [[Manual:DIL_Manual/#interrupt|interrupt()]] - Set up event handlers without waiting
* [[Manual:DIL_Manual/#send|send()]] / [[Manual:DIL_Manual/#sendto|sendto()]] - Send messages to other DIL programs
* [[Manual:DIL_Manual/#command|command()]] - Check specific command names
* [[Manual:DIL_Manual/#heartbeat|heartbeat]] - Control timer frequency
* [[Manual:DIL_Manual/#activator|activator]] - Unit that triggered the event
* [[Manual:DIL_Manual/#argument|argument]] - Command arguments or message content

== See Also ==
* [[Manual:DIL_Manual/#sfbcmd|SFB_CMD]] - Command message documentation
* [[Manual:DIL_Manual/#sfbtick|SFB_TICK]] - Timer message documentation  
* [[Manual:DIL_Manual/#sfbmsg|SFB_MSG]] - User message documentation
* [[Manual:DIL_Manual/#sfbdone|SFB_DONE]] - Command completion documentation
* [[Manual:DIL_Manual/#sfb_com|SFB_COM]] - Combat message documentation
* [[Manual:DIL_Manual/#sfb_dead|SFB_DEAD]] - Death message documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/waitnoop</title>
     <ns>0</ns>
     <id>929064</id>
     <revision>
       <id>1310432</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of waitnoop.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= waitnoop =
 function: &apos;&apos;&apos;waitnoop&apos;&apos;&apos;();
 function: &apos;&apos;&apos;waitnoop&apos;&apos;&apos;(command_string : string);
 
The &apos;&apos;&apos;waitnoop&apos;&apos;&apos; function performs a no-operation wait that temporarily releases security constraints on secured units.

== Description ==
The &apos;&apos;&apos;waitnoop&apos;&apos;&apos; function creates a special wait state that temporarily removes [[Manual:DIL_Manual/#secure|secure()]] constraints on units. This allows DIL programs to execute commands on secured units without triggering secure violations. The function is particularly useful in follower systems where the follower needs to execute movement commands that would normally break the secure relationship with their master. There are two forms: parameterless (uses current command) and with explicit command string.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| command_string || string || Optional explicit command to execute. If omitted, uses current command.
|}

== Examples ==
=== Basic Follower Movement ===
 dilbegin simple_follower();
 var
   master : unitptr;
 
 code
 {
   if (not self.master)
     quit;
   
   master := self.master;
   
   :start:
   wait(SFB_DONE, TRUE);
   
   if (not visible(self, master))
     goto start;
   
   if (command(&quot;north&quot;))
   {
     act(&quot;You follow $3n north.&quot;, A_HIDEINV, self, &quot;north&quot;, master, TO_CHAR);
     waitnoop;
     exec(&quot;north&quot;, self);
   }
   else if (command(&quot;south&quot;))
   {
     act(&quot;You follow $3n south.&quot;, A_HIDEINV, self, &quot;south&quot;, master, TO_CHAR);
     waitnoop;
     exec(&quot;south&quot;, self);
   }
   
   goto start;
 } dilend

=== Command with Arguments ===
 dilbegin smart_follower();
 var
   master : unitptr;
   direction : string;
 
 code
 {
   master := self.master;
   
   :start:
   wait(SFB_DONE, TRUE);
   
   if (command(&quot;leave&quot;) or command(&quot;exit&quot;))
   {
     direction := argument;
     if (direction == null)
       direction := &quot;&quot;;
     
     act(&quot;You follow $3n.&quot;, A_HIDEINV, self, null, master, TO_CHAR);
     waitnoop(&quot;leave &quot; + direction);
     exec(&quot;leave &quot; + direction, self);
   }
   
   goto start;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;waitnoop&apos;&apos;&apos; function temporarily releases [[Manual:DIL_Manual/#secure|secure()]] constraints during command execution
* This is essential for follower systems where followers need to move with their master
* Without &apos;&apos;&apos;waitnoop&apos;&apos;&apos;, followers would trigger secure violations when trying to follow their master
* The parameterless form uses the current [[Manual:DIL_Manual/#cmdstr|cmdstr]] value
* The parameter form allows explicit command specification with arguments
* Common use cases include:
** Follower movement commands (north, south, east, west, etc.)
** Enter/exit commands for following between rooms/objects
** Complex directional commands (northeast, southwest, etc.)
** Commands with arguments (leave &lt;direction&gt;, enter &lt;object&gt;)
* The function works by setting SFB_NOOP flag and managing wait command state
* Security is automatically restored after the command execution

== Error Handling ==
* If &apos;&apos;&apos;command_string&apos;&apos;&apos; parameter is not a string, a runtime error occurs
* The function should only be used on units that have been [[Manual:DIL_Manual/#secure|secured()]]
* Using &apos;&apos;&apos;waitnoop&apos;&apos;&apos; without proper [[Manual:DIL_Manual/#secure|secure()]] setup may have unpredictable results
* Always ensure the unit has a valid master before using in follower contexts
* The function does not validate the command - invalid commands will still execute

== Related Functions/Fields ==
* [[Manual:DIL_Manual/#secure|secure()]] - Secure a unit and set up violation handling
* [[Manual:DIL_Manual/#unsecure|unsecure()]] - Remove security constraints from a unit
* [[Manual:DIL_Manual/#wait|wait()]] - Standard wait function for event handling
* [[Manual:DIL_Manual/#cmdstr|cmdstr]] - Current command string
* [[Manual:DIL_Manual/#visible|visible()]] - Check if units can see each other

== See Also ==
* [[Manual:DIL_Manual/#sfbcmd|SFB_CMD]] - Command message documentation
* [[Manual:DIL_Manual/#sfbdone|SFB_DONE]] - Command completion documentation
* [[Manual:DIL_Manual/#secure|secure()]] - Unit security documentation
* [[Manual:DIL_Manual/#unsecure|unsecure()]] - Unit security removal documentation</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/weapon_costs</title>
     <ns>0</ns>
     <id>1221249</id>
     <revision>
       <id>1503035</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of weapon_costs.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= weapon_costs =
field: integer &apos;&apos;&apos;.weapon_costs&apos;&apos;&apos;[idx] (Read-only)

The .weapon_costs field provides access to the cost multiplier for weapon skills based on racial bonuses.

== Description ==
The .weapon_costs field returns the racial weapon cost modifier for a specific weapon type. This value represents how much it costs a character of a particular race to advance in that weapon skill. The function uses the character&apos;s race and the weapon index to determine the appropriate cost multiplier from the racial weapon tables.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| pc.weapon_costs[idx] || integer || Returns the racial cost multiplier for weapon type &apos;idx&apos;
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Parameters ==
The field requires an integer index parameter:
; idx : integer
: The weapon type index (WPN_* constants from values.h and/or vme.h)

== Examples ==
=== Basic Weapon Cost Check ===
 dilbegin racial_weapon_check(pc : unitptr);
 var
    i : integer;
    cost : integer;
 code
    // Check weapon costs for all weapon types
    for (i := 0; i &lt; 10; i := i + 1)
    {
      cost := pc.weapon_costs[i];
      if (cost &gt; 0)
      {
        sendtext(&quot;Weapon &quot; + itoa(i) + &quot; cost: &quot; + itoa(cost) + &quot;&amp;n&quot;, self);
      }
    }
    quit;
 dilend

== Usage Notes ==
* The field is only accessible for player characters (UNIT_ST_PC)
* The weapon index must be within the valid range (0 to WPN_TREE_MAX - 1)
* The returned value represents a cost multiplier, not the absolute cost
* This field is typically used in character creation or skill advancement systems
* The function internally calls get_racial_weapon() to determine the cost

== Error Handling ==
* If accessed on a non-PC unit, the operation will fail
* If the weapon index is out of range, the operation will fail
* Invalid parameter types will result in an error

== Related Functions/Fields ==
* [[Manual:DIL_Manual/weapon_info|weapon_info]] - Get information about weapon types
* [[Manual:DIL_Manual/weapon_name|weapon_name]] - Get the name of a weapon type
* [[Manual:DIL_Manual/weapon_levels|weapon_levels]] - Get weapon skill level requirements
* .weapons[] - Access weapon skill values

== See Also ==
* [[Manual:DIL_Manual/skill_costs|skill_costs]] - Skill cost information
* [[Manual:DIL_Manual/ability_costs|ability_costs]] - Ability cost information
* Racial system documentation
* Weapon skill system</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/weapon_info</title>
     <ns>0</ns>
     <id>1148799</id>
     <revision>
       <id>1763470</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of weapon_info.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= weapon_info =
function: intlist &apos;&apos;&apos;weapon_info&apos;&apos;&apos;(i : integer);

The weapon_info function retrieves detailed information about a specific weapon type from the game&apos;s weapon definition tables.

== Description ==
The weapon_info function returns an integer list containing comprehensive data about a weapon type, including physical properties, combat characteristics, and damage calculations. The function accesses the weapons.def file data and weapon chart information to provide complete weapon statistics for use in equipment handling, combat calculations, and display functions.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| i || integer || Weapon type index (WPN_* constants from values.h and/or vme.h)
|}

The function returns an intlist with the following structure:
* Index 0: Number of hands required (1 or 2)
* Index 1: Weapon speed value
* Index 2: Weapon type classification
* Index 3: Shield block value
* Index 4: Parent weapon type in weapon tree
* Index 5+: Damage chart data (3 values per armor type: offset, base damage, alpha)

== Examples ==
=== Check Two-Handed Weapon ===
 dilbegin check_two_handed(weapon_idx : integer);
 var
    wpn_info : intlist;
 code
 {
    wpn_info := weapon_info(weapon_idx);
    
    if (wpn_info != null)
    {
       if (wpn_info.[0] == 2)
          sendtext(&quot;This is a two-handed weapon.&amp;n&quot;, self);
       else
          sendtext(&quot;This is a one-handed weapon.&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Invalid weapon type.&amp;n&quot;, self);
    }
    quit;
 } dilend

=== Display Weapon Stats ===
 dilbegin display_weapon_stats(weapon_idx : integer);
 var
    wpn_info : intlist;
 code
 {
    wpn_info := weapon_info(weapon_idx);
    
    if (wpn_info != null)
    {
       sendtext(&quot;Weapon Statistics:&amp;n&quot;, self);
       sendtext(&quot;Hands required: &quot; + itoa(wpn_info.[0]) + &quot;&amp;n&quot;, self);
       sendtext(&quot;Speed: &quot; + itoa(wpn_info.[1]) + &quot;&amp;n&quot;, self);
       sendtext(&quot;Type: &quot; + itoa(wpn_info.[2]) + &quot;&amp;n&quot;, self);
       sendtext(&quot;Shield value: &quot; + itoa(wpn_info.[3]) + &quot;&amp;n&quot;, self);
       sendtext(&quot;Parent type: &quot; + itoa(wpn_info.[4]) + &quot;&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;No such weapon type.&amp;n&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* The weapon index must be within the valid range (0 to WPN_TREE_MAX - 1)
* Returns null if the weapon index is invalid
* The returned intlist contains dynamic data that should not be modified
* The damage chart section (indices 5+) contains 3 values per armor type
* This function is commonly used in equipment wear/look commands and combat calculations
* The weapon data comes from the weapons.def configuration file

== Error Handling ==
* If the weapon index is out of range, returns null
* If the parameter is not an integer, returns an error
* Invalid weapon types will result in a null return value

== Related Functions/Fields ==
* [[Manual:DIL_Manual/weapon_name|weapon_name]] - Get the name of a weapon type
* [[Manual:DIL_Manual/weapon_costs|weapon_costs]] - Get racial weapon cost information
* [[Manual:DIL_Manual/weapon_levels|weapon_levels]] - Get weapon skill level requirements
* .weapons[] - Access weapon skill values on characters

== See Also ==
* Weapon system documentation
* Equipment handling functions
* Combat system functions
* Armor type constants</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/weapon_levels</title>
     <ns>0</ns>
     <id>815223</id>
     <revision>
       <id>1148194</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of weapon_levels.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= weapon_levels =
field: integer &apos;&apos;&apos;.weapon_levels&apos;&apos;&apos;[idx] (Read-only)

The .weapon_levels field provides access to the skill level of a specific weapon type for a player character.

== Description ==
The .weapon_levels field returns the current skill level that a player character has achieved with a specific weapon type. This represents the character&apos;s proficiency and training with that particular weapon category. The skill level affects combat accuracy, damage, and other weapon-related calculations.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| pc.weapon_levels[idx] || integer || Returns the skill level for weapon type &apos;idx&apos;
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)

== Parameters ==
The field requires an integer index parameter:
; idx : integer
: The weapon type index (WPN_* constants from values.h and/or vme.h)

== Examples ==
=== Check Weapon Skill ===
 dilbegin check_weapon_skill(pc : unitptr, weapon_type : integer);
 var
    level : integer;
 code
 {
    level := pc.weapon_levels[weapon_type];
    
    if (level &gt; 0)
    {
       sendtext(&quot;You have skill level &quot; + itoa(level) + &quot; with this weapon type.&amp;n&quot;, pc);
    }
    else
    {
       sendtext(&quot;You have not trained with this weapon type.&amp;n&quot;, pc);
    }
    quit;
 } dilend

=== List Weapon Skills ===
 dilbegin list_weapon_skills(pc : unitptr);
 var
    i : integer;
    level : integer;
 code
 {
    sendtext(&quot;Your weapon skills:&amp;n&quot;, pc);
    
    for (i := 0; i &lt; 10; i := i + 1)
    {
       level := pc.weapon_levels[i];
       if (level &gt; 0)
       {
          sendtext(&quot;Weapon &quot; + itoa(i) + &quot;: level &quot; + itoa(level) + &quot;&amp;n&quot;, pc);
       }
    }
    quit;
 } dilend

== Usage Notes ==
* The field is only accessible for player characters (UNIT_ST_PC)
* The weapon index must be within the valid range (0 to WPN_TREE_MAX - 1)
* Skill levels typically range from 0 (untrained) to higher values representing proficiency
* This field is read-only - skill levels are modified through training and practice
* The skill level directly impacts combat effectiveness with the weapon type
* When accessed from a zone with access level 0, returns a reference to the actual value
* When accessed from other zones, returns a copy of the value

== Error Handling ==
* If accessed on a non-PC unit, the operation will fail
* If the weapon index is out of range, the operation will fail
* Invalid parameter types will result in an error

== Related Functions/Fields ==
* [[Manual:DIL_Manual/weapon_info|weapon_info]] - Get information about weapon types
* [[Manual:DIL_Manual/weapon_name|weapon_name]] - Get the name of a weapon type
* [[Manual:DIL_Manual/weapon_costs|weapon_costs]] - Get racial weapon cost information
* .weapons[] - Access weapon skill values (alternative access method)

== See Also ==
* Skill system documentation
* Combat system documentation
* Training and advancement systems
* Weapon proficiency mechanics</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/weapon_name</title>
     <ns>0</ns>
     <id>679391</id>
     <revision>
       <id>1613164</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of weapon_name.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= weapon_name =
function: string &apos;&apos;&apos;weapon_name&apos;&apos;&apos;(i : integer);

The weapon_name function returns the descriptive name of a weapon type based on its index value.

== Description ==
The weapon_name function retrieves the human-readable name for a specific weapon type from the game&apos;s weapon collection. This function is commonly used to display weapon names to players, create menus of available weapon types, or provide descriptive output in combat and skill-related messages. The function accesses the weapon text definitions from the weapons.def configuration file.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| i || integer || Weapon type index (WPN_* constants from values.h and/or vme.h)
|}

== Examples ==
=== List Weapon Types ===
 dilbegin list_weapons();
 var
    i : integer;
    name : string;
 code
 {
    sendtext(&quot;Available weapon types:&amp;n&quot;, self);
    
    for (i := 0; i &lt; 50; i := i + 1)
    {
       name := weapon_name(i);
       if (name != &quot;&quot;)
       {
          sendtext(itoa(i) + &quot;: &quot; + name + &quot;&amp;n&quot;, self);
       }
    }
    quit;
 } dilend

=== Check Weapon Type ===
 dilbegin check_weapon_type(weapon_idx : integer);
 var
    name : string;
 code
 {
    name := weapon_name(weapon_idx);
    
    if (name != &quot;&quot;)
    {
       sendtext(&quot;Weapon type &quot; + itoa(weapon_idx) + &quot; is: &quot; + name + &quot;&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Invalid weapon type index.&amp;n&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* The weapon index must be within the valid range (0 to WPN_TREE_MAX - 1)
* Returns an empty string if the weapon index is invalid or has no name defined
* Returns null if the weapon index is out of bounds
* The function is useful for creating user-friendly displays of weapon types
* Commonly used in character creation, skill training, and equipment management systems
* The returned string is dynamically allocated and should not be modified

== Error Handling ==
* If the weapon index is out of range, returns null
* If the weapon index is valid but has no text defined, returns an empty string
* If the parameter is not an integer, returns an error

== Related Functions/Fields ==
* [[Manual:DIL_Manual/weapon_info|weapon_info]] - Get detailed information about weapon types
* [[Manual:DIL_Manual/weapon_costs|weapon_costs]] - Get racial weapon cost information
* [[Manual:DIL_Manual/weapon_levels|weapon_levels]] - Get weapon skill level requirements
* [[Manual:DIL_Manual/skill_name|skill_name]] - Get skill names (similar function for skills)
* .weapons[] - Access weapon skill values on characters

== See Also ==
* Weapon system documentation
* Skill system documentation
* Character creation and training systems
* Equipment handling functions</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/weapons</title>
     <ns>0</ns>
     <id>1046269</id>
     <revision>
       <id>1749914</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of weapons.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= weapons =
field: integer &apos;&apos;&apos;.weapons&apos;&apos;&apos;[idx] (Read-only)

The .weapons field provides access to the weapon skill values for both player characters and non-player characters.

== Description ==
The .weapons field returns the current weapon skill value for a specific weapon type. For player characters, this represents their trained proficiency with individual weapon types, while for NPCs, it represents their skill with weapon groups. These values directly affect combat accuracy, damage calculations, and overall effectiveness with different weapon categories.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| char.weapons[idx] || integer || Returns the weapon skill value for weapon type &apos;idx&apos;
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)

== Parameters ==
The field requires an integer index parameter:
; idx : integer
: The weapon type index (WPN_* constants from values.h and/or vme.h)
: For PCs: 0 to WPN_TREE_MAX - 1 (individual weapon types)
: For NPCs: 0 to WPN_GROUP_MAX - 1 (weapon groups only)

== Examples ==
=== Check Weapon Skill ===
 dilbegin check_weapon_skill(char : unitptr, weapon_type : integer);
 var
    skill : integer;
 code
 {
    skill := char.weapons[weapon_type];
    
    if (skill &gt; 0)
    {
       sendtext(&quot;Weapon skill: &quot; + itoa(skill) + &quot;&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;No skill with this weapon type.&amp;n&quot;, self);
    }
    quit;
 } dilend

=== Display All Weapon Skills ===
 dilbegin display_all_weapon_skills(char : unitptr);
 var
    i : integer;
    skill : integer;
    max_index : integer;
 code
 {
    if (char.type == UNIT_ST_PC)
       max_index := WPN_TREE_MAX;
    else
       max_index := WPN_GROUP_MAX;
    
    sendtext(&quot;Weapon Skills:&amp;n&quot;, self);
    
    for (i := 0; i &lt; max_index; i := i + 1)
    {
       skill := char.weapons[i];
       if (skill &gt; 0)
       {
          sendtext(&quot;Weapon &quot; + itoa(i) + &quot;: &quot; + itoa(skill) + &quot;&amp;n&quot;, self);
       }
    }
    quit;
 } dilend

== Usage Notes ==
* The field is accessible for both PCs and NPCs, but with different index ranges
* For PCs: Can access individual weapon types (0 to WPN_TREE_MAX - 1)
* For NPCs: Limited to weapon groups only (0 to WPN_GROUP_MAX - 1)
* When accessed from a zone with access level 0, returns a reference to the actual value
* When accessed from other zones, returns a copy of the value
* Higher skill values generally indicate better proficiency with the weapon type
* Weapon skills affect combat calculations including hit chance and damage
* This field is read-only - skills are modified through training and practice

== Error Handling ==
* If accessed on a non-character unit, the operation will fail
* If the weapon index is out of range for the unit type, the operation will fail
* Invalid parameter types will result in an error
* NPCs accessing individual weapon types (beyond WPN_GROUP_MAX) will fail

== Related Functions/Fields ==
* [[Manual:DIL_Manual/weapon_info|weapon_info]] - Get information about weapon types
* [[Manual:DIL_Manual/weapon_name|weapon_name]] - Get the name of a weapon type
* [[Manual:DIL_Manual/weapon_costs|weapon_costs]] - Get racial weapon cost information
* [[Manual:DIL_Manual/weapon_levels|weapon_levels]] - Get weapon skill level requirements (PCs only)
* .abilities[] - Access ability scores on characters

== See Also ==
* Combat system documentation
* Skill training and advancement systems
* Character creation and development
* Weapon proficiency mechanics</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/weather</title>
     <ns>0</ns>
     <id>843534</id>
     <revision>
       <id>1163737</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of weather.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= weather =
variable: integer &apos;&apos;&apos;weather&apos;&apos;&apos;

The weather variable returns the current sky condition for the zone where the executing unit is located.

== Description ==
The weather variable provides access to the current weather state as defined by the zone&apos;s weather system. It returns an integer value corresponding to one of the SKY_* constants defined in values.h and/or vme.h. This variable is commonly used in weather-dependent spells, outdoor activities, and environmental effects that need to react to current atmospheric conditions.

== Examples ==
=== Basic Weather Check ===
 dilbegin check_weather_for_spell();
 var
    current_weather : integer;
 code
 {
    current_weather := weather;
    
    if (current_weather == SKY_CLOUDLESS)
    {
       sendtext(&quot;The sky is completely clear.&amp;n&quot;, self);
    }
    else if (current_weather == SKY_CLOUDY)
    {
       sendtext(&quot;The sky is cloudy.&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;The weather conditions are not favorable.&amp;n&quot;, self);
    }
    quit;
 } dilend

=== Weather Report ===
 dilbegin weather_report();
 var
    current_weather : integer;
    report : string;
 code
 {
    current_weather := weather;
    
    switch (current_weather)
    {
       case SKY_CLOUDLESS:
          report := &quot;The sky is completely clear.&quot;;
          break;
       case SKY_CLOUDY:
          report := &quot;Clouds drift across sky.&quot;;
          break;
       case SKY_RAINING:
          report := &quot;Rain is falling from sky.&quot;;
          break;
       case SKY_LIGHTNING:
          report := &quot;Lightning flashes in stormy sky.&quot;;
          break;
       default:
          report := &quot;The weather conditions are unusual.&quot;;
          break;
    }
    
    act(report, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

 dilbegin sun_beam(medi : unitptr, tgt : unitptr, arg : string, hm : integer, effect : string);
 var
    u : unitptr;
 code
 {
    hm := 0;
    u := self.outside;
    
    while (u)
    {
       if (isset(u.flags, UNIT_FL_NO_WEATHER | UNIT_FL_INDOORS))
       {
          act(&quot;There is no access to the forces of nature from here.&quot;,
              A_ALWAYS, self, null, null, TO_CHAR);
          quit;
       }
       u := u.outside;
    }
    
    if ((weather != SKY_CLOUDLESS) or (weather != SKY_CLOUDY))
    {
       act(&quot;The heavy rain clouds block any chance of casting the spell.&quot;,
           A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }
    
    if ((mudhour &lt; 5) or (mudhour &gt;= 21))
    {
       act(&quot;The sun has not risen yet.&quot;,
           A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }
    
    // Most powerful at noon
    if (mudhour &lt; 12)
       hm := 18*(mudhour - 12);
    else
       hm := -15*(mudhour - 12);
    
    if (RACE_IS_UNDEAD(tgt.race))
       hm := hm + 100;
    
    hm := attack_spell(SPL_SUN_BEAM, self, medi, tgt, hm, effect);
    quit;
 } dilend

 dilbegin weather_report();
 var
    current_weather : integer;
    report : string;
 code
 {
    current_weather := weather;
    
    switch (current_weather)
    {
       case SKY_CLOUDLESS:
          report := &quot;The sky is completely clear.&quot;;
          break;
       case SKY_CLOUDY:
          report := &quot;Clouds drift across the sky.&quot;;
          break;
       case SKY_RAINING:
          report := &quot;Rain is falling from the sky.&quot;;
          break;
       case SKY_LIGHTNING:
          report := &quot;Lightning flashes in the stormy sky.&quot;;
          break;
       default:
          report := &quot;The weather conditions are unusual.&quot;;
          break;
    }
    
    act(report, A_ALWAYS, self, null, null, TO_CHAR);
    quit;
 } dilend

== Usage Notes ==
* The weather value is determined by the zone&apos;s weather system
* Returns SKY_* constants (SKY_CLOUDLESS, SKY_CLOUDY, SKY_RAINING, etc.)
* Weather affects outdoor spells and environmental effects
* Indoor locations or areas with UNIT_FL_NO_WEATHER flag may have different behavior
* The weather is zone-specific, so different zones can have different weather conditions
* Commonly used with time variables like mudhour for comprehensive environmental checks

== Error Handling ==
* The weather variable is always available and returns a valid integer
* No error conditions are expected when accessing this variable

== Related Functions/Fields ==
* [[Manual:DIL_Manual/mudhour|mudhour]] - Current hour of the mud day
* [[Manual:DIL_Manual/mudday|mudday]] - Current day of the mud month
* [[Manual:DIL_Manual/mudmonth|mudmonth]] - Current month of the mud year
* [[Manual:DIL_Manual/mudyear|mudyear]] - Current mud year
* .outside - Access to outdoor environment

== See Also ==
* Weather system documentation
* Time system documentation
* Environmental spell effects
* Zone configuration and weather patterns</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/weight</title>
     <ns>0</ns>
     <id>996333</id>
     <revision>
       <id>1198902</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of weight.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= weight =
field: integer &apos;&apos;&apos;.weight&apos;&apos;&apos; (Read-only)

The .weight field returns the current total weight of a unit including all its contents.

== Description ==
The .weight field provides access to the total weight of a unit, which includes both the unit&apos;s base weight and the weight of all items contained within it. This is different from the .baseweight field which only returns the empty weight of the unit itself. The weight is returned in pounds ( kg units) and is commonly used for encumbrance calculations, capacity checks, and inventory management.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.weight || integer || Returns the total weight of the unit and its contents
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
=== Check Encumbrance ===
 dilbegin check_encumbrance(pc : unitptr);
 var
    total_weight : integer;
    capacity : integer;
 code
 {
    total_weight := pc.weight;
    capacity := pc.capacity;
    
    if (total_weight &gt; capacity)
    {
       sendtext(&quot;You are overburdened! (&quot; + itoa(total_weight) + &quot;/&quot; + itoa(capacity) + &quot;)&amp;n&quot;, pc);
    }
    else
    {
       sendtext(&quot;You are carrying &quot; + itoa(total_weight) + &quot;/&quot; + itoa(capacity) + &quot; pounds.&amp;n&quot;, pc);
    }
    quit;
 } dilend

=== Container Check ===
 dilbegin container_check(container : unitptr);
 var
    container_weight : integer;
    container_capacity : integer;
 code
 {
    container_weight := container.weight;
    container_capacity := container.capacity;
    
    if (container_weight &gt; container_capacity)
    {
       sendtext(&quot;The container is overloaded! (&quot; + itoa(container_weight) + &quot;/&quot; + itoa(container_capacity) + &quot;)&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Container weight: &quot; + itoa(container_weight) + &quot;/&quot; + itoa(container_capacity) + &quot;&amp;n&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* The weight includes both the unit&apos;s base weight and all contained items
* Weight is measured in pounds ( kg units)
* This field is read-only - use [[Manual:DIL_Manual/set_weight|set_weight]] to modify weight
* For containers, this includes the weight of all items inside
* For characters, this includes equipment and inventory weight
* Commonly used with .capacity field for encumbrance calculations
* The .baseweight field provides the empty weight of the unit alone

== Error Handling ==
* If accessed on a null unit pointer, the operation will fail
* No other error conditions are expected when accessing this field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/baseweight|baseweight]] - The empty weight of the unit (without contents)
* [[Manual:DIL_Manual/capacity|capacity]] - The maximum weight a unit can contain
* [[Manual:DIL_Manual/set_weight|set_weight]] - Procedure to modify a unit&apos;s weight
* [[Manual:DIL_Manual/set_weight_base|set_weight_base]] - Procedure to modify a unit&apos;s base weight
* [[Manual:DIL_Manual/can_carry|can_carry]] - Function to check if a unit can carry additional weight

== See Also ==
* Encumbrance system documentation
* Inventory management functions
* Container system documentation
* Weight calculation mechanics</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/while</title>
     <ns>0</ns>
     <id>835529</id>
     <revision>
       <id>1826242</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of while.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= while =

 statement: &apos;&apos;&apos;while&apos;&apos;&apos;(expression) statement;

Executes a block of code repeatedly while a boolean expression evaluates to TRUE.

== Description ==
The &apos;&apos;&apos;while&apos;&apos;&apos; statement creates a loop that continues executing a block of code as long as a specified condition remains true. This is commonly used for creating continuous processes, monitoring systems, or repetitive actions that need to run until a certain condition is met.

The while loop evaluates the expression before each iteration. If the expression is TRUE, the code block is executed. If the expression becomes FALSE, the loop terminates and execution continues with the statement following the while block.

== Examples ==
=== Basic Counter ===
 dilbegin simple_counter();
 var
    count : integer;
 code
 {
    :start:
    count := 0;
    
    :start:
    count := count + 1;
    exec(&quot;say Count: &quot; + itoa(count), self);
    
    if (count &lt; 10)
    {
       goto start;
    }
    else
    {
       exec(&quot;say Counting complete. Final count: &quot; + itoa(count), self);
       quit;
    }
    
    goto start;
 } dilend

=== Continuous Monitoring ===
 dilbegin monitor_system();
 var
    status : integer;
 code
 {
    :start:
    wait(SFB_TICK, TRUE);
    
    // Check system status every 5 seconds
    status := rnd(0, 1); // 0 = normal, 1 = warning
    
    if (status == 1)
    {
       exec(&quot;say Warning: System status issue detected.&quot;, self);
    }
    else
    {
       exec(&quot;say System status: Normal.&quot;, self);
    }
    
    goto start;
 } dilend

=== Input Processing Loop ===
 dilbegin input_processor();
 var
    input : string;
 code
 {
    :start:
    wait(SFB_CMD, TRUE);
    
    input := argument;
    
    if (input == &quot;quit&quot;)
    {
       exec(&quot;say Processing complete. Exiting.&quot;, self);
       quit;
    }
    else
    {
       exec(&quot;say Processing input: &quot; + input, self);
    }
    
    goto start;
 } dilend

== Usage Notes ==
* The &apos;&apos;&apos;while&apos;&apos;&apos; statement is fundamental to DIL programming for creating loops
* The expression is evaluated before each iteration, not after
* Use proper exit conditions to prevent infinite loops
* Common patterns include counters, timers, and input processing
* The while statement is commonly used with SFB_TICK for timed operations
* Always provide a way to break out of loops (break, quit, or return)
* Test while loops thoroughly to ensure they terminate as expected
* Consider edge cases where conditions might never become FALSE

== Error Handling ==
* Always validate that loop conditions will eventually become FALSE
* Be careful with counter variables to avoid overflow
* Use proper boolean expressions that will eventually become FALSE
* Test while loop functionality thoroughly with different conditions
* Always provide alternative exit mechanisms for user control

== Related Functions/Fields ==
* [[Manual:DIL_Manual/wait|wait]] - Often used with while loops for continuous processing
* [[Manual:DIL_Manual/SFB_TICK|SFB_TICK]] - Common for timer-based loops
* [[Manual:DIL_Manual/pause|pause]] - Used to control loop timing
* [[Manual:DIL_Manual/quit|quit]] - Used to exit from loops
* [[Manual:DIL_Manual/rnd|rnd]] - Often used for random conditions in loops
* [[Manual:DIL_Manual/exec|exec]] - Used for actions within loops
* [[Manual:DIL_Manual/itoa|itoa]] - Used for number formatting in loops

== See Also ==
* [[Manual:DIL_Manual/for|for]] - Alternative loop construct
* [[Manual:DIL_Manual/if|if]] - Conditional branching
* [[Manual:DIL_Manual/break|break]] - Loop control statement
* [[Manual:DIL_Manual/continue|continue]] - Loop control statement</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/zhead</title>
     <ns>0</ns>
     <id>939873</id>
     <revision>
       <id>1813821</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of zhead.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= zhead =
function: zoneptr &apos;&apos;&apos;zhead&apos;&apos;&apos;();

The zhead function returns a pointer to the first zone in the global zone list.

== Description ==
The zhead function provides access to the head of the global zone list, allowing iteration through all zones in the game. This function is commonly used for zone management, administrative commands, and system-wide zone analysis. The returned zoneptr can be traversed using the .next field to access subsequent zones in the list.

== Examples ==
=== List All Zones ===
 dilbegin list_all_zones();
 var
    zones : zoneptr;
    buffer : string;
 code
 {
    zones := zhead();
    buffer := &quot;Available Zones:&amp;n&quot;;
    
    while (zones)
    {
       buffer := buffer + zones.name + &quot; - &quot; + zones.title + &quot;&amp;n&quot;;
       zones := zones.next;
    }
    
    pagestring(buffer, self);
    quit;
 } dilend

=== Zone Statistics ===
 dilbegin zone_statistics();
 var
    zones : zoneptr;
    total_zones : integer;
    total_rooms : integer;
    total_npcs : integer;
    total_objs : integer;
 code
 {
    total_zones := 0;
    total_rooms := 0;
    total_npcs := 0;
    total_objs := 0;
    
    zones := zhead();
    while (zones)
    {
       total_zones := total_zones + 1;
       total_rooms := total_rooms + zones.roomcount;
       total_npcs := total_npcs + zones.npccount;
       total_objs := total_objs + zones.objcount;
       zones := zones.next;
    }
    
    sendtext(&quot;Zone Statistics:&amp;n&quot;, self);
    sendtext(&quot;Total Zones: &quot; + itoa(total_zones) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total Rooms: &quot; + itoa(total_rooms) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total NPCs: &quot; + itoa(total_npcs) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total Objects: &quot; + itoa(total_objs) + &quot;&amp;n&quot;, self);
    quit;
 } dilend

=== Find Zone by Name ===
 dilbegin find_zone_by_name(search_name : string);
 var
    zones : zoneptr;
    found : zoneptr;
 code
 {
    found := null;
    zones := zhead();
    
    while (zones)
    {
       if (zones.name == search_name)
       {
          found := zones;
          break;
       }
       zones := zones.next;
    }
    
    if (found)
    {
       sendtext(&quot;Found zone: &quot; + found.title + &quot; (&quot; + found.name + &quot;)&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Zone &apos;&quot; + search_name + &quot;&apos; not found.&amp;n&quot;, self);
    }
    quit;
 } dilend

 dilbegin zone_statistics();
 var
    zones : zoneptr;
    total_zones : integer;
    total_rooms : integer;
    total_npcs : integer;
    total_objs : integer;
 code
 {
    total_zones := 0;
    total_rooms := 0;
    total_npcs := 0;
    total_objs := 0;
    
    zones := zhead();
    while (zones)
    {
       total_zones := total_zones + 1;
       total_rooms := total_rooms + zones.roomcount;
       total_npcs := total_npcs + zones.npccount;
       total_objs := total_objs + zones.objcount;
       zones := zones.next;
    }
    
    sendtext(&quot;Zone Statistics:&amp;n&quot;, self);
    sendtext(&quot;Total Zones: &quot; + itoa(total_zones) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total Rooms: &quot; + itoa(total_rooms) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total NPCs: &quot; + itoa(total_npcs) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total Objects: &quot; + itoa(total_objs) + &quot;&amp;n&quot;, self);
    quit;
 } dilend

 dilbegin find_zone_by_name(search_name : string);
 var
    zones : zoneptr;
    found : zoneptr;
 code
 {
    found := null;
    zones := zhead();
    
    while (zones)
    {
       if (zones.name == search_name)
       {
          found := zones;
          break;
       }
       zones := zones.next;
    }
    
    if (found)
    {
       sendtext(&quot;Found zone: &quot; + found.title + &quot; (&quot; + found.name + &quot;)&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Zone &apos;&quot; + search_name + &quot;&apos; not found.&amp;n&quot;, self);
    }
    quit;
 } dilend

 dilbegin boot_area();
 var
    zones : zoneptr;
    zonelist : stringlist;
    donlist : stringlist;
    nodonlist : stringlist;
    conlist : stringlist;
    tlist : stringlist;
    temp : string;
    i : integer;
    ln : integer;
 code
 {
    heartbeat := 4;
    
: start:
    zones := zhead();
    zonlist := {&quot;$zonlist&quot;};
    donlist := {&quot;$donlist&quot;};
    nodonlist := {&quot;$nodonlist&quot;};
    conlist := {&quot;$conlist&quot;};
    
    while (zones)
    {
       tlist := split(zones.title, &quot;@&quot;);
       
       if (length(tlist) == 2)
       {
          temp := tlist.[1] + &quot;@&quot; + tlist.[0];
          if (zones.payonly)
          {
             if (not((zones.title + &quot;@*&quot;) in zonlist))
             {
                addstring(zonlist, (zones.title + &quot;@*&quot;));
                addstring(conlist, (temp + &quot;@*&quot;));
             }
          }
          else
          {
             if (not((zones.title + &quot;@n&quot;) in zonlist))
             {
                addstring(zonlist, (zones.title + &quot;@n&quot;));
                addstring(conlist, (temp + &quot;@n&quot;));
             }
          }
       }
       
       zones := zones.next;
    }
    
    pause;
    
    // Additional processing for zone boot sequence
    i := 1;
    ln := length(zonlist);
    while (i &lt; ln)
    {
       tlist := split(zonlist.[i], &quot;@&quot;);
       if (tlist.[2] == &quot;n&quot;)
          addstring(nodonlist, tlist.[0] + &quot;@&quot; + tlist.[1]);
       else
          addstring(donlist, tlist.[0] + &quot;@&quot; + tlist.[1]);
       
       i := i + 1;
    }
    
    addextra(self.extra, zonlist, &quot;all&quot;);
    addextra(self.extra, donlist, &quot;all&quot;);
    addextra(self.extra, conlist, &quot;all&quot;);
    addextra(self.extra, nodonlist, &quot;all&quot;);
    quit;
 } dilend

== Usage Notes ==
* The function returns the first zone in the global zone list
* Use the .next field to traverse through all zones
* The returned zoneptr provides access to all zone properties like .name, .title, .rooms, etc.
* Commonly used in administrative commands and zone management systems
* The zone list includes all zones currently loaded in the game
* This function is essential for any operation that needs to process all zones

== Error Handling ==
* The function always returns a valid zoneptr or null if no zones are loaded
* No error conditions are expected when calling this function
* If no zones exist in the game, the function may return null

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type and available fields
* [[Manual:DIL_Manual/ghead|ghead]] - Get first player in global player list
* [[Manual:DIL_Manual/obj_head|obj_head]] - Get first object in global object list
* [[Manual:DIL_Manual/npc_head|npc_head]] - Get first NPC in global NPC list
* [[Manual:DIL_Manual/room_head|room_head]] - Get first room in global room list

== See Also ==
* Zone system documentation
* Global list traversal functions
* Administrative command functions
* Zone management systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/zone</title>
     <ns>0</ns>
     <id>933120</id>
     <revision>
       <id>1323705</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of zone.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= zone =
field: string &apos;&apos;&apos;.zone&apos;&apos;&apos; (Read-only)

The .zone field returns the name of the zone that a unit belongs to.

== Description ==
The .zone field provides access to the zone name identifier for any unit. This field returns the zone name as a string, which is commonly used for zone-based checks, storage operations, and administrative functions. The zone name represents the zone where the unit was originally defined or currently exists.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.zone || string || Returns the zone name of the unit
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
=== Check Unit Zone ===
 dilbegin check_unit_zone(unit : unitptr);
 var
    zone_name : string;
 code
 {
    zone_name := unit.zone;
    
    if (zone_name != &quot;&quot;)
    {
       sendtext(&quot;This unit belongs to zone: &quot; + zone_name + &quot;&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;This unit has no zone association.&amp;n&quot;, self);
    }
    quit;
 } dilend

=== Zone-Specific Storage ===
 dilbegin zone_specific_storage(pc : unitptr);
 var
    player_zone : string;
    storage_key : string;
 code
 {
    player_zone := pc.zone;
    storage_key := &quot;chest_&quot; + player_zone;
    
    sendtext(&quot;Your zone-specific storage key is: &quot; + storage_key + &quot;&amp;n&quot;, pc);
    
    // Store player&apos;s items in zone-specific container
    store(storage_key, pc, FALSE);
    quit;
 } dilend

=== Zone-Restricted Item ===
 dilbegin zone_restricted_item(item : unitptr);
 var
    item_zone : string;
    player_zone : string;
 code
 {
    item_zone := item.zone;
    player_zone := self.zone;
    
    if (item_zone == player_zone)
    {
       sendtext(&quot;This item belongs to your current zone (&quot; + item_zone + &quot;).&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;This item is from zone &quot; + item_zone + &quot; (you are in &quot; + player_zone + &quot;).&amp;n&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* The field returns the zone name as defined in the unit&apos;s zone file
* Zone names are typically short identifiers like &quot;midgaard&quot;, &quot;death&quot;, &quot;justice&quot;
* This field is read-only and cannot be modified through DIL
* Commonly used for zone-based storage keys and file operations
* The zone name is used by functions like [[Manual:DIL_Manual/store|store]] and [[Manual:DIL_Manual/restore|restore]] for zone-specific data
* All units inherit their zone from their original definition location
* This field is essential for multi-zone environments and zone-specific mechanics

== Error Handling ==
* If accessed on a null unit pointer, the operation will fail
* If the unit has no zone association, may return an empty string
* No other error conditions are expected when accessing this field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zoneidx|zoneidx]] - The unique database name in zone format
* [[Manual:DIL_Manual/nameidx|nameidx]] - The unique database zone name for the unit
* [[Manual:DIL_Manual/store|store]] - Store unit data with zone-specific keys
* [[Manual:DIL_Manual/restore|restore]] - Restore unit data from zone-specific storage
* [[Manual:DIL_Manual/fname|fname]] - The filename of the unit&apos;s zone

== See Also ==
* Zone system documentation
* Storage and persistence functions
* Multi-zone environment handling
* Unit identification and naming systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/zone_head</title>
     <ns>0</ns>
     <id>579227</id>
     <revision>
       <id>1531681</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of zone_head.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= zone_head =
function: zoneptr &apos;&apos;&apos;zone_head&apos;&apos;&apos;();

The zone_head function returns a pointer to the first zone in the global zone list.

== Description ==
The zone_head function provides access to the head of the global zone list, allowing iteration through all zones in the game. This function is commonly used for zone management, administrative commands, and system-wide zone analysis. The returned zoneptr can be traversed using the .next field to access subsequent zones in the list. Note that this function appears to be obsolete or unused in current DIL implementations.

== Examples ==
=== List All Zones ===
 dilbegin list_all_zones();
 var
    zones : zoneptr;
    buffer : string;
 code
 {
    zones := zone_head();
    buffer := &quot;Available Zones:&amp;n&quot;;
    
    while (zones)
    {
       buffer := buffer + zones.name + &quot; - &quot; + zones.title + &quot;&amp;n&quot;;
       zones := zones.next;
    }
    
    pagestring(buffer, self);
    quit;
 } dilend

=== Zone Statistics ===
 dilbegin zone_statistics();
 var
    zones : zoneptr;
    total_zones : integer;
    total_rooms : integer;
    total_npcs : integer;
    total_objs : integer;
 code
 {
    total_zones := 0;
    total_rooms := 0;
    total_npcs := 0;
    total_objs := 0;
    
    zones := zone_head();
    while (zones)
    {
       total_zones := total_zones + 1;
       total_rooms := total_rooms + zones.roomcount;
       total_npcs := total_npcs + zones.npccount;
       total_objs := total_objs + zones.objcount;
       zones := zones.next;
    }
    
    sendtext(&quot;Zone Statistics:&amp;n&quot;, self);
    sendtext(&quot;Total Zones: &quot; + itoa(total_zones) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total Rooms: &quot; + itoa(total_rooms) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total NPCs: &quot; + itoa(total_npcs) + &quot;&amp;n&quot;, self);
    sendtext(&quot;Total Objects: &quot; + itoa(total_objs) + &quot;&amp;n&quot;, self);
    quit;
 } dilend

=== Find Zone by Name ===
 dilbegin find_zone_by_name(search_name : string);
 var
    zones : zoneptr;
    found : zoneptr;
 code
 {
    found := null;
    zones := zone_head();
    
    while (zones)
    {
       if (zones.name == search_name)
       {
          found := zones;
          break;
       }
       zones := zones.next;
    }
    
    if (found)
    {
       sendtext(&quot;Found zone: &quot; + found.title + &quot; (&quot; + found.name + &quot;)&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Zone &apos;&quot; + search_name + &quot;&apos; not found.&amp;n&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* The function returns the first zone in the global zone list
* Use the .next field to traverse through all zones
* The returned zoneptr provides access to all zone properties like .name, .title, .rooms, etc.
* Commonly used in administrative commands and zone management systems
* The zone list includes all zones currently loaded in the game
* This function appears to be obsolete or unused in current DIL implementations
* Consider using [[Manual:DIL_Manual/zhead|zhead]] instead for current implementations

== Error Handling ==
* The function always returns a valid zoneptr or null if no zones are loaded
* No error conditions are expected when calling this function
* If no zones exist in the game, the function may return null

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type and available fields
* [[Manual:DIL_Manual/zhead|zhead]] - Current implementation for getting zone list head
* [[Manual:DIL_Manual/global_head|global_head]] - Get first unit in global list
* [[Manual:DIL_Manual/obj_head|obj_head]] - Get first object in global object list
* [[Manual:DIL_Manual/npc_head|npc_head]] - Get first NPC in global NPC list
* [[Manual:DIL_Manual/room_head|room_head]] - Get first room in global room list

== See Also ==
* Zone system documentation
* Global list traversal functions
* Administrative command functions
* Zone management systems</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/zoneidx</title>
     <ns>0</ns>
     <id>505603</id>
     <revision>
       <id>1298313</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of zoneidx.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= zoneidx =
field: string &apos;&apos;&apos;.zoneidx&apos;&apos;&apos; (Read-only)

The .zoneidx field returns the unique database name identifier of a unit in zone format.

== Description ==
The .zoneidx field provides access to the unique database identifier for a unit, formatted as &quot;nameidx@zone&quot;. This identifier is commonly used for storage operations, database lookups, and zone-specific functionality. The zoneidx combines both the unit&apos;s name index and its originating zone into a single string for easy reference.

== Field Access ==
{| class=&quot;wikitable&quot;
! Access !! Type !! Description
|-
| unit.zoneidx || string || Returns the unique database name in &quot;nameidx@zone&quot; format
|}

== Availability ==
This field is available on the following unit types:
* UNIT_ST_PC (Player Character)
* UNIT_ST_NPC (Non-Player Character)
* UNIT_ST_OBJ (Object)
* UNIT_ST_ROOM (Room)

== Examples ==
=== Check Unit Identity ===
 dilbegin check_unit_identity(unit : unitptr);
 var
    unit_id : string;
 code
 {
    unit_id := unit.zoneidx;
    
    if (unit_id != &quot;&quot;)
    {
       sendtext(&quot;Unit ID: &quot; + unit_id + &quot;&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;This unit has no zone identifier.&amp;n&quot;, self);
    }
    quit;
 } dilend

=== Zone-Specific Storage ===
 dilbegin zone_specific_storage(pc : unitptr);
 var
    player_id : string;
    storage_key : string;
    storage_unit : unitptr;
 code
 {
    player_id := pc.zoneidx;
    storage_key := &quot;chest_&quot; + player_id;
    
    sendtext(&quot;Your storage key: &quot; + storage_key + &quot;&amp;n&quot;, pc);
    
    // Find zone-specific storage container
    storage_unit := load(storage_key);
    
    if (storage_unit)
    {
       sendtext(&quot;Found your storage container.&amp;n&quot;, pc);
    }
    else
    {
       sendtext(&quot;Storage container not found.&amp;n&quot;, pc);
    }
    quit;
 } dilend

=== Save Player Data ===
 dilbegin save_player_data(pc : unitptr);
 var
    player_id : string;
    save_file : string;
 code
 {
    player_id := pc.zoneidx;
    save_file := &quot;player_backup_&quot; + player_id + &quot;.dat&quot;;
    
    sendtext(&quot;Saving your data to: &quot; + save_file + &quot;&amp;n&quot;, pc);
    
    // Store player data with zone-specific filename
    store(save_file, pc, TRUE);
    quit;
 } dilend

== Usage Notes ==
* The field returns a string in &quot;nameidx@zone&quot; format
* This is the unique database identifier for the unit
* Commonly used for zone-specific storage keys and file operations
* The zoneidx is used by functions like [[Manual:DIL_Manual/store|store]] and [[Manual:DIL_Manual/restore|restore]] for data persistence
* Different from .nameidx which is just the zone name part
* Different from .zone which is just the zone name part
* Essential for multi-zone environments and zone-specific mechanics
* The format is consistent across all unit types

== Error Handling ==
* If accessed on a null unit pointer, the operation will fail
* If the unit has no zone association, may return an empty string
* No other error conditions are expected when accessing this field

== Related Functions/Fields ==
* [[Manual:DIL_Manual/nameidx|nameidx]] - The zone name part of the identifier
* [[Manual:DIL_Manual/zone|zone]] - The zone name part of the identifier
* [[Manual:DIL_Manual/symname|symname]] - The concatenated zoneidx@zone string
* [[Manual:DIL_Manual/store|store]] - Store unit data with zone-specific keys
* [[Manual:DIL_Manual/restore|restore]] - Restore unit data from zone-specific storage

== See Also ==
* Zone system documentation
* Storage and persistence functions
* Unit identification and naming systems
* Multi-zone environment handling</text>
     </revision>
   </page>
   <page>
     <title>Manual:DIL_Manual/zonereset</title>
     <ns>0</ns>
     <id>933230</id>
     <revision>
       <id>1286493</id>
       <timestamp>2025-12-04T13:55:49Z</timestamp>
       <contributor>
         <username>Admin</username>
         <id>1</id>
       </contributor>
       <comment>Automated upload of zonereset.wiki</comment>
       <model>wikitext</model>
       <format>text/x-wiki</format>
       <text xml:space="preserve">= zonereset =
procedure: &apos;&apos;&apos;zonereset&apos;&apos;&apos;(zone : zoneptr);

The zonereset procedure triggers a reset of all mobiles and objects within a specified zone.

== Description ==
The zonereset procedure initiates a complete zone reset, causing all mobiles and objects in the specified zone to be reset to their initial states. This is commonly used by administrative commands to repopulate zones after crashes, clear out accumulated changes, or refresh zone content. The reset process follows the zone&apos;s defined reset mode and timing parameters.

== PARAMETERS ==
{| class=&quot;wikitable&quot;
! Parameter !! Type !! Description
|-
| zone || zoneptr || The zone to be reset
|}

== Examples ==
=== Reset Current Zone ===
 dilbegin reset_current_zone();
 var
    current_room : unitptr;
    target_zone : zoneptr;
 code
 {
    current_room := self.outside;
    
    if (current_room and current_room.type == UNIT_ST_ROOM)
    {
       target_zone := findzone(current_room.zone);
       
       if (target_zone)
       {
          sendtext(&quot;Resetting zone: &quot; + target_zone.name + &quot;&amp;n&quot;, self);
          zonereset(target_zone);
          sendtext(&quot;Zone reset complete.&amp;n&quot;, self);
       }
       else
       {
          sendtext(&quot;Could not find zone to reset.&amp;n&quot;, self);
       }
    }
    else
    {
       sendtext(&quot;You must be in a room to reset its zone.&amp;n&quot;, self);
    }
    quit;
 } dilend

=== Zone Reset Command ===
 dilbegin zone_reset_command(arg : string);
 var
    target_zone : zoneptr;
 code
 {
    if (arg == &quot;&quot;)
    {
       sendtext(&quot;Syntax: resetzone &lt;zone_name&gt;&amp;n&quot;, self);
       quit;
    }
    
    target_zone := findzone(arg);
    
    if (target_zone)
    {
       sendtext(&quot;Initiating reset for zone: &quot; + target_zone.name + &quot;&amp;n&quot;, self);
       zonereset(target_zone);
       act(&quot;$1n has been reset.&quot;, A_ALWAYS, self, null, null, TO_ALL);
    }
    else
    {
       sendtext(&quot;Zone &apos;&quot; + arg + &quot;&apos; not found.&amp;n&quot;, self);
    }
    quit;
 } dilend

=== Emergency Reset ===
 dilbegin emergency_reset();
 var
    problem_zone : zoneptr;
 code
 {
    // Find problematic zone and reset it
    problem_zone := findzone(&quot;problem_zone&quot;);
    
    if (problem_zone)
    {
       sendtext(&quot;Emergency reset initiated for problem zone.&amp;n&quot;, self);
       zonereset(problem_zone);
       sendtext(&quot;Emergency reset complete.&amp;n&quot;, self);
    }
    else
    {
       sendtext(&quot;Problem zone not found.&amp;n&quot;, self);
    }
    quit;
 } dilend

== Usage Notes ==
* The procedure affects all mobiles and objects within the specified zone
* Reset behavior is determined by the zone&apos;s reset mode and timing settings
* Players in the zone are not affected by the reset
* The reset process follows the zone&apos;s defined reset parameters
* Commonly used after crashes, maintenance periods, or administrative cleanup
* All mobiles return to their original positions and states
* All objects are reset according to their reset definitions
* The procedure is immediate and affects the entire zone

== Error Handling ==
* If zone parameter is null, the operation fails and logs an error
* If zone parameter is not a valid zone pointer, the operation fails and logs an error
* All errors are logged to the zone&apos;s log file for debugging
* The procedure does not return any value to indicate success or failure

== Related Functions/Fields ==
* [[Manual:DIL_Manual/zone_head|zone_head]] - Get first zone in global list
* [[Manual:DIL_Manual/findzone|findzone]] - Locate a zone by name
* [[Manual:DIL_Manual/zoneptr|zoneptr]] - Zone pointer type and available fields
* [[Manual:DIL_Manual/resetmode|resetmode]] - Zone reset mode setting
* [[Manual:DIL_Manual/resettime|resettime]] - Zone reset timing setting

== See Also ==
* Zone system documentation
* Reset system documentation
* Administrative command functions
* Mobile and object management</text>
     </revision>
   </page>
</mediawiki>