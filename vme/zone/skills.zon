/*
filename    skills
password    mfxmas
changedby   Sender
EmailAdd
request     compile
version     12
END HEADER*/

#include <macros.h>

%zone skills
reset RESET_NOT
weather 1040
creators {"whistler"}

notes
"This is the skills zone. Dont let any rooms point to this zone, or use any
objects from this zone without special permission. Do not slime objects from
this zone."

#define FLEE_LEAVE "$noflee"
#define NO_TRAP "$notrap"

%dil


/* ============== GENERIC SKILLS FUNCTIONS ===================== */

/* MS2020

   Important. See game mechanics skill section on wiki.dikumud.com on how
   to do proper skill checks.
*/


/* MS2020 skillchecksau() checks 'u' versus the difficulty        */
/*    SkillIdx is the skill in question.                          */ 
/*    AbiIdx is the primary ability related                       */
/*    Difficulty is how hard. 50 means 50 hard. -50 means easier! */
/* Result > 0 is success                                          */
/* If skill and difficulty are equal => 50% chance success        */

dilbegin integer skillchecksau(u : unitptr, skillidx : integer, abiidx : integer, difficulty : integer);
var
  roll : integer;
  skl : integer;
code
{
   roll := openroll(100, 5);

   if (u.type == UNIT_ST_PC)
      skl := (u.skills[skillidx] * 2 + u.abilities[abiidx]) / 3; /* 2/3rd skill, 1/3rd ability */
   else
      skl := u.abilities[abiidx];

   if (difficulty < 0)
      log("skillchecksau < 0 (easier)");
   //log("skillchecksau() 1d100OE = " + itoa(roll) +" plus skill " + itoa(skl) + " less " + itoa(difficulty) + " less 50 > 0");

   return (roll + skl - difficulty - 50);
}
dilend



/* MS2020 skillchecksa() checks 'self' versus the difficulty
 * This is identical to skillchecksau except self == u
 */
dilbegin integer skillchecksa(skillidx : integer, abiidx : integer, difficulty : integer);
var
  roll : integer;
  skl : integer;
code
{
   roll := openroll(100, 5);

   if (self.type == UNIT_ST_PC)
      skl := (self.skills[skillidx] * 2 + self.abilities[abiidx]) / 3; /* 2/3rd skill, 1/3rd ability */
   else
      skl := self.abilities[abiidx];

   if (difficulty < 0)
      log("skillchecksa < 0 (easier)");

   //log("skillchecksa() 1d100OE = " + itoa(roll) +" plus skill " + itoa(skl) + " less " + itoa(difficulty) + " less 50 > 0");

   return (roll + skl - difficulty - 50);
}
dilend


/* MS2020 skillchecksaopp() checks 'self' versus the opponent
 *    skillidx 
 *    abiidx
 *    opp
 */
dilbegin integer skillchecksaopp(skillidx : integer, abiidx1 : integer, abiidx2 : integer,
                                 opp : unitptr, oabiidx1 : integer, oabiidx2 : integer);
var
   roll : integer;
   skl : integer;
   oppskl : integer;

code
{
   roll := openroll(100, 5);

   skl := (2*self.abilities[abiidx1]+self.abilities[abiidx2]) / 3;
   if (self.type == UNIT_ST_PC)
      skl := (self.skills[skillidx] * 2 + skl) / 3;   // 2/3rd skill, 1/3rd ability

   oppskl := (2*opp.abilities[oabiidx1]+opp.abilities[oabiidx2]) / 3;
   if (opp.type == UNIT_ST_PC)
      oppskl := (opp.skills[skillidx] * 2 + oppskl) / 3; // 2/3rd skill, 1/3rd ability

   //log("skillchecksaopp() 1d100OE = " + itoa(roll) +" plus skill " + itoa(skl) + " less " + itoa(difficulty) + " less 50 > 0");

   return (roll + skl - oppskl - 50);
}
dilend


/* MS2020 SkillCheck() the skill versus the difficulty           */
/* When skill equals difficulty there's a 50% chance of success. */ 
/* Result > 0 is success                                         */
dilbegin integer skillcheck(skilllevel : integer, difficulty : integer);
var
  i : integer;
code
{
   i := openroll(100, 5);

   if (difficulty < 0)
      log("skillchecks < 0 (easier)");

   //log("1d100OE = " + itoa(i) +" plus skill " + itoa(skilllevel) + " less " + itoa(difficulty) + " less 50 > 0");
   return (i + skilllevel - difficulty - 50);
}
dilend


/* MS2020 E.g. resist. If person resisting is higher level, then deltalevel should be positive */
/* E.g. flee.   If person fleeing is higher level, then deltalevel should be positive */
/* deltalevel is the level difference of the two involved chars and wil be multiplied by 5 */
/* Result > 0 is success */
dilbegin integer skillchecklevel(skilllevel : integer, deltalevel : integer);
code
{
   return (openroll(100, 5) + skilllevel + deltalevel*5 - 50);
}
dilend


/* skillbattle
 *   att : the char attacking
 *   attskiidx : e.g. SKI_STEAL
 *   attabiidx : e.g. ABIL_DEX
 *   def : the char defending
 *   defskiidx : e.g. 
 */
dilbegin integer skillbattle(att : unitptr, attskiidx : integer, attabiidx : integer,
                             def : unitptr, defskiidx : integer, defabiidx : integer);
var
  aski, aabi : integer;
  dski, dabi : integer;

code
{
   aabi := att.abilities[attabiidx];
   if (att.type == UNIT_ST_PC)
      aski := att.skills[attskiidx];
   else
      aski := aabi;

   dabi := def.abilities[defabiidx];
   if (def.type == UNIT_ST_PC)
      dski := def.skills[defskiidx];
   else
      dski := dabi;

   return (openroll(100, 5) + aabi + aski - dabi - dski - 50);
}
dilend



dilbegin integer skillchar(u : unitptr, skiidx : integer, abiidx : integer);
code
{
   if (u.type == UNIT_ST_PC)
      return(u.skills[skiidx]);
   else
      return(u.abilities[abiidx]);
}
dilend


dilbegin integer skillresist(aa : integer, ad : integer,
			     sa : integer, sd : integer);
code
{
                                         /* 100 was 50*/
   return (openroll(100, 5) + aa + sa - ad - sd - 50);
}
dilend


/* MS2020. Adjective for how well you managed a skill. >=1 means you made it. */
dilbegin string hm_adjective(hm : integer);
code
{
   if (hm  >= 200)
      return (" divinely ");
   else if (hm >= 100)
      return (" masterfully ");
   else if (hm >= 50)
      return (" skillfully ");
   else if (hm < -100)
      return (" terribly ");
   else if (hm < -50)
      return (" miserably ");

   return(" ");  // or maybe routinely ?
}
dilend




// THis could really do with a rewrite. And why can't you swim away? Or enter a room or exit a room? :o)
// 
dilbegin stringlist get_exits(u : unitptr);
var
   dir : stringlist;

code
{
   if((u.exit_to[NORTH] != null) and (not(isset(u.exit_info[NORTH], EX_CLOSED)))
      and (not(isset (u.exit_info[NORTH],EX_HIDDEN))) and (u.exit_to[NORTH].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(NORTH));
   if((u.exit_to[EAST] != null) and (not(isset(u.exit_info[EAST], EX_CLOSED)))
      and (not(isset (u.exit_info[EAST], EX_HIDDEN))) and (u.exit_to[EAST].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(EAST));
   if((u.exit_to[SOUTH] != null) and (not(isset(u.exit_info[SOUTH], EX_CLOSED)))
      and (not(isset (u.exit_info[SOUTH], EX_HIDDEN))) and (u.exit_to[SOUTH].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(SOUTH));
   if((u.exit_to[WEST] != null) and (not(isset(u.exit_info[WEST], EX_CLOSED)))
      and (not(isset (u.exit_info[WEST], EX_HIDDEN))) and (u.exit_to[WEST].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(WEST));
   if((u.exit_to[UP] != null) and (not(isset(u.exit_info[UP], EX_CLOSED)))
      and (not(isset (u.exit_info[UP], EX_HIDDEN))) and (u.exit_to[UP].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(UP));
   if((u.exit_to[DOWN] != null) and (not(isset(u.exit_info[DOWN], EX_CLOSED)))
      and (not(isset (u.exit_info[DOWN], EX_HIDDEN))) and (u.exit_to[DOWN].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(DOWN));
   if((u.exit_to[NORTHEAST] != null) and (not(isset(u.exit_info[NORTHEAST], EX_CLOSED)))
      and (not(isset (u.exit_info[NORTHEAST], EX_HIDDEN))) and (u.exit_to[NORTHEAST].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(NORTHEAST));
   if((u.exit_to[NORTHWEST] != null) and (not(isset(u.exit_info[NORTHWEST], EX_CLOSED)))
      and (not(isset (u.exit_info[NORTHWEST], EX_HIDDEN))) and (u.exit_to[NORTHWEST].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(NORTHWEST));
   if((u.exit_to[SOUTHEAST] != null) and (not(isset(u.exit_info[SOUTHEAST], EX_CLOSED)))
      and (not(isset (u.exit_info[SOUTHEAST], EX_HIDDEN))) and (u.exit_to[SOUTHEAST].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(SOUTHEAST));
   if((u.exit_to[SOUTHWEST] != null) and (not(isset(u.exit_info[SOUTHWEST], EX_CLOSED)))
      and (not(isset (u.exit_info[SOUTHWEST], EX_HIDDEN))) and (u.exit_to[SOUTHWEST].movement != SECT_WATER_SAIL))
         addstring(dir, itoa(SOUTHWEST));

   return(dir);
}
dilend


dilbegin string sizestring(cm : integer);
var
   ftn : integer;
   fts : string;
   inn : integer;
   ins : string;
code
{
   /* One inch equals 2,54 cm. There are 12 inches (30.48 cm) to a foot */
   ftn := cm / 30;
   inn := (10*(cm % 30))/25;
   if (ftn == 1)
     fts := "one foot";
   else if (ftn > 1)
     fts := itoa(ftn)+" feet";
   else
     fts := "";

   if (inn == 1)
     ins := "one inch";
   else if (inn > 1)
     ins := itoa(inn)+" inches";
   else
     ins := "";

   if (fts != "")
   {
      if (ins != "")
        fts := fts + " and ";
   }
   else
   {
      if (inn < 1)
	ins := "less than an inch";
   }

   return (fts + ins);
}
dilend


dilbegin string weightstring(p : integer);
var
   s : string;
code
{
   if (p == 1)
     s := "one pound";
   else if (p > 1)
     s := itoa(p)+" pounds";
   else
     s := "less than a pound";

   return (s);
}
dilend


dilbegin provoked_attack(victim : unitptr, ch : unitptr);
code
{
   if (not (victim.type & (UNIT_ST_NPC|UNIT_ST_PC)))
     return; /* FALSE */

   if (not (ch.type & (UNIT_ST_PC|UNIT_ST_NPC)))
     return; /* FALSE */

   if (victim.level >= 200)
     return; /* FALSE */

   if (ch.level >= 200)
     return; /* FALSE */

   if (not isset(ch.charflags, CHAR_SELF_DEFENCE))
   {
      if ((ch.fighting == null) and (not isset(victim.charflags, CHAR_LEGAL_TARGET)))
        set(victim.charflags, CHAR_SELF_DEFENCE);
   }

   /* Test for LEGAL_TARGET bit */
   if (isset(victim.charflags, CHAR_PROTECTED))
   {
       if ((not isset(victim.charflags, CHAR_LEGAL_TARGET)) and
           (not isset(ch.charflags, CHAR_SELF_DEFENCE)))
         set(ch.charflags, CHAR_LEGAL_TARGET);
   }

   if (victim.position <= POSITION_SLEEPING)
     return; /* FALSE */

   if (isset(victim.charflags, CHAR_PEACEFUL))
     return; /* FALSE */

   if (opponent(victim, ch))
     return; /* TRUE */

   set_fighting(victim, ch);

   return; /* TRUE */
}
dilend


dilbegin integer skill_duration(hm : integer);
code
{
   if (hm < 20)
     return (2);
   else if (hm > 150)
     return (15);
   else
     return (hm / 10);
}
dilend



/* ============== SKILLS BEGIN HERE ===================== */

/* do_steal */
dilbegin steal(arg : string);
external
   integer skillresist (aa : integer, ad : integer, sa : integer, sd : integer);
   provoked_attack (victim : unitptr, ch : unitptr);
   integer skillbattle(att : unitptr, attskiidx : integer, attabiidx : integer,
                       def : unitptr, defskiidx : integer, defabiidx : integer);


var
   skilla  :  integer;
   skillb  :  integer;
   skillc  :  integer;
   skilld  :  integer;
   hm      :  integer;
   vict    :  unitptr;
   object  :  unitptr;
   targ    :  unitptr;
   hands   :  integer;
   t       :  string;
   temp    : string;
   ti:integer;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_STEAL] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   object := self.inside;
   while ((object) and (hands != 2))
   {
      if ( ((object.equip == WEAR_WIELD) or (object.equip == WEAR_HOLD))
            and (isset(object.objectflags, OBJ_TWO_HANDS)) )
      {
         hands := 2;
         continue;
      }

      if ( (object.equip == WEAR_HOLD) or (object.equip == WEAR_WIELD) or
            (object.equip == WEAR_SHIELD) )
      {
         hands := hands + 1;
      }
      object := object.next;
   }

   if (hands == 2)
   {
      act("You must have at least one hand free to attempt that!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (" from " in arg))
   {
      act("Steal what from who?", A_SOMEONE, self, null, null,  TO_CHAR);
      quit;
   }

   /* needed for multi word names */
   t := getword(arg);
   temp := getword(arg);
   while (temp != "from")
   {
      t := (t + " " + temp);
      temp := getword(arg);
   }

   vict := findunit(self, arg, FIND_UNIT_SURRO, null);
   if ((vict == null) or not visible(self, vict))
   {
      act("No such person to steal from.",  A_SOMEONE, self, null,  null, TO_CHAR);
      quit;
   }


   if ( (vict.type != UNIT_ST_PC) and (vict.type != UNIT_ST_NPC) )
   {
      act("Why bother? Just get the darn thing!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if ((vict.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
   {
      if (not(isset (self.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless you sign the book of blood.", A_ALWAYS,self,null,null,TO_CHAR);
         quit;
      }

      if (not(isset (vict.pcflags, PC_PK_RELAXED)))
      {
         act("You are not allowed to do this unless $2e signs the book of blood.",
               A_ALWAYS,self,vict,null,TO_CHAR);
         quit;
      }
   }

   targ := findunit(vict, t, FIND_UNIT_IN_ME, null);

   if ((targ == null) or not visible(self,targ))
   {
      act("You can't find that on $3n.", A_SOMEONE, self, targ, vict, TO_CHAR);
      quit;
   }

   if (targ.objecttype == ITEM_MONEY)
   {
      act("That would take a different type of finesse, try pilfering " +
          "instead.", A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
   }

   if ( (targ.equip != 0) )  /* 0 = not equipped, value not in values.h */
   {
      act("You can only steal non-equiped items!", A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
   }

   if (targ.zoneidx == "treasure")
   {
      act("A chill runs down your spine...someone or something is watching.",
         A_ALWAYS, self, null, null, TO_CHAR);
      act("You change your mind about stealing that.", A_ALWAYS, self,
         null, null, TO_CHAR);
      quit;
   }

   ti:=can_carry (self,targ,1);
   if (ti==1)
	{
      act ("You can't carry another thing.", A_ALWAYS,self,null,null,TO_CHAR);
      quit;
   }

   hm := skillbattle(self, SKI_STEAL, ABIL_DEX, vict, SKI_STEAL, ABIL_BRA);


   if (hm <= -5)
   {
      act("You are caught!", A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
      {
         subaff(self, ID_INVISIBILITY);
      }
      act("You catch $1n trying to steal your $2n!", A_SOMEONE, self, targ,
          vict, TO_VICT);
      act("You see $1n trying to steal something from $3n...$3e doesn't " +
          "seem amused!", A_SOMEONE, self, targ, vict, TO_NOTVICT);
      provoked_attack (vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }

   if (hm <= 0)
   {
      act("You fail to steal $3n's $2n, but at least no one was watching!",
        A_SOMEONE, self, targ, vict, TO_CHAR);
      quit;
   }
   if (hm < 5)
   {
      act("You steal $2n from $3n just as $3e turns toward you..You have "+
          "been caught!", A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
      {
          subaff(self, ID_INVISIBILITY);
      }
      act("Arrgh!  $1n just stole your $2n!", A_SOMEONE, self, targ, vict, TO_VICT);
      act("You see $1n steal something from $3n...$3e doesn't seem amused!",
          A_SOMEONE, self, targ, vict, TO_NOTVICT);
      link(targ, self);
      provoked_attack (vict, self);
      logcrime(self, vict, CRIME_STEALING);
      send_done("steal",self,targ,vict,hm,arg,null);
      quit;
   }

   act("You stealthily steal $3n's $2n and quickly tuck it out of sight!", A_SOMEONE, self, targ, vict, TO_CHAR);
   link(targ, self);
   send_done("steal",self,targ,vict,hm,arg,null);
   quit;
}
dilend


dilbegin do_use(arg : string);
external
   integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);
   integer skillchar(u : unitptr, skiidx : integer, abiidx : integer);

var
   stick : unitptr;
   i      : integer;
   skilla   : integer;
   skillb   : integer;
   skillc   : integer;
   skilld   : integer;
   hm     : integer;
   tgt    : unitptr;
   sc_st  : string;
   mast   : unitptr;

code
{
   if(arg == "")
   {
      act("Use what?", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   stick := findunit(self,arg,FIND_UNIT_HERE,null);
   if(stick == null)
   {
      sendtext("How do you intend to use what you do not have?.<br/>",self);
      quit;
   }

   if ((stick.objecttype != ITEM_STAFF) and (stick.objecttype != ITEM_WAND))
   {
      sendtext("Use is intended to be used with wands and staffs.<br/>",self);
      return;
   }

   stick:=equipment(self,WEAR_HOLD);
   if (stick ==null)
   {
      act("You must hold it in your hand to use it.", A_SOMEONE, self, null, null, TO_CHAR);
      return;
   }
   
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_WAND_USE] <= 0))
   {
      sendtext("You must practice first.<br/>",self);
      return;
   }
 
   /* Are there any charges left? */
   if (stick.value[1] <= 0)
   {
      act ("The $2N seems to be drained of all power.", A_ALWAYS, self, stick, null, TO_CHAR);
      quit;
   }

   if (stick.objecttype == ITEM_WAND)
   {
      if (isset(self.charflags,CHAR_BLIND)) // You can't use a wand when blind
      {
         act("You can't see anything!!! You're blind!", A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
   }

   // First a skill check if you successfully can use the wand (you against wand)
   //    stick.value[0] contains the spell power (level)

   skilla := skillchar(self, SKI_WAND_USE, ABIL_BRA);
   skilld := stick.value[0];

   // Check if the character has enough skill with wands to actually use it.
   hm := skillresist(skilla, self.abilities[ABIL_BRA], skilld, skilld);

   /* all considerations before here, now we are ready */

   stick.spells[SPL_ALL] := stick.value[0]; // Why?
   stick.value[1] := stick.value[1] - 1;  // Use one charge even if two spells on device
 
   if (stick.objecttype == ITEM_STAFF)
   {
      if (hm <= 0) // Failed to use the wand / staff
      {
         act ("$1n taps $2n a few times on the ground.", A_HIDEINV, self, stick, null, TO_ROOM);

         if (hm < -50) // If you fail hard, you drain a charge
         {
            act("You unsuccessfully tap $2n a few times on the ground and drain it of some power.", A_SOMEONE, self, stick, null, TO_CHAR);
            stick.value[1] := stick.value[1] - 1;
         }
         else
            act("You tap $2n a few times on the ground...Nothing happens.", A_SOMEONE, self, stick,null, TO_CHAR);

         quit;
      }

      act("$1n taps $2n three times on the ground.", A_SOMEONE, self, stick, null, TO_ROOM);
      act("You tap $2n three times on the ground.", A_SOMEONE, self, stick, null, TO_CHAR);

      mast := self.master;
      if (not(self.master))
         mast := self;

      i := 2;  // stick.value[2] and [3] are spells
      while (i <= 3)
      {
         if (stick.value[i] != SPL_NONE)
         {
            foreach (UNIT_ST_PC | UNIT_ST_NPC, tgt)
            {
               if (self == tgt) continue;

               if (tgt.level >= IMMORTAL_LEVEL) continue;

               if (((tgt.type==UNIT_ST_PC) and(self.type==UNIT_ST_PC)) and
                     ((not (isset(tgt.pcflags,PC_PK_RELAXED))) or
                     (not (isset (self.pcflags,PC_PK_RELAXED))))) 
                  continue;
               
               if ((tgt.master != mast) and (tgt != mast) and (tgt != self))
                  cast_spell(stick.value[i], self, stick, tgt);
            }
         }
         i := i + 1;
      }
      send_done("use",self,stick,null,0,arg,null);
      quit;
   }


   // ====== WAND  =====


   tgt := findunit (self, arg, FIND_UNIT_HERE,null);

   if ((tgt.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
   {
      if (not(isset(self.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless you sign the book of blood.",
            A_ALWAYS,self,null,null,TO_CHAR);
         quit;
      }

      if (not(isset (tgt.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless $2e signs the book of blood.",
         A_SOMEONE,self,tgt,null,TO_CHAR);
         quit;
      }
   }

   if (tgt==null)
	{
      sendtext("You must use it on somebody.<br/>",self);
      quit;
	}

   if (self == tgt)
	{
      sendtext("You must use it on somebody not yourself!.<br/>",self);
      quit;
	}

   if (hm <= 0) // Failed to use the wand / staff
   {
      act ("$1n points $2n at $3n.", A_HIDEINV, self, stick, tgt, TO_ROOM);

      if (hm < -50) // If you fail hard, you drain a charge
      {
         act("You unsuccessfully use $2n and drain it of some power.", A_SOMEONE, self, stick, null, TO_CHAR);
         stick.value[1] := stick.value[1] - 1;
      }
      else
         act("You use $2n... nothing happens.", A_SOMEONE, self, stick,null, TO_CHAR);

      quit;
   }

   if (tgt.type == UNIT_ST_PC)
	{
      act("$1n points $2n at $3n.", A_HIDEINV, self, stick, tgt, TO_NOTVICT);
      act("$1n points $2n at you.", A_HIDEINV, self, stick, tgt, TO_VICT);
	}
   else
      act("$1n points $2n at $3n.", A_HIDEINV, self, stick, tgt, TO_ROOM);

   act ("You point $2n at $3n.", A_SOMEONE, self, stick, tgt, TO_CHAR);

   stick.spells[SPL_ALL] := stick.value[0]; // Why?

   i := 2;
   while (i <= 3)
   {
      if (stick.value[i] != SPL_NONE)
      {
         cast_spell(stick.value[i],self,stick,tgt);
      }
      i := i + 1;
   }


   send_done("use",self,stick,tgt,0,arg,null);
   quit;

   :losttgt:
   unsecure (tgt);
   quit;
}
dilend



/* do_flee in dil */
dilbegin aware flee(arg : string);
external
   string   dirstring@function(a3 : integer);
   stringlist get_exits@skills(u1 : unitptr);
   unitptr  unit_room@function(u2 : unitptr);
   integer issetclimb@function(d:integer);
   integer skillbattle(att : unitptr, attskiidx : integer, attabiidx : integer,
                        def : unitptr, defskiidx : integer, defabiidx : integer);

var
   i       :  integer;
   skill_flee :  integer;  
   me      :  unitptr;
   pc      :  unitptr;
   hm      :  integer;
   roomlst :  stringlist;
   climb_rm:unitptr;
   rm      :  integer;
   direc   :  string;
   dir_name:string;
   rmm     :  unitptr;
   roomin  :  unitptr;
   dirlist :  stringlist;
   rmchk   :  extraptr;
   mestring :  string;
   res:integer;

code
{
   interrupt (SFB_DEAD,self==activator,stopdie);

   /* MS2020 ought to be placed on vines DIL, not here. */
   if(dilfind("entangled_2@spells",self))
   {
      act("You struggle to flee but are prevented by the vines!.",
      A_SOMEONE, self, null, null, TO_CHAR);
      act("$1n struggles to flee but is prevented by the entangling vines.",
      A_SOMEONE, self, null, null, TO_REST);
      quit;
   }

   if (self.outside.type == UNIT_ST_NPC)
   {
      me := self.outside;
      mestring := "Your " + self.outside.name + " is";
   }
   else
   {
      me := self;
      mestring := "You are";
   }

   if (me.endurance < 20)
   {
      act("$2t too exhausted to flee.", A_SOMEONE, self, mestring, null, TO_CHAR);
      quit;
   }

   res := send_pre("flee", self, null, null, 0, arg, null);
   if (res != SFR_SHARE)
      quit;

   pc:=self.fighting;
   if (pc == null)
      goto flee;

   hm := skillbattle(self, SKI_FLEE, ABIL_DEX, pc, SKI_FLEE, ABIL_DEX);

   if (hm <= 0)
   {
      act("You PANIC! but you cannot escape!", A_SOMEONE, self, null, null, TO_CHAR);
      act("$1n tries to flee, but $1e cannot!", A_SOMEONE, self, null, null, TO_REST);
      self.endurance := self.endurance - hm/5;
      position_update(self);
      quit;
   }

   :flee:
   me.endurance := me.endurance - 20;
   position_update(me);

   if (me.type == UNIT_ST_NPC)
      self.endurance := self.endurance - 5;

   if (pc != null)
   {
      /* spare attack on the flee-er*/
      /* made this more random should not be every flee attempt they get an extra hit*/

      /* If you make your skill check with more than 50, no extra hit */
      if (hm <= 50)
      {
         act("As $2n flees, you hit $2m!", A_SOMEONE, pc, self, null, TO_CHAR);
         act("As you flee, $2n hits you!", A_SOMEONE, self, pc, null, TO_CHAR);

         hm := meleeattack(pc, self, (50-hm), -1); /* 50-hm is the bonus */

         if (self.fighting == pc)
            stop_fighting(self, pc);

         if (pc.fighting == null)
         {
            pc.position := POSITION_STANDING;
            position_update(pc);
         }
         if (self.fighting == null)
         {
            self.position := POSITION_STANDING;
            position_update(self);
         }

         if (self.hp <= 0)
            quit;
      }
   }

   if (me.outside.type != UNIT_ST_ROOM)
      goto flee_nonroom;

   roomin := me.outside;
   rmchk := FLEE_LEAVE in roomin.extra;
   roomlst := get_exits@skills(roomin);

   if(length(roomlst) == 0)
   {
      act("This room has no exits to flee through!", A_SOMEONE, self, null, null, TO_CHAR);
      /*  change_speed(self,24);*/
      quit;
   }

   rm := rnd(0, (length(roomlst) - 1));

   dirlist := {"to the north","to the east","to the south","to the west","upward","downward",
      "to the northeast", "to the northwest","to the southeast","to the southwest"};

   direc := dirstring@function(atoi(roomlst.[rm]));
   res := send_pre(direc, self, null, null, 0, arg, null);
   if (res != SFR_SHARE)
      quit;

   if ((rmchk != null) and (direc in rmchk.names))
   {
      direc := dirlist.[atoi(roomlst.[rm])];
      act("You try to flee $2t, but something prevents you from fleeing in that direction!",
          A_SOMEONE, self, direc, null, TO_CHAR);
      quit;
   }

   direc  := dirlist.[atoi(roomlst.[rm])];

   if (issetclimb@function(atoi(roomlst.[rm])))
   {
      act ("You look around quickly for the best way out and decide climbing is your nearest choice.",
         A_ALWAYS,self,null,null,TO_CHAR);
      act ("$1n looks around and decides to try to climb $1s way out of trouble.",
         A_SOMEONE,self,null,null,TO_REST);
      direc:=dirstring@function(atoi(roomlst.[rm]));

      exec ("climb "+direc,self);
   }
   else
   {
      if (self.outside.type != UNIT_ST_NPC)
      {
         act("You flee head over heels!", A_SOMEONE, self, null, null, TO_CHAR);
         act("$1n flees head over heels $2t!", A_SOMEONE, self, direc, null, TO_ROOM);
      }
      else
      {
         act("You charge away on your $2N!", A_SOMEONE, self, me, null, TO_CHAR);
         act("$1n charges away on $1s $2N $3t!", A_SOMEONE, self, me, direc, TO_ROOM);
      }

      link(me, me.outside.exit_to[atoi(roomlst.[rm])]);
      if (self.outside.type != UNIT_ST_NPC)
         act("$1n flees into the room!", A_SOMEONE, self, direc, null, TO_ROOM);
      else
         act("$1n charges into the room on $1s $2N!", A_SOMEONE, self, me, direc, TO_ROOM);

      self.position := POSITION_STANDING;
      position_update(pc);
      exec("look", self);
   }
   quit;


   :flee_nonroom:
   roomin := me.outside;

   if (self.outside.type != UNIT_ST_NPC)
   {
      act("You flee head over heels!", A_SOMEONE, self, null, null, TO_CHAR);
      act("$1n flees head over heels out of $2n!", A_SOMEONE, self, self.outside, null, TO_ROOM);
   }
   else
   {
      act("You charge away on your $2N!", A_SOMEONE, self, me, null, TO_CHAR);
      act("$1n charges out of $3n on $1s $2N!", A_SOMEONE, self, me, me.outside, TO_ROOM);
   }

   exec("exit", self);

   if (not isset(roomin.flags, UNIT_FL_TRANS))
   {
      if (self.outside.type != UNIT_ST_NPC)
         act("$1n flees out of $2n!", A_SOMEONE, self, roomin, null, TO_ROOM);
      else
         act("$1n charges out of $2n on $1s $2N!", A_SOMEONE, self, me, roomin, TO_ROOM);
   }

   self.position := POSITION_STANDING;
   position_update(pc);

   :stopdie:
   quit;
}
dilend



/* new picklock dil do_picklock */
dilbegin picklock(arg : string);
external
   integer is_hidden@basemove(u1 : unitptr, int1 : integer, u2 :unitptr);
   string  dirstring@function(i2 : integer);
   integer skillresist(i3 : integer, i4 : integer, i5 : integer, i6 : integer);
   integer skillchecksa(skillidx : integer, abiidx : integer, difficulty : integer);
   checkstand@basemove();
   integer checkdoor@basemove(arg : string);

var
   item       :  unitptr;
   pc         :  unitptr;
   arg1       :  string;
   arg2       :  string;
   arg3       :  stringlist;
   dir        :  integer;
   oppdir     :  intlist;
   test       :  integer;
   count      :  integer;
   counter    :  integer;
   hm         :  integer;
   aa         :  integer;
   ab         :  integer;
   ba         :  integer;
   bb         :  integer;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_PICK_LOCK] <= 0))
   {
      act("Perhaps you should practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   checkstand@basemove();

   if (arg == "")
   {
      act("Pick what?", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.endurance < 1)
   {
      act("You're too exhausted to pick locks right now.", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   /* next we see if the player has anything in his inventory or around him that he can lock */

   arg1 := arg;       /* saves the string in case we need it later */

   item := findunit(self, arg1, FIND_UNIT_HERE, null);

   /* If there is no item or we cant see it, check the doors in the room */
   if (item == null)
      goto check_doors;

   if (not visible(self, item))
      goto check_doors;

   if (isset(item.flags, UNIT_FL_BURIED))
      goto check_doors;

   /* If it cant be opened, it cant be locked. let the player know */
   if (not isset(item.openflags, EX_OPEN_CLOSE))
   {
      act("That is impossible", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   /* Check to make sure the object has a 'key' associated with it. */
   if (item.key == "")
   {
      act("Odd, you can't seem to find a keyhole.", A_ALWAYS, self, null, null, TO_CHAR);
       quit;
   }

   /* See if it is opened */
   if (not isset(item.openflags, EX_CLOSED))
   {
      act("It isn't even closed.....", A_ALWAYS, self, item, null, TO_CHAR);
      quit;
   }

   /* Check if it is locked */
   if (not isset(item.openflags, EX_LOCKED))
   {
      act("Oh... it wasn't locked, after all.", A_ALWAYS, self, item, null, TO_CHAR);
      quit;
   }

   if (self.level < IMMORTAL_LEVEL)
   {
      if (isset(item.openflags, EX_PICKPROOF))
         hm := -1;
      else
         hm := skillchecksa(SKI_PICK_LOCK, ABIL_DEX, item.opendiff);
   }
   else
      hm := 1;    /* imms always pick */

   if (hm < 0)
   {
      act("You fail to pick the $2N.", A_ALWAYS, self, item, null, TO_CHAR);
      act("$1n fails to pick the $2N.", A_SOMEONE, self, item, null, TO_REST);
      self.endurance := self.endurance + hm;
      quit;
   }

   act("You successfully pick the $2N - *click*", A_ALWAYS, self, item, null,TO_CHAR);
   act("$1n picks the $2n - *click*", A_ALWAYS, self, item, null, TO_REST);
   unset(item.openflags, EX_LOCKED);
   quit;


:check_doors:
   dir := checkdoor@basemove(arg);

   item := self.outside;
   if (item.type != UNIT_ST_ROOM)
      item:=item.outside;
      
   if (not isset(item.exit_info[dir], EX_CLOSED))
   {
      act("Perhaps you should close it first....", A_ALWAYS, self, null, null,TO_CHAR);
      quit;
   }

   if (item.exit_key[dir] == "")
   {
      act("Odd - you can't seem to find a keyhole.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (not isset(item.exit_info[dir], EX_LOCKED))
   {
      act("Oh... it wasn't locked, after all.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (isset(item.exit_info[dir], EX_PICKPROOF))
   {
      act("This door seems to be pick proof.",
      A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n Tries to pick the door but finds it impossible.",
      A_SOMEONE, self, null, null, TO_REST);
      quit;
   }

   if (self.level < IMMORTAL_LEVEL)
   {
      hm := skillchecksa(SKI_PICK_LOCK, ABIL_DEX, item.exit_diff[dir]);
   }
   else
      hm := 100;    /* imms always pick */

   if (hm < 0)
   {
      act("You fail to pick the $2t.", A_ALWAYS, self, item.exit_names[dir].[0], null, TO_CHAR);
      act("$1n fails to pick the $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_REST);
      self.endurance := self.endurance + hm;
      quit;
   }

   act("You successfully pick the $2t - *click*", A_ALWAYS, self, item.exit_names[dir].[0], null, TO_CHAR);
   act("$1n picks the $2t - *click*", A_HIDEINV, self, item.exit_names[dir].[0], null, TO_REST);

   unset(item.exit_info[dir], EX_LOCKED);
   unset(item.exit_to[dir].exit_info[oppdir.[dir]], EX_LOCKED);

   pc := item.exit_to[dir].inside;

   if (pc != null)
      act("A soft *click* comes from the $2t.", A_SOMEONE, pc, item.exit_to[dir].exit_names[oppdir.[dir]].[0], null, TO_ALL);
   quit;
}
dilend


#define  SKIN_SKIN    "skin"
#define  SKIN_HIDE    "hide"
#define  SKIN_FUR     "fur"
#define  SKIN_SCALE   "scales"
#define  SKIN_FEATHER "feathers"
#define  SKIN_QUILL   "quills"
#define  SKIN_TREE    "bark"
#define  SKIN_SHELL   "shell"
#define  SKIN_LEAF    "leafs"
#define  SKIN_NONE    "NONE"


dilbegin ski_glance(arg : string);
external
	integer skillresist (aa : integer, ad : integer,
                             sa : integer, sd : integer);
	string eq_string@commands(i : integer,ting : unitptr);
var
   tgt : unitptr;
   res : integer;
   obj : unitptr;
   num : integer;
   buf : string;
   str : string;
   len : integer;
   tot : integer;
   skilla : integer;
   skillb : integer;
   skillc : integer;
   skilld : integer;

code
{
   if(self.skills[SKI_GLANCE] <= 0)
   {
      sendtext("You must practice first.<br/>", self);
      quit;
   }

   if(arg == "")
   {
      sendtext("Glance at who?<br/>", self);
      quit;
   }

   if(not isaff(self,ID_SNEAK))
   {
      sendtext("Maybe you should try a 'sneakier' approach.<br/>", self);
      quit;
   }

   if(not isaff(self, ID_HIDE))
   {
      sendtext("Without hiding? What are you crazy?<br/>", self);
      quit;
   }

   tgt := findunit(self,arg,FIND_UNIT_SURRO,null);

   if((tgt == null) or (not visible(self,tgt)))
   {
      sendtext("No such person here.<br/>", self);
      quit;
   }

   if(tgt == self)
   {
      sendtext("You glance at yourself, amazing ehh?<br/>", self);
      act("$1n glances at $1mself.",
         A_SOMEONE, self, null, null, TO_REST);
      quit;
   }

   if(self.type==UNIT_ST_PC)
      skillc:=self.skills[SKI_GLANCE];
   else
      skillc := rnd(40,124);

   /*        skillc:=self.abilities[ABIL_BRA];     */
   if(tgt.type==UNIT_ST_PC)
      skilld:=tgt.skills[SKI_GLANCE];
   else
      skilld := rnd(40,124);

   /*   skilld:=tgt.abilities[ABIL_BRA]; */
   skilla:=self.abilities[ABIL_DEX];
   skillb:=tgt.abilities[ABIL_DEX];

   res:=skillresist(skilla,skillb,skillc,skilld);

   /* res := skillresist(self.abilities[ABIL_DEX],
                     tgt.abilities[ABIL_DEX],
                     self.skills[SKI_GLANCE],
                     tgt.skills[SKI_GLANCE]);*/
   if(res <= 0)
   {
      act("You try and sneak a peak at $3n, but $3e slaps you in the face.",
         A_ALWAYS, self, null, tgt, TO_CHAR);
      act("$1n tries to sneak a peak at $3n, but $3e slaps $1m in the face.",
         A_SOMEONE, self, null, tgt, TO_NOTVICT);
      act("$1n tries to sneak a peak at you, but you slap $1m in the face.",
         A_SOMEONE, self, null, tgt, TO_VICT);

      self.hp := self.hp - rnd(5,30);
      position_update(self);
      quit;
   }
   else if(res <= 50)
   {
      act("You glance at $3n briefly, but have to away before $1e catches you.",
         A_SOMEONE, self, null, tgt, TO_CHAR);
      num := rnd(2,18);
   }
   else
   {
      act("You stealthily sneak a peak at $3n out of the corner of your eye.",
         A_SOMEONE, self, null, tgt, TO_CHAR);
      num := 25; /* more than enough to see all positions */
   }

   obj := tgt.inside;
   if (tgt.extra.[""].descr != "")
      sendtext(tgt.extra.[""].descr,self);

   if (isset(tgt.pcflags,PC_PK_RELAXED))
   {
      act("<br/>You notice a scar on $3s wrist from the Book of Blood.",
         A_SOMEONE, self, null, tgt, TO_CHAR);
   }

   tot := 0;
   buf := "";
   buf:=buf+"<table class='colh2'>";

   while((obj != null) and (num > 0))
   {
      if (obj.equip)
      {
         str := eq_string@commands(obj.equip,obj);
         buf := buf+"<tr><td>&lt;"+str+"&gt;</td><td><div class='worn'>"+obj.title+"</div></td></tr>";
         tot := tot + 1;
         num := num - 1;
      }

      obj := obj.next;
   }
   buf:=buf+"</table>";

   if(tot < 1)
 	   buf := "Nothing<br/>";

   sendtext(buf,self);
   send_done("glance",self,null,tgt,res,arg,null);

   quit;
}
dilend


// do_bash
dilbegin ski_bash(arg : string);
external
   integer skillresist (aa : integer, ad : integer, sa : integer, sd : integer);
   provoked_attack(victim : unitptr, ch : unitptr);
   integer skillchecksaopp(skillidx : integer, abiidx1 : integer, abiidx2 : integer,
                           opp : unitptr, oabiidx1 : integer, oabiidx2 : integer);

var
   skia : integer;
   skib : integer;
   skic : integer;
   skid : integer;
   hm   : integer;
   tgt  : unitptr;
   shield : unitptr;
   skilla   : integer;
   skillb   : integer;
   skillc   : integer;
   skilld   : integer;

code
{
	if ((self.type == UNIT_ST_PC) and (self.skills[SKI_BASH] <= 0))
	{
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
	}

	if (equipment(self,WEAR_SHIELD) == null)
	{
      act("You must be wearing a shield to bash someone!", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
	}
	else 
      shield := equipment(self,WEAR_SHIELD);

	if (arg == "")
	{
      if (self.fighting)
      {
         tgt := self.fighting;
      }
      else
      {
         act("Bash who?", A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
	}
   else
   {
   	tgt := findunit(self,arg,FIND_UNIT_SURRO,null);
   }

	if ((tgt == null) or (not visible(self,tgt)))
	{
      act("Bash who?", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
	}

	if (tgt == self)
	{
      act("You bash yourself in the head!", A_ALWAYS, self, null, null, TO_CHAR);
      act("$1n bashes $1mself in the head!", A_SOMEONE, self, null, null, TO_REST);
      quit;
	}

	if ((tgt.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
	{
      if (not(isset (self.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless you sign the book of blood.",
         A_ALWAYS,self,null,null,TO_CHAR);
         quit;
      }

      if (not(isset (tgt.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless $2e signs the book of blood.",
         A_SOMEONE,self,tgt,null,TO_CHAR);
         quit;
      }
   }

   if ((tgt.weight - self.weight) > 125)
   {
      act("$3n is too large to be bashed!", A_SOMEONE, self, null, tgt, TO_CHAR);
      quit;
   }

   if (tgt.position < POSITION_FIGHTING)
   {
      act("$3n isn't even standing!", A_SOMEONE, self, null, tgt, TO_CHAR);
      quit;
   }

   :bash:
   if (dilfind("bashed@skills",tgt))
   {
      // This is the wierdest message...
      act("$3n skillfully dodges your bash.", A_SOMEONE, self, null, tgt, TO_CHAR);
      act("$3n skillfully dodges $1n's bash.", A_SOMEONE, self, null, tgt, TO_NOTVICT);
      act("$1n attempts to bash you, but you skillfully avoid it.", A_SOMEONE, self, null, tgt, TO_VICT);
      quit;
   }

   if (self.endurance < 10)
   {
      act("You are too exhausted to try that!", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else
      self.endurance := self.endurance - 10;

   hm := skillchecksaopp(SKI_BASH, ABIL_STR, ABIL_STR, tgt, ABIL_DEX, ABIL_DEX);

   if (hm < -25)
   {
      change_speed(self,PULSE_VIOLENCE);

      act("<div class='hit_opponent'>You attempt to bash $3n but your $2t slips "+
         "from your hands!</div>",
      A_SOMEONE, self, shield.name, tgt, TO_CHAR);
      act("<div class='hit_other'>$1n attempts to bash $3n but $1s $2t slips from "+
         "$1s hands!</div>",
            A_SOMEONE, self, shield.name, tgt, TO_NOTVICT);
      act("<div class='hit_me'>$1n attempts to bash you, but $1s $2t slips from "+
         "$1s hands!</div>",
            A_SOMEONE, self, shield.name, tgt, TO_VICT);
      provoked_attack(tgt,self);
      unequip(shield);
      quit;
   }

   if (hm < 0)
   {
      change_speed(self,PULSE_VIOLENCE / 2);

      act("<div class='hit_opponent'>You bash the passing wind.</div>",
      A_ALWAYS, self, null, null, TO_CHAR);
      act("<div class='hit_other'>$1n bashes the passing wind.</div>",
      A_SOMEONE, self, null, tgt, TO_NOTVICT);
      act("<div class='hit_me'>$1n bashes the passing wind.</div>",
      A_SOMEONE, self, null, tgt, TO_VICT);
      provoked_attack(tgt,self);
      quit;
   }

   dilcopy("bashed@skills",tgt);

   change_speed(tgt,PULSE_VIOLENCE);

   act("<div class='hit_opponent'>You slam your $2t into $3n.</div>", A_SOMEONE, self, shield.name, tgt, TO_CHAR);
   act("<div class='hit_other'>$1n slams $1s $2t into $3n.</div>", A_SOMEONE, self, shield.name, tgt, TO_NOTVICT);
   act("<div class='hit_me'>$1n slams $1s $2t into you!</div>", A_SOMEONE, self, shield.name, tgt, TO_VICT);

   provoked_attack(tgt, self);
   send_done("bash",self,shield,tgt,hm,arg,null);
   quit;
}
dilend


dilbegin bashed();
code
{
   heartbeat := PULSE_VIOLENCE * 3;

   wait(SFB_TICK, TRUE);
   quit;
}
dilend


dilbegin disarmed();
code
{
   heartbeat:=PULSE_VIOLENCE*4;
   wait (SFB_TICK,TRUE);
   quit;
}
dilend



dilbegin disarm(arg : string);
/* by Drevar */
/*updated by Darg 2/2006*/
external
   integer skillresist (aa : integer, ad : integer,
                             sa : integer, sd : integer);
   provoked_attack (victim : unitptr, ch : unitptr);

var
   tweapon  : unitptr;
   mweapon  : unitptr;
   skilla : integer;
   skilld : integer;
   hm     : integer;
   targ   : unitptr;
   skillb : integer;
   skillc : integer;
   f  : integer;
code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_DISARM] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      if (self.fighting)
      {
         targ := self.fighting;
         goto disarm;
      }
      else
      {
         act("Who do you wish to disarm?", A_SOMEONE, self, null, null,
            TO_CHAR);
         quit;
      }
   }
   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ == null) or not visible(self, targ))
   {
      act("They are not here!", A_SOMEONE, self, null, targ, TO_CHAR);
      quit;
   }

   if (targ==self)
   {
      act("Why not use the remove command.", A_SOMEONE, self,
          null, null, TO_CHAR);
      quit;
   }


  if ( (targ.type != UNIT_ST_PC) and (targ.type != UNIT_ST_NPC) )
   {
      act("No need to disarm that, it can't attack you.", A_SOMEONE, self,
            null, null, TO_CHAR);
      quit;
   }

   if (targ.position <= POSITION_INCAP)
   {
      act("Why bother?  $3e can't hurt you now!", A_SOMEONE, self, null,
         targ, TO_CHAR);
      quit;
   }

   if ((targ.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
   {
      if (not(isset (targ.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless $2e signs the book of blood.",
         A_ALWAYS,self,targ,null,TO_CHAR);
         quit;
      }
   }

   /*darg added to make mobs a bit more intelligent acting */

   if (RACE_IS_MAMMAL(targ.race) and (targ.type == UNIT_ST_NPC))
   {
      f := dilfind("disarm_pc@update", targ);
      if(f == FALSE)
      {
         dilcopy("disarm_pc@update()", targ);
      }
   }
   /* end darg add */


   :disarm:
      provoked_attack (targ, self);
if ((dilfind ("disarmed@skills",targ))or(dilfind ("disarmed@skills",targ)))
	{
	act ("$3n anticipates $1n's disarm attempt and avoids it completely.",
		A_ALWAYS, self,null,targ,TO_NOTVICT);
	act ("You try to disarm $3n again but $3n anticipates it and avoids it completely.",
		A_ALWAYS, self,null,targ,TO_CHAR);
		act ("You notice $3n trying to disarm you again and avoid it completely.",
			A_ALWAYS, targ,null,self,TO_CHAR);
            self.endurance := self.endurance - 20;
			position_update(self);
			quit;
			}

if ((dilfind ("disarmed@skills",self))or(dilfind ("disarmed@skills",self)))
	{
	act ("You are too shook up to try to disarm $3n at the moment.",
		A_ALWAYS, self,null,targ,TO_CHAR);
            self.endurance := self.endurance - 20;
			position_update(self);
			quit;
			}


   mweapon := self.inside;
   while (mweapon)
     {
       if ( (mweapon.objecttype == ITEM_WEAPON) and
            (mweapon.equip == WEAR_WIELD) )
         {
           break;
         }
       mweapon := mweapon.next;
     }

   if (mweapon == null)
     {
       act("Better get yourself a weapon first!", A_SOMEONE, self, null, null,
           TO_CHAR);
       quit;
     }

   tweapon := targ.inside;
   while (tweapon)
     {
       if ( (tweapon.objecttype == ITEM_WEAPON) and
            (tweapon.equip == WEAR_WIELD) )
         {
           break;
         }
       tweapon := tweapon.next;
     }

   if (tweapon == null)
     {
       act("$3n has no weapon!", A_SOMEONE, self, null, targ, TO_CHAR);
       quit;
     }


provoked_attack (targ, self);
       if(self.type==UNIT_ST_PC)  skillc:=self.skills[SKI_DISARM];
       else
	   skillc := rnd(40,150);

       if(targ.type==UNIT_ST_PC) skilld:=targ.skills[SKI_DISARM];
       else
       skilld := rnd(40,150);
       skilla:=(self.abilities[ABIL_DEX] + self.abilities[ABIL_STR])/2;
       skillb:=(targ.abilities[ABIL_DEX] + targ.abilities[ABIL_STR])/2;



        hm:=skillresist(skilla,skillb,skillc,skilld);


   if (self.endurance < 30)
     {
      act("You are too exhausted to attempt that.", A_ALWAYS, self, null,
         null, TO_CHAR);
       quit;
      }
   else self.endurance := self.endurance - 20;


   if (hm <= -25)
     {
        act("As you attempt to disarm $3n, your $2N slips through your " +
            "hands!", A_SOMEONE, self, mweapon, targ, TO_CHAR);
        act("$1n tries a fancy move, but you counter and cause $1m to drop
"  +
            "$1s $2N!.", A_SOMEONE, self, mweapon, targ, TO_VICT);
        act("$3n counters $1n's disarm attempt, $1n lost $1s own weapon " +
            "instead!",A_SOMEONE, self, mweapon, targ, TO_NOTVICT);
        link(mweapon, self.outside);
        if (self.type == UNIT_ST_NPC)
          dilcopy("rearm@skills("+mweapon.name+")", self);
        quit;
     }
   if (hm <= 0)
     {
       act("You attempt to disarm $3n, but fail.",
	    A_SOMEONE, self, null,targ,TO_CHAR);
       act("$1n makes a feeble attempt to relieve you of your $2N.",
           A_SOMEONE, self, tweapon, targ, TO_VICT);
       act("$1n fails $1s attempt at disarming $3n.", A_SOMEONE, self, null,
           targ, TO_NOTVICT);
       quit;
     }
   if (targ.position <= POSITION_SLEEPING)
     {
       act("You quietly disarm $3n without waking them.",
	    A_SOMEONE, self, null, targ, TO_CHAR);
     }
provoked_attack(targ, self);



   act("Your quick move pulls $3n's $2N from $3s hands!", A_SOMEONE, self,
       tweapon, targ, TO_CHAR);
   act("$1n strips your $2N from your hands!", A_SOMEONE, self, tweapon,
       targ, TO_VICT);
   act("$1n deftly strips $3n's $2N from $3s hands!", A_SOMEONE, self,
       tweapon, targ, TO_NOTVICT);
   link(tweapon, targ.outside);
   dilcopy ("disarmed@skills",targ);
   if (targ.type == UNIT_ST_NPC)
    dilcopy("rearm@skills("+tweapon.name+")", targ);
  provoked_attack (targ, self);
   quit;

}
dilend

dilbegin rearm(t : string);
var
i : integer;
tweap : unitptr;
code
{
  interrupt(SFB_DEAD, activator == self, stop);
  heartbeat := PULSE_VIOLENCE;

  :retry:

  wait(SFB_COM, self.position == POSITION_FIGHTING);

  heartbeat := PULSE_VIOLENCE;
  i := rnd(1, 100);
  if (i >= 40)
  {
    change_speed(self, PULSE_VIOLENCE);
    act("$1n ducks quickly and tries to recover $1s weapon.", A_SOMEONE,
        self, null, null, TO_ROOM);
    i := rnd(1, 200);
    if (i <= self.abilities[ABIL_DEX])
    {
      tweap := findunit(self, t, FIND_UNIT_SURRO, null);
          if ( (tweap!=null) and
          (tweap.type == UNIT_ST_OBJ) and
               (tweap.objecttype == ITEM_WEAPON) and
               (not isset(tweap.flags, UNIT_FL_BURIED)) )
      {
        link(tweap, self);
        act("$1n manages to retrieve $1s "+tweap.name+"", A_SOMEONE, self,
            null, null, TO_ROOM);
        exec("wield "+tweap.name+"", self);
        goto stop;
      }
      else
      {
        tweap := self.outside.inside;
        while (tweap)
        {
          if ( (tweap.type == UNIT_ST_OBJ) and
               (tweap.objecttype == ITEM_WEAPON) and
               (not isset(tweap.flags, UNIT_FL_BURIED)) )
          {
            link(tweap, self);
            act("$1n manages to retrieve a "+tweap.name+"", A_SOMEONE, self,
                null, null, TO_ROOM);
            exec("wield "+tweap.name+"", self);
            act("$1n scowls at $1s "+tweap.name+"", A_SOMEONE, self, null,
                null, TO_ROOM);
            i := 1;
            break;
          }
          else
          {
            tweap := tweap.next;
            i := 0;
          }
        }
      if (i == 0)
        act("$1n resigns to using $1s natural weapons.", A_SOMEONE, self,
            null, null, TO_ROOM);

      goto stop;
      }
    }
    else
    {
      act("$1n fumbles and fails to retrieve $1s weapon.", A_SOMEONE, self,
          null, null, TO_ROOM);
      goto retry;
    }
  }
  else
    goto retry;

  :stop:
  quit;
}
dilend

dilbegin storm_gate(medi:unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
var
   p : integer;
   s : string;
code
{
   heartbeat := PULSE_SEC * 2;
   if (tgt==null)
   {
      act("Your fist glows warmly and then returns to normal.", A_ALWAYS,
self, null, null, TO_CHAR);
      act("$1n's fist glows warmly and then returns to normal.", A_ALWAYS,
self, null, null, TO_REST);
      quit;
   }
   if (hm<0)
   {
      act("A sputter and hiss is emitted from your clenched fist.",
A_ALWAYS, self, null, null, TO_CHAR);
      act("A sputter and hiss is emitted from $1n's clenched fist.",
A_ALWAYS, self, null, null, TO_REST);
      quit;
   }
   if("storm gate" in tgt.names)
   {
     pause;
     sendto("OPENCAST "+itoa(self.abilities[ABIL_BRA]), tgt);
   }
   else
   {
      act("You pretend that $2n is a Storm Gate, but you fail.", A_ALWAYS,
self, tgt, null, TO_CHAR);
      act("$1n pretends that $3n is a Storm Gate and fails.", A_ALWAYS,
self, null, tgt, TO_NOTVICT);
      act("$2n pretends that you are a Storm Gate and fails.", A_ALWAYS,
tgt, self, null,  TO_CHAR);
      quit;
   }
   quit;
}
dilend


dilbegin pickpocket(arg : string);
/* by Drevar */
external
   integer skillresist (aa : integer, ad : integer,
                             sa : integer, sd : integer);
   provoked_attack (victim : unitptr, ch : unitptr);
var
skilla   :  integer;
skillb   :  integer;
skillc   :  integer;
skilld   :  integer;
hm       :  integer;
vict     :  unitptr;
object   :  unitptr;
willtake :  integer;
plat     :  integer;
gold     :  integer;
silv     :  integer;
copp     :  integer;
iron     :  integer;

code
{
  if ((self.type == UNIT_ST_PC) and (self.skills[SKI_PICK_POCKETS] <= 0))
  {
     act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
     quit;
  }

  object := self.inside;
  hm := 0;
  while ((object) and (hm != 2))
    {
      if ( (object.equip == WEAR_WIELD) and
           (isset(object.objectflags, OBJ_TWO_HANDS)) )
        {
          hm := 2;
          continue;
        }

      if ( (object.equip == WEAR_HOLD) or (object.equip == WEAR_WIELD) or
         (object.equip == WEAR_SHIELD) )
        {
          hm := hm + 1;
        }

      object := object.next;
    }

  if (hm == 2)
    {
       act("You must have at least one hand free to attempt that!", A_SOMEONE,
           self, null, null, TO_CHAR);
       quit;
    }


  vict := findunit(self, arg, FIND_UNIT_SURRO, null);

  if ((vict == null) or not visible(self, vict))
    {
  act("No such person to pickpocket.",  A_SOMEONE, self, null, null,TO_CHAR);
      quit;
    }

   if ((vict.type==UNIT_ST_PC) and   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (vict.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,vict,null,TO_CHAR);
  quit;
  }
  }
       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_PICK_POCKETS];
       else
        skillc := rnd(40,124);

	  /*  skillc:=self.abilities[ABIL_DEX];
        */
       if(vict.type==UNIT_ST_PC)
        /*
    SHOULD USE THERE BRAINS NOT THERE SKILL AT DOING IT
		skilld:=vict.skills[SKI_PICK_POCKETS];
       */

       skilld:=self.abilities[ABIL_BRA];
	   else
       skilld := (self.abilities[ABIL_BRA]+self.abilities[ABIL_DEX]) /2;;

	   /* skilld:=vict.abilities[ABIL_DEX];
        */
       skilla:=self.abilities[ABIL_DEX];
       skillb:=vict.abilities[ABIL_DEX];
        hm:=skillresist(skilla,skillb,skillc,skilld);
/*

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_PICK_POCKETS];
   else
     skilla := self.abilities[ABIL_DEX];

   if (vict.type == UNIT_ST_PC)
     skilld := vict.skills[SKI_PICK_POCKETS];
   else
     skilld := vict.abilities[ABIL_DEX];

   hm := skillresist (self.abilities[ABIL_DEX],
                     vict.abilities[ABIL_DEX],
		     skilla, skilld);
*/
  if (hm <= -5)
    {
      act("You are caught!", A_SOMEONE, self, null, vict, TO_CHAR);

      if (isaff(self, ID_INVISIBILITY))
        subaff(self, ID_INVISIBILITY);

      act("You catch $1n with $1s hand in your purse!",
	   A_SOMEONE, self, null,vict, TO_VICT);
      act("You see $1n trying to pilfer money from $3n...$3e doesn't " +
          "seem amused!", A_SOMEONE, self, null, vict, TO_NOTVICT);
      provoked_attack (vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }


  if (hm <= 0)
    {
  act("You fail to get any money from $3n, but at least"
  +" no one was watching!",A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
    }

  if (hm <= 5)
    {
      act("You have your fingers on a handful of $3n's coins "+
	  "just as $3e turns toward you...",A_SOMEONE, self, null, vict, TO_CHAR);
	  act("You have been caught!",A_SOMEONE, self, null, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        subaff(self, ID_INVISIBILITY);

      act("Arrgh!  $1n just tried to steal some of your hard earned money!",
           A_SOMEONE, self, null, vict, TO_VICT);
      act("You see $1n swipe a handful of coins from $3n...$3e doesn't " +
          "seem amused!", A_SOMEONE, self, null, vict, TO_NOTVICT);
      willtake := (self.skills[SKI_PICK_POCKETS] / 2);
      willtake := (rnd((willtake / 4), willtake));
      plat := (((purse(vict, PLATINUM_PIECE)*willtake) / 100) * 40960);
      gold := (((purse(vict, GOLD_PIECE)*willtake) / 100) * 5120);
      silv := (((purse(vict, SILVER_PIECE)*willtake) / 100) * 640);
      copp := (((purse(vict, COPPER_PIECE)*willtake) / 100) * 80);
      iron := (((purse(vict, IRON_PIECE)*willtake) / 100) * 10);

      if (iron)
        iron := (transfermoney(vict, self, iron));
      if (copp)
        copp := (transfermoney(vict, self, copp));
      if (silv)
        silv := (transfermoney(vict, self, silv));
      if (gold)
        gold := (transfermoney(vict, self, gold));
      if (plat)
        plat := (transfermoney(vict, self, plat));
      provoked_attack (vict, self);
      logcrime(self, vict, CRIME_STEALING);
      position_update(self);
	  position_update(vict);
	  send_done("pickpocket",self,null,vict,hm,arg,null);
      quit;
    }

  willtake := (self.skills[SKI_PICK_POCKETS] / 2);
  willtake := (rnd((willtake / 4), willtake));

  plat := (((purse(vict, PLATINUM_PIECE)*willtake) / 100) * 40960);
  gold := (((purse(vict, GOLD_PIECE)*willtake) / 100) * 5120);
  silv := (((purse(vict, SILVER_PIECE)*willtake) / 100) * 640);
  copp := (((purse(vict, COPPER_PIECE)*willtake) / 100) * 80);
  iron := (((purse(vict, IRON_PIECE)*willtake) / 100) * 10);

  if (iron)
    iron := (transfermoney(vict, self, iron));
  if (copp)
    copp := (transfermoney(vict, self, copp));
  if (silv)
    silv := (transfermoney(vict, self, silv));
  if (gold)
    gold := (transfermoney(vict, self, gold));
  if (plat)
    plat := (transfermoney(vict, self, plat));
      position_update(self);
      position_update(vict);
  act("You stealthily pilfer a handful of coins from $3n's purse and " +
      "quickly deposit them in your own.",A_SOMEONE, self, null, vict,
      TO_CHAR);
  send_done("pickpocket",self,null,vict,hm,arg,null);
  quit;

}
dilend

dilbegin peek(arg : string);

external
   integer skillresist (aa : integer, ad : integer,
                             sa : integer, sd : integer);

var
   skilla : integer;
   skillb : integer;
   skillc : integer;
   skilld : integer;
   hm     : integer;
   targ   : unitptr;
   object  : unitptr;
code
{
  if ((self.type == UNIT_ST_PC) and (self.skills[SKI_PEEK] <= 0))
  {
    act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
    quit;
  }

  if (arg == "")
  {
    act("Who's inventory do you wish to peek at?", A_SOMEONE, self, null,
         null, TO_CHAR);
    quit;
  }

  targ := findunit(self, arg, FIND_UNIT_SURRO, null);

  if ((targ == null) or not visible(self, targ))
  {
    act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
    quit;
  }

  if (targ.type &(UNIT_ST_ROOM | UNIT_ST_OBJ))
  {
    act("You don't have to peek, just look in it!", A_SOMEONE, self, null,
    null, TO_CHAR);
    quit;
  }

  if (targ == self)
  {
    act("Why don't you just use the inventory command?", A_SOMEONE, self,
         null, null, TO_CHAR);
    quit;
  }

  if (targ.position <=  POSITION_SLEEPING)
  {
    act("They won't mind if you take a little peek at the moment.",
        A_SOMEONE, self, null, null, TO_CHAR);
    goto success;
  }
       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_PEEK];
       else
	             skillc := rnd(40,124);

       /* skillc:=self.abilities[ABIL_BRA]; */

       if(targ.type==UNIT_ST_PC)
        skilld:=targ.skills[SKI_PEEK];
       else
                 skilld := rnd(40,124);

	   /* skilld:=targ.abilities[ABIL_BRA]; */

       skilla:=self.abilities[ABIL_BRA];
       skillb:=targ.abilities[ABIL_BRA];
        hm:=skillresist(skilla,skillb,skillc,skilld);

/*
  if (self.type == UNIT_ST_PC)
    skilla := self.skills[SKI_PEEK];
  else
    skilla := self.abilities[ABIL_BRA];

  if (targ.type == UNIT_ST_PC)
    skilld := targ.skills[SKI_PEEK];
  else
    skilld := targ.abilities[ABIL_BRA];

  hm := skillresist (self.abilities[ABIL_BRA],
                     targ.abilities[ABIL_BRA],
		     skilla, skilld);
*/
  if (hm < -25)
  {
    act("You clumsily attempt to see what goodies $3n has, $3e " +
         "doesn't seem to be amused.", A_SOMEONE, self, null, targ, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        {
          subaff(self, ID_INVISIBILITY);
        }
    act("You catch $1n blatently peeking at your possessions!",
         A_SOMEONE, self, null, targ, TO_VICT);
    quit;
  }

  if (hm <= 0)
  {
    act("You can't quite make out what $3e has, but at least you were " +
    "discrete.", A_SOMEONE, self, null, targ, TO_CHAR);
    quit;
  }

  act("You manage to peek at $3s belongings.", A_SOMEONE, self, null, targ,
      TO_CHAR);

  :success:
  act("You see $3e has: ", A_SOMEONE, self, null, targ, TO_CHAR);

  hm := FALSE;

  object := targ.inside;

  while (object)
  {
     if (visible(self, object))
     {
        if (object.equip == 0)
        {
           /* Perhaps do check for each item */
           act(object.title, A_SOMEONE, self, null, targ, TO_CHAR);
           hm := TRUE;
        }
     }
     object := object.next;
  }

  if (hm == FALSE)
    act("Absolutely nothing!", A_SOMEONE, self, null, targ, TO_CHAR);

  quit;
}
dilend



dilbegin filch(arg : string);

external
   integer skillresist (aa : integer, ad : integer,
                             sa : integer, sd : integer);
   provoked_attack (victim : unitptr, ch : unitptr);

var
skilla  :  integer;
skillb  :  integer;
skillc  :  integer;
skilld  :  integer;

   hm      : integer;
   targ    : unitptr;
   vict    : unitptr;
   from    : string;
   object  : unitptr;
   hands   : integer;
   t       : string;
   temp    : string;
	 ti:integer;
code
{
  if ((self.type == UNIT_ST_PC) and (self.skills[SKI_FILCH] <= 0))
  {
     act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
     quit;
  }

  object := self.inside;
  while ((object) and (hands != 2))
    {
      if ( ((object.equip == WEAR_WIELD) or (object.equip == WEAR_HOLD))
and (isset(object.objectflags, OBJ_TWO_HANDS)) )
        {
          hands := 2;
          continue;
        }

      if ( (object.equip == WEAR_HOLD) or (object.equip == WEAR_WIELD) or
           (object.equip == WEAR_SHIELD) )
        {
          hands := hands + 1;
        }
      object := object.next;
    }

  if (hands == 2)
    {
       act("You must have at least one hand free to attempt that!",
A_SOMEONE,
           self, null, null, TO_CHAR);
       quit;
    }

  if (not (" from " in arg))
    {
      act("Filch what from who?", A_SOMEONE, self, null, null,  TO_CHAR);
      quit;
    }

  /* needed for multi word names */
  t := getword(arg);
  temp := getword(arg);
  while (temp != "from")
  {
    t := (t + " " + temp);
    temp := getword(arg);
  }

  vict := findunit(self, arg, FIND_UNIT_SURRO, null);
  if ((vict == null) or not visible(self, vict))
    {
      act("No such person to filch from.",  A_SOMEONE, self, null,  null,
          TO_CHAR);
      quit;
    }
  if ( (not(vict.type & (UNIT_ST_PC | UNIT_ST_NPC)) ))
    {
      act("Why bother? Just get the darn thing!", A_SOMEONE, self, null,
null,
          TO_CHAR);
      quit;
    }


   if ((vict.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (vict.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of
blood.",
  A_ALWAYS,self,vict,null,TO_CHAR);
  quit;
  }
  }


  targ := findunit(vict, t, FIND_UNIT_EQUIP, null);
  if ((targ == null) or not visible(self, targ))
    {
      act("You can't find that on $3n.", A_SOMEONE, self, targ, vict,
TO_CHAR);
      quit;
    }

  if ( (targ.equip != WEAR_FINGER_R) and (targ.equip != WEAR_FINGER_L) and
       (targ.equip != WEAR_NECK_1) and (targ.equip != WEAR_NECK_2) and
       (targ.equip != WEAR_WAIST) and (targ.equip != WEAR_WRIST_R) and
       (targ.equip != WEAR_BACK) and (targ.equip != WEAR_EAR_L) and
       (targ.equip != WEAR_EAR_R) and (targ.equip != WEAR_ANKLE_L) and
       (targ.equip != WEAR_ANKLE_R) and (targ.equip != WEAR_WRIST_L) )
    {
      act("That would be much to difficult to filch away from $3n!",
          A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
    }

   if (targ.zoneidx == "treasure")
   {
     act("A chill runs down your spine...someone or something is watching.",
         A_ALWAYS, self, null, null, TO_CHAR);
     act("You change your mind about filching that.", A_ALWAYS, self,
         null, null, TO_CHAR);
     quit;
   }
ti:=can_carry (self,targ,1);
if (ti==1)
	{
	act ("You can't carry another thing.",
		A_ALWAYS,self,null,null,TO_CHAR);
		quit;
		}


   if (self.type == UNIT_ST_PC)
     skillc := self.skills[SKI_FILCH];
   else
              skillc := rnd(40,124);
   /*	 skillc := self.abilities[ABIL_DEX];
     */
   if (vict.type == UNIT_ST_PC)
     skilld := vict.skills[SKI_FILCH];
   else
             skilld := rnd(40,124);
   /*     skilld := vict.abilities[ABIL_DEX];
     */
     skilla := self.abilities[ABIL_DEX];
	 skillb := vict.abilities[ABIL_DEX];

    hm := skillresist(skilla,skillb,skillc,skilld);




/*
   hm := skillresist (self.abilities[ABIL_DEX],
                     vict.abilities[ABIL_DEX],
		     skilla, skilld);
*/



  if (hm <= -5)
    {
      act("You are caught!", A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        {
          subaff(self, ID_INVISIBILITY);
        }
      act("You catch $1n trying to filch your $2n!", A_SOMEONE, self, targ,
          vict, TO_VICT);
      act("You see $1n trying to filch something from $3n...$3e doesn't " +
          "seem amused!", A_SOMEONE, self, targ, vict, TO_NOTVICT);
      provoked_attack (vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }


  if (hm <= 0)
    {
      act("You fail to filch $3n's $2n, but at least no one was watching!",
        A_SOMEONE, self, targ, vict, TO_CHAR);
      quit;
    }

  if (hm <= 5)
    {
      act("You filch $2n from $3n just as $3e turns toward you..You have "
+
          "been caught!", A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        {
          subaff(self, ID_INVISIBILITY);
        }
      act("Arrgh!  $1n just stole your $2n!", A_SOMEONE, self, targ, vict,
          TO_VICT);
      act("You see $1n filch something from $3n...$3e doesn't seem
amused!",
          A_SOMEONE, self, targ, vict, TO_NOTVICT);
      link(targ, self);
      provoked_attack (vict, self);
      logcrime(self, vict, CRIME_STEALING);
      send_done("filch",self,targ,vict,hm,arg,null);
      quit;
    }

  act("You stealthily filch $3n's $2n and quickly tuck it out of " +
      "sight!", A_SOMEONE, self, targ, vict, TO_CHAR);
  link(targ, self);
  send_done("filch",self,targ,vict,hm,arg,null);
  quit;


}
dilend



dilbegin diagnose(arg : string);
external
   string sizestring (cm : integer);
   string weightstring (cm : integer);
   integer skillresist (aa : integer, ad : integer,
			     sa : integer, sd : integer);

var
   percent : integer;
   hm      : integer;
   s1      : string;
   s2      : string;
   vict    : unitptr;
   skilla  : integer;
code
{
   if ((self.type == UNIT_ST_PC) and
       (self.skills[SKI_DIAGNOSTICS] == 0))
   {
      act("You must practice first.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      vict := self.fighting;
      if (vict == null)
      {
	 act("Diagnose who?",
             A_ALWAYS, self, null, null, TO_CHAR);
	 quit;
      }
   }
   else
   {
      vict := findunit(self, arg, FIND_UNIT_SURRO, null);
      if ((vict == null) or not visible(self, vict))
      {
	 act("Nobody here by that name.",
	     A_ALWAYS, self, null, vict, TO_CHAR);
	 quit;
      }
   }

   if (not (vict.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("It seems to be dead?",
	  A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   if (vict.max_hp > 0)
     percent := (100 * vict.hp) / vict.max_hp;
   else
     percent := -1; /* How could MAX_HIT be < 1?? */

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_DIAGNOSTICS];
   else
     skilla := self.abilities[ABIL_BRA];

   hm := skillresist (self.abilities[ABIL_BRA], 20,
				skilla, 50);

   if (hm > 0)
     hm := 0;

   percent := percent + ((percent * (-hm))/100);

   if (percent >= 100)
     act("$3n is in an excellent condition.",
	 A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 90)
     act("$3n has a few scratches.",
	 A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 75)
     act("$3n has some small wounds and bruises.",
         A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 50)
     act("$3n has quite a few wounds.",
         A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 30)
     act("$3n has some big nasty wounds and scratches.",
         A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 15)
     act("$3n looks pretty hurt.",
         A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 0)
     act("$3n is in an awful condition.",
	 A_ALWAYS, self, null, vict, TO_CHAR);
   else
     act("$3n is bleeding awfully from big wounds.",
	 A_ALWAYS, self, null, vict, TO_CHAR);

   if (self.fighting == null)
   {
      s1 := weightstring (vict.baseweight);
      s2 := sizestring (vict.height);
      act("$3e weighs "+s1+" and is "+s2+" tall.",
	  A_SOMEONE, self, null, vict, TO_CHAR);
   }

   quit;
}
dilend

dilbegin resize(arg:string);
external
   res_clothes@skills (tgt:unitptr,tgt_pc:unitptr);
   res_lth@skills (tgt:unitptr,tgt_pc:unitptr);
   res_metal@skills (tgt:unitptr,tgt_pc:unitptr);
var
   item : unitptr;
   tgt_pc : unitptr;
code
{
   if (arg == "")
   {
      act("What do you wish to resize?", A_SOMEONE, self, null, null,TO_CHAR);
      quit;
   }

   item := findunit(self, arg, FIND_UNIT_INVEN, null);

   if ((item == null) or not visible(self, item))
   {
      act("No such thing by that name!", A_SOMEONE, self, null, null,
TO_CHAR);
      quit;
   }

   tgt_pc := findunit(self,arg,FIND_UNIT_SURRO,null);

   if ((tgt_pc==null) or not visible(self, tgt_pc))
     tgt_pc := self;

   if (not (item.type&UNIT_ST_OBJ))
   {
      act("You can't resize that!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (item.objecttype == ITEM_ARMOR)
   {
      if ((item.value[0]<ARM_CLOTHES)or
          (item.value[0]>ARM_PLATE))
      {
         act ("The armor seems to be broken.",
	      A_ALWAYS,self,null, null,TO_CHAR);
         quit;
      }
      on item.value[0] goto clothes,leather,leather,metal,metal;
   }
   else if (item.objecttype == ITEM_SHIELD)
     goto metal;
   else if (item.objecttype == ITEM_WEAPON)
     goto metal;
   else if (item.objecttype == ITEM_WORN)
     goto clothes;
   else
   {
      if ((item.manipulate & (MANIPULATE_WEAR_FINGER | MANIPULATE_WEAR_NECK  |
			     MANIPULATE_WEAR_BODY   | MANIPULATE_WEAR_HEAD  |
			     MANIPULATE_WEAR_LEGS   | MANIPULATE_WEAR_FEET  |
			     MANIPULATE_WEAR_HANDS  | MANIPULATE_WEAR_ARMS  |
			     MANIPULATE_WEAR_SHIELD | MANIPULATE_WEAR_ABOUT |
			     MANIPULATE_WEAR_WAIST  | MANIPULATE_WEAR_WRIST |
			     MANIPULATE_WIELD       | MANIPULATE_WEAR_EAR   |
			     MANIPULATE_WEAR_BACK   | MANIPULATE_WEAR_CHEST |
			     MANIPULATE_WEAR_ANKLE)) == 0)
      {
         act ("There is no way the $3N can be resized.",
	      A_SOMEONE, self, null, item, TO_CHAR);
         quit;
      }
      goto metal; /* What else can one do? */
   }
   quit;

   :clothes:
   res_clothes(item,tgt_pc);
   quit;
   :leather:
   res_lth (item,tgt_pc);
   quit;
   :metal:
   res_metal(item,tgt_pc);
   quit;
}
dilend


dilbegin res_clothes(tgt:unitptr,tgt_pc:unitptr);
external
   integer skillresist (aa : integer, ad : integer,
			     sa : integer, sd : integer);
   unitptr unit_room (u:unitptr);
var
  hm:integer;
  amount:integer;
  size:string;
  diff:integer;
  skilla : integer;
  rm:unitptr;
  skilld : integer;
  hold_eq:unitptr;
  wield_eq:unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_RESIZE_CLOTHES] <= 0))
   {
      act("You have no knowledge in tailoring, you must practice first.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/*
   rm := unit_room(self);
   if ("$clothes room" in rm.extra)
     goto workshop;

   hold_eq := equipment (self ,WEAR_HOLD);
   wield_eq := equipment (self,WEAR_WIELD);
   if ((not("$refit clothes" in hold_eq.extra)) and
       (not("$refit clothes" in wield_eq.extra)))
   {
      act ("You need to hold or use a proper tailoring tool to work on $2n.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }
*/
   :workshop:
   if ("$resized" in tgt.extra)
   {
      act("You see that the $2n has already been resized, you are unable "+
          "to do more yourself.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_RESIZE_CLOTHES];
   else
     skilla := self.abilities[ABIL_DEX];

   skilld := 2*tgt.value[1] + 6*tgt.value[2];

   hm := skillresist (self.abilities[ABIL_DEX],
		     tgt.spells[SPL_CREATION],
		     skilla, skilld);

   if (hm<=-100)
     goto major_fail;
   if (hm<-50)
     goto fail;
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   amount := (100*tgt_pc.height) / tgt.height;
   if (amount > 100)
     diff := amount - 100;
   else
     diff := 100 - amount;
   if (self.endurance<diff) goto fail_endurance;

   if (tgt_pc.height>tgt.height)
    size:="enlarges"
   else
    size:="shrinks";

   tgt.max_hp := tgt.max_hp-diff;
   tgt.hp := tgt.hp-diff;
   tgt.height := tgt_pc.height;

   addextra(tgt.extra, {"$resized"}, "");

   self.endurance := self.endurance - diff;

   if (tgt_pc==self)
   {
      act("You skillfully work on $2n until it $3t enough to fit.",
	  A_ALWAYS, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on $2n until it $3t enough to fit $1m",
	  A_SOMEONE, self, tgt, size, TO_REST);
   }
   else
   {
      act("You skillfully work on $2n until it $3t enough to fit "+
	  tgt_pc.name+".", A_SOMEONE, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on "+tgt.title+
	  " until it $3t enough to fit $2n",
	  A_SOMEONE, self, tgt_pc, size, TO_REST);
   }
   quit;

   :fail:
   tgt.hp := tgt.hp-diff;
   if (tgt.hp<1) goto major_fail;
   act("You try to $3t $2n but you make a mistake and damage it instead",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but $1e makes a mistake and damages it instead.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

   :major_fail:
   act("You try to $3t $2n but the job is too much for you and you destroy
it.",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but the job is too much for $1m and $1e destroys it.",
	A_SOMEONE, self, tgt, size, TO_REST);
  addextra (tgt.extra,tgt.names,
  "Well whatever this was it looks like someone realy screwed up resizing this.");
  tgt.title:=tgt.title+" (broken)";
   tgt.objecttype := ITEM_TRASH;
tgt.manipulate:=MANIPULATE_TAKE;
tgt.hp := -1;
position_update(tgt);
   quit;

   :fail_endurance:
   act("You begin to work on $2n but realize you are much too tired to finish.",
       A_ALWAYS, self, tgt,null, TO_CHAR);
   act("$1n Begins working on $2n but realizes $1e is too tired and slumps "+
       "back exausted.",
       A_SOMEONE, self, tgt, size, TO_REST);
   quit;
}
dilend

dilbegin res_lth(tgt:unitptr,tgt_pc:unitptr);
external
   integer skillresist (aa : integer, ad : integer,
			     sa : integer, sd : integer);
   unitptr unit_room (u:unitptr);
var
  hm:integer;
  amount:integer;
  size:string;
  diff:integer;
  rm:unitptr;
  skilla : integer;
  skilld : integer;
  hold_eq:unitptr;
  wield_eq:unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_RESIZE_LEATHER] <= 0))
   {
      act("You have no knowledge in leather, you must practice first.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/*
   rm := unit_room(self);
   if ("$leather room" in rm.extra) goto workshop;

   hold_eq := equipment (self ,WEAR_HOLD);
   wield_eq := equipment (self,WEAR_WIELD);

   if ((not("$refit leather" in hold_eq.extra)) and
       (not("$refit leather" in wield_eq.extra)))
   {
      act ("You need to use a proper leather tool to work on $2n.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }
*/
   :workshop:
   if ("$resized" in tgt.extra)
   {
      act("You see that the $2n have already been resized, you are unable "+
          "to do more yourself.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }

   if (tgt_pc.height > tgt.height)
     size := "enlarges"
   else
     size := "shrinks";

   if (self.type == UNIT_ST_PC)
     skilla  :=  self.skills[SKI_RESIZE_LEATHER];
   else
     skilla  :=  self.abilities[ABIL_STR];

   skilld := 2*tgt.value[1] + 6*tgt.value[2];

   hm := skillresist (self.abilities[ABIL_DEX],
		     tgt.spells[SPL_CREATION],
		     skilla, skilld);

   if (hm<=-100)goto major_fail;

   if (hm<-50) goto fail;

   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   amount := (100*tgt_pc.height) / tgt.height;
   if (amount > 100)
     diff := amount - 100;
   else
     diff := 100 - amount;
   if (self.endurance<diff) goto fail_endurance;

   tgt.max_hp := tgt.max_hp-diff;
   tgt.hp := tgt.hp-diff;
   tgt.height := tgt_pc.height;

   addextra(tgt.extra, {"$resized"}, "");

   self.endurance := self.endurance - diff;

   if (tgt_pc==self)
   {
      act("You skillfully work on $2n till it $3t enough to fit.",
	  A_ALWAYS, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on $2n till it $3t enough to fit $1m",
	  A_SOMEONE, self, tgt, size, TO_REST);
   }
   else
   {
      act("You skillfully work on $2n till it $3t enough to fit "+tgt_pc.name+".",
	  A_SOMEONE, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on "+tgt.title+" till it $3t enough to fit $2n",
	  A_SOMEONE, self, tgt_pc, size, TO_REST);
   }
   quit;

   :fail:
   tgt.hp := tgt.hp-diff;
   if (tgt.hp<1) goto major_fail;
   act("You try to $3t $2n but you make a mistake and damage it instead",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but $1e makes a mistake and damages it instead.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

   :major_fail:
   act("You try to $3t $2n but the job is to much for you and you destroy it.",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but the job is to much for $1m and he destroys it.",
	A_SOMEONE, self, tgt, size, TO_REST);
  addextra (tgt.extra,tgt.names,"Well whatever this was it looks like someone realy screwed up resizing this.");
  tgt.title:=tgt.title+" (broken)";
   tgt.objecttype := ITEM_TRASH;
tgt.manipulate:=MANIPULATE_TAKE;

tgt.hp := -1;
position_update(tgt);
   quit;

   :fail_endurance:
   act("You begin to work on $2n but realize you are much to tired to finish.",
       A_ALWAYS, self, tgt,null, TO_CHAR);
   act ("$1n Begins working on $2n but realizes $1e is to tired and slumps back exausted.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

}
dilend

dilbegin res_metal(tgt:unitptr,tgt_pc:unitptr);
external
   integer skillresist (aa : integer, ad : integer,
			     sa : integer, sd : integer);
   unitptr unit_room (u:unitptr);

var
  hm:integer;
  amount:integer;
  size:string;
  diff:integer;
  rm:unitptr;
  skilla : integer;
  skilld : integer;
  hold_eq:unitptr;
  wield_eq:unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_RESIZE_METAL] <= 0))
   {
      act("You have no knowledge in smithing, you must practice first.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/*
   rm := unit_room(self);
   if ("$metal room" in rm.extra) goto workshop;

   hold_eq := equipment (self ,WEAR_HOLD);
   wield_eq := equipment (self,WEAR_WIELD);

   if ((not("$refit metal" in hold_eq.extra)) and
       (not("$refit metal" in wield_eq.extra)))
   {
      act ("You need to use a proper smithing tool to work on $2n.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }
*/
   :workshop:
   if ("$resized" in tgt.extra)
   {
      act("You see that the $2N have already been resized, you are unable "+
          "to do more yourself.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }

   if (self.type == UNIT_ST_PC)
     skilla  :=  self.skills[SKI_RESIZE_METAL];
   else
     skilla := self.abilities[ABIL_STR];

   skilld := 2*tgt.value[1] + 6*tgt.value[2];

   hm := skillresist (self.abilities[ABIL_STR],
		     tgt.spells[SPL_CREATION],
		     skilla, skilld);

   if (hm<=-100)goto major_fail;
   if (hm<-50) goto fail;
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   amount := (100*tgt_pc.height) / tgt.height;
   if (amount > 100)
     diff := amount - 100;
   else
     diff := 100 - amount;
   if (self.endurance<diff) goto fail_endurance;

   if (tgt_pc.height>tgt.height)
    size:="enlarges"
   else
     size := "shrinks";

   self.endurance := self.endurance - diff;

   tgt.max_hp := tgt.max_hp-diff;
   tgt.hp := tgt.hp-diff;
   tgt.height := tgt_pc.height;

   addextra(tgt.extra, {"$resized"}, "");

   if (tgt_pc==self)
   {
      act("You skillfully work on $2n till it $3t enough to fit.",
	  A_ALWAYS, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on $2n till it $3t enough to fit $1m",
	  A_SOMEONE, self, tgt, size, TO_REST);
   }
   else
   {
      act("You skillfully work on $2n till it $3t enough to fit "+
	  tgt_pc.name+".", A_SOMEONE, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on "+tgt.title+
	  " till it $3t enough to fit $2n",
	  A_SOMEONE, self, tgt_pc, size, TO_REST);
   }

   quit;
   :fail:
   tgt.hp := tgt.hp-diff;
   if (tgt.hp<1) goto major_fail;
   act("You try to $3t $2n but you make a mistake and damage it instead",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but $1e makes a mistake and damages it instead.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

   :major_fail:

   act("You try to $3t $2n but the job is to much for you and you destroy
it.",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but the job is to much for $1m and he destroys it.",
	A_SOMEONE, self, tgt, size, TO_REST);
  addextra (tgt.extra,tgt.names,"Well whatever this was it looks like
someone realy screwed up resizing this.");
  tgt.title:=tgt.title+" (broken)";
   tgt.objecttype := ITEM_TRASH;
tgt.manipulate:=MANIPULATE_TAKE;

tgt.hp := -1;
position_update(tgt);

   quit;

   :fail_endurance:
   act("You begin to work on $2n but realize you are much to tired to finish.",
       A_ALWAYS, self, tgt,null, TO_CHAR);
   act ("$1n Begins working on $2n but realizes $1e is to tired and slumps
back exausted.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

}
dilend

/* The climb skill as a special routine to be connected to ROOMS

  Ticks  : None
  Used on: ROOMS
  Syntax : climb(destination:string, difficulty:integer,
	         damage : integer, direction : integer);
  Example: dilcopy climb ("deck@ship", 17, 20, "up");

     This special dil is used for the climb skill and should be set
     on stationary objects (stationary mast, robe, tree, wall, etc).
     The <difficulty> is the skill-amount required to climb. A skill of 100
     would be a 50% chance for the expert thief / climber.
     The <damage> is how much damage is given if you fail to climb the
     object. When you fail, you "fall" to the <destination>, so you can
     make gravity work correctly.
     The destination can be the same room in which you started.
     The <direction> is the direction in which a climb is required
     (most usually it is up, which is macro UP == 5).
*/

dilbegin climb(destination:string, difficulty:integer,
               damage:integer, direction:integer);
external
    integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);

var
   dest : unitptr;
   skilla : integer;
   hm : integer;
   doorname : string;
code
{
   if (not self.exit_to[direction])
   {
      log("No such exit in climb dil.");
      quit;
   }

   if (not findroom(destination))
   {
      log("No such room in climb dil.");
      quit;
   }

   doorname := self.exit_names[direction].[0];
   /* One could check for an empty name here... */

   :loop:
   wait(SFB_CMD, command("climb") or command(direction));

   if (self.type == UNIT_ST_PC)
   {
      skilla := self.skills[SKI_CLIMB];
      if (skilla < 1)
	skilla := -25;
   }
   else
     skilla := self.abilities[ABIL_DEX];

   hm := skillresist (skilla, 0,
		     activator.abilities[ABIL_DEX], 0);

   if (hm >= difficulty)
   {
      act("You easily climb the $2t.",
	  A_ALWAYS, activator, doorname, null, TO_CHAR);
      act("$1n easily climbs the $2t.",
	  A_HIDEINV, activator, doorname, null, TO_ROOM);
      goto loop;
   }

   dest := findroom(destination);

   if (dest != activator.outside)
   {
      act("You fall and hit yourself!",
	  A_ALWAYS, activator, doorname, null, TO_CHAR);

      act("$1n failed to climb the $2t and takes a nasty fall...",
	  A_SOMEONE, activator, doorname, null, TO_ROOM);

      link(activator, dest);

      act("$1n failed to climb the $2t and lands at your feet...",
	  A_SOMEONE, activator, doorname, null, TO_ROOM);
   }
   else
   {
      act("You fail to climb the $2t!",
	  A_ALWAYS, activator, doorname, null, TO_CHAR);

      act("$1n failed to climb the $2t!",
	  A_SOMEONE, activator, doorname, null, TO_ROOM);
   }

   if (activator.level < IMMORTAL_LEVEL)
   {
      activator.hp := activator.hp - damage;
      position_update(activator);
   }
   block;
   goto loop;
}
dilend



dilbegin do_rescue(arg: string);

external base_rescue(targ: unitptr); /* Needed for SFUN_RESCUE */

var targ: unitptr;

code
{

if (arg == "")
    {
    sendtext("Rescue who?<br/>", self);
    quit;
    }

targ :=findunit(self, arg, FIND_UNIT_SURRO, null);

if ((not targ) or not(targ.type & UNIT_ST_PC|UNIT_ST_NPC))
    {
    sendtext("Who do you want to rescue?<br/>", self);
    quit;
    }

base_rescue(targ);

quit;
}

dilend


dilbegin base_rescue(targ: unitptr); /* May be copied on mobs easily */

external integer skillresist (aa : integer, ad : integer,
                              sa : integer, sd : integer);

var tmp: unitptr;
    hm : integer;
    ska: integer;
    skb: integer;
    skc: integer;
    skd: integer;
code
{

if (not visible(self, targ))
    {
    sendtext("Who do you want to rescue?<br/>", self);
    return;
    }

if (targ == self)
    {
    sendtext("What about fleeing instead?<br/>", self);
    return;
    }

if (targ == self.fighting)
    {
    sendtext("How can you rescue someone you are trying to kill?<br/>", self);
    return;
    }

foreach (UNIT_ST_PC|UNIT_ST_NPC, tmp)
    {
    if (tmp.fighting == targ)
        break;
    }

if ((tmp == null) or (tmp.fighting != targ))
    {
    act("Nobody is fighting $3m?", A_SOMEONE, self, null, targ, TO_CHAR);
    return;
    }

if ((self.type == UNIT_ST_PC) and (self.skills[SKI_RESCUE] <= 0))
    {
    sendtext("You'd better practice first.<br/>", self);
    return;
    }

if (self.type == UNIT_ST_PC)
    skc := self.skills[SKI_RESCUE];
else
          skc := (rnd(80,124)) + 50;
/*
    skc := (self.abilities[ABIL_DEX] + self.abilities[ABIL_BRA]) / 2;
  */
if (tmp.type == UNIT_ST_PC)
    skd := tmp.skills[SKI_RESCUE];
else
          skd := (rnd(60,100)) ;
/*
    skd := (tmp.abilities[ABIL_DEX] + tmp.abilities[ABIL_BRA]) / 2;
  */
    ska := self.abilities[ABIL_DEX];
	skb := tmp.abilities[ABIL_DEX];

hm := skillresist(ska, skb, skc, skd);
/*       log(self.name+" tried to rescue "+tmp.name+" openroll "
	   +itoa((openroll(100, 5)))+" skilla is: "+itoa(ska)
	   +" skillb is: "+itoa(skb)
	   +" skillc is: "+itoa(skc)+" skilld is: "+itoa(skd)+
	   "- 50 = hm total: "+itoa(hm));
*/

if ((tmp.type == UNIT_ST_PC) and (self.skills[SKI_LEADERSHIP])
   and (targ.master == self))
   hm := hm + self.skills[SKI_LEADERSHIP] / 4;

if (hm < 0)
    {
    sendtext("You bulge in from the left...<br/>"+
        "...and continue out to the right.<br/>", self);

    act("$1n bulges in from the left...<br/>"+
        "...and continues out to the right.",
        A_SOMEONE, self, null, targ, TO_VICT);

    act("$1n makes a feeble attempt to rescue $3n.",
        A_SOMEONE, self, null, targ, TO_NOTVICT);
    return;
    }

sendtext("Banzai! To the rescue...<br/>", self);

act("You are rescued by $1n, you are confused!",
    A_SOMEONE, self, null, targ, TO_VICT);

act("$1n heroically rescues $3n.", A_SOMEONE, self, null, targ, TO_NOTVICT);

if (targ.fighting == tmp)
    stop_fighting (targ, tmp);

if (self.fighting)
    stop_fighting (self, self.fighting);

if (isset(tmp.charflags, CHAR_SELF_DEFENCE))
    set(self.charflags, CHAR_SELF_DEFENCE);

set_fighting(self, tmp);
set_fighting(tmp, self);

/*
Can I set that?

   if (CHAR_COMBAT(tmp_ch))
     CHAR_COMBAT(tmp_ch)->setMelee(ch);
*/

return;
}

dilend


dilbegin kick(arg : string);

external
   provoked_attack (victim : unitptr, ch : unitptr);

var
   bonus : integer;
   targ  : unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.weapons[WPN_KICK] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      if (self.fighting)
      {
	 targ := self.fighting;
	 goto kick;
      }

      act("Kick who?", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ == null) or not visible(self, targ))
   {
      act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't kick that, silly!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (targ == self)
   {
      act("You kick yourself.", A_HIDEINV, self, null, null,
	  TO_CHAR);
      act("$1n kicks $1mself.", A_HIDEINV, self, null, null,
	  TO_ROOM);
      quit;
   }

   if ((targ.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (targ.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,targ,null,TO_CHAR);
  quit;
  }
  }


   :kick:
   if (equipment(self, WEAR_WIELD))
     bonus := 0;
   else
     {
     bonus := rnd(1,(self.weapons[WPN_KICK] - 70));
     if(bonus <= 0) bonus := 1;
     }
   if (self.endurance < 2)
     act("You are too exhausted to attempt that.", A_ALWAYS, self, null,
         null, TO_CHAR);
   else self.endurance := self.endurance - 2;
   provoked_attack (targ, self);
   bonus := meleeattack(self, targ, (bonus+self.level), WPN_KICK);
   quit;
}
dilend

dilbegin elbow(arg : string); /* Just like kick */

external
   provoked_attack (victim : unitptr, ch : unitptr);

var
   bonus : integer;
   targ  : unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.weapons[WPN_ELBOW] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      if (self.fighting)
      {
	 targ := self.fighting;
	 goto elbow;
      }

      act("Elbow who?", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ == null) or not visible(self, targ))
   {
      act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't elbow that, silly!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (targ == self)
   {
      act("You elbow yourself.", A_HIDEINV, self, null, null,
	  TO_CHAR);
      act("$1n elbows $1mself.", A_HIDEINV, self, null, null,
	  TO_ROOM);
      quit;
   }

   if ((targ.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (targ.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,targ,null,TO_CHAR);
  quit;
  }
  }


   :elbow:
   if (equipment(self, WEAR_WIELD))
     bonus := 0;
   else
   {
     bonus := rnd(1,(self.weapons[WPN_ELBOW] - 70));
     /* Possibly a +30 bonus if you are 100% in elbow */
     if(bonus <= 0) bonus := 1;
    }
   if (self.endurance < 2)
     act("You are too exhausted to attempt that.", A_ALWAYS, self, null,
         null, TO_CHAR);
   else self.endurance := self.endurance - 2;
   provoked_attack (targ, self);
   bonus := meleeattack(self, targ, (bonus+self.level), WPN_ELBOW);
   quit;
}
dilend

dilbegin knee(arg : string); /* Just like kick */

external
   provoked_attack (victim : unitptr, ch : unitptr);

var
   bonus : integer;
   targ  : unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.weapons[WPN_KNEE] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      if (self.fighting)
      {
	 targ := self.fighting;
	 goto knee;
      }

      act("Knee who?", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ == null) or not visible(self, targ))
   {
      act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't knee that, silly!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (targ == self)
   {
      act("You knee yourself.", A_HIDEINV, self, null, null,
	  TO_CHAR);
      act("$1n knees $1mself.", A_HIDEINV, self, null, null,
	  TO_ROOM);
      quit;
   }

   if ((targ.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (targ.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,targ,null,TO_CHAR);
  quit;
  }
  }


   :knee:
   if (equipment(self, WEAR_WIELD))
     bonus := 0;
   else
   {
     bonus := rnd(1,(self.weapons[WPN_KNEE] - 70));
     /* Possibly a +30 bonus if you are 100% in knee */
     if(bonus <= 0) bonus := 1;
   }
   if (self.endurance < 2)
     act("You are too exhausted to attempt that.", A_ALWAYS, self, null,
         null, TO_CHAR);
   else self.endurance := self.endurance - 2;
   provoked_attack (targ, self);
   bonus := meleeattack(self, targ, (bonus+self.level), WPN_KNEE);
   quit;
}
dilend


// do_hit
dilbegin punch(arg : string); /* works as cmds hit and punch */
external
   provoked_attack (victim : unitptr, ch : unitptr);

var
   bonus : integer;
   targ  : unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.weapons[WPN_FIST] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      if (self.fighting)
      {
         targ := self.fighting;
         goto hit;
      }

      act("Who do you wish to strike?", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ == null) or not visible(self, targ))
   {
      act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't hit that, silly!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (targ == self)
   {
      act("You hit yourself.", A_HIDEINV, self, null, null, TO_CHAR);
      act("$1n hits $1mself.", A_HIDEINV, self, null, null, TO_ROOM);
      quit;
   }

   if ((targ.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
   {
      if (not(isset (self.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless you sign the book of blood.", A_ALWAYS,self,null,null,TO_CHAR);
         quit;
      }

      if (not(isset (targ.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless $2e signs the book of blood.", A_ALWAYS,self,targ,null,TO_CHAR);
         quit;
      }
   }

   :hit:
   if (equipment(self, WEAR_WIELD))
     bonus := 0;
   else
   {
      bonus := rnd(1,(self.weapons[WPN_FIST] - 70));
      /* Possibly a +30 bonus if you are 100% in knee */
      if(bonus <= 0)
         bonus := 1;
   }

   if (self.endurance < 2)
      act("You are too exhausted to attempt that.", A_ALWAYS, self, null, null, TO_CHAR);
   else 
      self.endurance := self.endurance - 2;
   provoked_attack(targ, self);
   bonus := meleeattack(self, targ, (bonus+self.level), WPN_FIST);
   quit;
}
dilend


dilbegin tripwt ();
code
{
heartbeat:=PULSE_VIOLENCE*6;
wait (SFB_TICK,TRUE);
quit;
}
dilend

dilbegin tripped ();
code
{
heartbeat:=PULSE_VIOLENCE*3;
wait (SFB_TICK,TRUE);
quit;
}
dilend

dilbegin trip(arg : string);

external
   integer skillresist (aa : integer, ad : integer,
                             sa : integer, sd : integer);
   provoked_attack (victim : unitptr, ch : unitptr);

var
   skilla : integer;
   skillb : integer;
   skillc : integer;
   skilld : integer;
   hm     : integer;
   targ   : unitptr;
   f      : integer;
code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_TRIP] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

if ( self.position== POSITION_STUNNED)
{
      act("There doesn't seem to be a way to effectively trip $3n while your
	  laying face down in the muck!",
          A_SOMEONE, self, null, targ, TO_CHAR);
quit;
}

   if (arg == "")
   {
      if (self.fighting)
      {
	 targ := self.fighting;
	 goto trip;
      }
      else
      {
	 act("Who do you wish to trip?", A_SOMEONE, self, null, null,
	     TO_CHAR);
	 quit;
      }
   }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ == null) or not visible(self, targ))
   {
      act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't trip that, silly!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (targ == self)
   {
      act("You trip over your own feet.", A_HIDEINV, self, null, null,TO_CHAR);
      act("$1n trips over $1s own feet.", A_SOMEONE, self, null, null,TO_ROOM);
      self.position:=POSITION_SITTING;
      quit;
   }


   if ((targ.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (targ.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,targ,null,TO_CHAR);
  quit;
  }
  }

   if (not (RACE_IS_MAMMAL(targ.race)))
   {
      act("There doesn't seem to be a way to effectively trip $3n.",
          A_SOMEONE, self, null, targ, TO_CHAR);
      quit;
   }
/*darg added to make mobs a bit more intelligent acting */

   if (RACE_IS_MAMMAL(targ.race) and (targ.type == UNIT_ST_NPC))
    {
     f := dilfind("trip_pc@update", targ);
     if(f == FALSE)
      {
       dilcopy("trip_pc@update()", targ);
    }
    }
/* end darg add */


   if ( ((targ.weight - self.weight) > 350) )
   {
      act("You quickly find that $3e is much to heavy to trip...ouch.",
          A_SOMEONE, self, null, targ, TO_CHAR);
      quit;
   }

   if (targ.position <= POSITION_RESTING)
   {
      act("$3e is already down!", A_SOMEONE, self, null, targ, TO_CHAR);
      quit;
   }

 :trip:
   provoked_attack (targ, self);
        

if ((dilfind ("tripwt@skills",targ))or(dilfind ("tripped@skills",targ)))
	{
	act ("$3n anticipates $1n's trip and leaps harmlessly over.",
		A_ALWAYS, self,null,targ,TO_NOTVICT);
	act ("You try to trip $3n again but $3n anticipates your trip and leaps harmlessly over.",
		A_ALWAYS, self,null,targ,TO_CHAR);
		act ("You notice $3n trying to trip you again and you leap harmlessly over $3s leg.",
			A_ALWAYS, targ,null,self,TO_CHAR);
            self.endurance := self.endurance - 10;
			position_update(self);
			quit;
			}

   if (self.type == UNIT_ST_PC)
     skillc := self.skills[SKI_TRIP];
   else
       skillc := rnd(40,144);
     /*/
     skillc := self.abilities[ABIL_DEX];
     */
   if (targ.type == UNIT_ST_PC)
   /*  skilld := targ.skills[SKI_TRIP]; */
  skilld := targ.abilities[ABIL_DEX]/4;
   else
      skilld := rnd(40,144);

   /*
     skilld := targ.abilities[ABIL_DEX];
    */
    skilla := self.abilities[ABIL_DEX];
	skillb := targ.abilities[ABIL_DEX] ;
   hm := skillresist (skilla,skillb,skillc,skilld);



   if (self.endurance < 10)
     {
	 act("You are too exhausted to attempt that.", A_ALWAYS, self, null,null, TO_CHAR);
     quit;
	 }
   else
   {
  self.endurance:=self.endurance - 10;
    position_update(self);
	}
       
   if (hm < -25)
   {
      change_speed(self, PULSE_VIOLENCE);
      provoked_attack (targ, self);
      act("You fumble your trip attempt and stumble!.",
	   A_ALWAYS, self,null, targ, TO_CHAR);
      act("$1n ducks clumsily and attempts to sweep your feet!.",
	   A_ALWAYS, self, null, targ, TO_VICT);
      act("$1n attempts to trip $3n but fails miserably.", A_SOMEONE, self,
	  null, targ, TO_NOTVICT);
      self.endurance := self.endurance - 10;
	    position_update(self);
      quit;
   }

   if (hm < 0)
   {
      change_speed(self, PULSE_VIOLENCE / 2);
      act("You fumble your trip attempt on $3n!.", A_ALWAYS, self, null, targ,
	  TO_CHAR);
      act("$1n ducks and attempts to sweeep your feet!.", A_ALWAYS, self,
	  null, targ, TO_VICT);
      act("$1n attempts to trip $3n but fails.", A_SOMEONE, self, null, targ,
	  TO_NOTVICT);
      self.endurance := self.endurance - 10;
	    position_update(self);
      quit;
   }

dilcopy ("tripwt@skills",targ);
dilcopy ("tripped@skills",targ);
   change_speed(targ, PULSE_VIOLENCE);
   act("You make a quick move and trip $3n.", A_ALWAYS, self, null, targ,
       TO_CHAR);
   act("$1n ducks quickly and sweeps your feet from under you.",
       A_ALWAYS, self, null, targ, TO_VICT);
   act("$1n makes a quick manuever and trips $3n.", A_SOMEONE, self, null,
       targ, TO_NOTVICT);
   act("$3n falls on $3s backside with a loud THUMP!", A_SOMEONE, self, null,
       targ, TO_CHAR);
   act("$3n falls on $3s backside with a loud THUMP!", A_SOMEONE, self, null,
       targ, TO_NOTVICT);
   act("You fall on your backside with a loud THUMP!",
       A_ALWAYS, self, null, targ, TO_VICT);

   targ.position:=POSITION_SITTING;
   self.endurance := self.endurance - 10;
	    position_update(self);

      if (self.fighting == null)
      {
      set_fighting(self, targ);
      }

  quit;

}
dilend


dilbegin string race_skin (race_def:integer);
code
{
if (race_def==RACE_HUMAN)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_ELF)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_DWARF)  {
return (SKIN_HIDE);}
else if (race_def==RACE_HALFLING)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_GNOME)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_HALF_ORC)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_HALF_OGRE)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_HALF_ELF)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_BROWNIE)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_GROLL)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_DARK_ELF)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_SKAVEN)  {
  return (SKIN_SCALE);}
else if (race_def==RACE_GOBLIN)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_HOBGOBLIN)  {
return (SKIN_HIDE);}
else if (race_def==RACE_KOBOLD)  {
return (SKIN_HIDE);}
else if (race_def==RACE_NIXIE)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_NYMPH)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_OGRE)  {
return (SKIN_HIDE);}
else if (race_def==RACE_ORC)  {
return (SKIN_HIDE);}
else if (race_def==RACE_SATYR)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_FAUN)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_SPRITE)  {
  return (SKIN_SKIN);}
else if (race_def==RACE_DRYAD)  {
return (SKIN_SKIN);}
else if (race_def==RACE_LEPRECHAUN)  {
return (SKIN_SKIN);}
else if (race_def==RACE_PIXIE)  {
return (SKIN_SKIN);}
else if (race_def==RACE_SYLPH)  {
return (SKIN_SKIN);}
else if (race_def==RACE_HERMIT)  {
return (SKIN_SKIN);}
else if (race_def==RACE_SHARGUGH)  {
return (SKIN_SKIN);}
else if (race_def==RACE_GIANT)  {
return (SKIN_HIDE);}
else if (race_def==RACE_TROLL)  {
return (SKIN_SKIN);}
else if (race_def==RACE_NORSE_GOD)  {
return (SKIN_SKIN);}
else if (race_def==RACE_MERMAID)  {
return (SKIN_SCALE);}
else if (race_def==RACE_NAIAD)  {
return (SKIN_SKIN);}
else if (race_def==RACE_MERMAN)  {
return (SKIN_SCALE);}
else if (race_def==RACE_MINOTAUR)  {
return (SKIN_HIDE);}
else if (race_def==RACE_YETI)  {
return (SKIN_FUR);}
else if (race_def==RACE_OTHER_HUMANOID)  {
return (SKIN_SKIN);}
else if (race_def==RACE_BEAR)  {
return (SKIN_FUR);}
else if (race_def==RACE_DOG)  {
return (SKIN_FUR);}
else if (race_def==RACE_WOLF)  {
return (SKIN_FUR);}
else if (race_def==RACE_FOX)  {
return (SKIN_FUR);}
else if (race_def==RACE_CAT)  {
return (SKIN_FUR);}
else if (race_def==RACE_RABBIT)  {
return (SKIN_FUR);}
else if (race_def==RACE_DEER)  {
return (SKIN_HIDE);}
else if (race_def==RACE_COW)  {
return (SKIN_HIDE);}
else if (race_def==RACE_GOAT)  {
return (SKIN_HIDE);}
else if (race_def==RACE_EAGLE)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_PIG)  {
return (SKIN_HIDE);}
else if (race_def==RACE_DUCK)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_BIRD)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_RAT)  {
return (SKIN_FUR);}
else if (race_def==RACE_HORSE)  {
return (SKIN_HIDE);}
else if (race_def==RACE_BADGER)  {
return (SKIN_FUR);}
else if (race_def==RACE_SKUNK)  {
return (SKIN_FUR);}
else if (race_def==RACE_BOAR)  {
return (SKIN_HIDE);}
else if (race_def==RACE_MOUSE)  {
return (SKIN_FUR);}
else if (race_def==RACE_MONKEY)  {
return (SKIN_FUR);}
else if (race_def==RACE_PORCUPINE)  {
  return (SKIN_QUILL);}
else if (race_def==RACE_ELEPHANT)  {
return (SKIN_HIDE);}
else if (race_def==RACE_CAMEL)  {
return (SKIN_HIDE);}
else if (race_def==RACE_FERRET)  {
return (SKIN_FUR);}
else if (race_def==RACE_VULTURE)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_SQUIRREL)  {
return (SKIN_FUR);}
else if (race_def==RACE_OWL)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_ELK)  {
return (SKIN_HIDE);}
else if (race_def==RACE_LION)  {
return (SKIN_HIDE);}
else if (race_def==RACE_TIGER)  {
return (SKIN_HIDE);}
else if (race_def==RACE_LEOPARD)  {
return (SKIN_HIDE);}
else if (race_def==RACE_OTHER_MAMMAL)  {
return (SKIN_FUR);}
else if (race_def==RACE_TREE)  {
  return (SKIN_TREE);}
else if (race_def==RACE_VINE)  {
return (SKIN_NONE);}
else if (race_def==RACE_FLOWER)  {
return (SKIN_NONE);}
else if (race_def==RACE_SEAWEED)  {
return (SKIN_NONE);}
else if (race_def==RACE_CACTUS)  {
return (SKIN_NONE);}
else if (race_def==RACE_OTHER_PLANT)  {
return (SKIN_NONE);}
else if (race_def==RACE_MAGGOT)  {
return (SKIN_NONE);}
else if (race_def==RACE_BEETLE)  {
return (SKIN_NONE);}
else if (race_def==RACE_SPIDER)  {
return (SKIN_NONE);}
else if (race_def==RACE_COCKROACH)  {
return (SKIN_NONE);}
else if (race_def==RACE_BUTTERFLY)  {
return (SKIN_NONE);}
else if (race_def==RACE_ANT)  {
return (SKIN_NONE);}
else if (race_def==RACE_WORM)  {
return (SKIN_NONE);}
else if (race_def==RACE_LEECH)  {
return (SKIN_NONE);}
else if (race_def==RACE_DRAGONFLY)  {
return (SKIN_NONE);}
else if (race_def==RACE_MOSQUITO)  {
return (SKIN_NONE);}
else if (race_def==RACE_INSECT)  {
return (SKIN_NONE);}
else if (race_def==RACE_LIZARD)  {
return (SKIN_SCALE);}
else if (race_def==RACE_SNAKE)  {
return (SKIN_SKIN);}
else if (race_def==RACE_FROG)  {
return (SKIN_SKIN);}
else if (race_def==RACE_ALLIGATOR)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DINOSAUR)  {
return (SKIN_SCALE);}
else if (race_def==RACE_CHAMELEON)  {
return (SKIN_SCALE);}
else if (race_def==RACE_SCORPION)  {
return (SKIN_SHELL);}
else if (race_def==RACE_TURTLE)  {
return (SKIN_SHELL);}
else if (race_def==RACE_BAT)  {
return (SKIN_SKIN);}
else if (race_def==RACE_TOAD)  {
return (SKIN_SKIN);}
else if (race_def==RACE_OTHER_REPTILE)  {
return (SKIN_SCALE);}
else if (race_def==RACE_UR_VILE)  {
return (SKIN_SKIN);}
else if (race_def==RACE_STONE_RENDER)  {
return (SKIN_NONE);}
else if (race_def==RACE_VAMPIRE)  {
return (SKIN_SKIN);}
else if (race_def==RACE_SLIME)  {
return (SKIN_NONE);}
else if (race_def==RACE_WYRM)  {
return (SKIN_SKIN);}
else if (race_def==RACE_UNICORN)  {
return (SKIN_HIDE);}
else if (race_def==RACE_DRAGON_MIN)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_BLACK)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_BLUE)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_GREEN)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_RED)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_WHITE)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_SILVER)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_TURTLE)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_LAVA)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_SHADOW)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRAGON_LIZARD)  {
return (SKIN_SCALE);}
else if (race_def==RACE_LESSER_DEMON)  {
return (SKIN_SKIN);}
else if (race_def==RACE_GREATER_DEMON)  {
return (SKIN_SKIN);}
else if (race_def==RACE_LESSER_DEVIL)  {
return (SKIN_SKIN);}
else if (race_def==RACE_GREATER_DEVIL)  {
return (SKIN_SKIN);}
else if (race_def==RACE_SHADOW_DEVIL)  {
return (SKIN_SKIN);}
else if (race_def==RACE_GARGOYLE)  {
return (SKIN_NONE);}
else if (race_def==RACE_GOLEM)  {
return (SKIN_NONE);}
else if (race_def==RACE_YOGOLOTH)  {
return (SKIN_HIDE);}
else if (race_def==RACE_MIST_DWELLER)  {
return (SKIN_NONE);}
else if (race_def==RACE_WEREWOLF)  {
return (SKIN_FUR);}
else if (race_def==RACE_WERERAT)  {
return (SKIN_FUR);}
else if (race_def==RACE_ELEMENTAL_AIR)  {
return (SKIN_NONE);}
else if (race_def==RACE_ELEMENTAL_EARTH)  {
return (SKIN_NONE);}
else if (race_def==RACE_ELEMENTAL_FIRE)  {
return (SKIN_NONE);}
else if (race_def==RACE_ELEMENTAL_FROST)  {
return (SKIN_NONE);}
else if (race_def==RACE_ELEMENTAL_WATER)  {
return (SKIN_NONE);}
else if (race_def==RACE_ELEMENTAL_LIGHT)  {
return (SKIN_NONE);}
else if (race_def==RACE_FAMILIAR)  {
return (SKIN_NONE);}
else if (race_def==RACE_OTHER_CREATURE)  {
return (SKIN_HIDE);}
else if (race_def==RACE_ZOMBIE)  {
return (SKIN_NONE);}
else if (race_def==RACE_GHOUL)  {
return (SKIN_NONE);}
else if (race_def==RACE_SKELETON)  {
return (SKIN_NONE);}
else if (race_def==RACE_GHOST)  {
return (SKIN_NONE);}
else if (race_def==RACE_SPIRIT)  {
return (SKIN_NONE);}
else if (race_def==RACE_MUMMIE)  {
return (SKIN_NONE);}
else if (race_def==RACE_BANSHEE)  {
return (SKIN_SKIN);}
else if (race_def==RACE_UNDEAD)  {
return (SKIN_NONE);}
else if (race_def==RACE_CRAB)  {
return (SKIN_SHELL);}
else if (race_def==RACE_SEA_HORSE)  {
return (SKIN_NONE);}
else if (race_def==RACE_SHARK)  {
return (SKIN_SCALE);}
else if (race_def==RACE_MANTA_RAY)  {
return (SKIN_HIDE);}
else if (race_def==RACE_OYSTER)  {
return (SKIN_SHELL);}
else if (race_def==RACE_CAVE_FISHER)  {
return (SKIN_SHELL);}
else if (race_def==RACE_OCTOPUS)  {
return (SKIN_SKIN);}
else if (race_def==RACE_WHALE)  {
return (SKIN_SKIN);}
else if (race_def==RACE_DOLPHIN)  {
return (SKIN_SKIN);}
else if (race_def==RACE_EEL)  {
return (SKIN_SKIN);}
else if (race_def==RACE_MINNOW)  {
return (SKIN_SCALE);}
else if (race_def==RACE_KINGRAITH)  {
return (SKIN_SCALE);}
else if (race_def==RACE_DRACONIAN)  {
return (SKIN_SCALE);}
else if (race_def==RACE_TANNARI)  {
return (SKIN_HIDE);}
else if (race_def==RACE_DROW)  {
return (SKIN_SKIN);}
else if (race_def==RACE_BEE)  {
return (SKIN_NONE);}
else if (race_def==RACE_MANTIS)  {
return (SKIN_NONE);}
else if (race_def==RACE_TRIPHID)  {
return (SKIN_SHELL);}
else if (race_def==RACE_JELLYFISH)  {
return (SKIN_NONE);}
else if (race_def==RACE_PIRANHA)  {
return (SKIN_SCALE);}
else if (race_def==RACE_BARACUDA)  {
return (SKIN_SCALE);}
else if (race_def==RACE_CROCODILE)  {
return (SKIN_SCALE);}
else if (race_def==RACE_SQUID)  {
return (SKIN_SKIN);}
else if (race_def==RACE_OCTOPUS)  {
return (SKIN_SKIN);}
else if (race_def==RACE_CHICKEN)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_GOOSE)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_PIGEON)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_PEACOCK)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_OSTRICH)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_SEAGULL)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_SWAN)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_TURKEY)  {
return (SKIN_FEATHER);}
else if (race_def==RACE_BEAVER)  {
return (SKIN_FUR);}
else if (race_def==RACE_CHIPMUNK)  {
return (SKIN_FUR);}
else if (race_def==RACE_HAMSTER)  {
return (SKIN_FUR);}
else if (race_def==RACE_HAMSTER)  {
return (SKIN_FUR);}
else if (race_def==RACE_LLAMA)  {
return (SKIN_FUR);}
else if (race_def==RACE_MOLE)  {
return (SKIN_FUR);}
else if (race_def==RACE_MOOSE)  {
return (SKIN_FUR);}
else if (race_def==RACE_MOUNTAIN_LION)  {
return (SKIN_FUR);}
else if (race_def==RACE_RACCOON)  {
return (SKIN_FUR);}
else if (race_def==RACE_RHINO)  {
return (SKIN_HIDE);}
else if (race_def==RACE_SEAL)  {
return (SKIN_FUR);}
else if (race_def==RACE_SHEEP)  {
return (SKIN_HIDE);}
else if (race_def==RACE_SLOTH)  {
return (SKIN_FUR);}
else if (race_def==RACE_WALRUS)  {
return (SKIN_HIDE);}
else if (race_def==RACE_WEASLE)  {
return (SKIN_FUR);}
else if (race_def==RACE_WARTHOG)  {
return (SKIN_HIDE);}
else if (race_def==RACE_TUMBLEWEED)  {
return (SKIN_NONE);}
else if (race_def==RACE_PEPPER)  {
return (SKIN_NONE);}
else if (race_def==RACE_RASPBERRY)  {
return (SKIN_NONE);}
else if (race_def==RACE_CARROT)  {
return (SKIN_NONE);}
else if (race_def==RACE_BLUEBERRY)  {
return (SKIN_NONE);}
else if (race_def==RACE_LOSKA)  {
return (SKIN_NONE);}
else if (race_def==RACE_PUMPKIN)  {
return (SKIN_NONE);}
else if (race_def==RACE_BEAN)  {
return (SKIN_NONE);}
else if (race_def==RACE_STRAWBERRY)  {
return (SKIN_NONE);}
else if (race_def==RACE_POTATO)  {
return (SKIN_NONE);}
else if (race_def==RACE_TOMATO)  {
return (SKIN_NONE);}
else if (race_def==RACE_CABBAGE)  {
return (SKIN_NONE);}
else if (race_def==RACE_LETTUCE)  {
return (SKIN_NONE);}
else if (race_def==RACE_WHEAT)  {
return (SKIN_NONE);}
else if (race_def==RACE_CORN)  {
return (SKIN_NONE);}
else if (race_def==RACE_ACIDPLANT)  {
return (SKIN_NONE);}
else if (race_def==RACE_PLANT_GROW)  {
return (SKIN_NONE);}
else if (race_def==RACE_NORSE_GOD_AIR)  {
return (SKIN_SKIN);}
else if (race_def==RACE_NORSE_GOD_EARTH)  {
return (SKIN_SKIN);}
else if (race_def==RACE_NORSE_GOD_FIRE)  {
return (SKIN_SKIN);}
else if (race_def==RACE_NORSE_GOD_FROST)  {
return (SKIN_SKIN);}
else if (race_def==RACE_NORSE_GOD_LIGHT)  {
return (SKIN_SKIN);}
else if (race_def==RACE_NORSE_GOD_WATER)  {
return (SKIN_SKIN);}
else if (race_def==RACE_NORSE_GOD_DARKNESS)  {
return (SKIN_SKIN);}
else if ((race_def>=RACE_LICH_MIN) or (race_def<=RACE_LICH_MAX)){
return (SKIN_NONE);}
else if (race_def==RACE_HOMARID)  {
return (SKIN_SCALE);}
else if (race_def==RACE_PEGASUS)  {
return (SKIN_HIDE);}
else if (race_def==RACE_SAND_CRAWLER)  {
return (SKIN_NONE);}
else if (race_def==RACE_DEATH_GHAST)  {
return (SKIN_NONE);}
else if (race_def==RACE_SHADOW_BEAST)  {
return (SKIN_NONE);}
else if (race_def==RACE_CREEPER)  {
return (SKIN_NONE);}
else if (race_def==RACE_STATUE)  {
return (SKIN_NONE);}
else if (race_def==RACE_MUTANT)  {
return (SKIN_HIDE);}
return (SKIN_NONE);
}
dilend

dilbegin integer race_cost (race_def:integer);
var
  cst:integer;
code
{
if (race_def==RACE_HUMAN)  {
cst :=550;}
else if (race_def==RACE_ELF)  {
cst :=555;}
else if (race_def==RACE_DWARF)  {
cst :=550;}
else if (race_def==RACE_HALFLING)  {
cst :=580;}
else if (race_def==RACE_GNOME)  {
cst :=560;}
else if (race_def==RACE_HALF_ORC)  {
cst :=560;}
else if (race_def==RACE_HALF_OGRE)  {
cst :=550;}
else if (race_def==RACE_HALF_ELF)  {
cst :=554;}
else if (race_def==RACE_BROWNIE)  {
cst :=600;}
else if (race_def==RACE_GROLL)  {
cst :=485;}
else if (race_def==RACE_DARK_ELF)  {
cst :=455;}
else if (race_def==RACE_SKAVEN)  {
  cst :=750;}
else if (race_def==RACE_GOBLIN)  {
cst :=541;}
else if (race_def==RACE_HOBGOBLIN)  {
cst :=554;}
else if (race_def==RACE_KOBOLD)  {
cst :=589;}
else if (race_def==RACE_NIXIE)  {
cst :=500;}
else if (race_def==RACE_NYMPH)  {
cst :=500;}
else if (race_def==RACE_OGRE)  {
cst :=500;}
else if (race_def==RACE_ORC)  {
cst :=546;}
else if (race_def==RACE_SATYR)  {
cst :=582;}
else if (race_def==RACE_FAUN)  {
cst :=585;}
else if (race_def==RACE_SPRITE)  {
cst :=655;}
else if (race_def==RACE_DRYAD)  {
cst :=585;}
else if (race_def==RACE_LEPRECHAUN)  {
cst :=584;}
else if (race_def==RACE_PIXIE)  {
cst :=565;}
else if (race_def==RACE_SYLPH)  {
cst :=588;}
else if (race_def==RACE_HERMIT)  {
cst :=578;}
else if (race_def==RACE_SHARGUGH)  {
cst :=566;}
else if (race_def==RACE_GIANT)  {
cst :=548;}
else if (race_def==RACE_TROLL)  {
cst :=522;}
else if (race_def==RACE_NORSE_GOD)  {
cst :=895;}
else if (race_def==RACE_MERMAID)  {
cst :=600;}
else if (race_def==RACE_NAIAD)  {
cst :=598;}
else if (race_def==RACE_MERMAN)  {
cst :=859;}
else if (race_def==RACE_MINOTAUR)  {
cst :=600;}
else if (race_def==RACE_YETI)  {
cst :=900;}
else if (race_def==RACE_OTHER_HUMANOID)  {
cst :=550;}
else if (race_def==RACE_BEAR)  {
cst :=245;}
else if (race_def==RACE_DOG)  {
cst :=85;}
else if (race_def==RACE_WOLF)  {
cst :=150;}
else if (race_def==RACE_FOX)  {
cst :=125;}
else if (race_def==RACE_CAT)  {
cst :=65;}
else if (race_def==RACE_RABBIT)  {
cst :=110;}
else if (race_def==RACE_DEER)  {
cst :=160;}
else if (race_def==RACE_COW)  {
cst :=190;}
else if (race_def==RACE_GOAT)  {
cst :=148;}
else if (race_def==RACE_EAGLE)  {
cst :=250;}
else if (race_def==RACE_PIG)  {
cst :=142;}
else if (race_def==RACE_DUCK)  {
cst :=100;}
else if (race_def==RACE_BIRD)  {
cst :=75;}
else if (race_def==RACE_RAT)  {
cst :=65;}
else if (race_def==RACE_HORSE)  {
cst :=190;}
else if (race_def==RACE_BADGER)  {
cst :=115;}
else if (race_def==RACE_SKUNK)  {
cst :=85;}
else if (race_def==RACE_BOAR)  {
cst :=158;}
else if (race_def==RACE_MOUSE)  {
cst :=60;}
else if (race_def==RACE_MONKEY)  {
cst :=125;}
else if (race_def==RACE_PORCUPINE)  {
  cst :=250;}
else if (race_def==RACE_ELEPHANT)  {
cst :=800;}
else if (race_def==RACE_CAMEL)  {
cst :=350;}
else if (race_def==RACE_FERRET)  {
cst :=82;}
else if (race_def==RACE_VULTURE)  {
cst :=125;}
else if (race_def==RACE_SQUIRREL)  {
cst :=88;}
else if (race_def==RACE_OWL)  {
cst :=100;}
else if (race_def==RACE_ELK)  {
cst :=192;}
else if (race_def==RACE_LION)  {
cst :=800;}
else if (race_def==RACE_TIGER)  {
cst :=900;}
else if (race_def==RACE_LEOPARD)  {
cst :=1000;}
else if (race_def==RACE_OTHER_MAMMAL)  {
cst :=400;}
else if (race_def==RACE_TREE)  {
  cst :=0;}
else if (race_def==RACE_VINE)  {
cst :=0;}
else if (race_def==RACE_FLOWER)  {
cst :=0;}
else if (race_def==RACE_SEAWEED)  {
cst :=0;}
else if (race_def==RACE_CACTUS)  {
cst :=0;}
else if (race_def==RACE_OTHER_PLANT)  {
cst :=0;}
else if (race_def==RACE_MAGGOT)  {
cst :=0;}
else if (race_def==RACE_BEETLE)  {
cst :=0;}
else if (race_def==RACE_SPIDER)  {
cst :=0;}
else if (race_def==RACE_COCKROACH)  {
cst :=0;}
else if (race_def==RACE_BUTTERFLY)  {
cst :=0;}
else if (race_def==RACE_ANT)  {
cst :=0;}
else if (race_def==RACE_WORM)  {
cst :=0;}
else if (race_def==RACE_LEECH)  {
cst :=0;}
else if (race_def==RACE_DRAGONFLY)  {
cst :=0;}
else if (race_def==RACE_MOSQUITO)  {
cst :=0;}
else if (race_def==RACE_INSECT)  {
cst :=0;}
else if (race_def==RACE_LIZARD)  {
cst :=145;}
else if (race_def==RACE_SNAKE)  {
cst :=250;}
else if (race_def==RACE_FROG)  {
cst :=120;}
else if (race_def==RACE_ALLIGATOR)  {
cst :=500;}
else if (race_def==RACE_DINOSAUR)  {
cst :=1850;}
else if (race_def==RACE_CHAMELEON)  {
cst :=165;}
else if (race_def==RACE_SCORPION)  {
cst := 0;}
else if (race_def==RACE_TURTLE)  {
cst := 900;}
else if (race_def==RACE_BAT)  {
cst :=120;}
else if (race_def==RACE_TOAD)  {
cst :=100;}
else if (race_def==RACE_OTHER_REPTILE)  {
cst :=125;}
else if (race_def==RACE_UR_VILE)  {
cst :=250;}
else if (race_def==RACE_STONE_RENDER)  {
cst :=0;}
else if (race_def==RACE_VAMPIRE)  {
cst :=750;}
else if (race_def==RACE_SLIME)  {
cst :=0;}
else if (race_def==RACE_WYRM)  {
cst :=635;}
else if (race_def==RACE_UNICORN)  {
cst :=1800;}
else if (race_def==RACE_DRAGON_MIN)  {
cst :=8000;}
else if (race_def==RACE_DRAGON_BLACK)  {
cst :=9000;}
else if (race_def==RACE_DRAGON_BLUE)  {
cst :=10000;}
else if (race_def==RACE_DRAGON_GREEN)  {
cst :=11000;}
else if (race_def==RACE_DRAGON_RED)  {
cst :=12000;}
else if (race_def==RACE_DRAGON_WHITE)  {
cst :=13000;}
else if (race_def==RACE_DRAGON_SILVER)  {
cst :=14000;}
else if (race_def==RACE_DRAGON_TURTLE)  {
cst :=9850;}
else if (race_def==RACE_DRAGON_LAVA)  {
cst :=10000;}
else if (race_def==RACE_DRAGON_SHADOW)  {
cst :=12000;}
else if (race_def==RACE_DRAGON_LIZARD)  {
cst :=5800;}
else if (race_def==RACE_LESSER_DEMON)  {
cst :=815;}
else if (race_def==RACE_GREATER_DEMON)  {
cst :=899;}
else if (race_def==RACE_LESSER_DEVIL)  {
cst :=1000;}
else if (race_def==RACE_GREATER_DEVIL)  {
cst :=1250;}
else if (race_def==RACE_SHADOW_DEVIL)  {
cst :=1250;}
else if (race_def==RACE_GARGOYLE)  {
cst :=0;}
else if (race_def==RACE_GOLEM)  {
cst :=0;}
else if (race_def==RACE_YOGOLOTH)  {
cst :=0;}
else if (race_def==RACE_MIST_DWELLER)  {
cst :=0;}
else if (race_def==RACE_WEREWOLF)  {
cst :=550;}
else if (race_def==RACE_WERERAT)  {
cst :=125;}
else if (race_def==RACE_ELEMENTAL_AIR)  {
cst :=0;}
else if (race_def==RACE_ELEMENTAL_EARTH)  {
cst :=0;}
else if (race_def==RACE_ELEMENTAL_FIRE)  {
cst :=0;}
else if (race_def==RACE_ELEMENTAL_FROST)  {
cst :=0;}
else if (race_def==RACE_ELEMENTAL_WATER)  {
cst :=0;}
else if (race_def==RACE_ELEMENTAL_LIGHT)  {
cst :=0;}
else if (race_def==RACE_FAMILIAR)  {
cst :=0;}
else if (race_def==RACE_OTHER_CREATURE)  {
cst :=152;}
else if (race_def==RACE_ZOMBIE)  {
cst :=0;}
else if (race_def==RACE_GHOUL)  {
cst :=0;}
else if (race_def==RACE_SKELETON)  {
cst :=0;}
else if (race_def==RACE_GHOST)  {
cst :=0;}
else if (race_def==RACE_SPIRIT)  {
cst :=0;}
else if (race_def==RACE_MUMMIE)  {
cst :=0;}
else if (race_def==RACE_BANSHEE)  {
cst :=0;}
else if (race_def==RACE_UNDEAD)  {
cst :=0;}
else if (race_def==RACE_CRAB)  {
cst :=250;}
else if (race_def==RACE_SEA_HORSE)  {
cst :=0;}
else if (race_def==RACE_SHARK)  {
cst :=900;}
else if (race_def==RACE_MANTA_RAY)  {
cst :=1200;}
else if (race_def==RACE_OYSTER)  {
cst :=500;}
else if (race_def==RACE_CAVE_FISHER)  {
cst :=300;}
else if (race_def==RACE_OCTOPUS)  {
cst :=0;}
else if (race_def==RACE_WHALE)  {
cst :=15800;}
else if (race_def==RACE_DOLPHIN)  {
cst :=258;}
else if (race_def==RACE_EEL)  {
cst :=115;}
else if (race_def==RACE_MINNOW)  {
cst :=85;}
else if (race_def==RACE_KINGRAITH)  {
cst :=550;}
else if (race_def==RACE_DRACONIAN)  {
cst :=585;}
else if (race_def==RACE_TANNARI)  {
cst :=850;}
else if (race_def==RACE_DROW)  {
cst :=555;}
else if (race_def==RACE_BEE)  {
cst :=0;}
else if (race_def==RACE_MANTIS)  {
cst :=0;}
else if (race_def==RACE_TRIPHID)  {
cst :=0;}
else if (race_def==RACE_JELLYFISH)  {
cst :=0;}
else if (race_def==RACE_PIRANHA)  {
cst :=55;}
else if (race_def==RACE_BARACUDA)  {
cst :=95;}
else if (race_def==RACE_CROCODILE)  {
cst :=1258;}
else if (race_def==RACE_SQUID)  {
cst :=258;}
else if (race_def==RACE_CHICKEN)  {
cst :=258;}
else if (race_def==RACE_GOOSE)  {
cst :=450;}
else if (race_def==RACE_PIGEON)  {
cst :=110;}
else if (race_def==RACE_PEACOCK)  {
cst :=850;}
else if (race_def==RACE_OSTRICH)  {
cst :=1286;}
else if (race_def==RACE_SEAGULL)  {
cst :=55;}
else if (race_def==RACE_SWAN)  {
cst :=950;}
else if (race_def==RACE_TURKEY)  {
cst :=752;}
else if (race_def==RACE_BEAVER)  {
cst :=1000;}
else if (race_def==RACE_CHIPMUNK)  {
cst :=75;}
else if (race_def==RACE_HAMSTER)  {
cst :=38;}
else if (race_def==RACE_LLAMA)  {
cst :=258;}
else if (race_def==RACE_MOLE)  {
cst :=15;}
else if (race_def==RACE_MOOSE)  {
cst :=580;}
else if (race_def==RACE_MOUNTAIN_LION)  {
cst :=650;}
else if (race_def==RACE_RACCOON)  {
cst :=247;}
else if (race_def==RACE_RHINO)  {
cst :=975;}
else if (race_def==RACE_SEAL)  {
cst :=1000;}
else if (race_def==RACE_SHEEP)  {
cst :=248;}
else if (race_def==RACE_SLOTH)  {
cst :=125;}
else if (race_def==RACE_WALRUS)  {
cst :=625;}
else if (race_def==RACE_WEASLE)  {
cst :=75;}
else if (race_def==RACE_WARTHOG)  {
cst :=150;}
else if (race_def==RACE_TUMBLEWEED)  {
cst :=0;}
else if (race_def==RACE_PEPPER)  {
cst :=0;}
else if (race_def==RACE_RASPBERRY)  {
cst :=0;}
else if (race_def==RACE_CARROT)  {
cst :=0;}
else if (race_def==RACE_BLUEBERRY)  {
cst :=0;}
else if (race_def==RACE_LOSKA)  {
cst :=0;}
else if (race_def==RACE_PUMPKIN)  {
cst :=0;}
else if (race_def==RACE_BEAN)  {
cst :=0;}
else if (race_def==RACE_STRAWBERRY)  {
cst :=0;}
else if (race_def==RACE_POTATO)  {
cst :=0;}
else if (race_def==RACE_TOMATO)  {
cst :=0;}
else if (race_def==RACE_CABBAGE)  {
cst :=0;}
else if (race_def==RACE_LETTUCE)  {
cst :=0;}
else if (race_def==RACE_WHEAT)  {
cst :=0;}
else if (race_def==RACE_CORN)  {
cst :=0;}
else if (race_def==RACE_ACIDPLANT)  {
cst :=0;}
else if (race_def==RACE_PLANT_GROW)  {
cst :=0;}
else if (race_def==RACE_NORSE_GOD_AIR)  {
cst :=0;}
else if (race_def==RACE_NORSE_GOD_EARTH)  {
cst :=0;}
else if (race_def==RACE_NORSE_GOD_FIRE)  {
cst :=0;}
else if (race_def==RACE_NORSE_GOD_FROST)  {
cst :=0;}
else if (race_def==RACE_NORSE_GOD_LIGHT)  {
cst :=0;}
else if (race_def==RACE_NORSE_GOD_WATER)  {
cst :=0;}
else if (race_def==RACE_NORSE_GOD_DARKNESS)  {
cst :=0;}
else if ((race_def>=RACE_LICH_MIN) or (race_def<=RACE_LICH_MAX)){
cst := 0 ;}
else if (race_def==RACE_HOMARID)  {
cst :=580;}
else if (race_def==RACE_PEGASUS)  {
cst :=1542;}
else if (race_def==RACE_SAND_CRAWLER)  {
cst :=0;}
else if (race_def==RACE_DEATH_GHAST)  {
cst :=0;}
else if (race_def==RACE_SHADOW_BEAST)  {
cst :=0;}
else if (race_def==RACE_CREEPER)  {
cst :=0;}
else if (race_def==RACE_STATUE)  {
cst :=0;}
else if (race_def==RACE_MUTANT)  {
cst :=0;}

return (cst);
}
dilend

/* do_skin 
 *   See make_corpse in zone @death for corpse data
 */
dilbegin skin(arg : string);
external
   string race_skin(race_def:integer);
   integer race_cost(race_def:integer);
   checkstand@basemove();
   integer skillchecksa@skills(skillidx : integer, abiidx : integer, difficulty : integer);
   string hm_adjective(hm : integer);
   string race_name(race_def : integer);

var
   temp:string;
   hm      : integer;
   targ    : unitptr;
   wpn:unitptr;
   skin    : unitptr;
   cst:integer;
   skin_name:string;
   race_name:string;
   wt      : integer;
   corpse_name:string;
   beheaded:integer;
   i : integer;
   s : string;

code
{
   checkstand@basemove();

   beheaded:=0;
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_SKIN] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.endurance < 20)
   {
      act ("You are too tired to skin even a mouse.", A_ALWAYS,self,null,null,TO_CHAR);
      quit;
   }

   if (arg=="") {
      act ("Skin what?", A_ALWAYS,self,null,null,TO_CHAR);
      quit;
   }

   targ := findunit(self,arg,FIND_UNIT_SURRO,null);
   if ((targ==null) or not visible(self, targ))
   {
      act ("There is nothing like that to skin here.", A_ALWAYS,self,null,null,TO_CHAR);
      quit;
   }

   if ((targ.nameidx+"@"+targ.zoneidx)!="corpse@death")
   {
      act ("You can't skin that!",A_ALWAYS,self,null,null,TO_CHAR);
      quit;
   }

   if ("$skinned" in targ.extra)
   {
      act ("Sorry that has already been skinned.", A_ALWAYS,self,null,null,TO_CHAR);
      quit;
   }

   skin_name:=race_skin(targ.value[4]);

   if (skin_name=="NONE"){
      act ("That $2N can not be skinned.", A_ALWAYS,self,targ,null,TO_CHAR);
      quit;
   }

   secure (targ,losttarg);

   wpn := self.inside;

   while (wpn)
   {
      if (wpn.objecttype == ITEM_WEAPON) 
         if (wpn.value[0] == WPN_DAGGER)
            goto gotknife;
      wpn := wpn.next;
   }

   act("You need a knife to skin $3n.", A_SOMEONE, self, null, targ, TO_CHAR);
   quit;

   :gotknife:
   /* The difficulty equals the level of the dead corpse, but if the level is higher than the */
   /* self.level then there's a 5 point penalty per level. Ie. it's more demanding to skin a  */
   /* creature relatively higher level than yourself                                          */

   i := targ.value[3];  // The level is the difficulty.

   if (targ.value[3] > self.level)
      i := i - (self.level - targ.value[3]) * 5; // 5 more difficult per level difference ( - - = + )

   hm := skillchecksa(SKI_SKIN, ABIL_DEX, i);

   self.endurance := self.endurance - (5 + targ.weight / 10);
   position_update(self);

   if ("headless" in targ.outside_descr)
      beheaded:=1;

   addextra(targ.extra, {"$skinned"}, itoa(targ.value[4]));

   corpse_name := targ.outside_descr;

   if (hm <= 0)
   {
      act("You sadly mangle the "+skin_name+" of $3n with your $2n.",
         A_SOMEONE, self, wpn, targ, TO_CHAR);
      act("$1n mangles the "+skin_name+"  of $3n with $1s $2n. What a mess!",
         A_SOMEONE, self, wpn, targ, TO_ROOM);

      if (beheaded==0){
         targ.title:="a poorly skinned " + targ.names.[0];
         targ.outside_descr:="a poorly skinned "+targ.names.[0] + " is laying here.";
      }
      else
      {
         targ.title:="a poorly skinned, headless " + targ.names.[0];
         targ.outside_descr:="a poorly skinned and headless "+targ.names.[0] + " is laying here.";
      }
      quit;
   }

   s := hm_adjective(hm);
   act("Using your $2n you"+s+"skin $3n.", A_SOMEONE, self, wpn, targ, TO_CHAR);
   act("$1n uses $1s $2n to"+s+"skin $3n .", A_SOMEONE, self, wpn, targ, TO_REST);

   race_name := race_name(targ.value[4]);
   targ.title:="a skinned " + targ.names.[0];
   targ.outside_descr:="a skinned " + targ.names.[0] + " is laying here.";
   addstring(targ.names, "skinned "+ targ.names.[1]);

   skin := load("base_skin@skills");
   link(skin, self.outside);
   secure(skin, lostskin);
   // addstring(skin.names,corpse_name);
   addstring(skin.names, skin_name);
   skin.outside_descr := race_name + " " + skin_name + " is laying here.";
   skin.title := race_name + " " + skin_name;

   s := getword(race_name); // remove "a", "an", ...
   addstring(skin.names, race_name + " " + skin_name);
   substring(skin.names, "base skin");

   i := race_cost(targ.value[4]);
   skin.cost:= 1 + i * hm / 100;

   i := targ.weight / 10;
   if (i > 50)
      i := 50;
   if (i < 1)
      i := 1;
   setweight(skin, i);
   quit;

:losttarg:
:lostskin:
   unsecure (targ);
   unsecure(skin);
   quit;
}
dilend



dilbegin integer race_legs (race_def : integer);
code
{
if ((race_def >= 0) and (race_def <= 10)) return (2);
if ((race_def >= 120) and (race_def <= 142)) return (2);
if ((race_def == RACE_BEE) or (race_def == RACE_BEETLE) or
    (race_def == RACE_BUTTERFLY) or (race_def == RACE_COCKROACH) or
    (race_def == RACE_DRAGONFLY) or (race_def == RACE_INSECT) or
    (race_def == RACE_MANTIS) or (race_def == RACE_MOSQUITO)) return (6);
if ((race_def == RACE_SCORPION) or (race_def == RACE_SPIDER) or
    (race_def == RACE_TRIPHID) or (race_def == RACE_ANT)) return (8);
if ((race_def >= RACE_ANNELIDA_MIN) and (race_def <= RACE_ANNELIDA_MAX)) return (0);
if ((race_def >= RACE_CNIDARIA_MIN) and (race_def <= RACE_CNIDARIA_MAX)) return (0);
if ((race_def >= RACE_JAWLESS_FISH_MIN) and (race_def <= RACE_JAWLESS_FISH_MAX)) return (10);
if ((race_def >= RACE_CARTIL_FISH_MIN) and (race_def <= RACE_CARTIL_FISH_MAX)) return (10);
if ((race_def >= RACE_BONEY_FISH_MIN) and (race_def <= RACE_BONEY_FISH_MAX)) return (10);
if ((race_def >= RACE_AMPHIBIAN_MIN) and (race_def <= RACE_AMPHIBIAN_MAX)) return (4);
if ((race_def == RACE_ALLIGATOR) or (race_def == RACE_CHAMELEON) or
    (race_def == RACE_DINOSAUR) or (race_def == RACE_LIZARD) or
    (race_def == RACE_TURTLE) or (race_def == RACE_OTHER_REPTILE)) return (4);
if (race_def == RACE_SNAKE) return (0);
if ((race_def == RACE_CRAB) or (race_def == RACE_SQUID) or
    (race_def == RACE_OCTOPUS)) return (9);
if (race_def==RACE_OYSTER) return (-1);
if ((race_def >= RACE_BIRD_MIN) and (race_def <= RACE_BIRD_MAX)) return (2);
if ((race_def >= RACE_MAMMAL_MIN) and (race_def <= RACE_MAMMAL_MAX)) return (4);
if ((race_def >= RACE_PLANT_MIN) and (race_def <= RACE_PLANT_MAX)) return (-1);
if ((race_def >= RACE_NORSE_GOD_MIN) and (race_def <= RACE_NORSE_GOD_MAX)) return (2);
if ((race_def >= RACE_DRAGON_MIN) and (race_def <= RACE_DRAGON_MAX)) return (4);
if ((race_def >= RACE_SPIRIT_MIN) and (race_def <= RACE_SPIRIT_MAX)) return (2);
if ((race_def >= RACE_LICH_MIN) and (race_def <= RACE_LICH_MAX)) return (-1);
if ((race_def >= RACE_DEMON_MIN) and (race_def <= RACE_DEMON_MAX)) return (2);
if ((race_def == RACE_HOMARID) or (race_def == RACE_MERMAID) or
    (race_def == RACE_PIXIE) or (race_def == RACE_VAMPIRE) or
    (race_def == RACE_WYRM) or (race_def == RACE_BANSHEE) or
    (race_def == RACE_DRYAD) or (race_def == RACE_NAIAD) or
    (race_def == RACE_STONE_RENDER) or (race_def == RACE_UR_VILE) or
    (race_def == RACE_SKELETON) or (race_def == RACE_YOGOLOTH) or
    (race_def == RACE_YETI) or (race_def == RACE_MERMAN) or
    (race_def == RACE_SPRITE) or (race_def == RACE_NIXIE) or
    (race_def == RACE_NYMPH) or (race_def == RACE_SATYR) or
    (race_def == RACE_FAUN) or (race_def == RACE_LEPRECHAUN) or
    (race_def == RACE_SYLPH) or (race_def == RACE_HERMIT) or
    (race_def == RACE_SHARGUGH) or (race_def == RACE_OTHER_CREATURE) or
    (race_def == RACE_OTHER_HUMANOID) or (race_def == RACE_OTHER_MAMMAL)) return (2);
if ((race_def == RACE_MINOTAUR) or (race_def == RACE_PEGASUS) or
    (race_def == RACE_WEREWOLF) or (race_def == RACE_CREEPER) or
    (race_def == RACE_UNICORN) or (race_def == RACE_GARGOYLE) or
    (race_def == RACE_CAVE_FISHER)) return (4);
if ((race_def == RACE_SAND_CRAWLER) or (race_def == RACE_DEATH_GHAST) or
    (race_def == RACE_SHADOW_BEAST) or (race_def == RACE_STATUE) or
    (race_def == RACE_MIST_DWELLER) or (race_def == RACE_MUTANT) or
    (race_def == RACE_CAVE_FISHER)) return (-1);
else return (-1);
}
dilend /* race_legs */

dilbegin integer race_arms (race_def : integer);
code
{
if ((race_def >= 0) and (race_def <= 10)) return (2);
if ((race_def >= 120) and (race_def <= 142)) return (2);
if ((race_def == RACE_BEE) or (race_def == RACE_BEETLE) or
    (race_def == RACE_BUTTERFLY) or (race_def == RACE_COCKROACH) or
    (race_def == RACE_DRAGONFLY) or (race_def == RACE_INSECT) or
    (race_def == RACE_MANTIS) or (race_def == RACE_MOSQUITO)) return (0);
if ((race_def == RACE_SCORPION) or (race_def == RACE_SPIDER) or
    (race_def == RACE_TRIPHID) or (race_def == RACE_ANT)) return (0);
if ((race_def >= RACE_ANNELIDA_MIN) and (race_def <= RACE_ANNELIDA_MAX)) return (0);
if ((race_def >= RACE_CNIDARIA_MIN) and (race_def <= RACE_CNIDARIA_MAX)) return (0);
if ((race_def >= RACE_JAWLESS_FISH_MIN) and (race_def <= RACE_JAWLESS_FISH_MAX)) return (0);
if ((race_def >= RACE_CARTIL_FISH_MIN) and (race_def <= RACE_CARTIL_FISH_MAX)) return (0);
if ((race_def >= RACE_BONEY_FISH_MIN) and (race_def <= RACE_BONEY_FISH_MAX)) return (0);
if ((race_def >= RACE_AMPHIBIAN_MIN) and (race_def <= RACE_AMPHIBIAN_MAX)) return (0);
if ((race_def == RACE_ALLIGATOR) or (race_def == RACE_CHAMELEON) or
    (race_def == RACE_DINOSAUR) or (race_def == RACE_LIZARD) or
    (race_def == RACE_TURTLE) or (race_def == RACE_OTHER_REPTILE)) return (0);
if (race_def == RACE_SNAKE) return (0);
if ((race_def == RACE_CRAB) or (race_def == RACE_SQUID) or
    (race_def == RACE_OCTOPUS)) return (0);
if (race_def==RACE_OYSTER) return (-1);
if ((race_def >= RACE_BIRD_MIN) and (race_def <= RACE_BIRD_MAX)) return (0);
if ((race_def >= RACE_MAMMAL_MIN) and (race_def <= RACE_MAMMAL_MAX)) return (0);
if ((race_def >= RACE_PLANT_MIN) and (race_def <= RACE_PLANT_MAX)) return (-1);
if ((race_def >= RACE_NORSE_GOD_MIN) and (race_def <= RACE_NORSE_GOD_MAX)) return (2);
if ((race_def >= RACE_DRAGON_MIN) and (race_def <= RACE_DRAGON_MAX)) return (0);
if ((race_def >= RACE_SPIRIT_MIN) and (race_def <= RACE_SPIRIT_MAX)) return (2);
if ((race_def >= RACE_LICH_MIN) and (race_def <= RACE_LICH_MAX)) return (-1);
if ((race_def >= RACE_DEMON_MIN) and (race_def <= RACE_DEMON_MAX)) return (2);
if ((race_def == RACE_HOMARID) or (race_def == RACE_MERMAID) or
    (race_def == RACE_PIXIE) or (race_def == RACE_VAMPIRE) or
    (race_def == RACE_WYRM) or (race_def == RACE_BANSHEE) or
    (race_def == RACE_DRYAD) or (race_def == RACE_NAIAD) or
    (race_def == RACE_STONE_RENDER) or (race_def == RACE_UR_VILE) or
    (race_def == RACE_SKELETON) or (race_def == RACE_YOGOLOTH) or
    (race_def == RACE_YETI) or (race_def == RACE_MERMAN) or
    (race_def == RACE_SPRITE) or (race_def == RACE_NIXIE) or
    (race_def == RACE_NYMPH) or (race_def == RACE_SATYR) or
    (race_def == RACE_FAUN) or (race_def == RACE_LEPRECHAUN) or
    (race_def == RACE_SYLPH) or (race_def == RACE_HERMIT) or
    (race_def == RACE_SHARGUGH) or (race_def == RACE_OTHER_CREATURE) or
    (race_def == RACE_OTHER_HUMANOID) or (race_def == RACE_OTHER_MAMMAL)) return (2);
if ((race_def == RACE_MINOTAUR) or (race_def == RACE_PEGASUS) or
    (race_def == RACE_WEREWOLF) or (race_def == RACE_CREEPER) or
    (race_def == RACE_UNICORN) or (race_def == RACE_GARGOYLE) or
    (race_def == RACE_CAVE_FISHER)) return (0);
if ((race_def == RACE_SAND_CRAWLER) or (race_def == RACE_DEATH_GHAST) or
    (race_def == RACE_SHADOW_BEAST) or (race_def == RACE_STATUE) or
    (race_def == RACE_MIST_DWELLER) or (race_def == RACE_MUTANT) or
    (race_def == RACE_CAVE_FISHER)) return (-1);
else return (-1);
}
dilend /* race_arms */

dilbegin string race_name(race_def : integer);
code
{
if (race_def==RACE_HUMAN)  {
  return ("a human");}
else if (race_def==RACE_ELF)  {
  return ("an elf");}
else if (race_def==RACE_DWARF)  {
return ("a dwarf");}
else if (race_def==RACE_HALFLING)  {
  return ("a halfling");}
else if (race_def==RACE_GNOME)  {
  return ("a gnome");}
else if (race_def==RACE_HALF_ORC)  {
  return ("a half-orc");}
else if (race_def==RACE_HALF_OGRE)  {
  return ("a half-ogre");}
else if (race_def==RACE_HALF_ELF)  {
  return ("a half-elf");}
else if (race_def==RACE_BROWNIE)  {
  return ("a brownie");}
else if (race_def==RACE_GROLL)  {
  return ("a groll");}
else if (race_def==RACE_DARK_ELF)  {
  return ("a darkelf");}
else if (race_def==RACE_SKAVEN)  {
  return ("a skaven");}
else if (race_def==RACE_GOBLIN)  {
  return ("a goblin");}
else if (race_def==RACE_HOBGOBLIN)  {
  return ("a hobgoblin");}
else if (race_def==RACE_KOBOLD)  {
  return ("a kobold");}
else if (race_def==RACE_NIXIE)  {
  return ("a nixie");}
else if (race_def==RACE_NYMPH)  {
  return ("a nymph");}
else if (race_def==RACE_OGRE)  {
  return ("an ogre");}
else if (race_def==RACE_ORC)  {
  return ("an orc");}
else if (race_def==RACE_SATYR)  {
  return ("a satyr");}
else if (race_def==RACE_FAUN)  {
  return ("a faun");}
else if (race_def==RACE_SPRITE)  {
  return ("a sprite");}
else if (race_def==RACE_DRYAD)  {
return ("a dryad");}
else if (race_def==RACE_LEPRECHAUN)  {
return ("a leprechaun");}
else if (race_def==RACE_PIXIE)  {
return ("a pixie");}
else if (race_def==RACE_SYLPH)  {
return ("a sylph");}
else if (race_def==RACE_HERMIT)  {
return ("a hermit");}
else if (race_def==RACE_SHARGUGH)  {
return ("a shargugh");}
else if (race_def==RACE_GIANT)  {
return ("a giant");}
else if (race_def==RACE_TROLL)  {
return ("a troll");}
else if (race_def==RACE_NORSE_GOD)  {
return ("a norse god");}
else if (race_def==RACE_MERMAID)  {
return ("a mermaid");}
else if (race_def==RACE_NAIAD)  {
return ("a naiad");}
else if (race_def==RACE_MERMAN)  {
return ("a merman");}
else if (race_def==RACE_MINOTAUR)  {
return ("a minotaur");}
else if (race_def==RACE_YETI)  {
return ("a yeti");}
else if (race_def==RACE_OTHER_HUMANOID)  {
return ("some humanoid creature");}
else if (race_def==RACE_BEAR)  {
return ("a bear");}
else if (race_def==RACE_DOG)  {
return ("a dog");}
else if (race_def==RACE_WOLF)  {
return ("a wolf");}
else if (race_def==RACE_FOX)  {
return ("a fox");}
else if (race_def==RACE_CAT)  {
return ("a cat");}
else if (race_def==RACE_RABBIT)  {
return ("a rabbit");}
else if (race_def==RACE_DEER)  {
return ("a deer");}
else if (race_def==RACE_COW)  {
return ("a cow");}
else if (race_def==RACE_GOAT)  {
return ("a goat");}
else if (race_def==RACE_EAGLE)  {
return ("an eagle");}
else if (race_def==RACE_PIG)  {
return ("a pig");}
else if (race_def==RACE_DUCK)  {
return ("a duck");}
else if (race_def==RACE_BIRD)  {
return ("a bird");}
else if (race_def==RACE_RAT)  {
return ("a rat");}
else if (race_def==RACE_HORSE)  {
return ("a horse");}
else if (race_def==RACE_BADGER)  {
return ("a badger");}
else if (race_def==RACE_SKUNK)  {
return ("a skunk");}
else if (race_def==RACE_BOAR)  {
return ("a boar");}
else if (race_def==RACE_MOUSE)  {
return ("a mouse");}
else if (race_def==RACE_MONKEY)  {
return ("a monkey");}
else if (race_def==RACE_PORCUPINE)  {
  return ("a porcupine");}
else if (race_def==RACE_ELEPHANT)  {
return ("an elephant");}
else if (race_def==RACE_CAMEL)  {
return ("a camel");}
else if (race_def==RACE_FERRET)  {
return ("a ferret");}
else if (race_def==RACE_VULTURE)  {
return ("a vulture");}
else if (race_def==RACE_SQUIRREL)  {
return ("a squirrel");}
else if (race_def==RACE_OWL)  {
return ("an owl");}
else if (race_def==RACE_ELK)  {
return ("an elk");}
else if (race_def==RACE_LION)  {
return ("a lion");}
else if (race_def==RACE_TIGER)  {
return ("a tiger");}
else if (race_def==RACE_LEOPARD)  {
return ("a leopard");}
else if (race_def==RACE_OTHER_MAMMAL)  {
return ("some kind of mammal");}
else if (race_def==RACE_TREE)  {
  return ("a tree");}
else if (race_def==RACE_VINE)  {
return ("a vine");}
else if (race_def==RACE_FLOWER)  {
return ("a flower");}
else if (race_def==RACE_SEAWEED)  {
return ("some seaweed");}
else if (race_def==RACE_CACTUS)  {
return ("a cactus");}
else if (race_def==RACE_OTHER_PLANT)  {
return ("some kind of plant");}
else if (race_def==RACE_MAGGOT)  {
return ("a maggot");}
else if (race_def==RACE_BEETLE)  {
return ("a beetle");}
else if (race_def==RACE_SPIDER)  {
return ("a spider");}
else if (race_def==RACE_COCKROACH)  {
return ("a cockroach");}
else if (race_def==RACE_BUTTERFLY)  {
return ("a butterfly");}
else if (race_def==RACE_ANT)  {
return ("an ant");}
else if (race_def==RACE_WORM)  {
return ("a worm");}
else if (race_def==RACE_LEECH)  {
return ("a leech");}
else if (race_def==RACE_DRAGONFLY)  {
return ("a dragonfly");}
else if (race_def==RACE_MOSQUITO)  {
return ("a mosquito");}
else if (race_def==RACE_INSECT)  {
return ("some kind of insect");}
else if (race_def==RACE_LIZARD)  {
return ("a lizard");}
else if (race_def==RACE_SNAKE)  {
return ("a snake");}
else if (race_def==RACE_FROG)  {
return ("a frog");}
else if (race_def==RACE_ALLIGATOR)  {
return ("an alligator");}
else if (race_def==RACE_DINOSAUR)  {
return ("a dinosaur");}
else if (race_def==RACE_CHAMELEON)  {
return ("a chameleon");}
else if (race_def==RACE_SCORPION)  {
return ("a scorpion");}
else if (race_def==RACE_TURTLE)  {
return ("a turtle");}
else if (race_def==RACE_BAT)  {
return ("a bat");}
else if (race_def==RACE_TOAD)  {
return ("a toad");}
else if (race_def==RACE_OTHER_REPTILE)  {
return ("some kind of reptile");}
else if (race_def==RACE_UR_VILE)  {
return ("an ur-vile");}
else if (race_def==RACE_STONE_RENDER)  {
return ("a stone render");}
else if (race_def==RACE_VAMPIRE)  {
return ("a vampire");}
else if (race_def==RACE_SLIME)  {
return ("a slime");}
else if (race_def==RACE_WYRM)  {
return ("a wyrm");}
else if (race_def==RACE_UNICORN)  {
return ("a unicorn");}
else if (race_def==RACE_DRAGON_MIN)  {
return ("a dragon");}
else if (race_def==RACE_DRAGON_BLACK)  {
return ("a black dragon");}
else if (race_def==RACE_DRAGON_BLUE)  {
return ("a blue dragon");}
else if (race_def==RACE_DRAGON_GREEN)  {
return ("a green dragon");}
else if (race_def==RACE_DRAGON_RED)  {
return ("a red dragon");}
else if (race_def==RACE_DRAGON_WHITE)  {
return ("a white dragon");}
else if (race_def==RACE_DRAGON_SILVER)  {
return ("a silver dragon");}
else if (race_def==RACE_DRAGON_TURTLE)  {
return ("a dragon turtle");}
else if (race_def==RACE_DRAGON_LAVA)  {
return ("a lava dragon");}
else if (race_def==RACE_DRAGON_SHADOW)  {
return ("a shadow dragon");}
else if (race_def==RACE_DRAGON_LIZARD)  {
return ("a lizard dragon");}
else if (race_def==RACE_LESSER_DEMON)  {
return ("a lesser demon");}
else if (race_def==RACE_GREATER_DEMON)  {
return ("a greater demon");}
else if (race_def==RACE_LESSER_DEVIL)  {
return ("a lesser devil");}
else if (race_def==RACE_GREATER_DEVIL)  {
return ("a greater devil");}
else if (race_def==RACE_SHADOW_DEVIL)  {
return ("a shadow devil");}
else if (race_def==RACE_GARGOYLE)  {
return ("a gargoyle");}
else if (race_def==RACE_GOLEM)  {
return ("a golem");}
else if (race_def==RACE_YOGOLOTH)  {
return ("a yogoloth");}
else if (race_def==RACE_MIST_DWELLER)  {
return ("a mist dweller");}
else if (race_def==RACE_WEREWOLF)  {
return ("a werewolf");}
else if (race_def==RACE_WERERAT)  {
return ("a wererat");}
else if (race_def==RACE_ELEMENTAL_AIR)  {
return ("an air elemental");}
else if (race_def==RACE_ELEMENTAL_EARTH)  {
return ("an earth elemental");}
else if (race_def==RACE_ELEMENTAL_FIRE)  {
return ("a fire elemental");}
else if (race_def==RACE_ELEMENTAL_FROST)  {
return ("a frost elemental");}
else if (race_def==RACE_ELEMENTAL_WATER)  {
return ("a water elemental");}
else if (race_def==RACE_ELEMENTAL_LIGHT)  {
return ("an elemental of light");}
else if (race_def==RACE_FAMILIAR)  {
return ("a familiar");}
else if (race_def==RACE_OTHER_CREATURE)  {
return ("some kind of creature");}
else if (race_def==RACE_ZOMBIE)  {
return ("a zombie");}
else if (race_def==RACE_GHOUL)  {
return ("a ghoul");}
else if (race_def==RACE_SKELETON)  {
return ("a skeleton");}
else if (race_def==RACE_GHOST)  {
return ("a ghost");}
else if (race_def==RACE_SPIRIT)  {
return ("a spirit");}
else if (race_def==RACE_MUMMIE)  {
return ("a mummie");}
else if (race_def==RACE_BANSHEE)  {
return ("a banshee");}
else if (race_def==RACE_UNDEAD)  {
return ("some kind of undead creature");}
else if (race_def==RACE_CRAB)  {
return ("a crab");}
else if (race_def==RACE_SEA_HORSE)  {
return ("a sea horse");}
else if (race_def==RACE_SHARK)  {
return ("a shark");}
else if (race_def==RACE_MANTA_RAY)  {
return ("a manta ray");}
else if (race_def==RACE_OYSTER)  {
return ("an oyster");}
else if (race_def==RACE_CAVE_FISHER)  {
return ("a cave fisher");}
else if (race_def==RACE_OCTOPUS)  {
return ("an octopus");}
else if (race_def==RACE_WHALE)  {
return ("a whale");}
else if (race_def==RACE_DOLPHIN)  {
return ("a dolphin");}
else if (race_def==RACE_EEL)  {
return ("an eel");}
else if (race_def==RACE_MINNOW)  {
return ("a minnow");}
else if (race_def==RACE_KINGRAITH)  {
return ("a kingraith");}
else if (race_def==RACE_DRACONIAN)  {
return ("a draconian");}
else if (race_def==RACE_TANNARI)  {
return ("a tannari");}
else if (race_def==RACE_DROW)  {
return ("a drow");}
else if (race_def==RACE_BEE)  {
return ("a bee");}
else if (race_def==RACE_MANTIS)  {
return ("a mantis");}
else if (race_def==RACE_TRIPHID)  {
return ("a triphid");}
else if (race_def==RACE_JELLYFISH)  {
return ("a jellyfish");}
else if (race_def==RACE_PIRANHA)  {
return ("a piranha");}
else if (race_def==RACE_BARACUDA)  {
return ("a baracuda");}
else if (race_def==RACE_CROCODILE)  {
return ("a crocodile");}
else if (race_def==RACE_SQUID)  {
return ("a squid");}
else if (race_def==RACE_OCTOPUS)  {
return ("a octopus");}
else if (race_def==RACE_CHICKEN)  {
return ("a chicken");}
else if (race_def==RACE_GOOSE)  {
return ("a goose");}
else if (race_def==RACE_PIGEON)  {
return ("a pigeon");}
else if (race_def==RACE_PEACOCK)  {
return ("a peacock");}
else if (race_def==RACE_OSTRICH)  {
return ("a ostrich");}
else if (race_def==RACE_SEAGULL)  {
return ("a seagull");}
else if (race_def==RACE_SWAN)  {
return ("a swan");}
else if (race_def==RACE_TURKEY)  {
return ("a turkey");}
else if (race_def==RACE_BEAVER)  {
return ("a beaver");}
else if (race_def==RACE_CHIPMUNK)  {
return ("a chipmunk");}
else if (race_def==RACE_HAMSTER)  {
return ("a hamster");}
else if (race_def==RACE_LLAMA)  {
return ("a llama");}
else if (race_def==RACE_MOLE)  {
return ("a mole");}
else if (race_def==RACE_MOOSE)  {
return ("a moose");}
else if (race_def==RACE_MOUNTAIN_LION)  {
return ("a mountain lion");}
else if (race_def==RACE_RACCOON)  {
return ("a raccoon");}
else if (race_def==RACE_RHINO)  {
return ("a rhinoceros");}
else if (race_def==RACE_SEAL)  {
return ("a seal");}
else if (race_def==RACE_SHEEP)  {
return ("a sheep");}
else if (race_def==RACE_SLOTH)  {
return ("a sloth");}
else if (race_def==RACE_WALRUS)  {
return ("a walrus");}
else if (race_def==RACE_WEASLE)  {
return ("a weasle");}
else if (race_def==RACE_WARTHOG)  {
return ("a warthog");}
else if (race_def==RACE_TUMBLEWEED)  {
return ("a tumbleweed");}
else if (race_def==RACE_PEPPER)  {
return ("a pepper");}
else if (race_def==RACE_RASPBERRY)  {
return ("a raspberry");}
else if (race_def==RACE_CARROT)  {
return ("a carrot");}
else if (race_def==RACE_BLUEBERRY)  {
return ("a blueberry");}
else if (race_def==RACE_LOSKA)  {
return ("a loska");}
else if (race_def==RACE_PUMPKIN)  {
return ("a pumpkin");}
else if (race_def==RACE_BEAN)  {
return ("a bean");}
else if (race_def==RACE_STRAWBERRY)  {
return ("a strawberry");}
else if (race_def==RACE_POTATO)  {
return ("a potato");}
else if (race_def==RACE_TOMATO)  {
return ("a tomato");}
else if (race_def==RACE_CABBAGE)  {
return ("a cabbage");}
else if (race_def==RACE_LETTUCE)  {
return ("a lettuce");}
else if (race_def==RACE_WHEAT)  {
return ("a wheat");}
else if (race_def==RACE_CORN)  {
return ("a corn");}
else if (race_def==RACE_ACIDPLANT)  {
return ("a strange plant");}
else if (race_def==RACE_PLANT_GROW)  {
return ("a odd plant");}
else if (race_def==RACE_NORSE_GOD_AIR)  {
return ("a norse god");}
else if (race_def==RACE_NORSE_GOD_EARTH)  {
return ("a norse god");}
else if (race_def==RACE_NORSE_GOD_FIRE)  {
return ("a norse god");}
else if (race_def==RACE_NORSE_GOD_FROST)  {
return ("a norse god");}
else if (race_def==RACE_NORSE_GOD_LIGHT)  {
return ("a norse god");}
else if (race_def==RACE_NORSE_GOD_WATER)  {
return ("a norse god");}
else if (race_def==RACE_NORSE_GOD_DARKNESS)  {
return ("a norse god");}
else if (race_def==RACE_LICH_AIR)  {
return ("a lich");}
else if (race_def==RACE_LICH_EARTH)  {
return ("a lich");}
else if (race_def==RACE_LICH_FIRE)  {
return ("a lich");}
else if (race_def==RACE_LICH_FROST)  {
return ("a lich");}
else if (race_def==RACE_LICH_LIGHT)  {
return ("a lich");}
else if (race_def==RACE_LICH_WATER)  {
return ("a lich");}
else if (race_def==RACE_PEGASUS)  {
return ("a pegasus");}
else if (race_def==RACE_SAND_CRAWLER)  {
return ("a sand crawler");}
else if (race_def==RACE_DEATH_GHAST)  {
return ("a death ghast");}
else if (race_def==RACE_SHADOW_BEAST)  {
return ("a shadow beast");}
else if (race_def==RACE_CREEPER)  {
return ("a creeper");}
else if (race_def==RACE_STATUE)  {
return ("a statue");}
else if (race_def==RACE_MUTANT)  {
return ("a mutant");}
else if (race_def==RACE_CAVE_FISHER)  {
return ("a cave fisher");}
return ("some creature");
}
dilend /* race_name */


/* Eirinn Oct 1997 - This dil is the butcher skill. The last 2 dils above
   were coded for it too. */

dilbegin butcher(arg : string);

external
   integer skillresist@skills(aa : integer, ad : integer,
                             sa : integer, sd : integer);
   integer race_legs (race_def : integer);
   integer race_arms (race_def : integer);
   string race_name (race_def : integer);
   integer skillchecksa@skills(skillidx : integer, abiidx : integer, difficulty : integer);

var
   targ    : unitptr;
   wpn     : unitptr;
   unit1   : unitptr;
   arms    : integer;
   legs    : integer;
   hm      : integer;
   behead  : integer;
   i : integer;
   typec   : string;
   bw      : integer; /* Base weight unit */
   nleg    : integer; /* Number of legs */
   narm    : integer; /* Number of arms */
   nsteak  : integer; /* Number of steaks */
   nscraps : integer; /* Number of scraps */
   nfillet : integer; /* Number of fillets */
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;

code
{
   behead := 0;
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_BUTCHER] <= 0))
   {
      act("You must practice first.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   if (self.position==POSITION_FIGHTING)
   {
      act ("I seriously doubt you have time for that right now!",
            A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   if (arg=="")
   {
      act ("Butcher what?",
           A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   targ:=findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ==null) or not visible(self, targ))
   {
      act ("There is nothing like that to butcher here.",
           A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   if ((targ.nameidx+"@"+targ.zoneidx)!="corpse@death")

   {
      act ("You can't butcher that stupid!",
           A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   if ("$butchered" in targ.extra)
   {
      act ("That has already been butchered.",
           A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   if (not("$skinned" in targ.extra))
   {
      act ("You should skin it first silly!",
           A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   if (targ.weight <= 1)
   {
      act ("That's too small to butcher!",
           A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   arms := race_arms(targ.value[4]);
   legs := race_legs(targ.value[4]);
   typec := race_name(targ.value[4]);

   if ((arms == -1) or (legs == -1))
   {
      act ("That $2N can not be butchered.",
           A_ALWAYS, self, targ, null, TO_CHAR);
      quit;
   }

   secure(targ, lost_targ);

   wpn := self.inside;

   while (wpn)
   {
      if (wpn.objecttype == ITEM_WEAPON) 
         if (wpn.value[0] == WPN_DAGGER)
            goto gotknife;
      wpn := wpn.next;
   }

   act("You need a knife to butcher $3n.", A_SOMEONE, self, null, targ, TO_CHAR);
   quit;

   :gotknife:

   i := targ.value[3];  // The level is the difficulty.

   if (targ.value[3] > self.level)
      i := i - (self.level - targ.value[3]) * 5; // 5 more difficult per level difference ( - - = + )

   hm := skillchecksa(SKI_BUTCHER, ABIL_DEX, i);

  if ("beheaded" in targ.outside_descr) behead := 1;

  bw := targ.weight / 9;

   if (self.endurance < bw)
   {
      act ("You are too tired to butcher anything right now.",
           A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

  if (bw < 2) bw := -1;

  if ((legs >= 0) and (legs <= 8)) nleg := legs;
  else nleg := 0;

  if ((arms >=0) and (arms <=8)) narm := arms;
  else narm := 0;

  nscraps := bw / 5;
  if (nscraps < 1) nscraps := 1;

  nsteak := (bw) / 10;
  if (nsteak < 1) nsteak := 0;

  nfillet := 0; /* Just a safety value */

  if (legs == 9) /*crabs*/
  {
     nscraps := nscraps + nsteak;
     nsteak := 0;
  }

  if (legs == 10) /* Fish */
  {
     nfillet := nsteak;
     nsteak := 0;
  }

  if (hm <= 0)
  {
     act("You make a mess of butchering the corpse!",
         A_ALWAYS, self, null, null, TO_CHAR);
     act("$1n makes a mess of butchering the $3N!",
         A_ALWAYS, self, null, targ, TO_REST);
     if (behead == 1)
     {
        targ.title := "a poorly butchered beheaded corpse of " + typec;
        targ.outside_descr := "A poorly butchered beheaded corpse of " +
                              typec + " is " + "lying here rotting.";
     }
     else
     {
        targ.title := "a poorly butchered corpse of " + typec;
        targ.outside_descr := "A poorly butchered corpse of " + typec + " is " +
                              "lying here rotting.";
     }
     addextra(targ.extra, {"$butchered"}, itoa(targ.value[4]));
     unit1 := load("scraps_template@skills");
     link(unit1, self.outside);
     addstring(unit1.names, "Some scraps of " + typec);
     addstring(unit1.names, "meat");
     addstring(unit1.names, "scraps");
     addstring(unit1.names, "scrap");
     unit1.title := "some scraps of " + typec + " meat";
     unit1.outside_descr := "Some scraps of meat from " + typec +
                            " have been left here.";

     setweight(targ, targ.weight - bw);

     if (bw > 0)
        self.endurance := self.endurance - (bw * 2);
     else
        self.endurance := self.endurance - 2;

     if (legs == 5) destroy(targ);
     goto done;
  }

  if ((hm <= -10) and (bw != -1))
  {
     act("You butcher the $3N and leave a small amount of meat.",
         A_ALWAYS, self, null, targ, TO_CHAR);
     act("$1n butchers the $3N and leaves a small amount of meat.",
         A_ALWAYS, self, null, targ, TO_REST);

     if (behead == 1)
     {
        targ.title := "a butchered beheaded carcass of " + typec;
        targ.outside_descr := "A butchered beheaded carcass of " + typec +
                              " is lying here rotting.";
        substring(targ.names, "corpse");
        addstring(targ.names, "headless carcass");
        addstring(targ.names, "carcass");
        addstring(targ.names, "corpse");
     }
     else
     {
        targ.title := "a butchered carcass of " + typec;
        targ.outside_descr := "A butchered carcass of " + typec + " is " +
                              "lying here rotting.";
        substring(targ.names, "corpse");
        addstring(targ.names, "carcass");
        addstring(targ.names, "corpse");
     }
     addextra(targ.extra, {"$butchered"}, itoa(targ.value[4]));

     if (nleg > 1)
     {
        nleg := nleg / 2;
        while (nleg > 0)
        {
           unit1 := load("leg_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "leg of " + typec);
           addstring(unit1.names, "leg");
           unit1.title := "the leg of " + typec;
           unit1.outside_descr := "A leg of " + typec + " has been " +
                                  "discarded here.";
           setweight(unit1, targ.weight / 7);
           unit1 := null;
           nleg := nleg - 1;
        }
     }

     if (narm > 1)
     {
        narm := narm / 2;
        while (narm > 0)
        {
           unit1 := load("arm_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "arm of " + typec);
           addstring(unit1.names, "arm");
           unit1.title := "the arm of " + typec;
           unit1.outside_descr := "An arm of " + typec + " has been " +
                                  "left here.";
           setweight(unit1, targ.weight / 8);
           unit1 := null;
           narm := narm - 1;
        }
     }

     if (nsteak > 1)
     {
        nsteak := nsteak / 2;
        while (nsteak > 0)
        {
           unit1 := load("steak_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "steak of " + typec);
           addstring(unit1.names, "steak");
           unit1.title := "a juicy steak";
           unit1.outside_descr := "A juicy steak from " + typec + " has been " +
                                  "dropped here.";
           unit1 := null;
           nsteak := nsteak - 1;
        }
     }

     if (nscraps > 1)
     {
        nscraps := nscraps / 2;
        while (nscraps > 0)
        {
           unit1 := load("scraps_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "Some scraps of " + typec);
           addstring(unit1.names, "meat");
           addstring(unit1.names, "scraps");
           addstring(unit1.names, "scrap");
           unit1.title := "some scraps of " + typec + " meat";
           unit1.outside_descr := "Some scraps of meat from " + typec +
                                  " have been left here.";
           unit1 := null;
           nscraps := nscraps - 1;
        }
     }

     if (nfillet > 1)
     {
        nfillet := nfillet / 2;
        while (nfillet > 0)
        {
           unit1 := load("fillet_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "fillet of " + typec);
           addstring(unit1.names, "fillet");
           unit1.title := "a fillet of " + typec;
           unit1.outside_descr := "A fillet of " + typec + " has been " +
                                  "dropped on the ground here.";
           unit1 := null;
           nfillet := nfillet - 1;
        }
     }

     setweight(targ, targ.weight - (5 * bw));

     if (bw > 0)
        self.endurance := self.endurance - (bw * 2);
     else
        self.endurance := self.endurance - 2;

     goto done;
  }

  if ((bw == -1) and (hm <= -10))
  {
     act("$3N is so small that you only get a small amount of meat " +
         "from it.",
         A_ALWAYS, self, null, targ, TO_CHAR);
     act("$1n butchers the $3N and leaves a small amount of meat.",
         A_ALWAYS, self, null, targ, TO_REST);

     if (behead == 1)
     {
        targ.title := "a butchered beheaded carcass of " + typec;
        targ.outside_descr := "A butchered beheaded carcass of " +
                              typec + " is " + "lying here rotting.";
        substring(targ.names, "corpse");
        addstring(targ.names, "headless carcass");
        addstring(targ.names, "carcass");
        addstring(targ.names, "corpse");
     }
     else
     {
        targ.title := "a butchered carcass of " + typec;
        targ.outside_descr := "A butchered carcass of " + typec + " is " +
                              "lying here rotting.";
        substring(targ.names, "corpse");
        addstring(targ.names, "carcass");
        addstring(targ.names, "corpse");
     }
     addextra(targ.extra, {"$butchered"}, itoa(targ.value[4]));

     unit1 := load("scraps_template@skills");
     link(unit1, self.outside);
     setweight(unit1, targ.weight - bw);

     if (bw > 0)
        self.endurance := self.endurance - (bw * 2);
     else
        self.endurance := self.endurance - 2;

     goto done;
  }


  if ((hm > -10) and (bw != -1))
  {
     act("You butcher the $3N and leave a large amount of meat.",
         A_ALWAYS, self, null, targ, TO_CHAR);
     act("$1n butchers the $3N and leaves a large amount of meat.",
         A_ALWAYS, self, null, targ, TO_REST);

     if (behead == 1)
     {
        targ.title := "the headless bones of " + typec;
        targ.outside_descr := "The headless bones of " + typec + " are lying " +
                              "around on the ground here.";
        substring(targ.names, "corpse");
        addstring(targ.names, "headless bones");
        addstring(targ.names, "bones");
        addstring(targ.names, "skeleton");
        addstring(targ.names, "corpse");
     }
     else
     {
        targ.title := "the bones of " + typec;
        targ.outside_descr := "The bones of " + typec + " are " +
                              "scattered around here.";
        substring(targ.names, "corpse");
        addstring(targ.names, "bones");
        addstring(targ.names, "skeleton");
        addstring(targ.names, "corpse");
     }
     addextra(targ.extra, {"$butchered"}, itoa(targ.value[4]));

     if (nleg > 1)
     {
        while (nleg > 0)
        {
           unit1 := load("leg_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "leg of " + typec);
           addstring(unit1.names, "leg");
           unit1.title := "the leg of " + typec;
           unit1.outside_descr := "A leg of " + typec + " has been " +
                                  "discarded here.";
           unit1 := null;
           nleg := nleg - 1;
        }
     }

     if (narm > 1)
     {
        while (narm > 0)
        {
           unit1 := load("arm_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "arm of " + typec);
           addstring(unit1.names, "arm");
           unit1.title := "the arm of " + typec;
           unit1.outside_descr := "An arm of " + typec + " has been " +
                                  "left here.";
           unit1 := null;
           narm := narm - 1;
        }
     }

     if (nsteak > 1)
     {
        while (nsteak > 0)
        {
           unit1 := load("steak_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "steak of " + typec);
           addstring(unit1.names, "steak");
           unit1.title := "a juicy steak";
           unit1.outside_descr := "A juicy steak from " + typec + " has been " +
                                  "dropped here.";
           unit1 := null;
           nsteak := nsteak - 1;
        }
     }

     if (nscraps > 1)
     {
        while (nscraps > 0)
        {
           unit1 := load("scraps_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "Some scraps of " + typec);
           addstring(unit1.names, "meat");
           addstring(unit1.names, "scraps");
           addstring(unit1.names, "scrap");
           unit1.title := "some scraps of " + typec + " meat";
           unit1.outside_descr := "Some scraps of meat from " + typec +
                                  " have been left here.";
           unit1 := null;
           nscraps := nscraps - 1;
        }
     }

     if (nfillet > 1)
     {
        while (nfillet > 0)
        {
           unit1 := load("fillet_template@skills");
           link(unit1, self.outside);
           addstring(unit1.names, "fillet of " + typec);
           addstring(unit1.names, "fillet");
           unit1.title := "a fillet of " + typec;
           unit1.outside_descr := "A fillet of " + typec + " has been " +
                                  "dropped on the ground here.";
           unit1 := null;
           nfillet := nfillet - 1;
        }
     }

     setweight(targ, targ.weight - (5 * bw));

     if (bw > 0)
        self.endurance := self.endurance - (bw * 2);
     else
        self.endurance := self.endurance - 2;

     if (legs == 5)
     {
        destroy (targ); /* Crabs don't have skeletons */
     }
     goto done;
  }

  if ((bw == -1) and (hm > -10))
  {
     act("$3N is so small that you only get a small amount of meat " +
         "from it.",
         A_ALWAYS, self, null, targ, TO_CHAR);
     act("$1n butchers the $3N and leaves a small amount of meat.",
         A_ALWAYS, self, null, targ, TO_REST);

     if (behead == 1)
     {
        targ.title := "the headless bones of " + typec;
        targ.outside_descr := "The headless bones of " + typec + " are lying " +
                              "around on the ground here.";
        substring(targ.names, "corpse");
        addstring(targ.names, "headless bones");
        addstring(targ.names, "bones");
        addstring(targ.names, "skeleton");
        addstring(targ.names, "corpse");
     }
     else
     {
        targ.title := "the bones of " + typec;
        targ.outside_descr := "The bones of " + typec + " are " +
                              "scattered around here.";
        substring(targ.names, "corpse");
        addstring(targ.names, "bones");
        addstring(targ.names, "skeleton");
        addstring(targ.names, "corpse");
     }

     unit1 := load("scraps_template@skills");
     link(unit1, self.outside);
     setweight(targ, 4);

     if (bw > 0)
        self.endurance := self.endurance - (bw * 2);
     else
        self.endurance := self.endurance - 2;

     if (legs == 5) destroy(targ);
     goto done;
  }


:done:
position_update (self);
unsecure(targ);
quit;

:lost_targ:
unsecure(targ);
quit;
}
dilend /* Butcher */



/* Rangers January 1998 - The following skills were written by (people
   listed by increasing amount of work contributed): Javelin, Jager,
   Drevar, Whistler, Saor, Eirinn and Ratlin. */

dilbegin throw (arg : string); /* The throw skill */

external
   integer skillresist@skills(aa : integer, ad : integer, sa : integer,
                             sd : integer);

var
wp_info:intlist;
wielded:unitptr;
   held         : unitptr;  /* And what about that other handy... */
   thing        : unitptr;  /* Well I guess this is our missile. */
   targ         : unitptr;  /* Hewo wabbit. */

   cost_of      : integer;  /* Endurance cost. */
   bonus        : integer;  /* For meleedamage. */
   sharpness    : integer;  /* Approximate sharpness of non-weapons. */
   miss         : integer;
   mdam         : integer;  /* Damage the missile takes from the fight */
   hm           : integer;  /* For skillresist */
   dead_jim     : integer;  /* did we kill it? huh huh? */

   tstr         : string;   /* Temporary string for processing argument. */
   tstr2        : string;   /* For corpses */
   thing_name   : string;   /* In case we ever forget what we're throing. */
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;

code
{
   heartbeat := 2;
   miss := 0; /* We hit until we're told differently. */
   bonus := -20;

   if (self.position < POSITION_STANDING)
   {
      act("You need to be standing to do that.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   thing := findunit(self, arg, FIND_UNIT_IN_ME, null);

   if ((thing == null) or not visible(self, thing))
   {
      act("You can't find that in your inventory or your equipment!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (thing.type==UNIT_ST_NPC)
   {
   act ("$1e would not like that.",
   A_ALWAYS,self,null,null,TO_CHAR);
   quit;
   }

if (thing.type!=UNIT_ST_OBJ)
   {
      act("You can't find that in your inventory or your equipment!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   thing_name := thing.name;

   if (thing.objecttype != ITEM_WEAPON)
   {
      act("Why bother throwing that?! Throw a weapon instead!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }



   if ((thing.value[0] == WPN_BOW) or (thing.value[0] == WPN_CROSSBOW) or
       (thing.value[0] == WPN_SLING))
       {
       act ("You would do better using those correctly than throwing them like a nut case.",
       A_ALWAYS,self,null,null,TO_CHAR);
       quit;
       }


wp_info:=weapon_info(thing.value[0]);
   wielded := equipment(self, WEAR_WIELD);
   held    := equipment(self, WEAR_HOLD);

if (wp_info.[0]>1)
{
if ((wielded!=self) and
(held!=self))
       if ((wielded!=null) or (held!=null))
       {
                           act ("You need both hands free to throw that.",
                           A_ALWAYS,self,null,null,TO_CHAR);
                           quit;
       }
}
else
{
if ((wielded!=self) and
(held!=self))
if ((wielded!=null) and (held!=null))
{
act ("You need at least one free hand to throw that.",
A_ALWAYS,self,null,null,TO_CHAR);
}
}

   tstr := getword(arg);

   if (tstr == "at")
      tstr := arg;

   else if (tstr == "")
   {
      act("What do you want to throw that at?",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   else
      tstr := tstr + " " + arg;

   targ := findunit(self, tstr, FIND_UNIT_SURRO, null);

   if ((targ == null) or (not(visible(self, targ))))
   {
      act("You don't see that person here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("Yeah, take your frustration out on that poor inanimate " +
          "object! Hit it, yeah!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if ((targ.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
   {
      if (not(isset (self.pcflags, PC_PK_RELAXED)))
      {
         act("You are not allowed to do that unless you sign " +
             "the book of blood.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      if (not(isset (targ.pcflags, PC_PK_RELAXED)))
      {
         act("You are not allowed to do that unless $2e signs " +
             "the book of blood.",
             A_ALWAYS, self, targ, null, TO_CHAR);
         quit;
      }
   }

   wielded := equipment(self, WEAR_WIELD);
   held    := equipment(self, WEAR_HOLD);

/* This doesn't seem to work, but later in the dil something takes care
of the case in which you're wielding a weapon.. */

   if ((wielded != null) and (held != null) and ((thing != wielded) and
                                                 (thing != held)))
   {
      act("Your hands are full! How do you expect to throw something " +
          "if you don't have a free hand (or aren't throwing what's in " +
          "your hand) ?!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   cost_of := (rnd(20,30) * thing.weight) / 25;

   if (self.endurance < cost_of)
   {
      act("You simply don't have the energy to throw that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   /* DISABLED..Since we can only use meleedamage with Weapons, it's time to
      distinguish item types so we know which way to go. */

/*
   if (thing.objecttype == ITEM_WEAPON) goto is_weapon;
   else goto is_other;
*/


:is_weapon:

/* In a previous version, all targets were assumed having skills,
which caused the mobs to be easier to throw things at.. */

skilla := (self.abilities[ABIL_DEX] + self.abilities[ABIL_STR]/2);
skillb := (targ.abilities[ABIL_DEX] + targ.abilities[ABIL_STR]/2);

if(self.type == UNIT_ST_PC)
        skillc := self.skills[SKI_THROW];
else
            skillc := rnd(40,124);
	 /*   skillc := self.abilities[ABIL_DEX];
    */
if(targ.type == UNIT_ST_PC)
        skilld := targ.skills[SKI_THROW];
else
               skilld := rnd(40,124);
	  /*  skilld := targ.abilities[ABIL_DEX];*/

hm := skillresist(skilla,skillb,skillc,skilld);



/*
   if (targ.type == UNIT_ST_PC)
      hm := skillresist@skills((self.abilities[ABIL_DEX] +
                               self.abilities[ABIL_STR]) /2,
                               (targ.abilities[ABIL_DEX]*2)/3,
                               self.skills[SKI_THROW],
                               targ.skills[SKI_THROW] - 25);

   else
      hm := skillresist@skills((self.abilities[ABIL_DEX] +
                               self.abilities[ABIL_STR]) /2,
                               (targ.abilities[ABIL_DEX]*2)/3,
                               self.skills[SKI_THROW],
                               targ.abilities[ABIL_DEX] - 25);
*/
   if (hm < 0) goto miss;

   bonus := bonus + (self.weapons[thing.value[0]] /10);

   tstr := "";
   tstr2 := "";
   tstr := targ.name;
   if (targ.type == UNIT_ST_NPC) tstr2 := targ.title;

   dead_jim := targ.hp;

   if ((thing == held) and (wielded != null))
   {
      unequip(wielded);
      unequip(thing);
      addequip(thing, WEAR_WIELD);
      act("You throw your " + thing.name + " at $3n!",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("$1n throws $1s " + thing.name + " at you!",
          A_SOMEONE, self, null, targ, TO_VICT);
      act("$1n throw $1s " + thing.name + " at $3n!",
          A_SOMEONE, self, null, targ, TO_NOTVICT);
      bonus := meleedamage(self, targ, bonus, 0);
      unequip(thing);
      addequip(wielded, WEAR_WIELD);
   goto dispose_thing;
   }

   else if (thing == wielded)
   {
      act("You throw your " + thing.name + " at $3n!",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("$1n throws $1s " + thing.name + " at you!",
          A_SOMEONE, self, null, targ, TO_VICT);
      act("$1n throw $1s " + thing.name + " at $3n!",
          A_SOMEONE, self, null, targ, TO_NOTVICT);
      bonus := meleedamage(self, targ, bonus, 0);
      unequip(thing);
      goto dispose_thing;
   }

   else if ((wielded != null) and (thing != wielded))
   {
      unequip(wielded);
      addequip(thing, WEAR_WIELD);
      act("You throw your " + thing.name + " at $3n!",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("$1n throws $1s " + thing.name + " at you!",
          A_SOMEONE, self, null, targ, TO_VICT);
      act("$1n throw $1s " + thing.name + " at $3n!",
          A_SOMEONE, self, null, targ, TO_NOTVICT);
      bonus := meleedamage(self, targ, bonus, 0);
      unequip(thing);
      addequip(wielded, WEAR_WIELD);
      goto dispose_thing;
   }

   else
   {
      addequip(thing, WEAR_WIELD);
      act("You throw your " + thing.name + " at $3n!",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("$1n throws $1s " + thing.name + " at you!",
          A_SOMEONE, self, null, targ, TO_VICT);
      act("$1n throw $1s " + thing.name + " at $3n!",
          A_SOMEONE, self, null, targ, TO_NOTVICT);
      bonus := meleedamage(self, targ, bonus, 0);
      unequip(thing);
      goto dispose_thing;
   }

:miss:
bonus := 0;
   miss := 1;
   if (targ.position > POSITION_SLEEPING)
   {
      act("You throw your " + thing.name + " at $3n!",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("$1n throws $1s " + thing.name + " at you!",
          A_ALWAYS, self, null, targ, TO_VICT);
      act("$1n throws $1s " + thing.name + " at $3n!",
          A_SOMEONE, self, null, targ, TO_NOTVICT);

      act("$3n dodges your throw!",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("You skillfully dodge out of the path of $1n's " + thing.name +
          "!",
          A_ALWAYS, self, null, targ, TO_VICT);
      act("$1n misses as $3n skillfully dodges out of the way of $1s " +
          thing.name + ".",
          A_ALWAYS, self, null, targ, TO_NOTVICT);

      goto dispose_thing;
   }
   else
   {
      act("You throw your " + thing.name + " at $3n but miss $3m completely!",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("$1n throws $1s " + thing.name + " at $3n but misses completely!",
          A_SOMEONE, self, null, targ, TO_NOTVICT);
      goto dispose_thing;
   }


:dispose_thing:
dead_jim := dead_jim - bonus;

   if (bonus == -1)
   {
      link(thing, self.outside);
      quit;
   }
   else
   {
      mdam := rnd(0, 40 - (thing.value[1] + thing.value[2]));
      thing.hp := thing.hp - mdam;
      position_update(thing);

/*      if ((bonus > 30) and (dead_jim > -10)) link(thing, targ)
      else if ((bonus > 30) and (dead_jim == -10)) link(thing, self.outside);
      else if ((bonus >30) and (dead_jim < -10))
      {
         pause;
         thing := findunit(self, thing_name, FIND_UNIT_IN_ME, null);
         if (tstr2 == "")
         {
            tstr := "corpse of " + tstr;
            targ := findunit(self, tstr, FIND_UNIT_SURRO, null);
            if (targ == null) link(thing, self.outside);
            else link(thing, targ);
         }
         else if (tstr2 != "")
         {
            targ := findunit(self, "corpse", FIND_UNIT_SURRO, null);
            if (targ == null) link(thing, self.outside);
            else if (tstr2 in targ.outside_descr) link(thing, targ);
            else link(thing, self.outside);
         }
         else link(thing, self.outside);

      } */
      if ((bonus > 30) and (dead_jim >= -10))
        link (thing, targ);

      else if ((bonus > 30) and (dead_jim < -10))
        {
        targ := findunit(self, "corpse", FIND_UNIT_SURRO, null);

        if ((tstr2 != "") and (tstr2 in targ.outside_descr))
            link(thing, targ);
        else if ((tstr2 == "") and (tstr in targ.outside_descr))
            link (thing, targ);

        else link(thing, self.outside);
        }

      else
        link(thing, self.outside);
   }

   quit;
}
dilend /* throw */

dilbegin lay_trap (arg : string); /* Lay the trap */

var
   my_trap      : unitptr;

   pow          : integer;
   room_mod     : integer; /* Bearing the place has on chances of trapping */
   end          : integer;
   min          : integer;

   spring_self  : string;
   spring_other : string;

   expd         : extraptr;

code
{
   if (arg == "")
   {
      act("Lay what? An egg?!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "woman")
   {
      act("You're kidding right?!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.skills[SKI_LAY_TRAP] <= 0)
   {
      act("You should get some practice first.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   my_trap := findunit(self, arg, FIND_UNIT_IN_ME, null);

   if ((my_trap == null) or not visible(self, my_trap))
   {
      act("You can't find that in your inventory!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (not(my_trap.objecttype == ITEM_TRAP))
   {
      act("I don't know about you, but where I come from that's not " +
          "considered a trap.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.outside.type != UNIT_ST_ROOM)
   {
      act("You can't do that in here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if ((self.outside.movement > 7) and
            (self.outside.movement < 11))
   {
      act("You carefully drop your trap in the water. It sinks. " +
          "Now wasn't that clever?",
          A_ALWAYS, self, null, null, TO_CHAR);
      destroy(my_trap);
      quit;
   }
   else if (self.outside.movement == SECT_INSIDE)
   {
      min:=-15;
      end:=35;
      room_mod := -30;
   }
   else if (self.outside.movement == SECT_CITY)
   {
      min:=-10;
      end:=35;
      room_mod := -10;
   }
   else if (self.outside.movement == SECT_FIELD)
   {
      min:=-25;
      end:=30;
      room_mod := 10;
   }
   else if (self.outside.movement == SECT_FOREST)
   {
      min:=-25;
      end:=30;
      room_mod := 40;
   }
   else if (self.outside.movement == SECT_HILLS)
   {
      min:=-25;
      end:=30;
      room_mod := 30;
   }
   else if (self.outside.movement == SECT_MOUNTAIN)
   {
      min:=-10;
      end:=30;
      room_mod := 10;
   }
   else if (self.outside.movement == SECT_DESERT)
   {
      min:=-15;
      end:=30;
      room_mod := 50;
   }
   else if (self.outside.movement == SECT_SWAMP)
   {
      min:=-15;
      end:=30;
      room_mod := -50;
   }
   else if (self.outside.movement == SECT_SNOW)
   {
      min:=-30;
      end:=35;
      room_mod := 30;
   }
   else if (self.outside.movement == SECT_SLUSH)
   {
      min:=-15;
      end:=30;
      room_mod := 15;
   }
   else if (self.outside.movement == SECT_ICE)
   {
      min:=-10;
      end:=35;
      room_mod := -70;
   }

/* make sure we have the endurance necessary */

   if (self.endurance < end)
   {
      act("You're just too tired to lay the trap. Better get some rest.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else
      self.endurance := self.endurance - end;

   if (findunit(self, "trap", FIND_UNIT_SURRO, null) != null)
   {
      act("You get the impression as you start to lay your trap that " +
          "someone has already planted some kind of trap here - " +
          "the ground has been disturbed ever so slightly. It might " +
          "be wise to find that trap in case you trip it accidentally " +
          "first!.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   pow := ((self.abilities[ABIL_DEX]/2) + min + room_mod +
           my_trap.value[1] + my_trap.value[2] +
           (self.skills[SKI_LAY_TRAP] * 3) + self.abilities[ABIL_BRA]) / 6;

   act("You carefully lay the trap and hide it as best you can.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n carefully lays $1s trap and hides it as best $1e can.",
       A_HIDEINV, self, null, null, TO_REST);

   expd := "$spring_self" in my_trap.extra;
   if (expd)
      spring_self := expd.descr;
   else
      spring_self := "default";

   expd := "$spring_other" in my_trap.extra;
   if (expd)
      spring_other := expd.descr;
   else
      spring_other := "default";

   if (isset(self.pcflags, PC_PK_RELAXED))
      dilcopy ("trap_laid@skills(1, " + itoa(pow) + ", " + spring_self + ", " +
               spring_other + ", " + self.name + ")", my_trap);
   else
      dilcopy ("trap_laid@skills(0, " + itoa(pow) + ", " + spring_self + ", " +
               spring_other + ", " + self.name + ")", my_trap);
   link(my_trap, self.outside);

   quit;
}
dilend /* lay_trap */

dilbegin aware trap_laid(pk : integer, pow : integer, spring_self : string,
                         spring_other : string, owner : string);

var
   pc        : unitptr;
   tempu     : unitptr;

   ppl_list : stringlist;

   i         : integer;
   j         : integer;
   k         : integer;
   l         : integer;
   hm        : integer;

   tstr      : string;
   s_self    : string;
   s_other   : string;

code
{
   addstring(ppl_list, owner);
   self.minv := 51;
   heartbeat := PULSE_SEC * (pow*2 + 60);
   i := interrupt(SFB_TICK, TRUE, trap_over);
   j := interrupt(SFB_CMD, (command("search") and ("trap" in argument)),
                  search_test);
   l := interrupt(SFB_CMD, (command("disarm") and ("argument" in
                            self.names)), disarm);

   goto start;

:pre_start:
   unsecure(pc);

:start:

   wait(SFB_DONE, (activator.type == UNIT_ST_NPC) or
                   ((command("north") or command("east") or
                    command("south") or command("west") or
                    command("up") or command("down") or
                    command("look")) and (activator.type == UNIT_ST_PC)));

   if (activator.name in ppl_list)
   {
      pc := activator;
      secure(pc, pre_start);
      act("You carefully avoid the " + self.name + " here.",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto pre_start;
   }

   if (activator.level >= IMMORTAL_LEVEL) goto start;
   /* block trap spell add block here */

   if (NO_TRAP in activator.extra)
   {
    act("$1n spots a trap and dances like a ballerina around it.",
          A_SOMEONE, activator, null, null, TO_REST);
   goto start;
   }


   pc := activator;
   secure(pc, pre_start);
   if (pc.type == UNIT_ST_PC)
      hm := ((pc.abilities[ABIL_DEX] + (pc.skills[SKI_LAY_TRAP] * 3) +
             pc.abilities[ABIL_BRA]) / 6);
   else hm := (((pc.abilities[ABIL_DEX] + pc.abilities[ABIL_BRA]) * 5) / 12);

   if ((hm > pow) and (rnd(0,7) < 4))
   {
      act("You spot " + self.title + " carefully hidden here, and " +
          "narrowily avoid it.",
          A_ALWAYS, pc, null, null, TO_CHAR);
      addstring(ppl_list, pc.name);
      goto pre_start;
   }

   unsecure(pc);
:got_one:
   secure(pc, lost_trapped);

   clear(j);

   if ("default" in spring_self)
   {
      s_self := "You spring a carefully hidden " + self.name + "! " +
                     "You are trapped!";
   }
   if ("default" in spring_other)
      s_other := "$1n springs a carefully hidden " + self.name + "! ";

   tstr := pc.name;

   act(s_self,
       A_ALWAYS, pc, null, null, TO_CHAR);
   act(s_other,
       A_SOMEONE, pc, null, null, TO_REST);
   self.minv := 0;

   dilcopy("trap_spell@skills(" + pc.name + ", " + self.name + ")", pc);
   dilcopy("trap_tick@skills(" + pc.name + ", " + self.name + ")", pc);

   if (pc.type == UNIT_ST_PC)
      self.outside_descr := "A " + self.name + " has trapped " + pc.name +
                            " here!";
   else
      self.outside_descr := "A " + self.title + " has trapped " + pc.name +
                            " here!";

   j := interrupt(SFB_COM, (command(CMD_AUTO_COMBAT) and
                            (activator == pc.fighting)), fight_break);
   k := interrupt(SFB_MSG, ((getword(argument) == "checkout") and
                            (pc.name == argument)), lost_trapped);

:is_trapped:

   wait(SFB_CMD,( (not(command("look") or command("score") or
                      command("say") or command("shout") or
                      command("tell") or command("inventory") or
                      command("guild") or command("status") or
                      command("help") or command("who") or
                      command("equipment") or command("news") or
                      command("cast"))) and (activator == pc)));

   block;
   act("The " + self.name + " prevents you from doing that.",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("$1n tries to move in the " + self.name + " but can't!",
       A_ALWAYS, pc, null, null, TO_REST);

   if (((pk) and (isset(pc.pcflags, PC_PK_RELAXED))) or
       (pc.type == UNIT_ST_NPC))
   {
      act("That REALLY Hurt!!!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      act("$1n screams in dire agony!",
          A_SOMEONE, pc, null, null, TO_REST);
      pc.hp := pc.hp - rnd((pow/5), (pow/2));
      position_update(pc);
   }
   goto is_trapped;

:fight_break:
   act("The fight breaks the " + self.name + "!",
       A_SOMEONE, pc, null, null, TO_ALL);
   act("That REALLY Hurt!!!",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("$1n screams in dire agony!",
       A_SOMEONE, pc, null, null, TO_REST);
   pc.hp := pc.hp - rnd((pow/5), (pow/2));
   position_update(pc);

   goto trap_over1;

:disarm:
   block;
   tempu := activator;
   hm := ((tempu.abilities[ABIL_DEX] + (tempu.skills[SKI_LAY_TRAP] * 3) +
          tempu.abilities[ABIL_BRA]) / 6) + 50;
   if (hm > pow)
   {
      addstring(ppl_list, pc.name);
      act("You disarm the trap.",
          A_ALWAYS, tempu, null, null, TO_CHAR);
      act("$1n disarms a " + self.name + " which was carefully hidden " +
          "here.",
          A_ALWAYS, tempu, null, null, TO_REST);
      goto trap_over1;
   }
   else
   {
      act("Your hand slips!",
          A_ALWAYS, tempu, null, null, TO_CHAR);
      pc := tempu;
      goto got_one;
   }
   goto pre_start;

:search_test:
   pc := activator;
   secure(pc, pre_start);
   block;
   hm := ((pc.abilities[ABIL_DEX] + (pc.skills[SKI_LAY_TRAP] * 3) +
          pc.abilities[ABIL_BRA]) / 6) + 75;
   if (hm > pow)
   {
      addstring(ppl_list, pc.name);
      act("You spot a " + self.name + " carefully hidden here.",
          A_ALWAYS, pc, null, null, TO_CHAR);
   }
   else
   {
      act("You can find no such thing.",
          A_ALWAYS, pc, null, null, TO_CHAR);
   }
   goto pre_start;

:trap_over:
   act("A " + self.name + " springs and breaks.",
       A_SOMEONE, self, null, null, TO_ALL);
:trap_over1:
   clear(j);
   clear(i);
   clear(k);
   i := dildestroy("trap_spell@skills", pc);
   i := dildestroy("trap_tick@skills", pc);
   sendtoalldil("lostem " + tstr, "trap_spell@skills");
   sendtoalldil("lostem " + tstr, "trap_tick@skills");
   self.minv := 0;
   self.title := self.title + " [Broken]";
   self.outside_descr := "A broken " + self.name + " lies on the ground " +
                         "here.";
   self.objecttype := ITEM_TRASH;
self.manipulate:=MANIPULATE_TAKE;
   goto end;

:lost_trapped:
   clear(j);
   clear(i);
   clear(k);
   i := dildestroy("trap_spell@skills", pc);
   i := dildestroy("trap_tick@skills", pc);
   sendtoalldil("lostem " + tstr, "trap_spell@skills");
   sendtoalldil("lostem " + tstr, "trap_tick@skills");
   act("The " + self.name + " breaks as it loses its captive.",
       A_SOMEONE, self, null, null, TO_ALL);
   self.title := self.title + " [Broken]";
   self.outside_descr := "A broken " + self.name + " lies on the ground " +
                         "here.";
   self.objecttype := ITEM_TRASH;
self.manipulate:=MANIPULATE_TAKE;

:end:
   quit;
}
dilend /* trap_laid */

dilbegin aware trap_spell(pc_name : string, trap_name : string);
/* Prevent casting of magic */

var

code
{
   interrupt(SFB_MSG, ((getword(argument) == "lostem") and
                       (argument == self.name)), done);
:start:
   wait(SFB_PRE, command("cast"));
   if (activator==self)
   {
      power := -1;
      block;
      act("You are unable to concentrate enough because the trap " +
          "hurts so much!",
          A_ALWAYS, self, null, null, TO_CHAR);
   }
   goto start;

:done:
   quit;
}
dilend /* trap_spell */

dilbegin aware trap_tick(pc_name : string, trap_name : string);
/* Prevent casting of magic */

code
{
   heartbeat := PULSE_SEC*1;
   interrupt(SFB_MSG, ((getword(argument) == "lostem") and
                       (argument == self.name)), done);
:start:
   wait(SFB_TICK, TRUE);
   if (findunit(self, trap_name, FIND_UNIT_SURRO, null) == null)
      sendtoalldil("checkout" + " " + pc_name, "trap_laid@skills");
   goto start;

:done:
   quit;
}
dilend /* trap_tick */


dilbegin scan (arg : string);

external
   string dirstring@function(dir : integer);
   room_display@skills(the_dir : string, place : unitptr);
var
   room      : unitptr;

   ex_num    : integer;
   recur_num : integer;
   verify    : integer;
   temp_int  : integer;
   the_dir   : integer;

   tstr      : string;
   tstr2     : string;
   atoied    : string;

   cant_see1 : stringlist;
   cant_see2 : stringlist;
   cant_see3 : stringlist;

code
{
   heartbeat := PULSE_SEC;
   if (self.position != POSITION_STANDING)
   {
      act("You need to be standing and have room to look about you.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   atoied := getword(arg);

   if ((atoied == "north") or (atoied == "n"))
   {
      the_dir := 0;
      goto sing_prep;
   }

   else if ((atoied == "east") or (atoied == "e"))
   {
      the_dir := 1;
      goto sing_prep;
   }
   else if ((atoied == "south") or (atoied == "s"))
   {
      the_dir := 2;
      goto sing_prep;
   }
   else if ((atoied == "west") or (atoied == "w"))
   {
      the_dir := 3;
      goto sing_prep;
   }
   else if ((atoied == "up") or (atoied == "u"))
   {
      the_dir := 4;
      goto sing_prep;
   }
   else if ((atoied == "down") or (atoied == "d"))
   {
      the_dir := 5;
      goto sing_prep;
   }
   else if ((atoied == "northeast") or (atoied == "ne"))
   {
      the_dir := 6;
      goto sing_prep;
   }
   else if ((atoied == "northwest") or (atoied == "nw"))
   {
      the_dir := 7;
      goto sing_prep;
   }
   else if ((atoied == "southeast") or (atoied == "se"))
   {
      the_dir := 8;
      goto sing_prep;
   }
   else if ((atoied == "southwest") or (atoied == "sw"))
   {
      the_dir := 9;
      goto sing_prep;
   }

   goto arg_proc;

:sing_prep:

   if (self.skills[SKI_SCAN] >= 100) recur_num := 3;
   else if (self.skills[SKI_SCAN] >= 40) recur_num := 2;
   else recur_num := 1;

   goto start_single;

:arg_proc:

   if (atoied == "")
      recur_num := 1;
   else if ("0" in atoied)
      recur_num := 1;
   else recur_num := atoi(atoied);

   if (recur_num == 0)
   {
      act("You can't scan that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   else if ((recur_num == 2) and (self.skills[SKI_SCAN] < 40))
   {
      act("You must practice further in order to scan that far.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if ((recur_num == 3) and (self.skills[SKI_SCAN] < 100))
   {
      act("You must practice further in order to scan that far.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if (recur_num > 3)
   {
      act("No one can scan through more than three rooms away, no matter " +
          "what their skill!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if ((recur_num < 1) or (recur_num > 3))
   {
      act("I don't think so.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.outside.type != UNIT_ST_ROOM)
   {
      act("You cannot scan here.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg != "") goto single_dir;

   ex_num := 0;
   verify := 0;

   while (ex_num < 10)
   {
      tstr := dirstring@function(ex_num);
      if (not(self.outside.exit_to[ex_num])) 
         goto cannot_see;
      else if (isset(self.outside.exit_info[ex_num], EX_CLOSED))
         goto cannot_see;

      if (not(verify))
      {
         verify := 1;
         act("Closest to this place you see:",
             A_ALWAYS, self, null, null, TO_CHAR);
      }

      room := null;
      room := self.outside.exit_to[ex_num];
      if (room == null)
         act("Room is a null.",
             A_ALWAYS, self, null, null, TO_CHAR);
      room_display@skills(tstr, room);
      goto next_exit;

:cannot_see:
   addstring(cant_see1, tstr);

:next_exit:
      ex_num := ex_num + 1;
   }

   if ((cant_see1) and (not(cant_see1.[0] == "")))
   {
      tstr2 := "You cannot see";
      tstr2 := tstr2 + " " + cant_see1.[0];

      temp_int := 1;
      while (temp_int < (length(cant_see1) - 1) )
      {
         tstr2 := tstr2 + ", " + cant_see1.[temp_int];

         temp_int := temp_int + 1;
      }

      if (length(cant_see1) > 1)
         tstr2 := tstr2 + " or " + cant_see1.[length(cant_see1) - 1];
      tstr2 := tstr2 + ".";
      act(tstr2,
          A_ALWAYS, self, null, null, TO_CHAR);
   }

   if ((recur_num < 2) or (verify == 0)) goto end;

   verify := 0;

   ex_num := 0;

   act("<br/>And casting your gaze further away:",
       A_ALWAYS, self, null, null, TO_CHAR);

   while (ex_num < 10)
   {
      tstr := dirstring@function(ex_num);
      if (not(self.outside.exit_to[ex_num])) goto cannot_see2;
      else if (isset(self.outside.exit_info[ex_num], EX_CLOSED))
         goto cannot_see2;

      if (not(self.outside.exit_to[ex_num].exit_to[ex_num])) goto no_see2;
else if (isset(self.outside.exit_to[ex_num].exit_info[ex_num],
                     EX_CLOSED)) goto no_see2;

      if (not(verify))
      {
         verify := 1;
      }

      room := null;
      room := self.outside.exit_to[ex_num].exit_to[ex_num];
      if (room == null)
         act("Room is a null.",
             A_ALWAYS, self, null, null, TO_CHAR);
      room_display@skills(tstr, room);
      goto next_exit2;

:no_see2:
   addstring(cant_see2, tstr);

:cannot_see2:

:next_exit2:
      ex_num := ex_num + 1;
   }

   if ((cant_see2) and (not(cant_see2.[0] == "")))
   {
      tstr2 := "You cannot see any further";
      tstr2 := tstr2 + " " + cant_see2.[0];

      temp_int := 1;
      while (temp_int < (length(cant_see2) - 1) )
      {
         tstr2 := tstr2 + ", " + cant_see2.[temp_int];

         temp_int := temp_int + 1;
      }

      if (length(cant_see2) > 1)
         tstr2 := tstr2 + " or " + cant_see2.[length(cant_see2) - 1];
      tstr2 := tstr2 + ".";
      act(tstr2,
          A_ALWAYS, self, null, null, TO_CHAR);
   }

   if ((recur_num < 3) or (verify == 0)) goto end;

   verify := 0;

   ex_num := 0;

   act("<br/>And at the limit of your vision:",
       A_ALWAYS, self, null, null, TO_CHAR);

   while (ex_num < 10)
   {
      tstr := dirstring@function(ex_num);
      if (not(self.outside.exit_to[ex_num])) goto cannot_see3;
      else if (isset(self.outside.exit_info[ex_num], EX_CLOSED))
         goto cannot_see3;

      if (not(self.outside.exit_to[ex_num].exit_to[ex_num])) goto cannot_see3;
else if (isset(self.outside.exit_to[ex_num].exit_info[ex_num],
                     EX_CLOSED)) goto cannot_see3;

      if (not(self.outside.exit_to[ex_num].exit_to[ex_num].exit_to[ex_num]))
         goto no_see3;
else if (isset(self.outside.exit_to[ex_num].exit_to[ex_num].exit_info[ex_num],
               EX_CLOSED)) goto no_see3;

      if (not(verify))
      {
         verify := 1;
      }

      room := null;
      room := self.outside.exit_to[ex_num].exit_to[ex_num].exit_to[ex_num];
      if (room == null)
         act("Room is a null.",
             A_ALWAYS, self, null, null, TO_CHAR);
      room_display@skills(tstr, room);
      goto next_exit3;

:no_see3:
   addstring(cant_see3, tstr);

:cannot_see3:

:next_exit3:
      ex_num := ex_num + 1;
   }

   if ((cant_see3) and (not(cant_see3.[0] == "")))
   {
      tstr2 := "You cannot see any further";
      tstr2 := tstr2 + " " + cant_see3.[0];

      temp_int := 1;
      while (temp_int < (length(cant_see3) - 1) )
      {
         tstr2 := tstr2 + ", " + cant_see3.[temp_int];

         temp_int := temp_int + 1;
      }

      if (length(cant_see3) > 1)
         tstr2 := tstr2 + " or " + cant_see3.[length(cant_see3) - 1];
      tstr2 := tstr2 + ".";
      act(tstr2,
          A_ALWAYS, self, null, null, TO_CHAR);
   }

:end:
   quit;

:single_dir:
   if ((arg == "north") or (arg == "n"))
      the_dir := 0;
   else if ((arg == "east") or (arg == "e"))
      the_dir := 1;
   else if ((arg == "south") or (arg == "s"))
      the_dir := 2;
   else if ((arg == "west") or (arg == "w"))
      the_dir := 3;
   else if ((arg == "up") or (arg == "u"))
      the_dir := 4;
   else if ((arg == "down") or (arg == "d"))
      the_dir := 5;
   else if ((arg == "northeast") or (arg == "ne"))
      the_dir := 6;
   else if ((arg == "northwest") or (arg == "nw"))
      the_dir := 7;
   else if ((arg == "southeast") or (arg == "se"))
      the_dir := 8;
   else if ((arg == "southwest") or (arg == "sw"))
      the_dir := 9;
   else
   {
      act("That is not a valid direction to scan. It must be " +
          "north, east, south, west, up, down, northwest, northeast, " +
          "southwest, or southeast.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

:start_single:

   verify := 0;

   tstr := dirstring@function(the_dir);
   if (not(self.outside.exit_to[the_dir])) 
      goto sing_see1;
   else if (isset(self.outside.exit_info[the_dir], EX_CLOSED))
      goto sing_see1;

   if (not(verify))
   {
      verify := 1;
      act("Closest to this place you see:",
          A_ALWAYS, self, null, null, TO_CHAR);
   }

   room := null;
   room := self.outside.exit_to[the_dir];
   room_display@skills(tstr, room);
   goto sing_part2;

:sing_see1:
   act("You cannot see " + tstr + ".",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto end;


:sing_part2:

   if (recur_num < 2) goto end;
   if (verify == 0) goto end;

   verify := 0;

   act("<br/>And casting your gaze further away:",
       A_ALWAYS, self, null, null, TO_CHAR);

   if (not(self.outside.exit_to[the_dir].exit_to[the_dir])) goto sing_see2;
   else if (isset(self.outside.exit_to[the_dir].exit_info[the_dir], EX_CLOSED))
      goto sing_see2;

   if (not(verify))
   {
      verify := 1;
   }

   room := null;
   room := self.outside.exit_to[the_dir].exit_to[the_dir];
   room_display@skills(tstr, room);
   goto sing_part3;

:sing_see2:
   act("You cannot see any further " + tstr + ".",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto end;

:sing_part3:

   if (recur_num < 3) goto end;
   if (verify == 0) goto end;

   verify := 0;

   act("<br/>And at the limit of your vision:",
       A_ALWAYS, self, null, null, TO_CHAR);

   if (not(self.outside.exit_to[the_dir].exit_to[the_dir].exit_to[the_dir]))
      goto sing_see3;
else if (isset(self.outside.exit_to[the_dir].exit_to[the_dir].exit_info[the_dir], EX_CLOSED))
      goto sing_see3;

   if (not(verify))
   {
      verify := 1;
   }

   room := null;
   room := self.outside.exit_to[the_dir].exit_to[the_dir].exit_to[the_dir];
   room_display@skills(tstr, room);
   goto end;

:sing_see3:
   act("You cannot see any further " + tstr + ".",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto end;
}
dilend

dilbegin room_display(dir_scan : string, place : unitptr);

var
   end_str    : string;
   tmp_str    : string;

   str_list   : stringlist;
   str_list2  : stringlist;

   i          : integer;

   item       : unitptr;
   nxt        : unitptr;

code
{
   heartbeat := PULSE_SEC;
   end_str := "" + dir_scan + ": " +  place.title;
   end_str := textformat(end_str);
   act(end_str,
       A_ALWAYS, self, null, null, TO_CHAR);

   item := place.inside;
   while( item )
   {
      nxt := item.next;
	  	  if ((item.type==UNIT_ST_PC) and (item.level>=200))
	  {
 if (not(visible(self,item)))
 {
 item:=nxt;
 continue;
 }
	  }

      if (not(isset (item.flags, UNIT_FL_BURIED)))
      {
         if (item.type == UNIT_ST_PC)
         {
            if ((isset(self.charflags, CHAR_DETECT_LIFE)) and
                ((not(visible(self, item))) or (isset(item.charflags,
                                                      CHAR_HIDE)) ) )
            {
               tmp_str := "" + "You sense a hidden lifeform here.";
               addstring(str_list, tmp_str);
            }
            else if (visible(self, item) and (not(isset(item.charflags,
                                                        CHAR_HIDE))) )
            {
               if (item.position == POSITION_STANDING)
                  tmp_str := "" + item.name + " " + item.title +
                             " is standing here.";
               else if (item.position == POSITION_MORTALLYW)
                  tmp_str := "" + item.name + " " + item.title +
                             " is lying here, mortally wounded.";
               else if (item.position == POSITION_INCAP)
                  tmp_str := "" + item.name + " " + item.title +
                             " is lying here, incapacitated.";
               else if (item.position == POSITION_STUNNED)
                  tmp_str := "" + item.name + " " + item.title +
                             " is lying here, stunned.";
               else if (item.position == POSITION_SLEEPING)
                  tmp_str := "" + item.name + " " + item.title +
                             " is sleeping here.";
               else if (item.position == POSITION_SITTING)
                  tmp_str := "" + item.name + " " + item.title +
                             " is sitting here.";
               else if (item.position == POSITION_RESTING)
                  tmp_str := "" + item.name + " " + item.title +
                             " is resting here.";
               else if (item.position == POSITION_FIGHTING)
                  tmp_str := "" + item.name + " " + item.title +
                             " is fighting someone here.";
               else
                  tmp_str := "" + item.name + " " + item.title +
                             " is here.";

               addstring(str_list, tmp_str);
            }
         }
         if (item.type == UNIT_ST_NPC)
         {
            if ((isset(self.charflags, CHAR_DETECT_LIFE)) and
                ((not(visible(self, item))) or (isset(item.charflags,
                                                      CHAR_HIDE)) ) )
            {
               tmp_str := "" + "You sense a hidden lifeform here.";
               addstring(str_list, tmp_str);
            }
            else if (visible(self, item) and (not(isset(item.charflags,
                                                        CHAR_HIDE))) )
            {
            tmp_str := "" + item.outside_descr + "";
            addstring(str_list, tmp_str);
            }
         }
         if ((item.type == UNIT_ST_OBJ) and visible(self, item))
         {
            tmp_str := "" + item.outside_descr;
            addstring(str_list2, tmp_str);
         }
      }
      item := nxt;
   }
   i := 0;
   while( length(str_list2) > 0 )
   {
      tmp_str := str_list2.[length(str_list2) - 1];
      substring(str_list2, tmp_str);
      i := i + 1;
      while (tmp_str in str_list2)
      {
         i := i + 1;
         substring(str_list2, tmp_str);
      }
      if (i > 1)
      {
         end_str := "[x" + itoa(i) + "] " +
                    tmp_str;
         act(end_str,
             A_ALWAYS, self, null, null, TO_CHAR);
         i := 0;
      }
      else
      {
         end_str := tmp_str;
         act(end_str,
             A_ALWAYS, self, null, null, TO_CHAR);
         i := 0;
      }
   }
   while( length(str_list) > 0 )
   {
      tmp_str := str_list.[length(str_list) - 1];
      substring(str_list, tmp_str);
      i := i + 1;
      while (tmp_str in str_list)
      {
         i := i + 1;
         substring(str_list, tmp_str);
      }
      if (i > 1)
      {
         end_str := "[x" + itoa(i) + "] " +
                    tmp_str;
         act(end_str,
             A_ALWAYS, self, null, null, TO_CHAR);
         i := 0;
      }
      else
      {
         end_str := tmp_str;
         act(end_str,
             A_ALWAYS, self, null, null, TO_CHAR);
         i := 0;
      }
   }

:end:
   return;
}
dilend

dilbegin hunt(arg : string);

var
   i : integer;
code
{
   i := dilfind("hunting@skills", self);

   if (i == 0)
   {
      if (arg == "")
/*         act("Track who?",
             A_ALWAYS, self, null, null, TO_CHAR); */
       act("You don't see any tracks anywhere near here.",
             A_ALWAYS, self, null, null, TO_CHAR);

      else
         dilcopy("hunting@skills("+arg+")", self);
   }
   else
   {
      i := dildestroy("hunting@skills", self);
      act("You stop hunting.",
          A_ALWAYS, self, null, null, TO_CHAR);
   }

   quit;
}
dilend /* hunt */

dilbegin hunting(arg : string);

external
   string dirstring@function(dr : integer);
   integer skillresist@skills(aa : integer, ad : integer,
                             sa : integer, sd : integer);

var
   dir_string : string;
   argsave    : string;
   i         ,first : integer;
   hm         : integer;
   min        : integer;
   end        : integer;
   targ       : unitptr;
   room       : unitptr;
skilla   : integer;
skillb   : integer;
u:unitptr;
str,temp:string;
skillc   : integer;
skilld   : integer;
heart:integer;
code
{
   heartbeat := 2*PULSE_SEC;
   argsave := arg;
   room := self.outside;

/* make sure we have the ability necessary */

   if ((self.type == UNIT_ST_PC) and ((self.skills[SKI_TRACK] +
                                      self.skills[SKI_HUNT] / 2) <= 0))
   {
      act("You must practice your tracking and hunting skills first..",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

:loop:

/* make sure we have the proper enviroment */

   if (self.position != POSITION_STANDING)
   {
      act("You can't hunt in that position!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.outside.zoneidx == "basis")
   {
      act("You dream about using your mortal skills.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.outside.type != UNIT_ST_ROOM)
   {
      act("You can't track in here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if ((self.outside.movement > 7) and
            (self.outside.movement < 11))
   {
      act("You can't track in water!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if (self.outside.movement == SECT_INSIDE)
   {
      min:=-15;
      end:=15;
   }
   else if (self.outside.movement == SECT_CITY)
   {
      min:=-10;
      end:=15;
   }
   else if (self.outside.movement == SECT_FIELD)
   {
      min:=-25;
      end:=10;
   }
   else if (self.outside.movement == SECT_FOREST)
   {
      min:=-25;
      end:=10;
   }
   else if (self.outside.movement == SECT_HILLS)
   {
      min:=-25;
      end:=10;
   }
   else if (self.outside.movement == SECT_MOUNTAIN)
   {
      min:=-10;
      end:=10;
   }
   else if (self.outside.movement == SECT_DESERT)
   {
      min:=-15;
      end:=10;
   }
   else if (self.outside.movement == SECT_SWAMP)
   {
      min:=-15;
      end:=10;
   }
   else if (self.outside.movement == SECT_SNOW)
   {
      min:=-30;
      end:=5;
   }
   else if (self.outside.movement == SECT_SLUSH)
   {
      min:=-15;
      end:=10;
   }
   else if (self.outside.movement == SECT_ICE)
   {
      min:=-10;
      end:=15;
   }

/* make sure we have the endurance necessary */

   if (self.endurance < end)
   {
      act("You're just too tired to track anymore.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else
      self.endurance := self.endurance - end;

   act("$1n carefully examines the ground for tracks.",
       A_HIDEINV, self, null, null, TO_REST);
   act("You carefully examine the ground for tracks.",
       A_ALWAYS, self, null, null, TO_CHAR);

/* acquire target */

   targ := findunit(self, arg, FIND_UNIT_ZONE, null);
   arg := argsave;

   if ((targ==null) or not visible(self, targ))
   {
      targ := findunit(self, arg, FIND_UNIT_WORLD, null);
      if ((targ==null) or not visible(self, targ))
/*         act("Track who?",
             A_ALWAYS, self, null, null, TO_CHAR); */
       act("You don't see any tracks anywhere near here.",
             A_ALWAYS, self, null, null, TO_CHAR);
      else
         act("You don't see any of $3n's tracks near here.",
             A_ALWAYS, self, null, targ, TO_CHAR);

      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't track that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (targ == self)
   {
      act("You carefully examine the ground and determine that you've " +
          "found yourself!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/* check how our skill matches the targets */


       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_HUNT];
       else
           skillc := rnd(40,124);

 /*       skillc:=self.abilities[ABIL_STR];
  */
       if(targ.type==UNIT_ST_PC)
        skilld:=targ.skills[SKI_HUNT];
       else
              skilld := rnd(40,124);
    /*
	    skilld:=targ.abilities[ABIL_STR];
      */
       skilla:=self.abilities[ABIL_BRA] + self.level;
       skillb:=targ.abilities[ABIL_DEX] + targ.level;
        hm:=skillresist(skilla,skillb,skillc,skilld);




/*

   if (targ.type == UNIT_ST_PC)
      hm:=skillresist@skills(self.abilities[ABIL_BRA]+self.level,
                            targ.abilities[ABIL_BRA]+targ.level,
                            (self.skills[SKI_TRACK]+self.skills[SKI_HUNT])/2,
                            targ.skills[SKI_TRACK]);
   else
      hm:=skillresist@skills(self.abilities[ABIL_BRA]+self.level,
                            targ.abilities[ABIL_BRA]+(targ.level/4),
                            (self.skills[SKI_TRACK]+self.skills[SKI_HUNT])/2,
                            targ.abilities[ABIL_BRA]);
*/
   if (hm < min)
   {
      act("You think you see tracks, but you can't make anything of them.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/* do the actual path to call and display results */

heartbeat:=1;
str:=targ.name;
first:=0;
:repeater:
temp:=str;
u:=findunit(self,temp,FIND_UNIT_WORLD,null);
if (u==null)
 goto lostu;
   i := pathto (self,u);
if (i==DIR_TRYAGAIN)
{
if (first ==0)
{
act ("The path is a bit harder to follow than you expected you start turning over everything in sight.",
A_SOMEONE,self,null,u,TO_CHAR);
first:=1;

}
pause;
   goto repeater;
   }

   if (i == DIR_IMPOSSIBLE)
   {
   :lostu:
      act("You search the ground but don't see any of $3n's tracks.",
          A_ALWAYS, self, null, targ, TO_CHAR);
      quit;
   }
   else if (i == DIR_HERE)
      act("The tracks lead to this very place!",
          A_ALWAYS, self, null, null, TO_CHAR);
   else if (i == DIR_ENTER)
   {
      act("You search and see the tracks enter something here.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if (i==DIR_EXIT)
      act("You search and see the tracks exit here.",
          A_ALWAYS, self, null, null, TO_CHAR);
   else
   {
      dir_string:=dirstring@function(i);
      act("You search and see some tracks to the $2t.",
          A_ALWAYS, self, dir_string, null, TO_CHAR);
   }
   if (targ==null) goto end;

   if (targ == null) goto end;

   if (i == DIR_HERE)
   {
      if (not(visible(self, targ)))
      {
         act("Though you can't see $3n, you know $3e must be right here.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
         if ((targ.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
         {
            if (not(isset (self.pcflags, PC_PK_RELAXED)))
            {
               act("You are not allowed to do that unless you sign " +
                   "the book of blood.",
                    A_ALWAYS, self, null, null, TO_CHAR);
               quit;
            }

            if (not(isset (targ.pcflags, PC_PK_RELAXED)))
            {
               act("You are not allowed to do that unless $2e signs " +
                   "the book of blood.",
                   A_ALWAYS, self, targ, null, TO_CHAR);
               quit;
            }
         }
      set_fighting(self, targ);
	  set_fighting(targ, self);
      quit;
   }
   else if (i == DIR_EXIT)
      exec("exit", self);
   else
   {
      if (isset (self.outside.exit_info[i], EX_HIDDEN))
         exec("search " + dir_string + " " + self.outside.exit_names[i].[0],
              self);
      if (isset (self.outside.exit_info[i], EX_CLOSED))
         exec("open " + dir_string + " " + self.outside.exit_names[i].[0],
              self);
      exec(dir_string, self);
   }

   if (room == self.outside)
   {
      act("You can't seem to get any further.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   pause;

   goto loop;

:end:
   unsecure(room);
   quit;
}
dilend /* hunting */

dilbegin track(arg : string);
external
   string dirstring@function(dr : integer);
   integer skillresist@skills(aa : integer, ad : integer, sa : integer,
                             sd : integer);
var
   dir_string : string;
   targ       : unitptr;
   i,first         : integer;
   hm         : integer;
   min        : integer;
   end        : integer;
   theskill   : integer;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;
heart:integer;
u:unitptr;
str,temp:string;

code
{
   if (self.skills[SKI_TRACK] <= 0)
   {
      act("You must practice first.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.outside.zoneidx == "basis")
   {
      act("You dream about using your mortal skills.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.position != POSITION_STANDING)
   {
      act("You need to be standing with some space around you in order " +
          "to find tracks.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      act("You show off your tracking skills to the people around you.",
          A_ALWAYS, self, null, null, TO_CHAR);
      act("$1n demonstrates his tracking skills - oooooh ahhhhh.",
          A_SOMEONE, self, null, null, TO_REST);
      quit;
   }

/* make sure we have the proper enviroment */

   if (self.outside.type != UNIT_ST_ROOM)
   {
      act("You can't track in here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if ((self.outside.movement > 7) and (self.outside.movement < 11))
   {
      act("You can't track in water!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if (self.outside.movement==SECT_INSIDE)
   {
      min:=-15;
      end:=15;
   }
   else if (self.outside.movement==SECT_CITY)
   {
      min:=-10;
      end:=15;
   }
   else if (self.outside.movement==SECT_FIELD)
   {
      min:=-25;
      end:=10;
   }
   else if (self.outside.movement==SECT_FOREST)
   {
      min:=-25;
      end:=10;
   }
   else if (self.outside.movement==SECT_HILLS)
   {
      min:=-25;
      end:=10;
   }
   else if (self.outside.movement==SECT_MOUNTAIN)
   {
      min:=-10;
      end:=10;
   }
   else if (self.outside.movement==SECT_DESERT)
   {
      min:=-15;
      end:=10;
   }
   else if (self.outside.movement==SECT_SWAMP)
   {
      min:=-15;
      end:=10;
   }
   else if (self.outside.movement==SECT_SNOW)
   {
      min:=-30;
      end:=5;
   }
   else if (self.outside.movement==SECT_SLUSH)
   {
      min:=-15;
      end:=10;
   }
   else if (self.outside.movement==SECT_ICE)
   {
      min:=-10;
      end:=15;
   }
   else
   {
      min:=-15;
      end:=5;
   }

/* make sure we have the endurance necessary */

   if (self.endurance < end)
   {
      act("You're just too tired to track anymore.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else self.endurance := self.endurance - end;

   act("You carefully examine the ground for tracks.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n carefully examines the ground for tracks.",
       A_HIDEINV, self, null, null, TO_REST);

/* acquire target */

   targ := findunit(self, arg, FIND_UNIT_ZONE, null);

   if ((targ==null) or not visible(self, targ))
   {
      targ := findunit(self, arg, FIND_UNIT_WORLD, null);

      if ((targ==null) or not visible(self, targ))
       act("You don't see any tracks anywhere near here.",
             A_ALWAYS, self, null, null, TO_CHAR);
      else
         act("You don't see any tracks anywhere near here.",
             A_ALWAYS, self, null, targ, TO_CHAR);

      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
         act("You can't track that!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
   }

   if (targ==self)
   {
         act("You carefully examine the ground and determine that you've " +
             "found yourself!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
   }

/* check how our skill matches the targets */

       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_TRACK];
       else
	             skillc := rnd(40,124);

	   /*
        skillc:=self.abilities[ABIL_BRA]/2;
       */
       if(targ.type==UNIT_ST_PC)
        skilld:=targ.skills[SKI_TRACK];
       else
                 skilld := rnd(40,124);

	   /*
        skilld:=targ.abilities[ABIL_BRA]/2;
        */
       skilla:=self.abilities[ABIL_BRA] + self.level;
       skillb:=targ.abilities[ABIL_DEX] + targ.level /3;
        hm:=skillresist(skilla,skillb,skillc,skilld);



/*
   if (targ.type == UNIT_ST_PC)
         hm := skillresist@skills(self.abilities[ABIL_BRA]+self.level,
                                 targ.abilities[ABIL_BRA]+targ.level,
                                 self.skills[SKI_TRACK],
                                 targ.skills[SKI_TRACK]);
   else
         hm := skillresist@skills(self.abilities[ABIL_BRA]+self.level,
                                 targ.abilities[ABIL_BRA]+(targ.level/4),
                                 self.skills[SKI_TRACK],
                                 targ.abilities[ABIL_BRA]);
*/
   if (hm < min)
   {
      act("You think you see tracks, but you can't make anything of them.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/* do the actual path to call and display results */
              heartbeat:=1;
str:=targ.name;
first:=0;
:repeater:
temp:=str;
u:=findunit(self,temp,FIND_UNIT_WORLD,null);
if (u==null)
 goto lostu;
   i := pathto (self,u);
if (i==DIR_TRYAGAIN)
{
if (first ==0)
{
act ("The path is a bit harder to follow than you expected you start turning over everything in sight.",
A_SOMEONE,self,null,u,TO_CHAR);
first:=1;

}
pause;
   goto repeater;
   }
targ:=u;
   if (i == DIR_IMPOSSIBLE)
   {
   :lostu:
      act("You search the ground but don't see any of $3n's tracks.",
          A_ALWAYS, self, null, targ, TO_CHAR);
		  }
   else if (i == DIR_HERE)
      act("The tracks lead to this very place!",
          A_ALWAYS, self, null, null, TO_CHAR);
   else if (i == DIR_ENTER)
      act("You search and see the tracks enter something here.",
          A_ALWAYS, self, null, null, TO_CHAR);
   else if(i==DIR_EXIT)
      act("You search and see the tracks exit here.",
          A_ALWAYS, self, null, null, TO_CHAR);
   else
   {
      dir_string := dirstring@function(i);
      act("You search and see some tracks to the $2t.",
          A_ALWAYS, self, dir_string, null, TO_CHAR);
   }

   quit;
}
dilend /* track */

dilbegin integer is_blade(wpn_type : integer);
var
ilst : intlist;
i : integer;
code
{

/* insert new bladed weapons here */
ilst :=
{WPN_BATTLE_AXE,WPN_HAND_AXE,WPN_GREAT_SWORD,WPN_SCIMITAR,
WPN_FALCHION,WPN_LONG_SWORD,WPN_RAPIER,
WPN_SHORT_SWORD,WPN_DAGGER,WPN_SPEAR,WPN_HALBERD,WPN_BARDICHE,WPN_SICKLE,
WPN_SCYTHE,WPN_TRIDENT,WPN_BITE,WPN_STING,WPN_CLAW,WPN_WHIP,
WPN_BOW,WPN_CROSSBOW,WPN_LANCE, WPN_MAIN_GAUCHE, WPN_STILETTO };

i := 0;

while(i < length(ilst))
{
if(wpn_type == ilst.[i])
	return(TRUE);

i := i + 1;
}

return(FALSE);

}
dilend

dilbegin curare(arg : string);
external
	integer is_blade(wpn_type : integer);
      integer skillresist@skills(aa : integer, ad : integer,
                                sa : integer, sd : integer);

var
   targ : unitptr;
   hm   : integer;

   ext  : extraptr;
   room : unitptr;
   i    : integer;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_CURARE] <= 0))
      {
         act("You must practice first.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (self.position == POSITION_FIGHTING)
      {
         act("No time for that right now!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   i := self.outside.movement;

   if (not ((i == SECT_FOREST) or (i == SECT_FIELD) or
            (i == SECT_HILLS) or (i == SECT_SWAMP)) )
      {
         act("You wouldn't find the right plants here.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (self.endurance < 20)
      {
         act("You haven't the energy. Better rest.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (arg == "")
      {
         act("What weapon do you wish to prepare with poison?",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   targ := findunit(self, arg, FIND_UNIT_EQUIP, null);

   if ((targ == null) or not visible(self, targ) or
       (not(targ.manipulate & (MANIPULATE_WIELD | MANIPULATE_HOLD))))
      {
         act("You aren't wielding or holding such a weapon.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (dilfind("weapon_curare@skills", targ))
      {
         if (self.level >= IMMORTAL_LEVEL) {
           hm := dildestroy("weapon_curare@skills", targ);
           act ("You wipe the curare off your weapon.",
             A_ALWAYS, self, null, null, TO_CHAR);
           }
         else {
           act("But it has already got poison on it!",
               A_ALWAYS, self, null, null, TO_CHAR);
           quit;
           }
      }

   i := is_blade(targ.value[0]);
   if(i == FALSE)
      {
      act ("This isn't a bladed weapon.",
         A_ALWAYS, self, null,  null, TO_CHAR);
      quit;
      }

   room := self.outside;
   if ("$curare clean" in room.extra) {
      hm := -50;
      goto hm_check;
      }

/*
Non-nerds and big nerds don't read this it's not scientific

We want an average hm of 10:

openroll(100,5) : 55
+ bra / 2       : 80
+ sk            : 130

we thus need a -120 modifier

openroll(100,5) = 1_100
+ (bra / 2) = + 1_50
+ sk = + 5_100
- 120

1_100 + 1_50 + 5_100 - 120 = 7_250 - 120 = -113_130

OR

-openroll(100,5) + openroll(20,1) + (bra / 2) + sk
-55 + 11 + 25 + 50
-44 + 75 = 31

we thus need a -21 modifier

-1_-100 + 1_20 + 1_50 + 5_100 - 21 = 7_170 - 121_22 = -114_148

*/
/*
   hm := -openroll(100,5);
   hm := hm + openroll(20,1);
   hm := hm + (self.abilities[ABIL_BRA] / 2);
   hm := hm + self.skills[SKI_CURARE];
   hm := hm - 41;
*/

       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_CURARE];
       else
        skillc := rnd(40,124);

       if(self.type==UNIT_ST_PC)
        skilld:=openroll(20,1);
       else
        skilld:=openroll(20,1);

       skilla:= self.abilities[ABIL_BRA] /2;
       skillb:= 41;

       hm:=skillresist(skilla,skillb,skillc,skilld);


   if (hm > 50) hm := 50;

:hm_check:

   if (hm <= 0)
      {
         act("You search the vegetation for some poisonous plants, " +
             "but find nothing.",
             A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n searches the vegetation but finds nothing.",
             A_ALWAYS, self, null, null, TO_REST);
         if ((rnd(1,100) <= 28) and
            not("$curare clean" in self.outside.extra))
            addextra (self.outside.extra,{"$curare clean"},"tito");
         quit;
      }

   else if (hm < 5)
      {
         act("You manage to find some poisonous plants, and mixing " +
             "the saps, you produce a weak poison which you smear " +
             "on your " + targ.name + ".",
             A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n finds some plants and smears their saps on $1s " +
             targ.name + ".",
             A_ALWAYS, self, null, null, TO_REST);
         goto check;
      }
   else if (hm < 25)
      {
         act("You find a few different poisonous plants, and mixing " +
             "the saps, you produce a mild poison which you smear " +
             "on your " + targ.name + ".",
             A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n finds some plants and smears their saps on $1s " +
             targ.name + ".",
             A_ALWAYS, self, null, null, TO_REST);
         goto check;
      }
   else if (hm < 40)
      {
         act("You find many types of poisonous plants, and mixing " +
             "the saps, you produce a strong poison which you smear " +
             "on your " + targ.name + ".",
             A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n finds some plants and smears their saps on $1s " +
             targ.name + ".",
             A_ALWAYS, self, null, null, TO_REST);
         goto check;
      }
   else
      {
         act("You find many poisonous plants after careful searching, " +
             "and mixing the saps, you produce a powerful poison which " +
             "you smear on your " + targ.name + ".",
             A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n finds some plants and smears their saps on $1s " +
             targ.name + ".",
             A_ALWAYS, self, null, null, TO_REST);
         goto check;
      }

:check:
   if (openroll(60,rnd(1,2)) > self.skills[SKI_CURARE])
      {
         act("You slip and accidentally cut yourself!",
             A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n slips and accidentally cuts $1mself!",
             A_ALWAYS, self, null, null, TO_REST);
         dilcopy("spl_poison@spells("+itoa( (hm * rnd(1,5)) )+")", self);
      }
   self.endurance := self.endurance - 20;

   if (rnd(1,100) <= 13)
      addextra (self.outside.extra,{"$curare clean"},"totu");

:poison_weapon:
   dilcopy("weapon_curare@skills(" + itoa(hm) + ")", targ);
   quit;
}
dilend

/* This dil is the dil on the weapon which has been treated with
   curare. It's quite nifty. */

/* This is Eirinn's dil. Awful.
- Storm */

dilbegin recall weapon_curare(pwr : integer);
external
      integer skillresist@skills(aa : integer, ad : integer,
                                sa : integer, sd : integer);
var
   origpwr : integer;
   mypulse : integer;
   hm      : integer;
   i       : integer;
   s: string;
   msg_t: integer;
   ski_t: integer;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;

code
{
   origpwr := pwr / 2;

   mypulse := (PULSE_SEC * SECS_PER_MUD_HOUR) / 2;
   heartbeat := mypulse;

:init:
   i := interrupt(SFB_TICK, TRUE, ticking);

   subextra(self.extra, "$curare_str");
   addextra(self.extra, {"$curare_str"}, itoa(pwr));

   goto battle;

:ticking:
   pwr := pwr - rnd(1,3);
   subextra(self.extra, "$curare_str");
   addextra(self.extra, {"$curare_str"}, itoa(pwr));

   if (pwr < origpwr)
      {
         act("The poison on the " + self.name + " has worn off.",
             A_SOMEONE, self.outside, null, null, TO_CHAR);
         quit;
      }

:battle:

wait (SFB_PRE, (command(CMD_AUTO_DAMAGE) and
   (activator == self.outside) and
   (medium == self)) );

   s := getword(argument);
   msg_t := atoi(s);
   if ((msg_t == MSG_TYPE_SPELL) or (msg_t == MSG_TYPE_OTHER))
      goto battle;

   s := getword(argument);
   ski_t := atoi(s);

   if ((msg_t == MSG_TYPE_WEAPON) and not((ski_t == WPN_BOW) or
            (ski_t == WPN_CROSSBOW)) and (target != self.outside.fighting))
      goto battle;

   else if ((msg_t == MSG_TYPE_SKILL) and (ski_t != SKI_BACKSTAB))
      goto battle;

   if (power < 15)
      goto battle;

       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_CURARE];
       else
	             skillc := rnd(40,124);
       /*
        skillc:=self.abilities[ABIL_BRA];
       */
       if(self.outside.fighting.type==UNIT_ST_PC)
        skilld:=self.outside.fighting.skills[SKI_HERBS];
       else
	             skilld := rnd(40,124);
      /*        skilld:=self.outside.fighting.abilities[ABIL_DEX];
        */
       skilla:=self.abilities[ABIL_DEX];
       skillb:=self.outside.fighting.abilities[ABIL_DEX];
        hm:=skillresist(skilla,skillb,skillc,skilld);

/*

   hm := skillresist@skills(self.outside.abilities[ABIL_DEX],
                         self.outside.fighting.abilities[ABIL_DEX],
                         self.outside.abilities[ABIL_BRA],
                         self.outside.fighting.abilities[ABIL_CON]);
*/
   if (hm >= 0)
      {
         if (not(isset(self.outside.fighting.pcflags, PC_PK_RELAXED)) and
             (target.type == UNIT_ST_PC))
            goto battle;
      if (not(dilfind("spl_poison@spells", target)))
         {
            if ((msg_t == MSG_TYPE_SKILL) and (ski_t == SKI_BACKSTAB))
               dilcopy("spl_poison@spells("+itoa(pwr*
                 (activator.level / 10))+")", target);
            else if (power < 30)
               dilcopy("spl_poison@spells("+itoa(pwr / 2)+")", target);
            else dilcopy("spl_poison@spells("+itoa(pwr)+")", target);
            act("$3n's weapon cuts you and you feel poison enter " +
                "your body!",
                A_ALWAYS, target, null, self.outside,
                TO_CHAR);
            act("Your weapon cuts $1n and they flinch as poison " +
                "enters $1s body.",
                A_ALWAYS, target, null, self.outside,
                TO_VICT);
            act("$1n flinches as poison enters $1s body!",
                A_ALWAYS, target, null, null, TO_REST);
         }
      else if (rnd(0,10) < 1)
         {
            dilcopy("spl_poison@spells("+itoa(pwr / 2)+")",
                    target);
            act("$3n's weapon cuts you and you feel poison enter " +
                "your body!",
                A_ALWAYS, target, null, self.outside,
                TO_CHAR);
            act("$1n flinches as poison enters $1s body!",
                A_ALWAYS, target, null, null, TO_REST);
         }
      }
   goto battle;
}
dilend /* weapon_curare */

dilbegin shoot(arg : string);

external
   integer skillresist@skills(aa : integer, ad : integer, sa : integer,
                             sd : integer);

var
   targ     : unitptr;   /* El victimo */
   missile  : unitptr;   /* The actual arrow/sling/etc to shoot */
   quiver   : unitptr;   /* The quiver, pouch, etc */
   weapon   : unitptr;   /* Ranged Weapon */
   in_hand  : unitptr;   /* Am I holding anything */
   tempu    : unitptr;   /* Old room */
   wep_type : integer;   /* The Ranged Weapon Type - Bow, Crossbow, Sling */
   slay_bon : integer;   /* Slaying bonus if weapon or missiles match
                            targ.race - not cumalative */
   result   : integer;   /* Integer for cast_spell */
   spl_type : integer;   /* The bow's spells */
   bonus    : integer;   /* For meleeattack */
   mdam     : integer;   /* Missile's damage taken */
   hm       : integer;
   temp     : integer;   /* did we kill it? */

   act_list : stringlist; /* list of strings */
   magic_ar : string;    /* Magic arrow attack type */
   temp_str : string;     /* Temporary string*/

   tstr         : string;   /* Temporary string for processing argument. */
   tstr2        : string;   /* For corpses */
   thing_name   : string;   /* In case we ever forget what we're throwing. */

code
{
   heartbeat:=2;
/*   if (self.fighting != null)
   {
      act("You're too busy to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
*/

   weapon:=equipment(self, WEAR_HOLD);
   in_hand:=equipment(self, WEAR_WIELD);

   if (weapon==null)
   {
      act("You aren't holding anything to shoot with!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (in_hand != null)
   {
      act("You need two hands to shoot accurately.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
/*
   if (self.skills[SKI_SHOOT] <= 0)
   {
      act("You need to practice your shooting first.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
*/

   if (weapon.objecttype != ITEM_FIREWEAPON)
   {
      act("How do you propose to shoot something with that!?",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      act("Shoot? Yes! Fine! Shoot we must, but WHAT??",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   temp_str := arg;

   wep_type := weapon.value[4];
   if ((wep_type != WPN_BOW) and (wep_type != WPN_CROSSBOW) and
       (wep_type != WPN_SLING))
   {
      act("Invalid Ranged Weapon - Please report this to a god.",
          A_ALWAYS, self, null, null, TO_CHAR);
      log(self.name + " has encountered an invalid ranged weapon " +
          "- this is a big error so someone tell Eirinn quick.");
      quit;
   }

   if (wep_type == WPN_BOW)
      act_list := {"Bow", "arrow", "quiver", "42", "draw back",
                   "draws back", "shoot", "shoots"};
   else if (wep_type == WPN_CROSSBOW)
      act_list := {"Crossbow", "bolt", "quiver", "43", "knock",
                   "knocks", "shoot", "shoots"};
   else
      act_list := {"Sling", "stone", "pouch", "44", "spin",
                   "spins", "let fly", "lets fly"};

   if (self.weapons[wep_type] <= 0)
   {
      act("You are not skilled enough with a " + act_list.[0] + ". You " +
          "should practice.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (weapon.value[0] > 0) goto get_targ; /* This is magical - no arrows */

   quiver := findunit(self, act_list.[2], FIND_UNIT_EQUIP, null);

   if (quiver.objecttype != ITEM_CONTAINER) goto search_inv;

   missile := findunit(quiver, act_list.[1], 0, quiver.inside);

   if ((missile == null) or not visible(self, missile)) goto search_inv;

   if (missile.value[0] != atoi(act_list.[3]))
   {
      act("You have no proper " + act_list.[1] + "s!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   goto get_targ;


:search_inv:
   missile := findunit(self, act_list.[1], 0, self.inside);

   if (missile == null)
   {
      act("You can't find any " + act_list.[1] + "s to shoot.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (missile.value[0] != atoi(act_list.[3]))
   {
      act("You have no proper " + act_list.[1] + "s!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }


:get_targ:

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ==null) or (not(visible(self, targ))))
   {
      act("You don't see that here.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (not (targ.type & UNIT_ST_NPC|UNIT_ST_PC))
   {
      act("Why waste a good " + act_list.[1] + " on an inanimate object " +
          "like that?",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (targ==self)
   {
      act("You carefully aim at your foot, then think better of it.",
          A_ALWAYS, self, null, null, TO_CHAR);
      act("$1n almost shoots $1mself in the foot! What an idiot.",
          A_HIDEINV, self, null, null, TO_REST);
      quit;
   }

   if ((targ.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
   {
      if (not(isset (self.pcflags, PC_PK_RELAXED)))
      {
         act("You are not allowed to do that unless you sign " +
             "the book of blood.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      if (not(isset (targ.pcflags, PC_PK_RELAXED)))
      {
         act("You are not allowed to do that unless $2e signs " +
             "the book of blood.",
             A_ALWAYS, self, targ, null, TO_CHAR);
         quit;
      }
   }


:slay_proc:

   if (weapon.value[0] > 0) goto spell_proc;

/* Slaying missiles/bows etc. Effects not cumalative */

   slay_bon := 0;

   hm := skillresist@skills(self.abilities[ABIL_DEX],
                           (targ.abilities[ABIL_DEX]-20),
                           self.weapons[wep_type],
                           (targ.abilities[ABIL_BRA]-10));
   if (hm <= -10)
   {
      act("Your " + act_list.[1] + " misses $3n as $3e dodges out " +
          "of the way.",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("$1n's " + act_list.[1] + " misses $3n " +
          "as $3e dodges out of the way.",
          A_SOMEONE, self, null, targ, TO_NOTVICT);
      act("$1n's " + act_list.[1] + " misses you " +
          "as you dodge out of the way.",
          A_SOMEONE, self, null, targ, TO_VICT);
      bonus := -1;
      goto finish_off;
   }

   link(missile, self);
   addequip(missile, WEAR_WIELD);
   act("You " + act_list.[4] + " your " + weapon.name + " and " +
       act_list.[6] + " at $3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n " + act_list.[5] + " $1s " + weapon.name + " and " +
       act_list.[7] + " at $3n!",
       A_ALWAYS, self, null, targ, TO_NOTVICT);
   act("$1n " + act_list.[5] + " $1s " + weapon.name + " and " +
       act_list.[7] + " at you!",
       A_ALWAYS, self, null, targ, TO_VICT);

   if (missile.value[3] == targ.race)
   {
      slay_bon := 15;
/*
      act("Your $2n glows!",
          A_ALWAYS, self, missile, null, TO_CHAR);
      act("$1n's $2n glows!",
          A_ALWAYS, self, missile, null, TO_REST);
*/
   }

   if ((weapon.value[3] == targ.race) and (slay_bon == 0))
   {
      slay_bon := 30;
      act("Your $2n glows!",
          A_ALWAYS, self, weapon, null, TO_CHAR);
      act("$1n's $2n glows!",
          A_ALWAYS, self, weapon, null, TO_REST);
   }

   bonus := missile.value[1] + missile.value[2] + weapon.value[1] +
            weapon.value[2] + self.skills[weapon.value[4]] +
            slay_bon;

   goto do_damage;



:spell_proc:

/* Magic Bows, etc: Fire, Frost, Lightning, Acid.
   NOTE:  CURARE is an exception to this and does not count as a spell. */

   spl_type := 0;

   if (weapon.value[0] > 0)
   {
      if (weapon.value[0] == 1)
      {
         spl_type := SPL_FIREBALL_3;
         magic_ar := "fire";
      }
      else if (weapon.value[0] == 2)
      {
         spl_type := SPL_FROSTBALL_3;
         magic_ar := "frost";
      }
      else if (weapon.value[0] == 3)
      {
         spl_type := SPL_LIGHTNING_3;
         magic_ar := "lightning";
      }
      else if (weapon.value[0] == 4)
      {
         spl_type := SPL_ACIDBALL_3;
         magic_ar := "acid";
      }
      else
      {
         act("Invalid Ranged Weapon - Please report this to a god.",
             A_ALWAYS, self, null, null, TO_CHAR);
         log(self.name + " has encountered an invalid ranged weapon " +
             "- this is a big error so someone tell Eirinn quick.");
         quit;
      }
   }

   if (self.mana < 20)
   {
      act("You have not the magical essence left to succeed.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skillresist@skills(self.abilities[ABIL_DEX],
                           (targ.abilities[ABIL_DEX]-20),
                           self.weapons[wep_type],
                           (targ.abilities[ABIL_BRA]-10));

   if (hm <= -10)
   {
      act("You " + act_list.[4] + " your " + weapon.name + " and " +
          act_list.[6] + " a magical " + act_list.[1] +
          " of " + magic_ar + " but you miss $3n!",
          A_ALWAYS, self, null, targ, TO_CHAR);
      act("$1n " + act_list.[5] + " $1s " + weapon.name + " and " +
          act_list.[7] + " a magical " + act_list.[1] +
          " of " + magic_ar + " at $3n but misses $3m completely!",
          A_ALWAYS, self, null, targ, TO_NOTVICT);
      act("$1n " + act_list.[5] + " $1s " + weapon.name + " and " +
          act_list.[7] + " a magical " + act_list.[1] +
          " of " + magic_ar + " at you but it misses you completely!",
          A_ALWAYS, self, null, targ, TO_VICT);
      goto spell_end;

   }

   act("You " + act_list.[4] + " your " + weapon.name + " and " +
       act_list.[6] + " a magical " + act_list.[1] +
       " of " + magic_ar + " at $3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n " + act_list.[5] + " $1s " + weapon.name + " and " +
       act_list.[7] + " a magical " + act_list.[1] +
       " of " + magic_ar + " at $3n!",
       A_ALWAYS, self, null, targ, TO_NOTVICT);
   act("$1n " + act_list.[5] + " $1s " + weapon.name + " and " +
       act_list.[7] + " a magical " + act_list.[1] +
       " of " + magic_ar + " at you!",
       A_ALWAYS, self, null, targ, TO_VICT);
   result := cast_spell(spl_type, self, weapon, targ, "");
:spell_end:
   self.mana := self.mana - 20;
   quit;


:do_damage:
   thing_name := missile.name;
   tstr := targ.name;
   if (targ.type == UNIT_ST_NPC) tstr2 := targ.title;

   temp := targ.hp;

   bonus := meleedamage(self, targ, bonus, 0);

   missile := equipment(self, WEAR_WIELD);
   unequip(missile);

:finish_off:

   temp := temp - bonus;
   if (bonus <= 0)
   {
      link(missile, self.outside);
      quit;
   }
   else
   {
:do_dam:
      mdam := rnd(0, 40 - (missile.value[1] + missile.value[2]));
      missile.hp := missile.hp - mdam;
      position_update(missile);

      if ((bonus > 30) and (temp > -10)) link(missile, targ)
      else if ((bonus > 30) and (temp == -10)) link(missile, self.outside);
      else if ((bonus > 30) and (temp < -10))
      {
         pause;
         missile := findunit(self, thing_name, FIND_UNIT_IN_ME, null);
         if (tstr2 == "")
         {
            tstr := "corpse of " + tstr;
            targ := findunit(self, tstr, FIND_UNIT_SURRO, null);
            if (targ == null) link(missile, self.outside);
            else link(missile, targ);
         }
         else if (tstr2 != "")
         {
            targ := findunit(self, "corpse", FIND_UNIT_SURRO, null);
            if (targ == null) link(missile, self.outside);
            else if (tstr2 in targ.outside_descr) link(missile, targ);
            else link(missile, self.outside);
         }
         else link(missile, self.outside);

      }
      else link(missile, self.outside);
   }

   quit;
}
dilend /* Shoot */

dilbegin ranged_need(); /* Wearing/Wielding */

var
   skill  : integer;
   strga  : string;
   strgb  : string;
code
{
:start:
   wait(SFB_DONE, (command("hold") and (medium == self) and
                   (activator==self.outside)));
   if (self.outside.weapons[self.value[4]] <= 0)
      strga := "utterly hopeless";
   else if ((self.outside.weapons[self.value[4]] > 0) and
            (self.outside.weapons[self.value[4]] < 11))
      strga := "impossible";
   else if ((self.outside.weapons[self.value[4]] > 10) and
            (self.outside.weapons[self.value[4]] < 26))
      strga := "poor";
   else if ((self.outside.weapons[self.value[4]] > 25) and
            (self.outside.weapons[self.value[4]] < 41))
      strga := "good";
   else if ((self.outside.weapons[self.value[4]] > 40) and
            (self.outside.weapons[self.value[4]] < 51))
      strga := "skilled";
   else if ((self.outside.weapons[self.value[4]] > 50) and
            (self.outside.weapons[self.value[4]] < 71))
      strga := "specialized";
   else if ((self.outside.weapons[self.value[4]] > 70) and
            (self.outside.weapons[self.value[4]] < 91))
      strga := "supreme";
   else if ((self.outside.weapons[self.value[4]] > 90) and
            (self.outside.weapons[self.value[4]] < 101))
      strga := "expert";
   else if (self.outside.weapons[self.value[4]] > 100)
      strga := "godly";
/*
   if (self.outside.skills[SKI_SHOOT] <= 0)
      strgb := "utterly hopeless";
   else if ((self.outside.skills[SKI_SHOOT] > 0) and
            (self.outside.skills[SKI_SHOOT] < 11))
      strgb := "impossible";
   else if ((self.outside.skills[SKI_SHOOT] > 10) and
            (self.outside.skills[SKI_SHOOT] < 26))
      strgb := "poor";
   else if ((self.outside.skills[SKI_SHOOT] > 25) and
            (self.outside.skills[SKI_SHOOT] < 41))
      strgb := "good";
   else if ((self.outside.skills[SKI_SHOOT] > 40) and
            (self.outside.skills[SKI_SHOOT] < 51))
      strgb := "skilled";
   else if ((self.outside.skills[SKI_SHOOT] > 50) and
            (self.outside.skills[SKI_SHOOT] < 71))
      strgb := "specialized";
   else if ((self.outside.skills[SKI_SHOOT] > 70) and
            (self.outside.skills[SKI_SHOOT] < 91))
      strgb := "supreme";
   else if ((self.outside.skills[SKI_SHOOT] > 90) and
            (self.outside.skills[SKI_SHOOT] < 101))
      strgb := "expert";
   else if (self.outside.skills[SKI_SHOOT] > 100)
      strgb := "godly";*/

   act("You are " + strga + " at using " + self.title + ".",
      A_ALWAYS, self.outside, null, null, TO_CHAR);

   goto start;
}
dilend /* ranged_need */

dilbegin fashion_weapon(arg : string);

var
   unit1   : unitptr;
   thing   : string;
   thingid : string;
   tstr    : string;
   hm      : integer;
   hm1     : integer;
   tint    : integer;
   cost_of : integer;

code
{
   heartbeat := PULSE_SEC*5;
   interrupt(SFB_COM,self.position==POSITION_FIGHTING,in_fight);
   if (self.type == UNIT_ST_NPC)
   {
   quit;
   }
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_FASHION] <= 0))
      {
         act("You must practice first.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (self.position == POSITION_FIGHTING)
      {
         act("No time for that right now!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (self.outside.movement != SECT_FOREST)
      {
         act("You must be in a forest in order to find the wood for that!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
   if ("$fashioning" in self.extra)
   {act("You are busy making a weapon and decide not to start "
   +"another project until one is finnished!",
    A_ALWAYS, self, null, null, TO_CHAR);
    quit;
   }

 addextra(self.extra, {"$fashioning"}, "");

/*if (dilfind("fashion_weapon@skills", self))
   {act("You are busy making a weapon and decide not to start "
   +"another project until one is finnished!",
    A_ALWAYS, self, null, null, TO_CHAR);
    quit;
   }
*/
   cost_of := rnd(100, 200) - self.skills[SKI_FASHION] / 2;

   if (self.endurance < cost_of)
      {
         act("You haven't the energy. Better rest first.",
             A_ALWAYS, self, null, null, TO_CHAR);
   subextra(self.extra, "$fashioning");
         quit;
      }

   if (("bow" in arg) and (self.skills[SKI_FASHION] < 75))
   {
      act("You need to practice further before you can make a " +
          "bow.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto can_current;
   }

   else if (("fighting staff" in arg) and (self.skills[SKI_FASHION] < 100))
   {
      act("You need to practice further before you can make a " +
          "fighting staff.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto can_current;
   }

   else if (("quarter staff" in arg) and (self.skills[SKI_FASHION] < 25))
   {
      act("You need to practice further before you can make a " +
          "quarter staff.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto can_current;
   }

   else if (("trap" in arg) and (self.skills[SKI_FASHION] < 50))
   {
      act("You need to practice further before you can make a " +
          "quarter staff.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto can_current;
   }


   if (arg == "staff")
   {
      act("What kind of staff?",
          A_ALWAYS, self, null, null, TO_CHAR);
      subextra(self.extra, "$fashioning");
      quit;
   }

   if ("bow" in arg)
      {
         thing := "bow";
         thingid := "bow@skills";
      }
   else if ("arrow" in arg)
      {
         thing := "fine arrow";
         thingid := "arrow@skills";
      }
   else if ("fighting staff" in arg)
      {
         thing := "fighting staff";
         thingid := "f_staff@skills";
      }
   else if ("quarter staff" in arg)
      {
         thing := "quarter staff";
         thingid := "q_staff@skills";
      }
   else if ("trap" in arg)
      {
         thing := "man trap";
         thingid := "man_trap@skills";
      }
   else goto can_current;

   hm := ((self.skills[SKI_FASHION] - 25) / 9) - rnd(0,5);

   if (hm < -5) hm := -5;
   if (hm > 25) hm := 25; /* Not likely but just in case */
   hm1 := hm /2;
   if (hm1 < 0) hm1 := 0;

   act("You set about making a " + thing + " from a fallen tree " +
       "branch.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n sets about making a " + thing + " from a fallen tree " +
       "branch.",
       A_SOMEONE, self, null, null, TO_REST);
   pause;
   self.endurance := self.endurance - cost_of;
   act("You take great care as you survey the work in progress.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n takes great care as $1e surveys the work in progress.",
       A_SOMEONE, self, null, null, TO_REST);
   pause;
//   self.endurance := self.endurance - cost_of;
//   Why twice? Commented out.
   act("You finish making your " + thing + ". You are very proud " +
       "of your work.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n finishes making $1s " + thing + " - $1e looks very proud " +
       "of $1s work.",
   A_SOMEONE, self, null, null, TO_REST);
   unit1 := load(thingid);
   link(unit1, self.inside);
   unit1.value[1] := hm;
   unit1.value[2] := hm1;
   addextra(unit1.extra, {"$identify"},
            "It has a craftsmanship of " + itoa(hm) + " and a magical " +
            "modifier of " + itoa(hm1) + ".");
      subextra(self.extra, "$fashioning");
   quit;

:in_fight:
  act("So much for that idea!",
      A_ALWAYS, self, null, null, TO_CHAR);
   subextra(self.extra, "$fashioning");
  quit;

:can_current:
  tint := self.skills[SKI_FASHION];

  if ((tint >= 0) and (tint < 25))
  {
     act("You can only fashion an arrow right now. If you practice more " +
         "you can fashion a bow, a fighting staff, a quarter " +
         "staff, and a trap too.",
         A_ALWAYS, self, null, null, TO_CHAR);
  }
  else if ((tint >= 25) and (tint < 50))
  {
     act("You can only fashion an arrow or quarter staff right now. " +
         "If you practice more you can fashion a bow, a fighting " +
         "staff, and a trap too.",
         A_ALWAYS, self, null, null, TO_CHAR);
  }
  else if ((tint >= 50) and (tint < 75))
  {
     act("You can only fashion an arrow, a quarter staff, and a trap " +
         "right now. If you practice more you can fashion a bow and a " +
         "fighting staff too.",
         A_ALWAYS, self, null, null, TO_CHAR);
  }
  else if ((tint >= 75) and (tint < 100))
  {
     act("You can fashion an arrow, a quarter staff, a trap, and a " +
         "bow. If you practice more you can fashion a fighting " +
         "staff too.",
         A_ALWAYS, self, null, null, TO_CHAR);
  }
  else
     act("You can only fashion an arrow, a quarter staff, a trap, a " +
         "bow, or a fighting staff.",
         A_ALWAYS, self, null, null, TO_CHAR);
   subextra(self.extra, "$fashioning");
  quit;
}
dilend /* fashion_weapon */

/* This depends on the aggressive@function routine. Basically, if the mob
   which the pc is trying to soothe is susceptible to soothe (this is taken
   care of by aggressive@function), this dil tests if the ranger can soothe
   the mob, and if so, it adds the ranger's name to the $Soothe extra on the
   mob in question so it won't attack the ranger in the future. */

dilbegin soothe(arg : string);

external
   integer skillresist@skills(aa : integer, ad : integer,
                             sa : integer, sd : integer);

var
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;
   hm      : integer;
   targ    : unitptr;
   temp_st : string;   /* Temporary string */
   elist   : extraptr; /* For the $Soothe extra */

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_SOOTHE] <= 0))
      {
         act("You must practice first.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (self.position == POSITION_FIGHTING)
      {
         act("You're a little busy right now!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (arg == "")
      {
         act("What do you wish to soothe?",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ == null) or not visible(self, targ))
      {
         act("That is not here!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (targ.type != UNIT_ST_NPC)
      {
         act("You can't Soothe that!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (not("$Soothe" in targ.extra))
      {
         act("You sense that this one is immune to your skill.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   elist := "$Soothe" in targ.extra;
   if (self.name in elist.descr)
      {
         act("It is already friendly towards you, why bother!?",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if ((targ.position == POSITION_FIGHTING) or
       (targ.position < POSITION_RESTING))
      {
         act("It doesn't notice your attempts to soothe it!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_SOOTHE];
       else
	             skillc := rnd(40,124);
       /*
        skillc:=self.abilities[ABIL_BRA];
       */
       if(targ.type==UNIT_ST_PC)
        skilld:=targ.skills[SKI_SOOTHE];
       else
          skilld := rnd(40,124);

	   /*
        skilld:=targ.abilities[ABIL_BRA];
       */
       skilla:=self.abilities[ABIL_CHA];
       skillb:=targ.abilities[ABIL_CHA];

       hm:=skillresist(skilla,skillb,skillc,skilld);

/*
   if (self.type == UNIT_ST_PC)
      skilla := self.skills[SKI_SOOTHE];
   else
      skilla := self.abilities[ABIL_BRA];

   skilld := targ.abilities[ABIL_BRA];

   hm := skillresist@skills(self.abilities[ABIL_CHA],
                           targ.abilities[ABIL_BRA],
                           skilla, skilld);
*/
   if (hm < -25)
      {
         act("You provoke it into attack!",
             A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n fails to soothe the $3n and provokes it into attack!",
             A_SOMEONE, self, null, targ, TO_REST);
         set_fighting(targ, self);
         quit;
      }

   if (hm < 0)
      {
         act("You unsuccessfully attempt to soothe the $3n.",
             A_ALWAYS, self, null, targ, TO_CHAR);
         act("$1n fails to soothe the $3n.",
             A_SOMEONE, self, null, targ, TO_REST);
         quit;
      }


   act("You manage to soothe the $3n!<br/>It seems to warm to you.",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n soothes $3n, and it seems to warm to $1m.",
       A_SOMEONE, self, null, targ, TO_REST);

   elist := "$Soothe" in targ.extra;
   temp_st := elist.descr;
   temp_st := temp_st + " " + self.name;
   subextra(targ.extra, "$Soothe");
   addextra(targ.extra, {"$Soothe"}, temp_st);

   quit;
}
dilend /* soothe */



dilbegin aware fnpri(FN_PRI_BLOCK-1) shelter_block();
var
   i : integer;

code
{
   :loop:
   wait(SFB_CMD, activator == self);

   if (not dilfind("shelter@skills", self))
      quit;

   log("Block check");
   if (command("north") or command("south") or command("east") or command("west") or 
      command("up") or command("down") or
      command("ne") or command("nw") or
      command("se") or command("sw") or
      command("northeast")  or command("northwest") or
      command("southeast")  or command("southwest") or
      command("enter") or command("climb"))
   {
      log("Block");
      block;

      act("You realize you're busy building a shelter and decide not to move until it is finished!",
          A_ALWAYS, self, null, null, TO_CHAR);
   }
   goto loop;
}
dilend




dilbegin shelter(arg : string);

var
   i        : integer;
   j        : integer;
   lifetime : integer; /* How long the shelter lasts. */
   uname    : string;  /* The shelter type. */
   unit1    : unitptr;
   k        : integer;
code
{
   interrupt(SFB_COM,self.position==POSITION_FIGHTING,in_fight);

   heartbeat:=PULSE_SEC*5;

   if (self.skills[SKI_SHELTER] <= 0)
      {
         act("You must practice first.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
   if ((self.outside.type != UNIT_ST_ROOM) or
       (self.outside.movement == SECT_INSIDE))
      {
         act("You're already inside, why bother?",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
   if (self.outside.objecttype == ITEM_CONTAINER)
   {
         act("You can't make a shelter here.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;

    }

   if ((self.outside.movement != SECT_FOREST) and
       (self.outside.movement != SECT_FIELD) and
       (self.outside.movement != SECT_SWAMP) and
       (self.outside.movement != SECT_SNOW) and
       (self.outside.movement != SECT_ICE))
      {
         act("You can't make a shelter here.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   i := self.skills[SKI_SHELTER] * rnd (1,5);

   if (i <=0)
      {
         lifetime := 3 * PULSE_SEC;
         j := rnd(80, 100);
      }

   if (i < 50)
      {
         lifetime := 5 * PULSE_SEC;
         j := rnd (80, 100);
      }
   else if (i < 100)
      {
         lifetime := 6 * PULSE_SEC;
         j := rnd (60, 80);
      }
   else if (i < 200)
      {
         lifetime := 8 * PULSE_SEC;
         j := rnd (40, 60);
      }
   else if (i < 500)
      {
         lifetime := 10 * PULSE_SEC;
         j := rnd (20,40);
      }

   if (self.endurance < j)
      {
         act("You can't seem to muster the energy to attempt it right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   dilcopy("shelter_block@skills", self);

   act("You set about gathering the materials to construct the shelter.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n sets about gathering the materials to construct a shelter.",
       A_HIDEINV, self, null, null, TO_REST);
   pause;
   act("You begin constructing the shelter.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n starts to build $1s shelter.",
       A_SOMEONE, self, null, null, TO_REST);
   pause;
   act("You complete your shelter.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n completes $1s shelter.",
       A_SOMEONE, self, null, null, TO_REST);

   if (self.outside.movement == SECT_FOREST) uname := "wooden_shack@skills";
   else if ((self.outside.movement == SECT_SNOW) or
            (self.outside.movement == SECT_ICE))
      uname := "igloo@skills";
   else uname := "grass_hut@skills";

   unit1 := load(uname);
   link(unit1, self.outside);
   dilcopy("shelter_rot@skills(" + itoa(lifetime) + ")", unit1);
   self.endurance := self.endurance - 40;
   quit;

:in_fight:
   act("Well so much for that idea!",
       A_ALWAYS, self, null, null, TO_CHAR);
   quit;
}
dilend /* shelter */



dilbegin shelter_rot(str_time : integer);

var
   shelter_t : string;  /* temp string */
   temp_t    : unitptr; /* temp unitptr */

code
{
   heartbeat := PULSE_SEC * 60 * str_time;

   pause;
   if ("shack" in self.names) shelter_t := "The wooden shack begins to rot.";
   else if ("igloo" in self.names) shelter_t := "The igloo begings to melt " +
                                                "and collapse.";
   else shelter_t := "The grass hut begins to rot.";

   act(shelter_t,
       A_SOMEONE, self, null, null, TO_ALL);
   act(shelter_t,
       A_SOMEONE, self.inside, null, null, TO_ALL);

   heartbeat := PULSE_SEC * 20;
   pause;
   while (self.inside) link(self.inside, self.outside);

   if ("shack" in self.names) shelter_t := "The wooden shack collapses.";
   else if ("igloo" in self.names) shelter_t := "The igloo collapses.";
   else shelter_t := "The grass hut collapses.";

   act(shelter_t,
       A_SOMEONE, self, null, null, TO_ALL);

   if ("shack" in self.names) shelter_t := "wood@skills";
   else if ("igloo" in self.names) shelter_t := "ice@skills";
   else shelter_t := "grass@skills";

   temp_t := load(shelter_t);
   link(temp_t, self.outside);

   if ("shack" in self.names) shelter_t := "The grass rots away.";
   else if ("igloo" in self.names) shelter_t := "The ice melts.";
   else shelter_t := "The wood rots.";

   dilcopy("blowaway@function(300, " + shelter_t +")", temp_t);

   destroy(self);
   quit;
}
dilend /* shelter rot */


dilbegin ambush(arg : string);

var
   targ     : unitptr;
   gotweap  : unitptr;
   weaptype : integer;
   bonus    : integer;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_AMBUSH] <= 0))
      {
         act("You must practice first.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (self.position == POSITION_FIGHTING)
      {
         act("Maybe when you're not as busy?",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

/* Why was this removed and no end charged? Charging end would prevent the
over usage of the command */
   if (self.endurance < 20)
      {
         act("You haven't the energy. Better rest first.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
      else self.endurance := self.endurance - 20;

   if (not(isset(self.charflags, CHAR_HIDE)))
      {
         act("How do you expect to ambush someone when you're not " +
             "hiding?!?",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   gotweap := equipment(self, WEAR_WIELD);
   if (gotweap == null)
      {
         act("It would help if you were wielding something you know.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   weaptype := gotweap.value[0];

   if (arg == "")
      {
         act("Ambush who?",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if ((targ == null) or not visible(self, targ))
      {
         act("That person is not here!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
      {
         act("You can't ambush that, silly! Sheesh some people.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

   if (targ == self)
      {
         act("You ambush yourself. Very amusing.",
             A_ALWAYS, self, null, null, TO_CHAR);
         act("$1n ambushes $1mself. It's rather strange looking, " +
             "trust me.",
             A_HIDEINV, self, null, null, TO_REST);
         quit;
      }

   if ((targ.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
      {
         if (not(isset (self.pcflags, PC_PK_RELAXED)))
            {
               act("You are not allowed to do that unless you sign " +
                   "the book of blood.",
                   A_ALWAYS, self, null, null, TO_CHAR);
                   quit;
            }

         if (not(isset (targ.pcflags, PC_PK_RELAXED)))
            {
               act("You are not allowed to do that unless $2e signs " +
                   "the book of blood.",
                   A_ALWAYS, self, targ, null, TO_CHAR);
               quit;
            }
      }

   if (isset (targ.charflags, CHAR_DETECT_LIFE)) bonus := -25;
   else bonus := +25;

   act("You ambush $3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n appears from nowhere and ambushes you!",
       A_ALWAYS, self, null, targ, TO_VICT);
   act("$1n appears from nowhere and ambushes $3n!",
       A_SOMEONE, self, null, targ, TO_NOTVICT);
   bonus := meleeattack(self, targ, (bonus + self.level), 0);
   quit;
}
dilend /* ambush */

/* forage skill by Saor, October, 1997 */
dilbegin forage(arg : string);
external
      integer skillresist@skills(aa : integer, ad : integer,
                                sa : integer, sd : integer);
var
   food : unitptr;
   u    : unitptr;
   i    : integer;
   t    : integer;
   pois : integer;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;

code
{

    pois := 0;
    u := self.outside;
    if ((self.type == UNIT_ST_PC) and (self.skills[SKI_FORAGE] <= 0))
    {
       act("You must practice first.", A_ALWAYS, self, null, null,
           TO_CHAR);
       quit;
    }

    if (u.type != UNIT_ST_ROOM)
    {
       act("You are not able to forage from here.", A_ALWAYS, self,
           null, null, TO_CHAR);
       quit;
    }

    act("$1n begins to search the area for food.", A_SOMEONE, self,
        null, null, TO_REST);
    act("You begin to search the area for food.", A_ALWAYS, self,
        null, null, TO_CHAR);

    if (self.endurance < 20)
    {
       act("You are too exhausted.", A_SOMEONE, self, null, null,
           TO_CHAR);
       quit;
    }
    else self.endurance := self.endurance - 20;
    position_update(self);
    on u.movement goto c1, c2, c3, c4, c5, c6, c7, c8, c9,
                       c10, c11, c12, c13, c14;
    act("You are confused.", A_ALWAYS, self, null, null, TO_CHAR);
    quit;

    :c1: /* city */
    :c2: /* inside */
    :c14: /* ice */
    act("There is no chance of finding food here.", A_ALWAYS, self,
        null, null, TO_CHAR);
    quit;

    :c3: /* field */
    t := rnd(0, 4);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_FORAGE], 100);
    goto test;

    :c4: /* forest */
    t := rnd(0, 8);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_FORAGE], 100);
    goto test;

    :c5: /* hills */
    t := rnd(0, 4);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_FORAGE], 50);
    goto test;

    :c6: /* mountain */
    t := rnd(2, 4);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_FORAGE], 0);
    goto test;

    :c7: /* desert */
    t := 9;
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_FORAGE], 200);
    goto test;

    :c8: /* swamp */
    t := rnd(10, 16);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_FORAGE], 0);
    goto test;

    :c9: /* water swim */
    :c10: /* water sail */
    :c11: /* under water */
    t := rnd(10, 14);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_FORAGE], 50);
    goto test;

    :c12: /* snow */
    :c13: /* slush */
    t := rnd(0, 1);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_FORAGE], 200);
    goto test;

    :test:
    if (self.abilities[ABIL_BRA] >= 100)
    {
       i := i + 0;
    }
    else if (self.abilities[ABIL_BRA] >= 80)
    {
       i := i + rnd(1, 5);
    }
    else if (self.abilities[ABIL_BRA] >= 50)
    {
       i := i + rnd(1, 10);
    }
    else if (self.abilities[ABIL_BRA] >= 30)
    {
       i := i + rnd(1, 20);
    }
    else if (self.abilities[ABIL_BRA] >= 0) i := i + rnd(1, 30);
    if (i == 0) goto zero;
    if (i < 0) goto bust;
    if (i > 0) goto yay;

    :zero:
    act("You find dirt.", A_SOMEONE, self, null, null, TO_CHAR);
    quit;

    :bust:
    act("You find nothing.", A_SOMEONE, self, null, null, TO_CHAR);
    quit;

    :yay:
    on t goto f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13,
              f14, f15, f16, f17;
    act("You get bloody fingernails.", A_ALWAYS, self, null, null,
        TO_CHAR);
    quit;

    :f1: /* roots */
    act("$1n digs around and finds some roots.", A_SOMEONE, self, null,
        null, TO_REST);
    act("You dig around and find some roots.", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("roots@skills");
    pois := rnd(1, 100);
    if (pois >= 75) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f2: /* tubers */
    act("$1n digs around and finds some tubers.", A_SOMEONE, self, null,
        null, TO_REST);
    act("You dig around and find some tubers.", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("tubers@skills");
    pois := rnd(1, 100);
    if (pois >= 75) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f3: /* berries */
    act("$1n picks some berries.", A_SOMEONE, self, null, null, TO_REST);
    act("You pick some berries.", A_ALWAYS, self, null, null, TO_CHAR);
    food := load("berries@skills");
    pois := rnd(1, 100);
    if (pois >= 80) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f4: /* grubs */
    act("$1n finds some grubs underneath a log.", A_SOMEONE, self,
        null, null, TO_REST);
    act("You find some grubs underneath a log.", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("grubs@skills");
    pois := rnd(1, 100);
    if (pois >= 60) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f5: /* bird egg */
    act("$1n finds a bird egg!", A_SOMEONE, self, null, null, TO_REST);
    act("You find a bird egg!", A_ALWAYS, self, null, null, TO_CHAR);
    food := load("egg@skills");
    pois := rnd(1, 100);
    if (pois >= 90) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f6: /* mushroom */
    act("$1n picks a mushroom.", A_SOMEONE, self, null, null, TO_REST);
    act("You pick a mushroom.", A_ALWAYS, self, null, null, TO_CHAR);
    food := load("mushroom@skills");
    pois := rnd(1, 100);
    if (pois >= 50) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f7: /* truffle */
    act("$1n digs around and finds a truffle!", A_SOMEONE, self, null,
        null, TO_REST);
    act("You dig around and find a truffle!", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("truffle@skills");
    pois := rnd(1, 100);
    if (pois >= 95) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f8: /* fruit */
    act("$1n picks some fruit off a nearby tree.", A_SOMEONE, self,
        null, null, TO_REST);
    act("You pick some fruit off a nearby tree.", A_ALWAYS, self,
        null, null, TO_CHAR);
    food := load("fruit@skills");
    pois := rnd(1, 100);
    if (pois >= 85) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f9: /* nuts */
    act("$1n picks some nuts from a nearby tree.", A_SOMEONE, self,
        null, null, TO_REST);
    act("You pick some nuts from a nearby tree.", A_ALWAYS, self,
        null, null, TO_CHAR);
    food := load("nuts@skills");
    pois := rnd(1, 100);
    if (pois >= 90) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f10:
    act("$1n finds a lizard under a rock and kills it.", A_SOMEONE,
        self, null, null, TO_REST);
    act("You find a lizard and break its neck.", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("d_lizard@skills");
    pois := rnd(1, 100);
    if (pois >= 65) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f11:
    act("$1n finds a newt on a log and kills it.", A_SOMEONE, self,
        null, null, TO_REST);
    act("You find a newt and crush it to death.", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("d_newt@skills");
    pois := rnd(1, 100);
    if (pois >= 60) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f12:
    act("$1n finds a big slimy gob of algae.", A_SOMEONE, self, null,
        null, TO_REST);
    act("You find a big slimy gob of algae.", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("algae@skills");
    pois := rnd(1, 100);
    if (pois >= 75) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f13:
    act("$1n finds a clump of green kelp.", A_SOMEONE, self, null,
        null, TO_REST);
    act("You find a clump of green kelp.", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("kelp@skills");
    pois := rnd(1, 100);
    if (pois >= 85) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f14:
    act("$1n finds a sleek silver fish!", A_SOMEONE, self, null,
        null, TO_REST);
    act("You find a sleek silver fish and gut it quickly.", A_ALWAYS,
        self, null, null, TO_CHAR);
    food := load("d_fish@skills");
    pois := rnd(1, 100);
    if (pois >= 90) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f15:
    act("$1n finds a big bullfrog covered in slime.", A_SOMEONE,
        self, null, null, TO_REST);
    act("You find a big ugly bullfrog and kill it before it escapes.",
        A_ALWAYS, self, null, null, TO_CHAR);
    food := load("d_frog@skills");
    pois := rnd(1, 100);
    if (pois >= 55) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f16:
    act("$1n finds a huge slimy snail and plucks it from the shell.",
        A_SOMEONE, self, null, null, TO_REST);
    act("You find a huge slimy snail and pluck it from its shell.",
        A_ALWAYS, self, null, null, TO_CHAR);
    food := load("d_snail@skills");
    pois := rnd(1, 100);
    if (pois >= 40) food.value[3] := rnd(1,10);
    link(food, u);
    quit;

    :f17:
    act("$1n finds a giant squirming slug!", A_SOMEONE, self, null,
        null, TO_REST);
    act("You find a gigantic squirming slug!", A_ALWAYS, self, null,
        null, TO_CHAR);
    food := load("d_slug@skills");
    pois := rnd(1, 100);
    if (pois >= 40) food.value[3] := rnd(1,10);
    link(food, u);
    quit;
}
dilend
/* end of forage skill */

/* dowse by Saor, September 1997 */
dilbegin dowse(arg : string);
external
      integer skillresist@skills(aa : integer, ad : integer,
                                sa : integer, sd : integer);
var
    u    : unitptr;
    w    : unitptr;
    i    : integer;
    pois : integer;
code
{

    pois := 0;
    u := self.outside;
    if ((self.type == UNIT_ST_PC) and (self.skills[SKI_DOWSE] <= 0))
    {
       act("You must practice first.", A_ALWAYS, self, null, null,
           TO_CHAR);
       quit;
    }

    if (u.type != UNIT_ST_ROOM)
    {
       act("You are not able to dowse from here.", A_SOMEONE, self, null,
           null, TO_CHAR);
       quit;
    }

    act("$1n begins to search the area for water.", A_SOMEONE, self,
        null, null, TO_REST);
    act("You begin to search the area for water.", A_SOMEONE, self,
        null, null, TO_CHAR);

    if (self.endurance < 20)
    {
       act("You are too exhausted.", A_SOMEONE, self, null, null,
           TO_CHAR);
       quit;
    }
    else self.endurance := self.endurance - 20;

    on u.movement goto c1, c2, c3, c4, c5, c6, c7, c8, c9,
                       c10, c11, c12, c13, c14;
    act("You are confused.", A_SOMEONE, self, null, null, TO_CHAR);
    quit;

    :c1: /* city */
    :c2: /* inside */
    act("There is no chance of finding water here.", A_SOMEONE, self,
        null, null, TO_CHAR);
    quit;

    :c3: /* field */
    :c4: /* forest */
    act("The chances of finding water here are good.", A_SOMEONE, self,
        null, null, TO_CHAR);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_DOWSE], 100);
    goto test;

    :c5: /* hills */
    act("The chances of finding water here are very good.", A_SOMEONE,
        self, null, null, TO_CHAR);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_DOWSE], 50);
    goto test;

    :c6: /* mountain */
    act("The chances of finding water here are excellent.", A_SOMEONE,
        self, null, null, TO_CHAR);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_DOWSE], 0);
    goto test;

    :c7: /* desert */
    act("The chances of finding water here are poor.", A_SOMEONE,
        self, null, null, TO_CHAR);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_DOWSE], 200);
    goto test;

    :c8: /* swamp */
    act("The chances of finding water here are excellent, but it may "+
        "be tainted.", A_SOMEONE, self, null, null, TO_CHAR);
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_DOWSE], 0);
    pois := 1;
    goto test;

    :c9: /* water swim */
    :c10: /* water sail */
    :c11: /* under water */
    act("There is water all around you!", A_SOMEONE, self, null, null,
        TO_CHAR);
    act("$1n looks sheepish.", A_SOMEONE, self, null, null, TO_REST);
    act("$1n realizes that there is water all around, and isolates "+
        "some for general use.", A_SOMEONE, self, null, null, TO_REST);
    act("$1n fashions a cup from dead leaves, and fills it with water.",
        A_SOMEONE, self, null, null, TO_REST);
    act("You fashion a cup from dead leaves and fill it with water.",
        A_SOMEONE, self, null, null, TO_CHAR);
    w := load("b_leafcup@skills");
    link(w, u);
    quit;

    :c12: /* snow */
    :c13: /* slush */
    :c14: /* ice */
    act("$1n takes some snow and ice in $1s hand and begins to melt "+
        "it...", A_SOMEONE, self, null, null, TO_REST);
    act("You take some snow and ice into your hand and begin to melt "+
        "it...", A_SOMEONE, self, null, null, TO_CHAR);
    act("The cold causes your hand to freeze!", A_SOMEONE, self,
        null, null, TO_CHAR);
    act("The cold causes $1n's hand to freeze!", A_SOMEONE, self,
        null, null, TO_REST);
    self.hp := self.hp - rnd(1, 10);
    position_update(self);
    if (self.position <= POSITION_STUNNED) quit;
    act("You melt some snow and ice into a small pool.", A_SOMEONE, self,
        null, null, TO_CHAR);
    act("$1n melts some snow and ice into a small pool.", A_SOMEONE, self,
        null, null, TO_REST);
    w := load("b_icepool@skills");
    link(w, u);
    quit;

    :test:
    if (self.abilities[ABIL_BRA] >= 100)
    {
       i := i + 0;
    }
    else if (self.abilities[ABIL_BRA] >= 80)
    {
       i := i + rnd(1, 5);
    }
    else if (self.abilities[ABIL_BRA] >= 50)
    {
       i := i + rnd(1, 10);
    }
    else if (self.abilities[ABIL_BRA] >= 30)
    {
       i := i + rnd(1, 20);
    }
    else if (self.abilities[ABIL_BRA] >= 0) i := i + rnd(1, 30);
    if (i == 0) goto zero;
    if (i < 0) goto bust;
    if (i > 0) goto yay;

    :zero:
    act("You find dampness.", A_SOMEONE, self, null, null, TO_CHAR);
    quit;

    :bust:
    act("You find nothing.", A_SOMEONE, self, null, null, TO_CHAR);
    quit;

    :yay:
    act("$1n finds a hidden spring which bubbles up at your feet!",
        A_SOMEONE, self, null, null, TO_REST);
    act("You find a hidden spring which bubbles up at your feet!",
        A_SOMEONE, self, null, null, TO_CHAR);
    w := load("b_spring@skills");
    if (pois) w.value[3] := rnd(0, 4);
    link(w, u);
    quit;
}
dilend
/* end of dowse skill */

/* custom blowaway type dil for dowse objects */
dilbegin empty();
code
{
   heartbeat := PULSE_SEC*9;

   wait(SFB_CMD, command("drink") or command("pour"));

   if ((self.value[1] <= 0) and (self.nameidx == "b_spring"))
   {
      pause;
      act("$1n dries up and disappears.", A_SOMEONE, self, null, null,
          TO_ALL);
      destroy(self);
   }

   if ((self.value[1] <= 0) and (self.nameidx == "b_leafcup"))
   {
      pause;
      act("$1n crumbles into bits of dead leaves.", A_SOMEONE, self,
          null, null, TO_ALL);
      destroy(self);
   }
}
dilend
/* end of empty dil */

/* herbs skill by Saor, September, 1997 */
dilbegin herbs(arg : string);
external
      integer skillresist@skills(aa : integer, ad : integer,
                                sa : integer, sd : integer);
var
   u : unitptr;
   t : unitptr;
   i : integer;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;

code
{

    u := self.outside;
    if ((self.type == UNIT_ST_PC) and (self.skills[SKI_HERBS] <= 0))
    {
       act("You must practice first.", A_ALWAYS, self, null, null,
           TO_CHAR);
       quit;
    }

    if (u.type != UNIT_ST_ROOM)
    {
       act("You can not find herbs from here.", A_SOMEONE, self, null,
           null, TO_CHAR);
       quit;
    }

    if ((arg == "") or (arg == "self"))
    {
       t := self;
       goto doit;
    }

    t := findunit(self, arg, FIND_UNIT_SURRO, null);
    if ((t == null) or not visible(self, t))
    {
       act("There is nothing here by that name.", A_ALWAYS, self, null,
           null, TO_CHAR);
       quit;
    }

    if ((t.type == UNIT_ST_OBJ) or (t.type == UNIT_ST_ROOM))
    {
       act("It is not possible to heal that!", A_ALWAYS, self, null,
           null, TO_CHAR);
       quit;
    }

    :doit:
    if (t.hp == t.max_hp)
    {
       act("$2n does not need to be healed.", A_SOMEONE, self, t,
           null, TO_CHAR);
       quit;
    }

    act("$1n begins to search for medicinal herbs.", A_SOMEONE, self,
        null, null, TO_REST);
    act("You begin to search for medicinal herbs.", A_ALWAYS, self,
        null, null, TO_CHAR);

    if (self.endurance < 20)
    {
       act("You are too exhausted.", A_SOMEONE, self, null, null,
           TO_CHAR);
       quit;
    }
    else self.endurance := self.endurance - 20;

    on u.movement goto c1, c2, c3, c4, c5, c6, c7, c8, c9,
                       c10, c11, c12, c13, c14;
    act("You are confused.", A_SOMEONE, self, null, null, TO_CHAR);
    quit;

    :c1: /* city */
    :c2: /* inside */
    act("There are no plants of medicinal value here.", A_ALWAYS, self,
        null, null, TO_CHAR);
    quit;

    :c3: /* field */
    :c4: /* forest */
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_HERBS], 0);
    goto test;

    :c5: /* hills */
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_HERBS], 50);
    goto test;

    :c6: /* mountain */
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_HERBS], 100);
    goto test;

    :c7: /* desert */
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_HERBS], 200);
    goto test;

    :c8: /* swamp */
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_HERBS], 50);
    goto test;

    :c9: /* water swim */
    :c10: /* water sail */
    :c11: /* under water */
    i := skillresist@skills(self.abilities[ABIL_BRA], 0,
                           self.skills[SKI_HERBS], 50);
    goto test;

    :c12: /* snow */
    :c13: /* slush */
    :c14: /* ice */
    act("There are no plants of medicinal value here.", A_ALWAYS, self,
        null, null, TO_CHAR);
     quit;

    :test:
    if (self.abilities[ABIL_BRA] >= 100)
    {
       i := i + 0;
    }
    else if (self.abilities[ABIL_BRA] >= 80)
    {
       i := i + rnd(1, 5);
    }
    else if (self.abilities[ABIL_BRA] >= 50)
    {
       i := i + rnd(1, 10);
    }
    else if (self.abilities[ABIL_BRA] >= 30)
    {
       i := i + rnd(1, 20);
    }
    else if (self.abilities[ABIL_BRA] >= 0) i := i + rnd(1, 30);
    if (i == 0) goto zero;
    if (i < 0) goto bust;
    if (i > 0) goto yay;

    :zero:
    act("You find something you can not quite identify. Better not "+
        "risk using it.", A_ALWAYS, self, null, null, TO_CHAR);
    quit;

    :bust:
    act("You find nothing.", A_ALWAYS, self, null, null, TO_CHAR);
    quit;

    :yay:
    if (t == self)
    {
       act("$1n finds some medicinal herbs which $1e uses to heal "+
           "$1mself.", A_SOMEONE, self, null, null, TO_REST);
       act("You find some medicinal herbs which you use to heal "+
           "yourself.", A_ALWAYS, self, null, null, TO_CHAR);
    }
    else
    {
       act("$1n finds some medicinal herbs which $1e uses to heal $2n.",
           A_SOMEONE, self, t, null, TO_REST);
       act("You find some medicinal herbs which you use to heal $2n.",
           A_SOMEONE, self, t, null, TO_CHAR);
    }
    t.hp := t.hp + rnd(1, i);
    if (t.hp > t.max_hp) t.hp := t.max_hp;
    position_update(t);
    act("You feel better.", A_ALWAYS, self, null, t, TO_VICT);
    act("$3n looks better.", A_SOMEONE, self, null, t, TO_NOTVICT);
    quit;
}
dilend
/* end of herbs skill */

dilbegin cook(arg : string);
external
      integer skillresist@skills(aa : integer, ad : integer,
                                sa : integer, sd : integer);
var
   u    : unitptr;
   t    : unitptr;
   fire : unitptr;
   i    : integer;
code
{

    u := self.outside;
    if ((self.type == UNIT_ST_PC) and (self.skills[SKI_COOK] <= 0))
    {
       act("You must practice first.", A_ALWAYS, self, null, null,
           TO_CHAR);
       quit;
    }

    if (self.position == POSITION_FIGHTING)
    {
       act("No way! You are fighting for your life!", A_ALWAYS, self,
           null, null, TO_CHAR);
       quit;
    }

    if (u.type != UNIT_ST_ROOM)
    {
       act("You can not start a fire here.", A_ALWAYS, self, null,
           null, TO_CHAR);
       quit;
    }

    if (arg == "")
    {
       act("Cook what?", A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    if (arg == "self")
    {
       act("You must be really hungry!", A_ALWAYS, self, null, null,
           TO_CHAR);
       act("You stare at your hand for a moment then shake your head.",
           A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    t := findunit(self, arg, FIND_UNIT_HERE, null);
    if ((t == null) or not visible(self, t))
    {
       act("There is nothing here by that name.", A_ALWAYS, self, null,
           null, TO_CHAR);
       quit;
    }

    if (t.type != UNIT_ST_OBJ)
    {
       act("It is not possible to cook that!", A_ALWAYS, self, null,
           null, TO_CHAR);
       quit;
    }

    if (t.objecttype != ITEM_FOOD)
    {
       act("You can only cook food!", A_ALWAYS, self, null, null,
           TO_CHAR);
       quit;
    }

    if (self.endurance < 20)
    {
       act("You are too exhausted.", A_SOMEONE, self, null, null,
           TO_CHAR);
       quit;
    }
    else self.endurance := self.endurance - 20;

    if ((u.movement >= SECT_WATER_SWIM) or (u.movement <= SECT_CITY))
    {
       act("You cannot build a fire here.", A_ALWAYS, self, null,
           null, TO_CHAR);
       quit;
    }

    if ("(cooked)" in t.outside_descr)
    {
       act("That food is already cooked!", A_ALWAYS, self, null, null,
           TO_CHAR);
       quit;
    }

    fire := findunit(self, "campfire", FIND_UNIT_SURRO, null);
    if (fire.nameidx == "campfire_0") goto cookit;

    act("$1n begins to build a fire.", A_SOMEONE, self, null, null,
        TO_REST);
    act("You begin to build a fire.", A_ALWAYS, self, null, null,
        TO_CHAR);

    i := skillresist@skills(self.abilities[ABIL_DEX], 0,
                           self.skills[SKI_COOK], u.movement*27);

    if (i <= 0)
    {
       act("You were not able to find enough materials to start a "+
           "fire.", A_ALWAYS, self, null, null, TO_CHAR);
       quit;
    }

    act("$1n finds some kindling and rubs two sticks together, "+
        "starting a small campfire.", A_SOMEONE, self, null, null,
        TO_REST);
    act("You find some kindling and rub two sticks together, "+
        "starting a small campfire.", A_ALWAYS, self, null, null,
        TO_CHAR);
    fire := load("campfire_0@skills");
    link(fire, u);

    :cookit:
    act("The campfire flares into life, and $1n begins to cook the "+
        "$2N.", A_SOMEONE, self, t, null, TO_REST);
    act("The campfire flares into life and you begin to cook the "+
        "$2N.", A_ALWAYS, self, t, null, TO_CHAR);
    t.title := t.title + " (cooked)";
    t.outside_descr := t.outside_descr + " (cooked)";
    t.value[0] := t.value[0] + rnd(5,15);
    if (t.value[3] <= 10)
    {
        t.value[3] := 0;
    }
    else t.value[3] := t.value[3] - rnd(5,10);
    act("The fire sizzles and the food is done.", A_ALWAYS, self, null,
        null, TO_ALL);
    quit;
}
dilend
/* end of cook skill */

/* End Rangers version 1 */

/* Mesmer- Rewrite of base coded scroll use */
dilbegin ski_scroll_use(arg : string);
external
    integer skillresist@skills(aa : integer,ad : integer,sa : integer,sd : integer);

var
scroll : unitptr;
i      : integer;
skia   : integer;
skib   : integer;
hm     : integer;
tgt    : unitptr;
sc_st  : string;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;


code
{

 if(arg == "")
 {
  act("What do you want to recite?",
       A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(self.skills[SKI_SCROLL_USE] <= 0)
 {
  act("You must practice first.",
       A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(isset(self.charflags,CHAR_BLIND))
 {
  act("You can't see anything!!! You're blind!",
        A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }


 scroll := findunit(self,arg,FIND_UNIT_IN_ME,null);

 if(scroll == null)
 {
  act("You do not have such an item.",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(scroll.objecttype != ITEM_SCROLL)
 {
  act("Recite is normally used for scroll's.",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(arg == "")
  tgt := self;
   else
    tgt := findunit(self,arg,FIND_UNIT_SURRO,null);

  if(tgt == null)
   {
    act("No such thing around to recite the scroll on.",
      A_ALWAYS, self, null, null, TO_CHAR);
     quit;
   }
       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_SCROLL_USE];
       else
                 skillc := rnd(40,124);
       /*
	    skillc:=self.abilities[ABIL_BRA] / 3;
       */
       if(tgt.type==UNIT_ST_PC)
        skilld:=tgt.skills[SKI_SCROLL_USE];
       else
	             skilld := rnd(40,124);
       /*
        skilld:=tgt.abilities[ABIL_BRA] / 2;
       */
       skilla:=scroll.value[0];
       skillb:=scroll.value[0];

       hm:=skillresist(skilla,skillb,skillc,skilld);

/*
  if(self.type == UNIT_ST_PC)
     skia := self.skills[SKI_SCROLL_USE];
   else
    skia := self.abilities[ABIL_BRA];

  skib := self.abilities[ABIL_BRA];

 hm := skillresist@skills(skia,scroll.value[0],skib,scroll.value[0]);
*/
 if(hm < -50)
 {
  act("You failed to recite the scroll properly.",
     A_ALWAYS, self, null, null, TO_CHAR);
  act("You fail to recite $2n which then crumbles to dust.",
     A_ALWAYS, self, scroll, null, TO_CHAR);
  destroy(scroll);
  quit;
 }

 if(hm < 0)
 {
   act("You failed to recite the scroll properly.",
       A_ALWAYS, self, null, null, TO_CHAR);
   quit;
 }

 act("You recite $2n which dissolves.",
    A_ALWAYS, self, scroll, null, TO_CHAR);

 scroll.spells[SPL_ALL] := scroll.value[0];
 i := 1;

 while( i <= 3 )
 {

  if(scroll.value[i] != SPL_NONE)
   cast_spell(scroll.value[i],self,scroll,tgt);

  i := i + 1;
 }

  send_done("recite",self,scroll,tgt,0,arg,null);


 destroy(scroll);
 quit;
}
dilend

dilbegin ski_turn(arg : string);
external
    integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);
    provoked_attack (victim : unitptr, ch : unitptr);
var
tgt    : unitptr;
hm     : integer;
skilla : integer;
skillb : integer;
skillc : integer;
skilld : integer;

code
{

 if(self.skills[SKI_TURN_UNDEAD] <= 0)
 {
  act("You failed.", A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 tgt := findunit(self,arg,FIND_UNIT_SURRO,null);

 if(tgt == null)
 {
  act("No such undead here?",
       A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(not(tgt.type & (UNIT_ST_PC | UNIT_ST_NPC)))
 {
  act("This one is stone dead for sure!",
      A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 /* Undead PC ? Thats an idea */

 if(self.type == UNIT_ST_PC)
  skillc := self.skills[SKI_TURN_UNDEAD];
   else
             skillc := rnd(40,124);

   /*
    skillc := self.abilities[ABIL_DIV];
    */
 if(tgt.type == UNIT_ST_PC)
   skilld := tgt.skills[SKI_TURN_UNDEAD];
       else
          skilld := rnd(40,124);
 	/*
     skilld := tgt.abilities[ABIL_DIV];
    */
 skilla := self.abilities[ABIL_DIV];
 skillb := tgt.abilities[ABIL_DIV];

 hm := skillresist(skilla,skillb,skillc,skilld);
 if((hm >= 0) and (RACE_IS_UNDEAD(tgt.race)))
 {
if (self.endurance<20) self.endurance:=0;
else
self.endurance:=self.endurance-20;
if (self.endurance==0)
  {
   self.position:=POSITION_STUNNED;
   quit;
   }


  act("$3n is terrified!",
      A_SOMEONE, self, null, tgt, TO_CHAR);
  act("$1n turns $3n!",
      A_SOMEONE, self, null, tgt, TO_NOTVICT);
  act("You are turned by $1n!",
      A_SOMEONE, self, null, tgt, TO_VICT);


  send_done("turn",self,null,tgt,0,arg,null);

  exec("flee", tgt);

  }
   else
    {
      act("$3n seems to ignore your attempt.",
          A_SOMEONE, self, null, tgt, TO_CHAR);
      act("$1n attempts to turn $3n.",
          A_SOMEONE, self, null, tgt, TO_NOTVICT);
      act("$1n attempts to turn you.",
          A_SOMEONE, self, null, tgt, TO_VICT);
          provoked_attack(tgt,self);
     }
 quit;
}
dilend


dilbegin ski_appraise(arg : string);
external
  integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);

var
hm   : integer;
skia : integer;
val  : integer;
item : unitptr;
f    : integer;
mstr : string;

code
{

 if(arg == "")
 {
  act("Appraise what?",
    A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(self.skills[SKI_APPRAISAL] <= 0)
 {
  act("You must practice first.",
    A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 item := findunit(self,arg,FIND_UNIT_HERE,null);

 if(item == null)
 {
 act("No such thing around.",
    A_ALWAYS, self, null, null, TO_CHAR);
 quit;
 }

 if(item.type != UNIT_ST_OBJ)
 {
  act("It is not possible to estimate $3s value.",
    A_SOMEONE, self, null, item, TO_CHAR);
  quit;
 }

 if(self.type == UNIT_ST_PC)
   skia := self.skills[SKI_APPRAISAL];
    else
     skia := self.abilities[ABIL_BRA];

 hm := skillresist(self.abilities[ABIL_BRA],50,skia,0);

 val := item.cost;

 if(hm < 0)
 {

   f := -hm / 100;

   val := val * f;
 }

 if(val < 8)
  val := 8;

 mstr := moneystring(val,TRUE);

 act("It's probably worth $2t to the right person.",
   A_SOMEONE,self,mstr,null,TO_CHAR);

  send_done("appraise",self,item,null,0,arg,null);


 quit;

}
dilend

dilbegin ski_ventril(arg : string);
external
  integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);

var
hm   : integer;
skia : integer;
skib : integer;
abia : integer;
abib : integer;
vict : unitptr;
str  : string;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;


code
{

 if(arg == "")
 {
  act("Who or what should speak?",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(self.skills[SKI_VENTRILOQUATE] <= 0)
 {
  act("You must practice first.",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 vict := findunit(self,arg,FIND_UNIT_SURRO,null);

 if(vict == null)
 {
  act("No such thing here.",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(arg == "")
 {
  sendtext("What should be said?<br/>", self);
  quit;
 }

/* Moan why did papi have to do it this way? */

 if(self.type & (UNIT_ST_PC | UNIT_ST_NPC))
   abia := self.abilities[ABIL_BRA] +
           self.abilities[ABIL_CHA];
   else
    abia := 50;

  if(abia < 50) abia := 50;

 if(self.type == UNIT_ST_PC)
   skia := self.skills[SKI_VENTRILOQUATE];
    else
     skia := abia;

 if(vict.type & (UNIT_ST_PC | UNIT_ST_NPC))
   abib := vict.abilities[ABIL_BRA] +
           vict.abilities[ABIL_CHA];
    else
     abib := 50;

  if(vict.type == UNIT_ST_PC)
    skib := vict.skills[SKI_VENTRILOQUATE];
     else
      skib := abib;

/*
 Since I have no skip_spaces funciton I'll do it this way.
 Here what I had by just repeating the arg...
 Healer Koarn seems to say ' blah'
 Stupid spaces.
*/

 str := getword(arg);

 if(arg != "")
  arg := str+" "+arg;
 else
  arg := str;

  hm := skillresist(abia,abib,skia,skib);


  if(hm >= 0)
   {
    act("<div class='say_other'>$1n says '$2t'</div>",A_HIDEINV,vict,arg,self,TO_NOTVICT);
    act("Someone says '$2t'",A_HIDEINV,vict,arg,self,TO_CHAR);
    act("$1n seems to say '$2t'",A_SOMEONE, vict, arg, self, TO_VICT);

    send_done("ventriloquate",self,null,vict,0,arg,null);

   }
   else
    {
     act("$3n says '$2t'<br/>in a funny way.",A_HIDEINV, vict, arg, self, TO_NOTVICT);
     act("$3n says '$2t'<br/>in a funny way.",A_HIDEINV, vict, arg, self, TO_CHAR);
     act("$1n seems to say '$2t'",A_SOMEONE, vict, arg, self, TO_VICT);
     }

 quit;
}
dilend

dilbegin ski_weather(arg : string);
external
   integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);

var
skia : integer;
chng : integer;
list : stringlist;
hm   : integer;
room : unitptr;

code
{

 list := {"cloudless",
          "cloudy",
          "rainy",
          "lit by flashes of lightning"};

 room := self.outside;

 if((room.type != UNIT_ST_ROOM) or
    (room.flags & (UNIT_FL_NO_WEATHER | UNIT_FL_INDOORS)))
 {
  act("You can't see the sky from here.",
      A_ALWAYS, self, null, null, TO_CHAR);
  quit;
  }
 else
  act("The sky is $3t.",
      A_ALWAYS, self, null, list.[weather], TO_CHAR);

 if(self.type == UNIT_ST_PC)
  skia := self.skills[SKI_WEATHER_WATCH];
   else
    skia := self.abilities[ABIL_BRA];

/*
   This is really worthless at the moment without being able to
   really predict weather.
*/

 if(skia > 0)
 {

  if(weather < 3)
   act("The weather will probably become worse.",
     A_ALWAYS, self, null,null, TO_CHAR);
    else
     act("The weather will probably be better.",
       A_ALWAYS, self, null, null, TO_CHAR);

  }
    send_done("weather",self,null,null,0,arg,null);

quit;
}
dilend


dilbegin ski_sneak(arg : string);
external
  integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);

var
hm   : integer;
skia : integer;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;


code
{

 if(self.skills[SKI_SNEAK] <= 0)
 {
  act("You must practice first.",
    A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(isaff(self,ID_SNEAK))
 {
  subaff(self,ID_SNEAK);
  quit;
 }
skilla := (self.abilities[ABIL_DEX] + self.abilities[ABIL_BRA]) / 2;
skillb := 60;

if(self.type == UNIT_ST_PC)
        skillc := self.skills[SKI_SNEAK];
else
        skillc := rnd(40,124);
 /*
 skillc := (self.abilities[ABIL_DEX] + self.abilities[ABIL_BRA]) / 2;
*/
if(self.type == UNIT_ST_PC)
        skilld := self.skills[SKI_SNEAK];
else
        skilld := rnd(40,124);
        /*skilld :=50; */
 /*
 skillc := (self.abilities[ABIL_DEX] + self.abilities[ABIL_BRA]) / 2;
*/

hm := skillresist(skilla,skillb,skillc,skilld);
 /*
 if(self.type == UNIT_ST_PC)
  skia := self.skills[SKI_SNEAK]
  else
   skia := (self.abilities[ABIL_DEX] +
            self.abilities[ABIL_BRA]) / 2;

 hm := skillresist((self.abilities[ABIL_DEX] +
                    self.abilities[ABIL_BRA]) / 2, 60, skia, 50);
*/
 if(hm < 0)
 {
  act("You make a feeble attempt to move silently.",
       A_ALWAYS, self, null, null, TO_CHAR);
  act("$1n makes a feeble attempt to move silently.",
       A_HIDEINV, self, null, null, TO_REST);
  quit;
 }

 addaff(self, ID_SNEAK, 6, 4 * (36 * hm) / 6 + 12, CHAR_SNEAK,
        0, 0, TIF_SNEAK_ON, TIF_SNEAK_TICK, TIF_SNEAK_OFF,
        APF_MOD_CHAR_FLAGS);

    send_done("sneak",self,null,null,0,arg,null);


 quit;
}
dilend


dilbegin ski_hide(arg : string);
external
  integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);

var
hm   : integer;
skia : integer;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;


code
{

 if(self.skills[SKI_HIDE] <= 0)
 {
  act("You must practice first.",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

/*
   This changes a bit, instead of actually using the TIF's the C code
   reads the affect data then generates the acts, something not doable
   in dil at this time.
*/

 if(isaff(self, ID_HIDE))
 {
  subaff(self, ID_HIDE);
  quit;
 }

 if(self.type == UNIT_ST_PC)
  skia := self.skills[SKI_HIDE]
   else
    skia := (self.abilities[ABIL_DEX] +
             self.abilities[ABIL_BRA]) / 2;

 hm := skillresist((self.abilities[ABIL_DEX] +
                    self.abilities[ABIL_BRA]) / 2, 20, skia, 50);

 if(hm < 0)
  {
  hm := -hm;
  addaff(self, ID_HIDE, 5, 4 * (24 * hm) / 6 + 12, CHAR_HIDE,
         5, 0, TIF_HIDE_ON, TIF_NOHIDE_TICK, TIF_HIDE_OFF, APF_NONE);
   }
   else
    addaff(self, ID_HIDE, 5, 4 * (24 * hm) / 6 + 12, CHAR_HIDE,
         5, 0, TIF_HIDE_ON, TIF_HIDE_TICK, TIF_HIDE_OFF,
         APF_MOD_CHAR_FLAGS);

    send_done("hide",self,null,null,0,arg,null);

 quit;
}
dilend


dilbegin ski_first_aid(arg : string);
external
  integer skillresist(aa : integer,ad : integer,sa : integer,sd : integer);

var
vict : unitptr;
hm   : integer;
skia : integer;

code
{

 if(self.skills[SKI_FIRST_AID] <= 0)
 {
  act("You must practice first.",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(arg == "")
 {
  act("Perform first aid on who?",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 vict := findunit(self, arg, FIND_UNIT_SURRO, null);

 if(vict == null)
 {
  act("No such person here.",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(not(vict.type & (UNIT_ST_PC | UNIT_ST_NPC)))
 {
  act("Surely you can't perform first aid on that?",
     A_ALWAYS, self, null, null, TO_CHAR);
  quit;
 }

 if(vict.hp > -1)
 {
  act("You can't do much more for $3m.",
    A_ALWAYS, self, null, vict, TO_CHAR);
  quit;
 }

 if(self.type == UNIT_ST_PC)
  skia := self.skills[SKI_FIRST_AID];
   else
    skia := (self.abilities[ABIL_BRA] +
             self.abilities[ABIL_DIV]) / 2;

 hm := skillresist((self.abilities[ABIL_BRA] +
                    self.abilities[ABIL_DIV]) / 2, 10, skia, 40);

 if(hm >= 0)
 {
  act("You perform first aid on $3n.",
       A_ALWAYS, self, null, vict, TO_CHAR);
  act("Someone performs first aid on you.",
       A_SOMEONE, self, null, vict, TO_VICT);
  vict.hp := vict.hp + 1;


 }
 else if(hm < -50)
  {
   act("You fumble... Real bad..",
       A_ALWAYS, self, null, vict, TO_CHAR);
   act("You feel someone poke in your wounds.",
       A_SOMEONE, self, null, vict, TO_VICT);
   vict.hp := vict.hp - 1;
  }
  else
   {
    act("You fumble...",
        A_ALWAYS, self, null, vict, TO_CHAR);
    act("Someone tries to perform first aid on you.",
        A_SOMEONE, self, null, vict, TO_VICT);
   }

send_done("aid",self,null,vict,hm,arg,null);
position_update(vict);

quit;
}
dilend


dilbegin slip(arg : string);
external
	integer skillresist (aa : integer, ad : integer,
			     sa : integer, sd : integer);
var
tgt : unitptr;
res : integer;
u : unitptr;
medi : unitptr;
carry : integer;

code
{

	if(self.skills[SKI_SLIP] <= 0)
	{
	act("You must practice first.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	if(arg == "")
	{
	act("Slip what to who???",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	if(self.endurance < 2)
	{
	act("You are too tired for that.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	medi := findunit(self,arg, FIND_UNIT_IN_ME, null);

	if((medi == null) or (not visible(self,medi)))
	{
	act("You don't have anything like that.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

        tgt := findunit(self, arg, FIND_UNIT_SURRO, null);

        if((tgt == null) or (not visible(self,tgt)) or
	   (not tgt.type & (UNIT_ST_PC | UNIT_ST_NPC)))
        {
        act("No such person to slip something to...",
                A_ALWAYS, self, null, null, TO_CHAR);
        quit;
        }

	res := skillresist(self.abilities[ABIL_DEX],50,
			   self.skills[SKI_SLIP],0);

	if(res <= 0)
	{
	act("You try to slip $2n to $3n but it slips from "+
	    "your hand and falls to the ground.",
		A_ALWAYS, self, medi, tgt, TO_CHAR);

	act("$1n tries to slip $2n to you, but it slips from "+
	    "$1s hand and falls to the ground.",
		A_SOMEONE, self, medi, tgt, TO_VICT);
	act("$1n tries to slip $2n to $3n but it slips from "+
	    "$1s hand and falls to the groud.",
	    	A_SOMEONE, self, medi, tgt, TO_NOTVICT);

	link(medi,self.outside);
	self.endurance := self.endurance - 2;
	quit;
	}

        carry := can_carry(tgt,medi,1);

        if(carry == 1)
        {
        act("$3n has $3s hands full.",
                A_ALWAYS, self, null, tgt, TO_CHAR);
        quit;
        }
        else if(carry == 2)
        {
        act("$3n can not carry anymore.",
                A_ALWAYS, self, null, tgt, TO_CHAR);
        quit;
        }



	act("You slip $2n to $3n.",
		A_ALWAYS, self, medi, tgt, TO_CHAR);
	act("$1n slips you $2n.",
		A_ALWAYS,self, medi, tgt, TO_VICT);

	link(medi,tgt);
	self.endurance := self.endurance - 2;

	if(self.type == UNIT_ST_PC)
	{

	foreach(UNIT_ST_PC, u)
	{

	if(u == self) continue;

	if(u.level >= IMMORTAL_LEVEL)
	{
	sendtext(self.name+" slips "+medi.name+" to "+tgt.name+".<br/>", u);
	continue;
	}

	res := skillresist(self.abilities[ABIL_DEX],
			   u.abilities[ABIL_DEX],
			   self.skills[SKI_SLIP],
			   u.skills[SKI_SLIP]);

	if(res <= 10)
		sendtext(self.name+" slips "+medi.name+" to "+tgt.name+".<br/>", u);
	}

	}

send_done("slip",self,medi,tgt,0,arg,null);
quit;
}
dilend

dilbegin plant(arg : string);
external
	integer skillresist (aa : integer, ad : integer,
                             sa : integer, sd : integer);

var
tgt : unitptr;
medi : unitptr;
res : integer;
carry : integer;
skilla   : integer;
skillb   : integer;
skillc   : integer;
skilld   : integer;

code
{

	if(self.skills[SKI_PLANT] <= 0)
	{
	act("You must practice first.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	if(arg == "")
	{
	act("Plant what on who?",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	if(self.endurance < 4)
	{
	act("You are far too tired to attempt that.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	medi := findunit(self,arg,FIND_UNIT_IN_ME,null);

	if((medi == null) or (not visible(self,medi)))
	{
	act("But you have no such thing.",
		A_ALWAYS, self, null, null,TO_CHAR);
	quit;
	}

	tgt := findunit(self,arg,FIND_UNIT_SURRO,null);

	if((tgt == null) or (not visible(self,tgt)) or
	   (not tgt.type & (UNIT_ST_PC | UNIT_ST_NPC)))
	{
	act("There is no one here by that name.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	if(not (tgt.type & (UNIT_ST_PC|UNIT_ST_NPC)))
	{
	act("You can't plant anything on that!",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}
       if(self.type==UNIT_ST_PC)
        skillc:=self.skills[SKI_PLANT];
       else
        skillc:=self.abilities[ABIL_BRA];

       if(tgt.type==UNIT_ST_PC)
        skilld:=tgt.abilities[ABIL_BRA] /4;
       else
        skilld:=tgt.abilities[ABIL_BRA]/2;

       skilla:=self.abilities[ABIL_DEX];
       skillb:=tgt.abilities[ABIL_DEX];

	   res:=skillresist(skilla,skillb,skillc,skilld);

/*

	res := skillresist(self.abilities[ABIL_DEX],50,
			   self.skills[SKI_PLANT],0);
*/

	if(res <= 0)
	{
	act("You try to plant $2n on $3n but it slips from "+
	    "your hand and falls to the ground.",
		A_ALWAYS, self, medi, tgt, TO_CHAR);

	act("$1n tries to plant $2n on you, but it slips from "+
	    "$1s hand and falls to the ground.",
		A_SOMEONE, self, medi, tgt, TO_VICT);
	act("$1n tries to plant $2n on $3n but it slips from "+
	    "$1s hand and falls to the groud.",
	    	A_SOMEONE, self, medi, tgt, TO_NOTVICT);

	link(medi,self.outside);
	self.endurance := self.endurance - 4;
	quit;
	}


        carry := can_carry(tgt,medi,1);

        if(carry == 1)
        {
        act("$3n has $3s hands full.",
                A_ALWAYS, self, null, tgt, TO_CHAR);
        quit;
        }
        else if(carry == 2)
        {
        act("$3n can not carry anymore.",
                A_ALWAYS, self, null, tgt, TO_CHAR);
        quit;
        }


    res := skillresist(skilla,skillb,skillc,skilld);
	/*
	res := skillresist(self.abilities[ABIL_DEX],
			   tgt.abilities[ABIL_DEX],
			   self.abilities[SKI_PLANT],
			   tgt.abilities[SKI_PLANT]);
    */
	if(res <= 10)
	{
	act("You clumsily plant $2n on $3n.",
		A_ALWAYS, self, medi, tgt, TO_CHAR);
	act("$1n clumsily plants $2n on you.",
		A_SOMEONE, self, medi, tgt, TO_VICT);
	}
	else
	{
	act("You plant $2n on $3n.",
		A_ALWAYS, self, medi, tgt, TO_CHAR);
	}

	link(medi,tgt);

	if(self.level < IMMORTAL_LEVEL)
		self.endurance := self.endurance - 4;

	send_done("plant",self,medi,tgt,res,arg,null);

quit;
}
dilend

dilbegin unitptr find_outside(arg:string);
var
 ln:integer;
 count:integer;
 item:unitptr;
 args:stringlist;

code
{
  args:=split(arg,".");
  ln:=length (args);
  if (ln>1)
  {
  	arg:=args.[1];
	count:=atoi(args.[0]);
	}
else
count:=1;

item:=self.outside.inside;
while (item!=null){
if ((not(visible(self,item))) or
(isset(item.flags,UNIT_FL_BURIED))){
item:=item.next;
continue;
}

 if (arg in item.names){
 if (count>1){
 count:=count-1;
 item:=item.next;
 continue;
 }
 return (item);
 }
 item:=item.next;
}
item:=null;
return (item);
}
dilend

dilbegin palm(arg : string);
external
 unitptr find_outside (s:string);
	integer skillresist (aa : integer, ad : integer,
			     sa : integer, sd : integer);

var
medi : unitptr;
carry : integer;
res : integer;
u : unitptr;
code
{


	if(self.skills[SKI_PALM] <= 0)
	{
	act("You must practice first.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	if(arg == "")
	{
	act("Palm what ?",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	if(self.endurance < 3)
	{
	act("You are too exhausted.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	medi :=find_outside(arg);

	if((medi == null) or (not visible(self,medi)) or
	   (isset(medi.flags,UNIT_FL_BURIED)))
	{
	act("You see no such thing here.",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	if(not isset(medi.manipulate,MANIPULATE_TAKE))
	{
	act("You can not palm that!",
		A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}

	res := skillresist(self.abilities[ABIL_DEX],50,
			   self.skills[SKI_PALM],0);

	if(res <= 0)
	{
	act("You stumble around and fail to palm $2n.",
		A_ALWAYS, self, medi, null, TO_CHAR);

	act("$1n stumbles around trying to palm $2n.",
		A_SOMEONE, self, medi, null, TO_REST);

	self.endurance := self.endurance - 3;
	quit;
	}


        carry := can_carry(self,medi,1);

        if(carry == 1)
        {
        act("You have your hands full.",
                A_ALWAYS, self, null, null, TO_CHAR);
        quit;
        }
        else if(carry == 2)
        {
        act("You can not carry anymore.",
                A_ALWAYS, self, null, null, TO_CHAR);
        quit;
        }


	foreach(UNIT_ST_PC,u)
	{

	res := skillresist(self.abilities[ABIL_DEX],
			   u.abilities[ABIL_DEX],
			   self.skills[SKI_PALM],
			   u.skills[SKI_PALM]);


	if(res <= 0)
	{
		act("$1n palms $2n from the ground.",
			A_SOMEONE, self, medi, u, TO_VICT);
	}
	}


	act("You quickly palm $2n from the ground.",
		A_ALWAYS, self, medi, null, TO_CHAR);

	link(medi,self);

	if(self.level < IMMORTAL_LEVEL)
		self.endurance := self.endurance - 3;

	send_done("palm",self,medi,null,0,arg,null);

	quit;
}
dilend

dilbegin ski_stalk(arg : string);
external
        integer skillresist(aa : integer, ad : integer,
                            sa : integer, sd : integer);
var
tgt : unitptr;
res : integer;
skilla : integer;
skillb : integer;
skillc : integer;
skilld : integer;
code
{

if((self.type == UNIT_ST_PC) and (self.skills[SKI_STALK] <= 0))
{
 sendtext("You must practice first.<br/>", self);
 quit;
}

if(self.position != POSITION_STANDING)
{
 sendtext("You must be standing in order to stalk someone!<br/>", self);
 quit;
}

if(arg == "")
{
 sendtext("Who do you wish to stalk?<br/>", self);
 quit;
}

tgt := findunit(self,arg,FIND_UNIT_SURRO, null);

if((tgt == null) or (not visible(self,tgt)))
{
 sendtext("There is no one by that name here!<br/>", self);
 quit;
}

if(tgt == self)
{
 sendtext("You attempt to stalk yourself, but you end up "+
 "spinning in circles and fall down.<br/>", self);
 act("$1n tries to stalk $1mself but ends up falling down!",
        A_HIDEINV, self, null, null, TO_REST);
 self.position := POSITION_RESTING;
 quit;
}

if(not tgt.type & (UNIT_ST_PC | UNIT_ST_NPC))
{
 sendtext("Yeah, a lot of good that would do!<br/>", self);
 quit;
}
skilla := self.abilities[ABIL_BRA];
skillb := self.abilities[ABIL_BRA];

if(self.type == UNIT_ST_PC)
        skillc := tgt.skills[SKI_STALK];
else
        skillc := rnd(40,124);
 /*
 skillc := (self.abilities[ABIL_DEX] + self.abilities[ABIL_BRA]) / 2;
*/
 /*       skillc := tgt.abilities[ABIL_DEX];
*/
if(tgt.type == UNIT_ST_PC)
        skilld := tgt.skills[SKI_STALK];
else
        skilld := rnd(40,124);
  /*      skilld := tgt.abilities[ABIL_DEX];
*/
res := skillresist(skilla,skillb,skillc,skilld);


if(res <= -30) /* Major fail */
{
 act("You attempt to stalk $3n, but fail miserably.",
        A_ALWAYS, self, null, tgt, TO_CHAR);
 act("$1n attempts to stalk you, but fails miserably.",
        A_SOMEONE, self, null, tgt, TO_VICT);
 act("$1n attempts to stalk $3n, but fails miserably.",
        A_SOMEONE, self, null, tgt, TO_NOTVICT);
}
else if(res <= 0)
{
 act("Just as you begin to stalk $3n, $3e notices you!",
        A_ALWAYS, self, null, tgt, TO_CHAR);
 act("$1n begins to stalk you.",
        A_SOMEONE, self, null, tgt, TO_VICT);
 follow(self,tgt);
}
else
{
 act("You silently begin to stalk $3n.",
        A_ALWAYS, self, null, tgt, TO_CHAR);
 follow(self,tgt);
}

send_done("stalk",self,null,tgt,res,arg,null);
quit;
}
dilend // ski_stalk

/* Barbarian Skills */
/* Original concept and implementation by Sender */

dilbegin ski_taunt(arg : string);
external
   integer skillresist (aa : integer, ad : integer, sa : integer, sd : integer);
   provoked_attack(victim : unitptr, ch : unitptr);
   integer skillchecksaopp(skillidx : integer, abiidx1 : integer, abiidx2 : integer,
                           opp : unitptr, oabiidx1 : integer, oabiidx2 : integer);

var
   hm   : integer;
   tgt  : unitptr;
   end  : integer;

code
{
	if ((self.type == UNIT_ST_PC) and (self.skills[SKI_TAUNT] <= 0))
	{
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
	}

	if (arg == "")
	{
      if (self.fighting)
      {
         tgt := self.fighting;
      }
      else
      {
         act("Taunt who?", A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
	}
   else
   {
   	tgt := findunit(self,arg,FIND_UNIT_SURRO,null);
   }

	if ((tgt == null) or (not visible(self,tgt)))
	{
      act("Taunt who?", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
	}

	if (tgt == self)
	{
      act("You mercilessly taunt yourself !", A_ALWAYS, self, null, null, TO_CHAR);
      act("$1n mercilessly taunts $1mself!", A_SOMEONE, self, null, null, TO_REST);
      quit;
	}

	if ((tgt.type==UNIT_ST_PC) and (self.type==UNIT_ST_PC))
	{
      if (not(isset (self.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless you sign the book of blood.",
         A_ALWAYS,self,null,null,TO_CHAR);
         quit;
      }

      if (not(isset (tgt.pcflags, PC_PK_RELAXED)))
      {
         act ("You are not allowed to do this unless $2e signs the book of blood.",
         A_SOMEONE,self,tgt,null,TO_CHAR);
         quit;
      }
   }

   if ((tgt.weight - self.weight) > 125)
   {
      act("Perhaps you shouldn't taunt someone as large as $3n!", A_SOMEONE, self, null, tgt, TO_CHAR);
      quit;
   }

   :taunt:
   if (dilfind("taunted@skills",tgt))
   {
      act("$3n quietly ignores your continued taunting.", A_SOMEONE, self, null, tgt, TO_CHAR);
      act("$3n quietly ignores $1n's continued taunting.", A_SOMEONE, self, null, tgt, TO_NOTVICT);
      act("$1n attempts to taunt you again, but you quietly ignore it.", A_SOMEONE, self, null, tgt, TO_VICT);
      quit;
   }

   if (self.endurance < 10)
   {
      act("You are too exhausted to try that!", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else

   hm := skillchecksaopp(SKI_TAUNT, ABIL_CON, ABIL_DEX, tgt, ABIL_BRA, ABIL_DEX);

   if (hm < -25)
   {
      change_speed(self,PULSE_VIOLENCE);

      act("<div class='nodam_me'>You foolishly exhaust yourself attempting to taunt $3n!</div>",
      A_SOMEONE, self, null, tgt, TO_CHAR);
      act("<div class='nodam_other'>$1n seems to foolishly exhaust themself attempting to taunt $3n!</div>",
            A_SOMEONE, self, null, tgt, TO_NOTVICT);
      act("<div class='nodam_opponent'>$1n foolishly exhausts themself attempting to taunt you!</div>",
            A_SOMEONE, self, null, tgt, TO_VICT);
      provoked_attack(tgt,self);
      
	  end := self.endurance - 40;
	  if(end < 0)
	  {
			end := 0;
	  }
	  self.endurance := end;
      quit;
   }

   if (hm < 0)
   {
      change_speed(self,PULSE_ROUND);

      act("<div class='miss_me'>Your taunting of $3n falls on deaf ears.</div>",
      A_ALWAYS, self, null, tgt, TO_CHAR);
      act("<div class='miss_other'>$1n pitifully attempt to taunt $3n.</div>",
      A_SOMEONE, self, null, tgt, TO_NOTVICT);
      act("<div class='hit_opponent'>$1n fails their effort to taunt you.</div>",
      A_SOMEONE, self, null, tgt, TO_VICT);
      provoked_attack(tgt,self);
      quit;
   }

   dilcopy("taunted@skills",tgt);

   change_speed(tgt,PULSE_VIOLENCE*3);

   act("<div class='shield_me'>You mercilessly taunt $3n.</div>", A_SOMEONE, self, null, tgt, TO_CHAR);
   act("<div class='shield_other'>$1n mercilessly taunts $3n.</div>", A_SOMEONE, self, null, tgt, TO_NOTVICT);
   act("<div class='shield_opponent'>$1n mercilessly taunts you!</div>", A_SOMEONE, self, null, tgt, TO_VICT);
   act("<div class='miss_me'>Your taunting causes $3n to swing wildly.</div>", A_SOMEONE, self, null, tgt, TO_CHAR);
   act("<div class='miss_other'>$3n swings wildly after $1n's taunts.</div>", A_SOMEONE, self, null, tgt, TO_NOTVICT);
   act("<div class='miss_opponent'>$1n's taunting causes you to swing wildly!</div>", A_SOMEONE, self, null, tgt, TO_VICT);

   provoked_attack(tgt, self);
   send_done("taunt",self,null,tgt,hm,arg,null);
   quit;
}
dilend

dilbegin taunted();
code
{
   heartbeat := PULSE_VIOLENCE * 3;

   wait(SFB_TICK, TRUE);
   quit;
}
dilend

dilbegin ski_berserk(medi:unitptr, tgt : unitptr, arg : string,
	       hm : integer, effect : string);
var
	heal : integer;
	end : integer;
code
{
   /*
      Skill Berserk:
      This skill sends a character berserk.
      As a result the character's HP, END, and CON are increased temporarily.
      */

    if (isaff(tgt, ID_BERSERK))
    {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
    }

    hm := 1 + hm / 10;
    if (hm > 10) hm := 10;
	
	addaff(self, ID_BERSERK, 10, WAIT_SEC*30,
	  ABIL_CON, hm, 0, TIF_BERSERK_ON, TIF_BERSERK_TICK, TIF_BERSERK_OFF,
	  APF_ABILITY);
	  
    hm := 1 + hm / 10;
    if (hm > 20) hm := 20;
	heal := tgt.hp + (hm * 3);
	end := tgt.endurance + (hm * 6);
	
	addaff(self, ID_BERSERK, 20, WAIT_SEC*30,
	  ABIL_HP, hm, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	  APF_ABILITY);
	
	tgt.endurance := end;
	tgt.hp := heal;
    quit;
}
dilend

dilbegin ski_frenzy(arg : string);
code
{
	quit;
}
dilend

dilbegin ski_rage(arg : string);
code
{
	quit;
}
dilend

/* END Barbarian Skills */
%rooms
                                   skill_room
title "The Skill Room"
descr
"Token room."
movement SECT_INSIDE
flags {UNIT_FL_NO_WEATHER}
ALWAYS_LIGHT
end


%objects


/* Butcher objects */

fillet_template
names {"fillet"}
title "a succulent fillet"
descr "A fillet of some marine creature has been left here."
extra {}
"A choice fillet of some fishy creature, this looks very good to eat."

weight 4

manipulate {MANIPULATE_TAKE}
FOOD_DEF(16, 0)
dilcopy blowaway@function(220, "$1n is consumed by some smelly maggots.");
end /* fillet_template */

leg_template
names {"leg"}
title "a lovely leg"
descr "The leg of some creature has been left here."
extra {}
"This leg looks very good to eat."

weight 1

manipulate {MANIPULATE_TAKE}
FOOD_DEF(10, 0)
dilcopy blowaway@function(250, "$1n is consumed by some smelly maggots.");
end /* leg_template */

arm_template
names {"arm"}
title "a lovely arm"
descr "The arm of some creature has been left here."
extra {}
"This arm would make good eating."
weight 1

manipulate {MANIPULATE_TAKE}
FOOD_DEF(10, 0)
dilcopy blowaway@function(280, "$1n is consumed by some smelly maggots.");
end /* arm_template */

scraps_template
names {"scraps", "meat"}
title "some scraps of meat"
descr "Some scraps of meat have been left on the ground here."
extra {}
"They look reasonably edible."

weight 2

manipulate {MANIPULATE_TAKE}
FOOD_DEF(3, 0)
dilcopy blowaway@function(240, "$1n are consumed by some smelly maggots.");
end /* scraps_template */

steak_template
names {"delicious steak", "steak"}
title "a delicious steak"
descr "A steak cut from some creature has been discarded here."
extra {}
"This steak looks very tasty - perhaps it would make good eating."

weight 6

manipulate {MANIPULATE_TAKE}
FOOD_DEF(20, 0)
dilcopy blowaway@function(200, "$1n is consumed by some smelly maggots.");
end /* steak_template */

base_skin /* used for skin skill*/
title "a piece of base skin"
names {"base skin"}
outside_descr "base skin is lying here"
type ITEM_SKIN
manipulate {MANIPULATE_TAKE}
weight 1
dilcopy blowaway@function  (600,"$1n decays into dust.");
end

/* campfire obj for cook */
campfire_0
names {"campfire", "fire"}
title "a campfire"
descr "A crackling campfire is here."
extra {}
"This is a small campfire with flames about a foot high. It looks like
it could go out any minute."
weight 10
dilcopy blowaway@function(300, "$1n goes out suddenly in a puff of smoke.");
end
/* end of campfire obj for cook */

/* forage food objects for forage skill */
roots
names {"roots", "root"}
title "some roots"
descr "Some roots have been pulled out of the ground here."
extra {}
"These are just some thick brown roots which a ranger has pulled out of
the ground in their search for food."
weight 3
manipulate {MANIPULATE_TAKE}
FOOD_DEF(20, 0)
dilcopy blowaway@function(240, "$1n dry up and turn to dust.");
end

tubers
names {"tubers", "tuber"}
title "some tubers"
descr "Some tubers have been pulled out of the ground here."
extra {}
"These tubers are not unlike potatoes, except that they are different
shapes and sizes and do not have eyes. A ranger must have found these
in the search for food."
weight 3
manipulate {MANIPULATE_TAKE}
FOOD_DEF(20, 0)
dilcopy blowaway@function(240, "$1n dry up and turn to dust.");
end

berries
names {"berries", "berry"}
title "some berries"
descr "Some berries are lying here waiting to be stepped on."
extra {}
"These berries are of various shapes, sizes and colours. They look
positively delicious. A ranger must have picked these in the search for
food."
weight 1
manipulate {MANIPULATE_TAKE}
FOOD_DEF(10, 0)
dilcopy blowaway@function(240, "$1n get eaten by hungry ants.");
end

grubs
names {"grubs", "grub"}
title "some grubs"
descr "Some bloated grubs lie here, squirming."
extra {}
"These grubs, small, white and almost transparent, are utterly
repulsive, but what can one do when they're hungry? A ranger found
these in the search for food."
weight 1
manipulate {MANIPULATE_TAKE}
FOOD_DEF(5, 0)
dilcopy blowaway@function(240, "$1n dry up and turn to dust.");
end

egg
names {"bird egg", "egg"}
title "a bird egg"
descr "A small bird egg is here."
extra {}
"This is a small bird egg. It obviously got lost from its nest, and
now it can serve as food for a hungry ranger."
weight 2
manipulate {MANIPULATE_TAKE}
FOOD_DEF(8, 0)
dilcopy blowaway@function(240, "$1n gets crushed underfoot.");
end

mushroom
names {"mushroom"}
title "a mushroom"
descr "A mushroom is lying here."
extra {}
"This mushroom is rather large, with pinkish spots. A ranger has found
this in the search for food."
weight 2
manipulate {MANIPULATE_TAKE}
FOOD_DEF(7, 0)
dilcopy blowaway@function(240, "$1n turns to slime and seeps away.");
end

truffle
names {"truffle"}
title "a truffle"
descr "A truffle lies here, looking like a misshapen potato."
extra {}
"This is a type of fungus that grows underground. It is considered a
rare delicacy, and obviously the ranger that found it has exquisite
taste."
weight 3
manipulate {MANIPULATE_TAKE}
FOOD_DEF(12, 0)
dilcopy blowaway@function(240, "$1n turns to slime and seeps away.");
end

fruit
names {"fruit"}
title "a fruit"
descr "A piece of fruit is lying here."
extra {}
"This is a typical piece of fruit. It looks like a cross between an
apple and a pear, but smells more like an orange. A ranger has picked
this in the search for food."
weight 3
manipulate {MANIPULATE_TAKE}
FOOD_DEF(9, 0)
dilcopy blowaway@function(240, "$1n rots away.");
end

nuts
names {"nuts", "nut"}
title "some nuts"
descr "Some nuts have been left here."
extra {}
"These are some assorted nuts. They look very nutritious. A ranger must
have found them in the search for food."
weight 1
manipulate {MANIPULATE_TAKE}
FOOD_DEF(6, 0)
dilcopy blowaway@function(240, "$1n are carried off by a hungry squirrel.");
end

d_lizard
names {"dead lizard", "lizard"}
title "a dead lizard"
descr "A dead lizard is here."
extra {}
"This is a dead lizard, killed by a ranger in the search for food. It
is green, scaly and reminds you of a goblin with psoriasis."
weight 6
manipulate {MANIPULATE_TAKE}
FOOD_DEF(15, 0)
dilcopy blowaway@function(240, "$1n is consumed by a horde of maggots.");
end

d_newt
names {"dead newt", "newt"}
title "a dead newt"
descr "A dead newt is here."
extra {}
"This is a small, slimy, dead red newt. This dead red newt is also
a food source for hungry rangers."
weight 2
manipulate {MANIPULATE_TAKE}
FOOD_DEF(7, 0)
dilcopy blowaway@function(240, "$1n is consumed by a horde of maggots.");
end

algae
names {"algae"}
title "some algae"
descr "Some algae has been left in a pool here."
extra {}
"This algae is basically greenish-brown slime. It looks like something
orcs would have regurgitated, but it also serves as a meal for a ranger
in search of food."
weight 2
manipulate {MANIPULATE_TAKE}
FOOD_DEF(11, 0)
dilcopy blowaway@function(240, "$1n dries up and blows away.");
end

kelp
names {"kelp", "seaweed"}
title "some kelp"
descr "Some kelp lies here in a heap."
extra {}
"Some blackish, briny kelp. Rich in nutrients, richer in seawater. This
is a meal for a hungry ranger."
weight 3
manipulate {MANIPULATE_TAKE}
FOOD_DEF(14, 0)
dilcopy blowaway@function(240, "$1n dries up and blows away.");
end

d_fish
names {"dead fish", "fish"}
title "a dead fish"
descr "A dead fish lies here, doing nothing."
extra {}
"This dead fish is about a foot long, bright silver and looks almost
yummy. Caught by a ranger in search of food, this fish will yield a
lot of filet."
weight 12
manipulate {MANIPULATE_TAKE}
FOOD_DEF(25, 0)
dilcopy blowaway@function(240, "$1n is consumed by a horde of maggots.");
end

d_frog
names {"dead frog", "frog"}
title "a dead frog"
descr "A dead frog is here."
extra {}
"This is a dead bullfrog. It is a fine example of the species, and it
will also serve as a fine example of natural cuisine for a ranger."
weight 5
manipulate {MANIPULATE_TAKE}
FOOD_DEF(8, 0)
dilcopy blowaway@function(240, "$1n is consumed by a horde of maggots.");
end

d_snail
names {"dead snail", "snail"}
title "a dead snail"
descr "A dead snail lies here in a pool of its own slime."
extra {}
"Slimy, green and really disgusting, this snail is also considered food
by rangers in times of need. They don't seem to be very picky about
what they eat, do they?"
weight 1
manipulate {MANIPULATE_TAKE}
FOOD_DEF(2, 0)
dilcopy blowaway@function(240, "$1n dries up and blows away.");
end

d_slug
names {"dead slug", "slug"}
title "a dead slug"
descr "A dead slug is here, being disgusting."
extra {}
"Despite it's horrific appearance, this bright green, slimy object is
a slug, and not only that, it's food for a ranger. Maybe it's time to
finally start that diet..."
weight 2
manipulate {MANIPULATE_TAKE}
FOOD_DEF(4, 0)
dilcopy blowaway@function(240, "$1n dries up and blows away.");
end
/* end of forage objects */

/* b_spring, b_leafcup and b_icepool are for dowse skill */
b_spring
names {"spring", "springwater", "pool", "water"}
title "a pool of springwater"
descr "A small spring bubbles up at your feet."
extra {}
"This is a small spring that a Ranger has discovered. It only provides a
small amount of water, so be sparing with it."
LIQ_DEF("clear", 2,20,20,10,1,0,0)
dilcopy blowaway@function(240, "$1n dries up and disappears.");
dilcopy empty@skills();
end

b_leafcup
names {"leafcup", "cup", "water"}
title "a leafcup of water"
descr "A small leafcup of water is here."
extra {}
"This is a small cup fashioned from dead leaves that a Ranger has made.
It only provides a small amount of water, so be sparing with it."
LIQ_DEF("clear", 2,10,10,10,1,0,0)
dilcopy blowaway@function(240, "$1n dries up and disappears.");
dilcopy empty@skills();
end

b_icepool
names {"icewater", "pool", "water"}
title "a pool of icewater"
descr "A small pool of icewater is about to freeze solid here."
extra {}
"This is a small pool of icewater that a Ranger has melted. It only
provides a small amount of water, so be sparing with it."
LIQ_DEF("clear", 2,20,20,10,1,0,0)
dilcopy blowaway@function(60, "$1n freezes solid.");
end
/* end of dowse objects */

f_staff
names {"fighting staff", "full staff", "staff"}
title "a ranger's fighting staff"
descr "A hand crafted ranger staff has been discarded here."
MATERIAL_WOOD("Tree branch")
manipulate {MANIPULATE_TAKE, MANIPULATE_WIELD}
cost 100 IRON_PIECE
weight 12
extra {}
"Hand crafted by a skilled Ranger, this staff is a formidable
two-handed weapon. Wielding this staff would make any potential
opponent think twice before engaging the wielder in combat."

WEAPON_DEF(WPN_QUARTERSTAFF, 1, 0)

extra {"$wear_s"}
"You take the staff in your hands, ready for battle."

extra {"$wear_o"}
"$1n takes $1s staff in $1s hands, ready for battle."

extra {"$rem_s"}
"You let go of the staff."

extra {"$rem_o"}
"$1n lets go of $1s staff."

end /* f_staff */

q_staff
names {"quarter staff", "staff"}
title "a ranger's quarter staff"
descr "A hand crafted ranger quarter staff has been discarded here."
MATERIAL_WOOD("Tree branch")
manipulate {MANIPULATE_TAKE, MANIPULATE_WIELD}
cost 100 IRON_PIECE
weight 8
extra {}
"Hand crafted by a skilled Ranger, this staff is a formidable
weapon. Wielding this staff would make any potential
opponent think twice before engaging the wielder in combat."

WEAPON_DEF(WPN_QUARTERSTAFF, 1, 0)

extra {"$wear_s"}
"You take the staff in your hand, ready for battle."

extra {"$wear_o"}
"$1n takes $1s staff in $1s hand, ready for battle."

extra {"$rem_s"}
"You let go of the staff."

extra {"$rem_o"}
"$1n lets go of $1s staff. The battle has ended."

end /* q_staff */

bow
names {"long bow", "bow"}
title "a ranger's long bow"
descr "A hand crafted ranger long bow has been discarded here."
MATERIAL_WOOD("Tree branch")

RANGED_DEF(0, 10, 5, 15000, WPN_BOW, 0)

cost 100 IRON_PIECE
weight 3
extra {}
"Hand crafted by a skilled Ranger, this long bow is a formidable
weapon. With a true aim, this bow would likely bring down almost
any target."

extra {"$wear_s"}
"You take the bow in your hand, ready for battle."

extra {"$wear_o"}
"$1n takes $1s bow in $1s hand, ready for battle."

extra {"$rem_s"}
"You let go of the bow."

extra {"$rem_o"}
"$1n lets go of $1s bow. The battle has ended."

end

arrow
names {"arrow"}
title "an arrow"
descr "A hand crafted arrow has been discarded here."
MATERIAL_WOOD("Tree branch")

MISSILE_DEF(WPN_BOW, 5, 1, 15000, 0)

cost 10 IRON_PIECE
weight 1
extra {}
"Hand crafted by a skilled Ranger, this arrow is deadly when shot
by a skilled bowman."

end /* arrow */

man_trap
  names{"man trap", "trap"}
  title " man trap"
  descr "A small man trap lies nearly undetectable here."
  extra{}
  "This trap looks purposeful and nasty, hunting rabbit with it would be
  efficient to say the least but even the biggest ogre would have trouble
  wresting free of its jaws."

  TRAP_DEF(5, 5)

  extra {"$spring_self"}
  "default"
  extra {"$spring_other"}
  "default"

  flags      {UNIT_FL_NO_TELEPORT, UNIT_FL_TRANS}
  weight 4
  cost 2 COPPER_PIECE
  MATERIAL_WOOD("Wood from a tree branch")

end /* man_trap */

grass_hut
names {"grass hut", "hut", "shelter"}
title "a grass hut"
descr "A large sturdy grass hut has been erected here."

inside_descr
"The walls are made from long stems of grass woven into a thick mat. It looks
quite sturdy. The roof is flat and of the same construction as the walls. There
is a single entrance."

extra {}
"Fashioned from long grasses, this hut would accommodate at least three people.
Constructed by a ranger, it is deceptively strong, and it looks sturdy enough to
withstand all but the harshest of weather. There is a single entrance flap."

extra {"door", "flap"}
"The door to this hut is little more than a flap of grass woven into a mat."

extra {"$enter_s"}
"You crawl in through the narrow entrance to the hut. It feels nice and cosy
inside."
extra {"$enter_o"}
"$1n crawls into the hut."

extra {"$exit_s"}
"You crawl out of the hut."
extra {"$exit_o"}
"$1n crawls out of the hut."

CONTAINER_DEF(3000)
manipulate {MANIPULATE_ENTER}

weight 1000

flags {UNIT_FL_NO_MOB, UNIT_FL_SACRED, UNIT_FL_NO_TELEPORT}

open {EX_OPEN_CLOSE, EX_INSIDE_OPEN, EX_CLOSED}

end /* grass hut */

wooden_shack
names {"wooden shack", "shack", "shelter"}
title "a wooden shack"
descr "A sturdy wooden shack has been erected here."

inside_descr
"The walls have been constructed from tree branches bound together with a
makeshift rope of thin branches, rather like wattle. The roof is a flat mat of
branches covered in leaves and bound with the same thin young branches. There is
a single entrance."

extra {}
"Fashioned from the wood of the surrounding trees, this shack, though a
temporary abode, would accommodate at least three people, looks sturdy enough
to withstand all but the harshest of weather. There is a single door set
in one side. It looks to have been built by a ranger."

extra {"door"}
"The door has been made from a few wooden slats bound together with sapling
wood - not a very elaborate affair."

extra {"$enter_s"}
"You duck and enter through the narrow doorway of the shack."
extra {"$enter_o"}
"$1n enters the wooden shack."

extra {"$exit_s"}
"You duck and exit the hut."
extra {"$exit_o"}
"$1n emerges from the wooden hut."

CONTAINER_DEF(3000)
manipulate {MANIPULATE_ENTER}

weight 1000

flags {UNIT_FL_NO_MOB, UNIT_FL_SACRED, UNIT_FL_NO_TELEPORT}

open {EX_OPEN_CLOSE, EX_INSIDE_OPEN, EX_CLOSED}

end /* wooden_shack */

igloo
names {"igloo", "shelter"}
title "a small igloo"
descr "A small makeshift igloo has been constructed here."

inside_descr
"The crudely cut blocks of ice which make up the walls of this igloo provide a
greater amount of insulation than their appearance would betray. They form a
dome which apexs in a smooth curve for a roof, making the shape of the igloo
like a half-sphere. There is a single entrance."

extra {}
"This igloo looks to have been thrown together with speed - the blocks making up
the structure are crudely cut, but the igloo looks sturdy enough to last a day
or two. It looks to have been built by a ranger."

extra {"door"}
"The door is made from ice blocks piled on top of each other. It takes a bit
of time to open it."

extra {"$enter_s"}
"You enter through the low entrance to the igloo."

extra {"$enter_o"}
"$1n enters the igloo."

extra {"$exit_s"}
"You crouch down and exit the igloo."
extra {"$exit_o"}
"$1n exits the igloo through the low entrance."

CONTAINER_DEF(3000)
manipulate {MANIPULATE_ENTER}

weight 1000

flags {UNIT_FL_NO_MOB, UNIT_FL_SACRED, UNIT_FL_NO_TELEPORT}

open {EX_OPEN_CLOSE, EX_INSIDE_OPEN, EX_CLOSED}

end /* igloo */

grass
names {"grass", "pile"}
title "a pile of grass"
descr "A pile of grass has been left here."

extra {}
"It looks to be the remains of a grass hut."

end /* grass */

ice
names {"ice blocks", "ice block", "ice", "pile"}
title "a pile of ice blocks"
descr "A pile of ice blocks have been left here."

extra {}
"They look to be the remains of an igloo."

end /* ice */

wood
names {"wood sticks", "wood", "sticks"}
title "wooden sticks"
descr "A pile of wooden sticks are all that remain of a shack that was once
here."

extra {}
"They look to be the remains of an igloo."

end /* ice */

%mobiles
%mobiles

/* Just to test some stuff without having them cast spells - Storm */
hel
/* Godess of Hell */
names {"hel"}
title "Hel"
descr "Hel the grim reaper is here."
extra {} "Dressed in black."
romflags {CHAR_DETECT_INVISIBLE}
ATTACK_DEFENSE(+500, +500)

M_NORSE_GOD_LIGHT_GODLY(150,SEX_FEMALE)


end

%end
