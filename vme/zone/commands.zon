/*
filename    commands
password    mfxmas
changedby   Mesmer
EmailAdd
request     compile
version     7
END HEADER*/

#include <macros.h>

%zone                                  commands
reset RESET_NOT

weather 1040

creators {"papi"}

notes
"This is the commands zone. Don't let any rooms point to this zone, or use
any objects from this zone without special permission. Do not slime objects from
this zone."

help
"This zone is not intended for players."
#define  CLAN_NAME   "$clan_name"

#define UNIT_WEAR(OBJ_BIT,MANI_BIT)	\
((OBJ_BIT) & (MANI_BIT))



%dil


/* 
 * self is the PC
 * pfx is $alias, $trigger or $var 
 */
dilbegin string dlrdump(pfx : string);
var
   exd : extraptr;
   p   : extraptr;
   buf : string;
   s : string;
   t : string;
   i : integer;
code
{
   if (self.type != UNIT_ST_PC)
      return("");

   buf := "<data type='"+pfx+"'>";
   exd := self.info;
   i := 0;
   while (exd)
   {
      s := exd.names.[0];
      t := getword(s);
      if (t $= pfx)
      {
         buf := buf + "<li>" + s + " " + exd.names.[1] + "</li>";
         i := i + 1;
         if (i > 25)
         {
            sendtext(pfx + " limit exceeded, removing " + s + " " + exd.names.[1] + "<br/>", self);
            s := exd.names.[0];
            exd := exd.next;
            subextra(self.info, s);
            continue;
         }
      }
      exd := exd.next;
   }
   buf := buf + "</data>";

   return(buf);
}
dilend


/*
 * Used by do_alias, trigger, variable
 */
dilbegin dlrmanage(pfx : string, arg : string);
external
   string dlrdump@commands(pfx : string);

var
   s : string;
   t : string;
   c : string;
   sl : stringlist;
   exd : extraptr;

code
{
   c := right(pfx, length(pfx)-1);
   s := getword(arg);

   if (length(s) < 1)
   {
      sendtext("Your current " + c + " list:<br/>", self);
      exd := self.info;
      while (exd)
      {
         s := exd.names.[0];
         t := getword(s);
         if (t $= pfx)
         {
            if (length(exd.names) <= 1)
            {
               sendtext(exd.names.[0] + " == broken " + c + ", removing<br/>", self);
               subextra(self.info, exd.names.[0]);
            }
            else
               sendtext(exd.names.[0] + " " + exd.names.[1] +"<br/>", self);
         }

         exd := exd.next;
      }

      return;
   }

   if (length(s) > 12)
   {
      sendtext(c + " keyword too long [" + s + "]<br/>", self);
      return;
   }

   // Remove alias
   if (arg $= "")
   {
      t := pfx + " " + s;
      exd := t in self.info;

      if (exd == null)
      {
         sendtext("No such "+c+" found. Maybe you wanted to add one? Usage: "+c+" [keyword] [string]<br/>", self);
         return;
      }

      sendtext("Removing " + c + " " + s + " " + exd.names.[1] + "<br/>", self);
      subextra(self.info, t);

      s := dlrdump@commands(pfx);
      sendtext(s, self);

      return;
   }

   sl := null;
   t := pfx + " " + s;
   exd := t in self.info;

   if (exd == null)
   {
      sendtext("Adding " + c + " [" + s + "] "+arg+"<br/>", self);

      insert(sl, 0, t);
      insert(sl, 1, arg);
      addextra(self.info, sl, "");
   }
   else
   {
      sendtext("Replacing <a cmd='#'>" + c + " " + s + " " + exd.names.[1] + "</a> (click link to revet to this)<br/>", self);
      sendtext("New " + c + " " + s + " " + arg + "<br/>", self);
      exd.names.[1] := arg;
   }

   s := dlrdump@commands(pfx);
   sendtext(s, self);

   return;
}
dilend


dilbegin do_alias(arg : string);
external
   dlrmanage@commands(pfx : string, arg : string);
code
{
   dlrmanage@commands("$alias", arg);
   quit;
}
dilend


dilbegin do_trigger(arg : string);
external
   dlrmanage@commands(pfx : string, arg : string);
code
{
   dlrmanage@commands("$trigger", arg);
   quit;
}
dilend


dilbegin do_variable(arg : string);
external
   dlrmanage@commands(pfx : string, arg : string);
code
{
   dlrmanage@commands("$var", arg);
   quit;
}
dilend


// do_knock
dilbegin knock(arg : string);

external
   integer is_hidden@basemove(u1 : unitptr, int1 : integer, u2 : unitptr);
   string  dirstring@function(i2 : integer);
   integer checkdoor@basemove(arg : string);
   integer rev_dir@function(i : integer);

var
      item       :  unitptr;
      pc         :  unitptr;
      arg1       :  string;
      arg2       :  string;
      arg3       :  stringlist;
      dir        :  integer;
      oppdir     :  integer;
      test       :  integer;
      count      :  integer;
      counter    :  integer;

code
{
   if (self.position < POSITION_RESTING)
   {
      act("All you can do right now, is think about the stars!", A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   if (arg == "")
   {
      act("knock on what?", A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   /* next we see if the player has anything in his inventory or around him that he can knock on */
   arg1 := arg;       // saves the string in case we need it later

   item := findunit(self, arg1, FIND_UNIT_HERE, null);

   /* If there is no item or we cant see it, check the doors in the room */
   if (item == null)
      goto check_doors;

   // First figure out if we are knocking on the item, or from inside the item
   pc := self.outside;
   while (pc)
   {
      if (item == pc)
         break;

      pc := pc.outside;
   }

   // I decided that if you're inside a container you can always see it
   // Therefore the off (not pc) statement
   if ((not visible(self, item)) and (not pc))
      goto check_doors;

   if (pc)  // Knocking from the inside
   {
      if (isset(item.flags, UNIT_FL_BURIED))
         act("You hear a knocking sound from below.", A_SOMEONE, item, null, null, TO_ALL);
      else if (isset(item.openflags, EX_CLOSED) or (not isset(item.flags, UNIT_FL_TRANS)))
         act("You hear a loud knocking from $1n.", A_SOMEONE, item, null, null, TO_ALL);
   }
   else // knocking ON the object, we must be able to see it, check its not buried
   {
      if (isset(item.flags, UNIT_FL_BURIED))
         goto check_doors;

      if (isset(item.openflags, EX_CLOSED) or (not isset(item.flags, UNIT_FL_TRANS)))
         if (item.inside)
            act("You hear a loud knocking from $2n.", A_SOMEONE, item.inside, item, null, TO_ALL);
   }

   // message to everyone in the same location
   act("You knock on $2m.", A_SOMEONE, self, item, null, TO_CHAR);
   act("$1n knocks on $3n.", A_SOMEONE, self, null, item,TO_NOTVICT);
   act("$1n knocks on you.", A_SOMEONE, self, null, item, TO_VICT);

   send_done ("knock", self, null, item, 0, "", null);
   return;


   :check_doors:
   /* first we are going to check if the player dictated what direction they want to open */
   /* set up so we can close 'both' doors (room player is in and room the door leads to.) */

   dir := checkdoor@basemove(arg);

   if (dir == -1)
   {
      act("You see no such exit in that direction.", A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   item := self.outside;
   while (item.type != UNIT_ST_ROOM)
      item := item.outside;

   if (not isset(item.exit_info[dir], EX_CLOSED))
   {
      act("You knock on the open $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_CHAR);
      act("$1n knocks on the open $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_REST);
   }
   else
   {
      act("You knock on the $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_CHAR);
      act("$1n knocks on the $2t.", A_SOMEONE, self, item.exit_names[dir].[0], null, TO_REST);
   }

   pc := item.exit_to[dir].inside;
   if (pc != null)
   {
      oppdir := rev_dir@function(dir);

      if (not isset(item.exit_info[dir], EX_CLOSED))
      {
         act("$3n knocks on the open $2t.", A_SOMEONE, pc, item.exit_to[dir].exit_names[oppdir].[0] , self, TO_ALL);
      }
      else
      {
         act("You hear a knocking coming from $2t.", A_ALWAYS, pc,item.exit_to[dir].exit_names[oppdir].[0] , self, TO_ALL);
      }
   }

   send_done ("knock", self, null, null, 0, "", null);
   return;
}
dilend


dilbegin aware frozen ();
code
{
:start:
wait (SFB_CMD,self==activator);
if ((command("look")) or
(command("who")) or
(command("say")))
goto start;

block;
  sendtext ("You're totally frozen!<br/>",self);
goto start;
}
dilend

dilbegin do_freeze (arg:string);
var
 u:unitptr;
 i:integer;
code
{
if (arg=="")
 {
    sendtext ("Freeze who?<br/>",self);
    quit;
    }

u:=findunit(self,arg,FIND_UNIT_SURRO|FIND_UNIT_WORLD,null,UNIT_ST_PC);

if (u==null)
{
    sendtext ("No such person around.<br/>",self);
    quit;
    }

if (self==u)
{
    sendtext ("Hehe.  Most amusing, Sire. (People have actually DONE this!)<br/>",self);
              quit;
          }

if (self.level <= u.level)
{
    sendtext ("It IS a little cold isn't it?<br/>",self);
    quit;
    }

if (dilfind("frozen@commands",u))
{
       act ("$1n is now unfrozen.",
       A_SOMEONE, u, null, self, TO_VICT);
      sendtext ("You unfreeze.<br/>",u);
      i:=dildestroy ("frozen@commands",u);
      quit;
      }
else
 {
      act ("$1n is now frozen.",
      A_SOMEONE, u, null, self, TO_VICT);
      sendtext ("You totally freeze.<br/>",u);
      dilcopy ("frozen@commands",u);
      quit;
      }

      quit;
      }
      dilend

      dilbegin do_notell (arg:string);
      var
       vict:unitptr;

      code
      {
if (self.type!=UNIT_ST_PC)
return;

if (self.level<200)
 return;

  vict := findunit (self, arg, FIND_UNIT_WORLD,null,UNIT_ST_PC);
if (vict==null)
    {
      sendtext ("No such player around.<br/>",self);
            return;
    }


  if (vict.level >= self.level)
    {
      act ("$3e might object to that... better not.",
      A_SOMEONE, self, null, vict, TO_CHAR);
      return;
    }

  if (isset (vict.pcflags, PC_NOTELLING))
    {
      sendtext ("You regain your telepathic ability.<br/>",vict);
            sendtext("NOTELLING removed.<br/>",self);
            unset (vict.pcflags,PC_NOTELLING);
                }
  else
    {
     sendtext ("Your telepathic ability fades away!<br/>",vict);
           sendtext ("NOTELLING set.<br/>",self);
                             set (vict.pcflags,PC_NOTELLING);
    }

return;
}
dilend



dilbegin aware boot_area();
var
i:integer;
 cnt:integer;
 zones:zoneptr;
 tlist:stringlist;
 temp:string;
 ln:integer;
 iMax:integer;
 inc:integer;
 iVal:string;
 j:integer;
 donlist:stringlist;
 zonlist:stringlist;
  nodonlist:stringlist;
  conlist:stringlist;

code
{

heartbeat:=4;
:start:
zonlist:={"$zonlist"};
donlist:={"$donlist"};
nodonlist:={"$nodonlist"};
conlist:={"$conlist"};
    zones := zhead();
    cnt:=0;
 while(zones)
 {

		tlist := split(zones.title,"@");

if (length(tlist)==2)
         {
                 temp:=tlist.[1]+"@"+tlist.[0];
          if (zones.payonly)
{
if (not((zones.title+"@*") in zonlist))
{
addstring(zonlist,(zones.title+"@*"));
addstring(conlist,(temp+"@*"));
}
}
else
{
if (not((zones.title+"@n") in zonlist))
{
addstring(zonlist,(zones.title+"@n"));
addstring(conlist,(temp+"@n"));
}
}

}

zones:=zones.next;
}

pause;

iMax:=length(zonlist);
inc:=1;

while (inc < iMax)
 inc := inc *3+1;

inc:=inc/3;
while(inc > 0)
 {

 i:=inc;
 while (i < iMax)
  {
  iVal := zonlist.[i];
  j:=i;
  while(j > (inc-1))
   {
   if(iVal < zonlist.[j - inc])
    {
    zonlist.[j] := zonlist.[j - inc];
    }
   else
    break;
   j:=j-inc;
   }
  zonlist.[j] := iVal;
  i:=i+1;
  }
 inc := inc /3;
 }

pause;

iMax:=length(conlist);
inc:=1;

while (inc < iMax)
 inc := inc *3+1;

inc:=inc/3;
while(inc > 0)
 {

 i:=inc;
 while (i < iMax)
  {
  iVal := conlist.[i];
  j:=i;
  while(j > (inc-1))
   {
   if(iVal < conlist.[j - inc])
    {
    conlist.[j] := conlist.[j - inc];
    }
   else
    break;
   j:=j-inc;
   }
  conlist.[j] := iVal;
  i:=i+1;
  }
 inc := inc /3;
 }

            pause;

            i:=1;
            ln:=length(zonlist);
            while (i<ln)
             {
             tlist:=split(zonlist.[i],"@");
              if (tlist.[2]=="n")
                             addstring(nodonlist,tlist.[0]+"@"+tlist.[1]);
              else
                             addstring(donlist,tlist.[0]+"@"+tlist.[1]);

                             i:=i+1;
                             }

addextra(self.extra,zonlist,"all");
addextra(self.extra,donlist,"all");
addextra(self.extra,conlist,"all");
addextra(self.extra,nodonlist,"all");
                                                                      addextra(self.extra,donlist,"all");
quit;
}
dilend


dilbegin do_areas(arg : string);
var
rm:unitptr;
   tlist   : stringlist;
   buffer  : string;
   ln      : integer;
   i       : integer;
   action  : string;
   ival:string;
   tf:integer;
   space:string;


code
{
   if (self.type != UNIT_ST_PC)
   {
      sendtext("For PC's only.", self);
      quit;
   }

   rm:=findroom("hold_room@commands");
   action:=getword (arg);
   if (action== "") goto helpthem;
   else if (action==left("all",length(action))) goto areaall;
   else if (action==left("continent",length(action))) goto contlist;
   else if (action==left("donation",length(action))) goto don;
   else if (action==left("non donation",length(action)))  goto nodon;
   else goto by_cont;
   quit;


   :helpthem:

   sendtext("<u>Your options are:</u><br/><table class='colh2'>"+
   "<tr><td>'area all'</td><td>will list all areas on Valhalla</td></tr>"+
   "<tr><td>'area all continent'</td><td>will list all areas by continent</td></tr>"+
   "<tr><td>'area continent'</td><td>will list Valhalla current known continents</td></tr>"+
   "<tr><td>'area continent all'</td><td>will list all areas by continent</td></tr>"+
   "<tr><td>'area donation'</td><td>will list all donation only areas on Valhalla</td></tr>"+
   "<tr><td>'area non donation'</td><td>will list all non donation areas on Valhalla</td></tr>"+
   "</table><br/>", self);
    quit;

   :areaall:

   action:=getword(arg);
   if (action!="")
   {
      if (action==left("continent",length(action)))
      {
         action:="all";
         goto contlist;
      }
   }

   i := 1;
   ln := length(rm.extra.["$zonlist"].names);
   buffer := "<u>All Areas of Valhalla (*)denotes donation area:</u><br/>";
   buffer := buffer + "<table class='colh2'>";
   while (i < ln)
   {
      tlist:=split(rm.extra.["$zonlist"].names.[i],"@");

      if (tlist.[2]=="n")
      {
         buffer := buffer+"<tr><td>"+tlist.[0]+"</td><td>"+tlist.[1]+"</td></tr>";
      }
      else
      {
         buffer := buffer+"<tr><td>*"+tlist.[0]+"</td><td>"+tlist.[1]+"</td></tr>";
      }

      i := i + 1;
   }
   buffer := buffer + "</table>";
   goto end;


   :don:

   i := 1;
   ln := length(rm.extra.["$donlist"].names);
   buffer := "<u>Donation Areas of Valhalla:</u><br/><table class='colh2'>";
   while (i < ln)
   {
      tlist:=split(rm.extra.["$donlist"].names.[i],"@");
      buffer := buffer+"<tr><td>"+tlist.[0]+"</td><td>"+tlist.[1]+"</td></tr>";
      i := i + 1;
   }
   buffer := buffer + "</table>";
   goto end;


   :nodon:
   i := 1;
   ln := length(rm.extra.["$nodonlist"].names);
   buffer := "<u>Non Donation Areas of Valhalla</u><br/><table class='colh2'>";
   while (i < ln)
   {
      tlist:=split(rm.extra.["$nodonlist"].names.[i],"@");
      buffer := buffer+"<tr><td>"+tlist.[0]+"</td><td>"+tlist.[1]+"</td></tr>";
      i := i + 1;
   }
   buffer := buffer + "</table>";
   goto end;


   :by_cont:
   i := 1;
   ln := length(rm.extra.["$conlist"].names);
   tf:=0;

   while (i < ln)
   {
      tlist:=split(rm.extra.["$conlist"].names.[i],"@");
      if (action==left(tlist.[0],length(action)))
      {
         if (tf==0)
            buffer := "<u>"+tlist.[0]+" areas:</u>";
         tf:=1;
         if (tlist.[2]=="n")
            buffer := buffer+" "+tlist.[1]+"<br/>";
         else
            buffer := buffer+" * "+tlist.[1]+"<br/>";
      }
      i := i + 1;
   }

   if (tf != 1)
   {
      sendtext ("No continent by that name!",self);
      quit;
   }

  goto end;


   :contlist:
   /*now to figure out if player wants just continents list or all */
   if (action!="all")
      action:=getword(arg);

   if ((action!="")  and (action==left("all",length(action))))
      goto full_cont;


   /*print out just the list of continents*/
   i:=1;
   ln:=length(rm.extra.["$conlist"].names);
   ival:="";
   buffer:="";
   while (i<ln)
   {
      tlist:=split(rm.extra.["$conlist"].names.[i],"@");
      if (ival!=tlist.[0])/*if already printed it out skip*/
      {
         buffer:=buffer+" "+tlist.[0]+"<br/>";
         ival:=tlist.[0];
      }
      i:=i+1;
   }

   goto end;


   :full_cont:
   i:=1;
   ln:=length(rm.extra.["$conlist"].names);
   ival:="not a area";
   buffer:="List of Valhalla Areas By Continent<br/>";
   while (i<ln)
   {
      tlist:=split(rm.extra.["$conlist"].names.[i],"@");

      if (ival!=tlist.[0])
      {
         ival:=tlist.[0];
         buffer:=buffer+"<br/>"+tlist.[0]+"<br/><br/>";
      }
      if (tlist.[2]=="n")
         buffer := buffer+" "+tlist.[1]+"<br/>";
      else
         buffer := buffer+" * "+tlist.[1]+"<br/>";
      i:=i+1;
   }
   goto end;


   :end:
   pagestring(buffer,self);
   quit;
}
dilend


/* do_mount : this converts the mount command from base code to dil */
dilbegin do_mount(arg : string);

var

   horse    :  unitptr;
   saddle   :  unitptr;
   bridle   :  unitptr;
   cnt      :  integer;
   temp     :  string;

code{

if (arg == "")
    {
      sendtext("What do you wish to mount?<br/>", self);
      quit;
    }

temp := arg;
cnt := 1;
:loop:

horse := findunit(self, temp, FIND_UNIT_SURRO, null, UNIT_ST_NPC);

if (horse == null)
    {
      sendtext("Nothing named " + temp + " here to mount.<br/>", self);
      quit;
    }

if (not visible(self, horse))
    {
      cnt := cnt + 1;
      temp := itoa(cnt) + "." + arg;
      goto loop;
    }

if (horse == self)
    {
      sendtext("Uhm, that would defy the laws of physics!<br/>", self);
      quit;
    }

if (horse.type == UNIT_ST_OBJ)
    {
      sendtext("You cannot mount that!<br/>", self);
      quit;
    }

if (horse.type == UNIT_ST_PC)
    {
      act("$2e might not like that!", A_ALWAYS, self, horse, null, TO_CHAR);
      quit;
    }

if (horse.type == UNIT_ST_ROOM)
    {
      act("You are already in it!", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
    }

if ((not isset(horse.flags, UNIT_FL_TRANS)) and (not isset(horse.manipulate, MANIPULATE_ENTER)))
    {
      act("$2e might not like that!", A_ALWAYS, self, horse, null, TO_CHAR);
      quit;
    }

/* MS2020 eh. there are no shops or trainers ?
if (not horse.extra.["$trained"])
    {
      act("$2n is not trained to be a mount.", A_SOMEONE, self, horse, null,
TO_CHAR);
      quit;
    }

saddle := equipment(horse, WEAR_BACK);

if (not saddle)
    {
      act("$2n is not wearing a saddle.  You cannot mount $2m.", A_SOMEONE,
self, horse, null, TO_CHAR);
      quit;
    }

bridle := equipment(horse, WEAR_HEAD);

if (not bridle)
    {
      act("$2n is not wearing a bridle.  You cannot mount $2m.", A_SOMEONE,
self, horse, null, TO_CHAR);
      quit;
    }

if (not horse.extra.["$shoed"])
    {
      act("$2n is not shoed.  You cannot mount $2m.", A_SOMEONE, self,
horse, null, TO_CHAR);
      quit;
    }
*/
cnt := can_carry(horse, self, 1);

if (cnt)
    {
      act("You are too heavy for $2n.  You would surely break $2s back.",
A_SOMEONE, self, horse, null, TO_CHAR);
      quit;
    }

act("You mount $2n.", A_SOMEONE, self, horse, null, TO_CHAR);
act("$1n mounts $2n.", A_SOMEONE, self, horse, null, TO_REST);
link(self, horse);
exec("look", self);

send_done("mount", self, horse, null, 0, "", null);

quit;

}dilend


/* do_dismount : This converts the base code dismount command into dil. */

dilbegin do_dismount(arg : string);

var

   horse   :  unitptr;

code{


  if ((self.outside.type == UNIT_ST_NPC) and (isset(self.outside.flags, UNIT_FL_TRANS)) and
      (isset(self.outside.manipulate, MANIPULATE_ENTER)) and (self.outside.extra.["$trained"]))
     {
       horse := self.outside;
       act("You dismount $2n.", A_SOMEONE, self, horse, null, TO_CHAR);
       act("$1n dismounts $1s $2N.", A_SOMEONE, self, horse, null, TO_REST);
       link(self, horse.outside);
       exec("look", self);
       send_done("dismount", self, horse, null, 0, "", null);
       quit;
     }

  sendtext("You are not on a steed!<br/>", self);

  quit;

}dilend



/* dil do_prompt */
dilbegin do_prompt(arg : string);
var

   prom     :  string;
   i:integer;

code
{
   if (self.type != UNIT_ST_PC)
   {
      sendtext("This command is for PC's only.<br/>", self);
      quit;
   }

   if ("$noprompt" in self.extra)
   {
      sendtext("You have lost the ability to set your prompt.<br/>",self);
      quit;
   }

   if (arg == "")
   {
      prom := "Usage: prompt <prompt string><br/>" + 
              "Prompt string special identifiers, see help for more details<br/>";
      sendtext(prom, self);
      quit;
    }
    
   if (arg == "show")
   {
      sendtext("Your current prompt is :<br/><br/> " +self.prompt+"<br/>", self);
      /*log(self.name+" shows their prompt as : " +self.prompt+ " <br/>");*/
      quit;
   }

   if (arg=="default")
      self.prompt:= "%mana%m/%e%e/%hp%h> ";
   else 
      self.prompt := arg;

   i:=dildestroy("send_prompt@update",self);
   dilcopy("send_prompt@update",self);
   quit;
}dilend


/* do_time : This will show what the mud time is to the player. */
dilbegin do_time(arg : string);

var

   buffer   :  string;
   temp     :  string;
   i        :  integer;
   j        :  integer;
   ampm     :  string;
   day      :  string;
   dday     :  integer;
   month    :  string;
   mlist    :  stringlist;
   dlist    :  stringlist;
   st       :  string;

code
{
   /*
   sendtext("DEBUG<br/> mudday : " + itoa(mudday) + "<br/> mudhour " + itoa(mudhour)
   + "<br/> mudmonth " + itoa(mudmonth) + "<br/>", self);
   */
   mlist := {"Month of Winter", "Month of the Winter Wolf",
   "Month of the Frost Giant", "Month of the Spring","Month of Futility",
   "Month of the Sun", "Month of the Heat","Month of the Long Shadows",
   "Month of the Ancient Darkness"};

   dlist := {"the Day of the Bull", "the Day of the Deception",
            "the Day of Thunder", "the Day of Freedom",
            "the Day of the Great Gods", "the Day of the Sun",
            "the Day of the Moon"};

   i := mudhour;
   /* MS2020 ... bizarre! i:=i+1; 0 o'clock is 0 oclock and 1 is 1.*/
   if (i<13)
   {
      ampm := "AM";
      if (i==12)
         ampm := "O-clock, High noon!";
      else if (i==0)
      {
         ampm := "O-clock, Midnight!";
         i := 12;
      }
   }
   else
   {
      i:=i-12;
      ampm := "PM";
   }

   j := mudday;
   day := dlist.[j % 7];
   month := mlist.[mudmonth];

   dday := mudday + 1;

   if (dday == 1)
      st := "st";
   else if (dday == 2)
      st := "nd";
   else if (dday == 3)
      st := "rd";
   else
      st := "th";

   buffer := "It is " + itoa(i) + " " + ampm + ", on " + day + ",<br/>";
   buffer := buffer + "   the " + itoa(dday) + st + " Day of the " + month +
   ", Year " + itoa(mudyear) + ".<br/>";

   sendtext(buffer, self);

   quit;
}dilend



/* do_wiz to replace internal by that crack head Mesmer */
dilbegin do_wiz(arg : string);
var
ch : unitptr;
wizlvl : integer;
wizcmd : cmdptr;
tmp : string;
cnt : integer;
emote : integer;
lft : string;
code
{

   if(arg == "")
   {
    sendtext("Gods don't like being bothered like that!<br/>",self);
    quit;
   }

   wizcmd := chead();

   while((wizcmd) and (wizcmd.name != "wiz"))
    wizcmd := wizcmd.next;

   if(isset(self.flags,UNIT_FL_BURIED))
   {
    sendtext("You can not talk while buried.<br/>", self);
    quit;
   }

   if((left(arg,1) == "@") and (length(arg) > 1))
   {
   tmp := getword(arg);
   emote := TRUE;
   }

   else if(arg == "-")
   {
    if(isset(self.pcflags,PC_NOWIZ))
     sendtext("But you're ALREADY offline!<br/>", self);
    else
    {
     sendtext("You won't hear the wizline from now on.<br/>", self);
     set(self.pcflags,PC_NOWIZ);
    }
   quit;
   }

   else if(arg == "+")
   {
    if(not isset(self.pcflags,PC_NOWIZ))
     sendtext("But you're ALREADY online!<br/>", self);
    else
    {
     sendtext("You can now hear the wizline again.<br/>", self);
     unset(self.pcflags, PC_NOWIZ);
    }
   quit;
   }


   else if(arg == "?")
   {
    ch := ghead();
    cnt := 0;

    while(ch.type == UNIT_ST_PC)
    {
     if((ch.level >= IMMORTAL_LEVEL) and (visible(self,ch)))
     {
      if(cnt == 0)
      {
       if(ch.minv > 0)
        tmp := "*<div class='wiz'>"+ch.name+"("+itoa(ch.level)+")";
       else
        tmp := "<div class='wiz'>"+ch.name+"("+itoa(ch.level)+")";

                  if(isset(ch.pcflags,PC_NOWIZ))
                   tmp := tmp+"-<div class='wiz'>";
                 }
      else
      {
       if(ch.minv > 0)
        tmp := tmp+", *<div class='wiz'>"+ch.name+"("+itoa(ch.level)+")";
       else
        tmp := tmp+"<div class='wiz'>, "+ch.name+"("+itoa(ch.level)+")";

                  if(isset(ch.pcflags, PC_NOWIZ))
                   tmp := tmp+"-<div class='wiz'>";
                 }
      cnt := cnt + 1;
      }

     ch := ch.gnext;
    }

    sendtext(tmp, self);
    quit;
   }

   if(isset(self.pcflags,PC_NOWIZ))
   {
    sendtext("You're offline!!!<br/>", self);
    quit;
   }

   if((left(arg,1) == "#") and (length(arg) > 1))
   {
   tmp := getword(arg);
   wizlvl := atoi(right(tmp, length(tmp) - 1));

   if(wizlvl > self.level)
   {
    sendtext("You cannot limit the channel to a higher level than your own.<br/>", self);
    quit;
   }

   lft := ":"+itoa(wizlvl)+":";


   }
   else
   {

   wizlvl := self.minv;
   if(wizlvl > 200) lft := ":"+itoa(wizlvl)+":";
   else lft := "::";


   }

   ch := ghead();

   while(ch.type == UNIT_ST_PC)
   {

    if((ch.level >= wizcmd.level) and (ch.level >= wizlvl) and
           (not isset(ch.pcflags,PC_NOWIZ)))
        {
        if(emote)
           sendtext("<div class='wiz'>"+lft+" "+self.name+" "+arg+"<br/>", ch);
        else
           sendtext("<div class='wiz'>"+lft+" "+self.name+" :: "+arg+"<br/>", ch);
    }
    ch := ch.gnext;
   }

   send_done("wiz", self, null, null, 0, arg, null);
 quit;
}
dilend




/* do_setskill  : this will replace the base code setskill command */

dilbegin do_setskill(arg : string);

external
   integer skillindex(s1 : string);
   integer weaponindex(s1 : string);

var

  item        :  unitptr;
  cnt         :  integer;
  stype       :  string;
  sname       :  string;
  sdef        :  integer;
  samnt       :  integer;
  schk        :  integer;
  temp        :  string;
  slist       :  stringlist;
  scomp       :  stringlist;
  buffer      :  string;
  t1          :  integer;
  t2          :  integer;
  t3          :  integer;
  t4          :  integer;
  t5          :  integer;
  t6          :  integer;
  t7          :  integer;


code{


 if (arg == "")
    {
      sendtext("Syntax: setskill <name> (skill|spell|weapon) <field> <value>.<br/>", self);
      sendtext("For skills with spaces, use underscore, e.g. armor_soft_leather<br/>", self);
      quit;
    }

 temp := arg;
 cnt := 1;

:loop:

 item := findunit(self, temp, FIND_UNIT_GLOBAL, null);

 if ((item) and (not visible(self, item)))
    {
      cnt := cnt + 1;
      temp := itoa(cnt) + "." + arg;
      goto loop;
    }

 if (item == null)
    {
      sendtext("No such player or mobile to setskill on.<br/>", self);
      quit;
    }


 if ((item.type != UNIT_ST_PC) and (item.type != UNIT_ST_NPC))
    {
      sendtext("Setskill can only be used on PC's or NPC's.<br/>", self);
      quit;
    }

 stype := getword(temp);

 if (stype == "skill")
     goto set_skill;

 if (stype == "spell")
     goto set_spell;

 if (stype == "weapon")
     goto set_weapon;

 sendtext("Your options are either 'skill', 'spell' or 'weapon'.<br/>", self);
 quit;


:set_skill:

  if (item.type == UNIT_ST_NPC)
     {
       sendtext("Mobiles cannot have skills set in this manner.<br/>", self);
       quit;
     }

  sname := getword(temp);

  if (sname == "")
       sdef := -1;
  else
     {
       slist := split(sname, "_");

       sname := slist.[0];

       cnt := 1;

       while(cnt < length(slist))
           {
             sname := sname + " " + slist.[cnt];
             cnt := cnt + 1;
           }


       sdef := skillindex(sname);
     }

  if (sdef == -1)
     {
       buffer := "Invalid skill, please choose from the following:<br/>";

       sdef := 0;
       while(sdef < SKI_TREE_MAX)
          {
            sname := skill_name(sdef);

            if (sname == "")
                break;

            buffer := buffer + sname + "<br/>";

            sdef := sdef + 1;
          }

       sendtext(buffer, self);
       quit;
     }

  temp := getword(temp);
  samnt := atoi(temp);
  item.skills[sdef] := samnt;
  sname := skill_name(sdef);

  act("$2n's skill in " + sname + " is set to $3t.", A_ALWAYS, self, item, itoa(samnt), TO_CHAR);

  quit;



:set_weapon:

  sname := getword(temp);

  if (sname == "")
       sdef := -1;
  else
     {
       slist := split(sname, "_");

       sname := slist.[0];

       cnt := 1;

       while(cnt < length(slist))
           {
             sname := sname + " " + slist.[cnt];
             cnt := cnt + 1;
           }


       sdef := weaponindex(sname);
     }

  if (sdef == -1)
     {
       buffer := "Invalid weapon, please choose from the following:<br/>";

       sdef := 0;
       while(sdef < WPN_TREE_MAX)
          {
            sname := weapon_name(sdef);

            if (sname == "")
                break;

            buffer := buffer + sname + "<br/>";

            sdef := sdef + 1;
          }

       sendtext(buffer, self);
       quit;
     }

  if ((item.type == UNIT_ST_NPC) and (sdef >= WPN_GROUP_MAX))
     {
       sendtext("Mobiles can only have weapon groups set.<br/>", self);
       quit;
     }

  temp := getword(temp);
  samnt := atoi(temp);
  item.weapons[sdef] := samnt;
  sname := weapon_name(sdef);

  act("$2n's skill in " + sname + " is set to $3t.", A_ALWAYS, self, item, itoa(samnt), TO_CHAR);

  quit;


:set_spell:

  sname := getword(temp);

  if (sname == "")
       sdef := -1;
  else
     {
       slist := split(sname, "_");

       sname := slist.[0];

       cnt := 1;

       while(cnt < length(slist))
          {
            sname := sname + " " + slist.[cnt];
            cnt := cnt + 1;
          }


       sdef := spellindex(sname);
     }

  if (sdef == -1)
     {
       buffer := "Invalid spell, please choose from the following:<br/>";

       sdef := 0;
       while(sdef < SPL_TREE_MAX)
          {
            sname := spellinfo(sdef, t1, t2, t3, t4, t5, t6, t7);

            if (sname == "")
                break;

            buffer := buffer + sname + "<br/>";

            sdef := sdef + 1;
          }

       sendtext(buffer, self);
       quit;
     }

  if ((item.type == UNIT_ST_NPC) and (sdef >= SPL_GROUP_MAX))
     {
       sendtext("Mobiles can only have spell groups set.<br/>", self);
       quit;
     }

  temp := getword(temp);
  samnt := atoi(temp);
  item.spells[sdef] := samnt;
  sname := spellinfo(sdef, t1, t2, t3, t4, t5, t6, t7);

  act("$2n's skill in " + sname + " is set to $3t.", A_ALWAYS, self, item, itoa(samnt), TO_CHAR);

  quit;


}dilend




/* skillindex : This dil will return the SKI_XXXX of a skill if it matches
                the string it is sent.
*/

dilbegin integer skillindex(arg : string);

var

   sdef        :  integer;
   cnt         :  integer;
   sname       :  string;
   slist       :  stringlist;
   scomp       :  stringlist;

code{

  slist := getwords(arg);
  sdef := 0;


  while(sdef < SKI_TREE_MAX)
     {
       sname := skill_name(sdef);

       if (sname == "")
            break;

       scomp := getwords(sname);

       cnt := 0;

       while((cnt < length(slist)) and (cnt < length(scomp)))
          {
            if (not (slist.[cnt] in scomp.[cnt]))
                 break;

            cnt := cnt + 1;

            if ((cnt < length(slist)) and (cnt == length(scomp)))
                break;

            if (cnt == length(slist))
                 return(sdef);

          }


       sdef := sdef + 1;
     }

  return(-1);

}dilend

/* weaponindex : This dil will return the SKI_XXXX of a skill if it matches
                the string it is sent.
*/

dilbegin integer weaponindex(arg : string);

var

   sdef        :  integer;
   cnt         :  integer;
   sname       :  string;
   slist       :  stringlist;
   scomp       :  stringlist;

code{

  slist := getwords(arg);
  sdef := 0;


  while(sdef < WPN_TREE_MAX)
     {
       sname := weapon_name(sdef);

       if (sname == null)
            break;

       scomp := getwords(sname);

       cnt := 0;

       while((cnt < length(slist)) and (cnt < length(scomp)))
          {
            if (not (slist.[cnt] in scomp.[cnt]))
                 break;

            cnt := cnt + 1;

            if ((cnt < length(slist)) and (cnt == length(scomp)))
                break;

            if (cnt == length(slist))
                 return(sdef);

          }


       sdef := sdef + 1;
     }

  return(-1);

}dilend




/* do_wizinv : This will replace the base code wizinv command. */

dilbegin do_wizinv(arg : string);


var

  item   :  unitptr;
  cnt    :  integer;
  wizlvl :  integer;
  temp   :  string;

code{

 if (arg == "")
    {
      if (self.minv > 0)
         {
           act("You are no longer WIZI.", A_ALWAYS, self, null, null, TO_CHAR);
           self.minv := 0;
           quit;
         }

      self.minv := 219;
      act("You are now WIZI at level 219.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
    }



 temp := arg;

 temp := getword(temp);

 wizlvl := atoi(temp);

 if (wizlvl > self.level)
    {
      sendtext("You may not set items to a WIZI level greater than your own level.<br/>", self);
      quit;
    }

 if ((wizlvl > 0) or (temp == "0"))
    {
      self.minv := wizlvl;

      if (wizlvl == 0)
         {
           act("You are no longer WIZI.", A_ALWAYS, self, null, null, TO_CHAR);
           quit;
         }
      else
         {
           act("You are now WIZI level $2t.", A_ALWAYS, self, itoa(wizlvl), null, TO_CHAR);
           quit;
         }
    }



 temp := arg;

:loop:

 cnt := 1;

 item := findunit(self, temp, FIND_UNIT_GLOBAL, null);

 if ((item) and (not visible(self, item)))
    {
      cnt := cnt + 1;
      temp := itoa(cnt) + "." + arg;
      goto loop;
    }

 if (item == null)
    {
      act("No such thing to turn WIZI.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
    }

 temp := getword(temp);

 wizlvl := atoi(temp);

 if ((wizlvl == 0) and (temp != "0"))
    {
      if (item.minv == 0)
         {

           item.minv := 219;
           act("$2n has been set to WIZI level 219.", A_ALWAYS, self, item, null, TO_CHAR);
           quit;
         }
      else
         {
           item.minv := 0;
           act("$2n is no longer WIZI.", A_ALWAYS, self, item, null, TO_CHAR);
           quit;
         }
    }

 if (wizlvl > self.level)
    {
      act("You cannot assign a WIZI level above your own level.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
    }

 item.minv := wizlvl;
 act("$2n is now set to $3t WIZI level.", A_ALWAYS, self, item, itoa(wizlvl), TO_CHAR);

 quit;

}dilend


/* do_wiz : this will replace the base code wiz channel command */
/*
dilbegin do_wiz(arg : string);

var

  pc      :  unitptr;
  wizlvl  :  integer;
  temp    :  string;
  wizstr  :  string;
  wizcmd  :  cmdptr;


code{

 if (arg == "")
    {
      sendtext("The gods do not like to be disturbed in that fashion!<br/>", self);
      quit;
    }

 wizcmd := chead();

 while(wizcmd.name != "wiz")
    wizcmd := wizcmd.next;


 if (arg == "?")
    {
      pc := ghead();

      temp := "Wizards online:<br/>";

      while(pc.type == UNIT_ST_PC)
          {
            if ((pc.level >= IMMORTAL_LEVEL) and (visible(self, pc)))
                 temp := temp + pc.name + "(" + itoa(pc.level) + ")<br/>";

            pc := pc.gnext;
          }

      sendtext(temp, self);
      quit;
    }


 temp := arg;

 wizstr := getword(temp);

 if (left(wizstr, 1) == "#")
    {
      wizstr := right(wizstr, length(wizstr) - 1);
      wizlvl := atoi(wizstr);

      if (wizlvl > self.level)
         {
           sendtext("You cannot limit the channel to a higher level than your own.<br/>", self);
           quit;
         }
    }
 else
    {
      wizlvl := self.minv;
      wizstr := "";
    }

 if (wizlvl <= 199)
      temp := arg;

 if (left(temp, 1) == "@")
      temp := right(temp, length(temp) -1);
 else
      temp := ":: " + temp;

 pc := ghead();

 while(pc.type == UNIT_ST_PC)
    {
      if ((pc.level >= wizcmd.level) and (pc.level >= wizlvl))
           act("<div class='wiz'>:$3t: $2n " + temp + "</div>", A_ALWAYS, pc, self, wizstr, TO_CHAR);

      pc := pc.gnext;
    }

 quit;

}dilend
*/

/* do_purse : This dil replaces the original do_purse because if you picked
   up money that wasnt from basis.zon, it would screw up the purse count.
*/

dilbegin do_purse(arg : string);

var
u    : unitptr;
s    : stringlist;
buff : string;
cnt  : integer;

code
{

sendtext("Your purse contains:<br/> ", self);

buff := "";

s := {"null", "null", "null", "null", "null"};

u := self.inside;

while(u)
  {
     if ((u.type == UNIT_ST_OBJ) and (u.objecttype == ITEM_MONEY))
           s.[u.value[0]] := u.title + "<br/> ";

     u := u.next;
  }

cnt := MAX_MONEY;

while (cnt >= 0)
    {if (s.[cnt] != "null")
         buff := buff + s.[cnt];

     cnt := cnt - 1;
    }

if (buff == "")
    buff := "Nothing!<br/>";

sendtext (buff, self);

send_done("purse", self, null, null, 0, arg, null);

quit;

}dilend


/* do_inventory : This dil will show the players inventory to him */

dilbegin do_inventory(arg : string);


var

ln:integer;
z:integer;
   buffer   :  string;
   item     :  unitptr;
   temp     :  string;
   temp1    :  string;
   slist    :  stringlist;
   ilist    :  stringlist;
   clist    :  stringlist;
   cnt      :  integer;
   i        :  integer;

code
{
   buffer := "<u>You are carrying:</u><br/>";
   item := self.inside;

   while(item)
   {
      if (visible(self, item))
      {
         if ((item.type == UNIT_ST_OBJ) and ((item.objecttype == ITEM_MONEY) or (item.equip)))
         {
            item := item.next;
            continue;
         }
         else if (item.type == UNIT_ST_OBJ)
         {
            temp1 := "<div class='obj_title'>";
            temp :=  item.title;
         }
         else if (item.type == UNIT_ST_PC)
         {
            if (item.level >= IMMORTAL_LEVEL)
               temp1 := "<div class='imm_title'>";
            else
               temp1 := "<div class='pc_title'>";

            temp := item.name;
         }
         else if (item.type == UNIT_ST_NPC)
         {
            temp1 := "<div class='npc_title'>";
            temp := item.title;
         }
         else
         {
            sendtext("Something is wrong with your inventory. Please contact an admin immediately.</div><br/>", self);
            log("INVENTORY : " + self.name + " somehow had a room in his inventory.");
            quit;
         }

         if ((self.level >= IMMORTAL_LEVEL) and (item.minv > 0))
            temp := temp + " (wizinv)";

         if (item.bright > 0)
            temp := temp + " (light)";
         else if (item.bright < 0)
            temp := temp + " (dark)";

         cnt:=0;
         ln:=length(slist);
         while (cnt<ln)
         {
            if (temp==slist.[cnt])
               break;
            cnt:=cnt+1;
         }

         if (cnt!=ln)
         {
            i := atoi(ilist.[cnt]);
            i := i + 1;
            ilist.[cnt] := itoa(i);
            cnt:=cnt+1;
         }
         else
         {
            addstring(slist, temp);
            addstring(clist, temp1);
            cnt := length(slist);
            addstring(ilist, "1");
         }
      } // if visible

      item := item.next;
   }

   cnt := 0;

   if (not length(slist))
      buffer := buffer + "<div class='obj_title'> Nothing.</div><br/>";
   else
   {
      while(cnt < length(slist))
      {
         if (atoi(ilist.[cnt]) > 1)
            temp := clist.[cnt] + "[x" + ilist.[cnt] + "] ";
         else
            temp := clist.[cnt];

         buffer := buffer + temp + slist.[cnt] + "</div><br/>";

         cnt := cnt + 1;
      }
   }

   pagestring(buffer, self);
   quit;
}
dilend


/* add_spaces:  This is just a formatting command

dilbegin string add_spaces(len  : integer);

var

   temp : string;
   cnt  : integer;

code{
   temp:="&//s"+itoa(len);
   return(textformat(temp));

}dilend
*/



/* do_follow:  this will put the follow command into dil. */

dilbegin do_follow(arg : string);


var

   mast   :  unitptr;
   temp   :  string;
   cnt    :  integer;

code{

 if (arg == "")
    {
      mast := self.master;

      if (mast == null)
           sendtext("You are not following anyone.<br/>", self);
      else
           sendtext("You are following " + mast.name + ".<br/>", self);

      quit;
    }


/* This is a little messy, but only way I can think to do it to avoid
   people from following invisible players or worse, wizi gods.
   Let me know if there is a better way.
*/

 temp := arg;
 cnt := 1;

:loop:
 mast := findunit(self, temp, FIND_UNIT_SURRO, null);

 if (mast == null)
    {
      sendtext("There is no one named " + arg + " here to follow.<br/>", self);
      quit;
    }

 if (mast == self)
    {
      if (self.master == null)
         {
           sendtext("Who do you wish to follow?<br/>", self);
           quit;
         }
      else
         {
           mast := null;
           act("You stop following $2n.", A_SOMEONE, self, self.master, null, TO_CHAR);
           act("$1n stops following you.", A_SOMEONE, self, null, self.master, TO_VICT);

           follow(self, mast);

           if (not isset(self.charflags, CHAR_GROUP))
                set(self.charflags, CHAR_GROUP);
           quit;
         }
    }

 if ((not visible(self, mast)) or (mast.type == UNIT_ST_OBJ))
    {
      cnt := cnt + 1;
      temp := itoa(cnt) + "." + arg;
      goto loop;
    }


 if (mast == self.master)
    {
      act("You already are following $2n.", A_SOMEONE, self, mast, null, TO_CHAR);
      quit;
    }

 if (isset(self.charflags, CHAR_GROUP))
      unset(self.charflags, CHAR_GROUP);

 if (self.master != null)
      act("You stop following $2n.", A_SOMEONE, self, self.master, null, TO_CHAR);

 follow(self, mast);

 sendtext("You now follow " + mast.name + ".<br/>", self);

 if (visible(mast,self))
      sendtext(self.name + " starts following you.<br/>", mast);

 quit;

}dilend


/* ditch : this is a repair to the ditch dil that was released with 2.0.2
           this prevents people from aliasing 'follow' with their dictionaries
           and thus prevent people from ditching you. */

dilbegin ditch(arg : string);
var
   u : unitptr;
   s : string;
   p : unitptr;

code
{
   if (arg == "")
   {
      act("They are not here.",A_SOMEONE, self, null, null,TO_CHAR);
      quit;
   }

   u := findunit(self, arg, FIND_UNIT_WORLD, null);
   secure(u,losthim);

   if ((u == null) or not visible(self, u))
   {
      act("No such person by that name!.",A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (visible(self,u)))
   {
      act("No such person by that name!.",A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if ((u.master == self) and  (u.type == UNIT_ST_NPC))
   {
      act("$1n tries to ditch $3n but fails miserably.", A_SOMEONE, self, null, u, TO_NOTVICT);
      act("You can not ditch $3n.",A_SOMEONE, self,null,u, TO_CHAR);
      quit;
   }

   if ((u.master == self) and  (u.type == UNIT_ST_PC))
   {
      p := null;
      act("$1n has ditched $3n.", A_SOMEONE, self, null, u, TO_NOTVICT);
      act("$1n has ditched you.",A_SOMEONE,self, null,u, TO_VICT);
      act("You have ditched $3n.",A_SOMEONE, self,null,u, TO_CHAR);
      follow(u , p);
      quit;
   }
   else
   {
      act("$2n is not following you",A_SOMEONE, self, u, null, TO_CHAR);
      quit;
   }

   :losthim:
   quit;
}
dilend





/* do_group : this will replace the basecode group command */

dilbegin do_group (arg : string);

var

   mast    :  unitptr;
   buffer  :  string;
   fol     :  unitptr;
   cnt     :  integer;
   temp    :  string;

code{

 if (arg == "")
    {
      if (not isset(self.charflags, CHAR_GROUP))
         {
           sendtext("You are not a member of a group.<br/>", self);
           quit;
         }

      if (self.master)
          mast := self.master;
      else
          mast := self;

      cnt := 0;

      buffer := "Your group consists of:<br/>";

      if ((isset(mast.charflags, CHAR_GROUP)) and (mast.master == null))
         {

           if (not visible(self, mast))
              {
                if (fol.sex == SEX_NEUTRAL)
                     temp := "Something (Head of Group)<br/>";
                else
                     temp := "Someone (Head of Group)<br/>";
              }
           else if (mast.type == UNIT_ST_PC)
                temp := mast.name + " (Head of Group)<br/>";
           else if (mast.type == UNIT_ST_NPC)
                temp := mast.title + " (Head of Group)<br/>";

           buffer := buffer + "     " + temp;
         }



      while (cnt < mast.followercount)
         {
           fol := getfollower(mast, cnt);

           if (isset(fol.charflags, CHAR_GROUP))
              {
                 if (visible(self, fol))
                    {
                      if (fol.type == UNIT_ST_PC)
                           buffer := buffer + "     " + fol.name + "<br/>";
                      else
                           buffer := buffer + "     " + fol.title + "<br/>";
                    }
                 else
                    {
                      if (fol.sex == SEX_NEUTRAL)
                           buffer := buffer + "     Something<br/>";
                      else
                           buffer := buffer + "     Someone<br/>";
                    }
              }

           cnt := cnt + 1;
         }


      sendtext(buffer, self);

      quit;
    }


 /* This is a little messy, but only way I can think to do it to avoid
   people from grouping invisible players or worse, wizi gods, and telling
   that wizis are there by not being able to 'group whistler' but being
   able to group '2.whistler'.
   Let me know if there is a better way.
 */

 temp := arg;
 cnt := 1;

:loop:
 mast := findunit(self, temp, FIND_UNIT_SURRO, null);

 if (mast == null)
    {
      if (arg == "self")
           mast := self;
      else
          {
            sendtext("There is no one named " + arg + " here.<br/>", self);
            quit;
          }
    }

 if (((mast != self) and (not visible(self, mast))) or (mast.type == UNIT_ST_OBJ))
    {
      cnt := cnt + 1;
      temp := itoa(cnt) + "." + arg;
      goto loop;
    }


 if (self.master != null)
    {
      sendtext("You cannot enroll group members without being the head of the group.", self);
      quit;
    }

 if ((mast != self) and (mast.master != self))
    {
      sendtext(mast.name + " must follow you to enter your group.", self);
      quit;
    }


 if (not isset(mast.charflags, CHAR_GROUP))
    {
      set(mast.charflags, CHAR_GROUP);

      if (mast != self)
         {
           act("You are now a member of $2n's group.", A_ALWAYS, mast, self, null, TO_CHAR);
           act("$1n is now a member of your group.", A_ALWAYS, mast, null, self, TO_VICT);
         }
      else
           act("You are now a member of the group.", A_ALWAYS, self, null, null, TO_CHAR);


      act("$1n is now a member of $3n's group.", A_ALWAYS, mast, null, self, TO_NOTVICT);
    }
 else
    {
      unset(mast.charflags, CHAR_GROUP);

      if (mast != self)
         {
           act("You are no longer a member of $2n's group.", A_ALWAYS, mast, self, null, TO_CHAR);
           act("$1n is no longer a member of your group.", A_ALWAYS, mast, null, self, TO_VICT);
         }
      else
           act("You are no longer a member of the group.", A_ALWAYS, self, null, null, TO_CHAR);

      act("$1n is no longer a member of $3n's group.", A_ALWAYS, mast, null, self, TO_NOTVICT);

    }

 quit;

}dilend





/* do_restore : This will restore chosen character to full hps/mana/endurance full and thirst.
   'restore all' will do this to all players in the world.  Also, 'restore self' will set all
   stats on god to 200 and set thirst/full to 115, making them never get hungry/thirsty.
*/

dilbegin do_restore(arg : string);

var


   pc  : unitptr;
   i   : integer;
   ext : extraptr;

code{

if (self.level < IMMORTAL_LEVEL)
  {act("Whoa, how did you use this command???", A_ALWAYS, self, null, null, TO_CHAR);
   log(self.name + " used the Restore DIL some how.");
   quit;
  }

if (arg == "")
  {act("Who do you wish to restore?  (Usage : restore <unit name> or restore all)", A_ALWAYS, self, null, null, TO_CHAR);
   quit;
  }

if (arg == "self")
  goto restore_self;


pc := findunit(self, arg, FIND_UNIT_GLOBAL, null);

if ((pc == null) and (arg != "all"))
  {act("No such character to restore.", A_ALWAYS, self, null, null, TO_CHAR);
   quit;
  }

if (pc == self)
  goto  restore_self;

if (arg == "all")
  goto restore_all;

if ((pc.type != UNIT_ST_PC) and (pc.type != UNIT_ST_NPC))
  {act("No such character to restore.", A_ALWAYS, self, null, null, TO_CHAR);
   quit;
  }


pc.hp := pc.max_hp;
pc.mana := pc.max_mana;
pc.endurance := pc.max_endurance;
pc.full := 24;
pc.thirst := 24;

position_update(pc);

act("You have restore $3n to health.", A_ALWAYS, self, null, pc, TO_CHAR);
act("$1n has restored you to health.", A_ALWAYS, self, null, pc, TO_VICT);

quit;


:restore_all:

pc := ghead();

while((pc.type == UNIT_ST_PC))
   {

    if (pc.level > IMMORTAL_LEVEL)
        {
          pc := pc.gnext;
          continue;
        }

    pc.hp := pc.max_hp;
    pc.mana := pc.max_mana;
    pc.endurance := pc.max_endurance;
    pc.full := 24;
    pc.thirst := 24;

    position_update(pc);

    if (pc != self)
       act("$3n has restored the world to health!", A_ALWAYS, pc, null, self, TO_CHAR);

    pc := pc.gnext;
   }

act("You have restored the world to perfect health.", A_ALWAYS, self, null, null, TO_CHAR);

quit;

:restore_self:

i := 0;

while(i < ABIL_TREE_MAX)
   {self.abilities[i] := 200;
    i := i + 1;
   }

ext := "$hitpoints" in self.extra;
ext.names.[1] := "200";

i := 0;

while (i < WPN_TREE_MAX)
   {self.weapons[i] := 200;
    i := i + 1;
   }

i := 0;

while (i < SPL_TREE_MAX)
   {self.spells[i] := 200;
    i := i + 1;
   }

i := 0;

while (i < SKI_TREE_MAX)
   {self.skills[i] := 200;
    i := i + 1;
   }

self.hp := self.max_hp;
self.mana := self.max_mana;
self.endurance := self.max_endurance;

self.thirst := 115;
self.full := 115;

position_update(self);

act("You have divinely boosted yourself!", A_ALWAYS, self, null, null, TO_CHAR);

quit;

}dilend



dilbegin do_score(arg:string);
external
   string titlestring();
   string agestring(rce : integer);
   string playingstring();

var
   u : unitptr;
   leader : unitptr;
   slave : unitptr;
   alig : string;
   pos : string;
   deaths:string;
   want : string;
   start: string;
   sav : string;
   bob : string;
   stat : string;
   stat1 : string;
   stat2 : string;
   slvl : string;
   i : integer;
code
{
   /*if(self.type!=UNIT_ST_PC) quit;*/

   if(self.position == POSITION_FIGHTING)
   {
      sendtext("Not while fighting!<br/>", self);
      quit;
   }

   /*whats my align */
   if (self.alignment > 350)
      alig := "(Good)";
   else if (self.alignment < -350)
      alig := "(Evil)";
   else
      alig := "(Neutral)";
   /*whats my position */

   if(self.position == POSITION_DEAD)
      pos := "<div class='score'>Sorry old chap, it seems like you're Dead!</div>";
   else if(self.position == POSITION_MORTALLYW)
      pos := "<div class='score'>You are mortally wounded, you should seek help!</div>";
   else if(self.position == POSITION_INCAP)
      pos := "<div class='score'>You are incapacitated, slowly fading away.</div>";
   else if(self.position == POSITION_STUNNED)
      pos := "<div class='score'>You are stunned and unable to move.</div>";
   else if(self.position == POSITION_SLEEPING)
      pos := "<div class='score'>You are sleeping.</div>";
   else if(self.position == POSITION_RESTING)
      pos := "<div class='score'>You are resting.</div>";
   else if(self.position == POSITION_SITTING)
      pos := "<div class='score'>You are sitting.</div>";
   else
      pos := "<div class='score'>You are standing.</div>";

   if ("$TOTAL_DEATHS" in self.extra)
      deaths:="You have died a total of "+itoa(self.extra.["$TOTAL_DEATHS"].vals.[0])+" times <br/>";
   else 
      deaths:="";
   
   if (isset(self.charflags, CHAR_PROTECTED))
      want := "<div class='score'>You are a protected citizen.</div>";
   else if (isset(self.charflags, CHAR_LEGAL_TARGET))
      want := "<div class='score'>You are a protected citizen, but people may kill you now!</div>";
   else if (isset(self.charflags, CHAR_OUTLAW))
      want := "<div class='score'>You are wanted dead or alive by the law.</div>";
   else if (isaff(self, ID_REWARD))
      want := "<div class='score'>There is a reward on your head.</div>";
   else
      want :="";

   /* am i BoB */
   if (isset(self.pcflags,PC_PK_RELAXED))
      bob := "<div class='score'>You have signed the Book of Blood.</div>";
   else
      bob :="";

   /* am i drunk hungry thirsty? */
   if (self.drunk > 10 )
      stat :="<div class='score'>You are drunk!</div>";
   else
      stat := "";


   if (self.thirst < 4 )
      stat1 :="<div class='score'>You are thirsty.</div>";
   else
      stat1 := "";

   if (self.full < 4 )
      stat2 :="<div class='score'>You are hungry!</div>.";
   else
      stat2 := "";

   start := "";
   if (self.level <= START_LEVEL)
      start := "<br/><div class='score'>Try also the '<a cmd='#'>status</a>' command.</div>";
    
   if (not isplayer(self.name))
	{
      sendtext ("<div class='score'>You remain a GUEST until you 'save' yourself</div>",self);
      quit;
	}

   slvl := "";
   if (self.exptol <= 0)
   {
      slvl := "<b>You can advance a <a cmd='#'>level</a> now - congratulations!</b><br/>";
   }

   if(arg=="")
   {
      act(titlestring()
         +"<div class='score'>" + agestring(self.race)
         +"You have "+itoa(self.exp)+" experience points and you need "
         +itoa(self.exptol) + " to the next level.</div><br/>"+
         slvl
         +"<div class='score'>You have "+itoa(self.hp)+"("+itoa(self.max_hp)+") hit, "
         +itoa(self.mana)+"("+itoa(self.max_mana)+") mana, "
         +itoa(self.endurance)+"("+itoa(self.max_endurance)+") endurance points.</div><br/>"
         +"<div class='score'>"+bob+""+playingstring()+deaths+""+want+" "+pos+""+stat+""+stat1+""+stat2+"</div>"+start
         ,A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
   else if (arg==left("group",length(arg)))
   {
   if (isset(self.charflags,CHAR_GROUP))
   {
   if ((self.master==null) or (self.master==self))
   {
   :not_leader:
      if (self.followercount<=0)
      {
   act("<div class='score'>What group!!</div>",A_ALWAYS,self,null,self,TO_CHAR);
   quit;
   }
   act("<div class='score'>"+self.name+" "+itoa(self.hp)+"/"+itoa(self.max_hp)+
      " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
      " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana"+
      " to the group.</div>",A_ALWAYS,self,null,null,TO_CHAR);
   i:=0;
   while(i<self.followercount)
   {
   u:=getfollower(self,i);
   if (isset(u.charflags,CHAR_GROUP))
      act("<div class='score'>"+u.name+" "+itoa(u.hp)+"/"+itoa(u.max_hp)+
      " Hitpoints, "+itoa(u.endurance)+"/"+itoa(u.max_endurance)+
      " Endurance, "+itoa(u.mana)+"/"+itoa(u.max_mana)+" Mana"+
      " to the group.</div>",A_ALWAYS,self,null,u,TO_CHAR);
      i:=i+1;
      }

   }
         else
         {
         if (isset(self.master.charflags,CHAR_GROUP))
         {
         leader:=self.master;
         secure (leader,lead_end);
   act ("<div class='score'>"+leader.name+" "+itoa(leader.hp)+"/"+itoa(leader.max_hp)+
      " Hitpoints, "+itoa(leader.endurance)+"/"+itoa(leader.max_endurance)+
      " Endurance, "+itoa(leader.mana)+"/"+itoa(leader.max_mana)+" Mana"+
      " to the group.</div>",A_ALWAYS,self,null,leader,TO_CHAR);
   while(i<leader.followercount)
   {
   u:=getfollower(leader,i);
      if (isset(u.charflags,CHAR_GROUP))
      act("<div class='score'>"+u.name+" "+itoa(u.hp)+"/"+itoa(u.max_hp)+
      " Hitpoints, "+itoa(u.endurance)+"/"+itoa(u.max_endurance)+
      " Endurance, "+itoa(u.mana)+"/"+itoa(u.max_mana)+" Mana"+
      " to the group.</div>",A_ALWAYS,self,null,u,TO_CHAR);
      i:=i+1;
      }

         }
         else
         goto not_leader;
         }

   }
   else
   sendtext ("You are not in a group silly.<br/>",self);
   }
   else
      sendtext("Use either 'score' or 'score group'<br/>",self);

   :lead_end:
   unsecure(leader);
   quit;
}
dilend


dilbegin do_advance (arg:string);
var
  targ:unitptr;
  lvl:integer;
  pname:string;
  args:stringlist;


code
{
if (self.type!=UNIT_ST_PC)
  quit;

if (arg=="")
  {
  sendtext("Who do you want to advance and how high.<br/>",self);
  quit;
  }
args:=getwords(arg);
if (length(args)<3)
 {
 sendtext ("You must specify (Admin or Ply), name, and level.<br/>",self);
 quit;
 }

pname:=args.[1];
targ:=findunit(self,pname,FIND_UNIT_WORLD,null,UNIT_ST_PC);
if (targ==null)
  {
  sendtext ("That character is not here.<br/>",self);
  quit;
  }

if (not(visible(self,targ)))
 {
  sendtext ("That character is not here.<br/>",self);
  quit;
  }

lvl:=atoi(args.[2]);
if (lvl<1)
  {
  sendtext("You must supply a positive number.<br/>",self);
  quit;
  }

  if (args.[0]=="admin")
  goto admin_level;

	if (args.[0]=="ply")
	 goto ply_level;

sendtext("You must choose Admin or Player levels.",self);
quit;


:admin_level:
if ((lvl<200) or (lvl>255))
  {
  sendtext("Level must be in between 200 and 255 for Admin levels.<br/>",self);
  quit;
  }

  if (self.level<targ.level)
   {
   act ("$3n would not be pleased if you did that.",
   A_ALWAYS,self,null,targ,TO_VICT);
   quit;
   }

   if (lvl<targ.level)
   {
   act ("You demote $3n.",
   A_ALWAYS,self,null,targ,TO_CHAR);
      act ("$3n makes some strange gestures. "+
	   "A horrible feeling comes upon you, like a giant hand, darkness"+
	   "comes down from above, grabbing your body, which begin to ache "+
	   "with striking pain from inside. Your head seems to be filled with "+
	   "daemons from another plane as your body dissolves into the "+
	   "elements of time and space itself. You feel less powerful.",
	   A_ALWAYS, targ, null, self, TO_CHAR);
   }
else    if (lvl>targ.level)
   {
      act ("You promote $3n.",
   A_ALWAYS,self,null,targ,TO_CHAR);
  act ("$3n makes some strange gestures. "+
       "A strange feeling comes upon you, like a giant hand, light comes "+
       "down from above, grabbing your body, which begins to pulse with "+
       "coloured lights from inside. Your head seems to be filled with "+
       "daemons from another plane as your body dissolves into the elements "+
       "of time and space itself. Suddenly a silent explosion of light snaps "+
       "you back to reality. You feel slightly different.",
       A_ALWAYS, targ, null, self, TO_CHAR);
   }
else
  {
  act("$3n is already that level.",
  A_ALWAYS,self,null,targ,TO_CHAR);
  quit;
  }
targ.exp:=0;
targ.level:=lvl;

quit;

:ply_level:


if (targ.level>=200)
 {
 sendtext("You can't diminish that Admin status to a player you need to delete and start that character again.<br/>",self);
 quit;
 }


sendtext ("Characters Experience before you advanced = "+itoa(targ.exp),self);
if (lvl<=50)
{
targ.exp:=1500 * lvl + lvl * lvl * (300 / 2);
targ.vlevel:=lvl;
                targ.level:=lvl;
}
else
{
targ.exp:=(1500 * 50 + 50 * 50 * (300 / 2))+((1650+50*300)*(lvl-50));
targ.vlevel:=lvl;
                targ.level:=lvl;
 }
sendtext ("Characters Experience after you advanced = "+itoa(targ.exp),self);
sendtext ("Character needs "+itoa(targ.exptol)+" to level.",self);
if (targ.exptol==0)
  sendtext ("You have been advanced in levels you may raise levels using the 'level' command<br/>",targ);
quit;
}
dilend
dilbegin do_extinguish(arg:string);
var
torch : unitptr;
code
{
  torch := findunit(self, arg, FIND_UNIT_HERE,null,UNIT_ST_OBJ);

  if (torch == null)
    {
      sendtext("No such thing.<br/>",self);
      return;
    }

 if ((torch.type != UNIT_ST_OBJ) or (torch.objecttype != ITEM_LIGHT))
    {
      sendtext("You can't extinguish that.<br/>",self);
      return;
    }

     if (not(isaff(torch, ID_LIGHT_EXTINGUISH)))
    {
      sendtext("How silly, it isn't even lit!<br/>", self);
      return;
    }

   if (isaff(torch, ID_LIGHT_EXTINGUISH))
     subaff(torch, ID_LIGHT_EXTINGUISH);

  if (torch.value[0] > 0)
       torch.value[0] := 0;
  act ("You extinguish $2n with your bare hands.",
       A_SOMEONE, self, torch, null, TO_CHAR);

  act ("$1n extinguishes $2n with $1s bare hands.",
       A_SOMEONE, self, torch, null, TO_ROOM);


quit;
}
dilend


dilbegin do_light(arg:string);
var
torch : unitptr;
code
{

  torch := findunit(self, arg, FIND_UNIT_HERE,null,UNIT_ST_OBJ);

  if (torch == null)
    {
     sendtext("No such thing.<br/>",self);
      return;
    }

  if ((torch.type != UNIT_ST_OBJ) or (torch.objecttype != ITEM_LIGHT))
    {
     sendtext("You can't light that.<br/>",self);
      return;
    }
  if (isaff(torch, ID_LIGHT_EXTINGUISH))
    {
     sendtext("How silly, it is already lit.<br/>",self);
      return;
    }
   if (torch.value[0] <= 0)
    {
     sendtext("It wont ignite.<br/>",self);
      return;
    }

  	addaff(torch, ID_LIGHT_EXTINGUISH, torch.value[0],SECS_PER_MUD_HOUR*WAIT_SEC,
	       2, 0, 0, TIF_NONE, TIF_TORCH_TICK, TIF_NONE,APF_LIGHT_DARK);
  act("You light $2n.", A_SOMEONE, self, torch, null, TO_CHAR);
  act("$1n lights $2n.", A_SOMEONE, self, torch, null, TO_ROOM);
quit;
}
dilend


dilbegin do_practice (arg:string);
code
{
   sendtext("You can only practice at a teacher.<br/>",self);
   quit;
}
dilend


dilbegin do_info(arg:string);
code
{
   sendtext("You can't do that here (find a teacher, try '<a cmd='#'>status</a>' or '<a cmd='#'>help info</a>')<br/>",self);
   quit;
}
dilend

dilbegin do_purge(arg:string);
var
 u:unitptr;
code
{

if (arg=="")
	goto old_purge;

 u:=findunit(self,arg,FIND_UNIT_GLOBAL,null,UNIT_ST_PC);
if (u==null)
 u:=findunit(self,arg,FIND_UNIT_HERE,null,UNIT_ST_NPC);
 if (u==null)
 u:=findunit(self,arg,FIND_UNIT_HERE,null,UNIT_ST_OBJ);

if (u==null)
 u:=findunit(self,arg,FIND_UNIT_ZONE,null,UNIT_ST_NPC);
if (u==null)
 u:=findunit(self,arg,FIND_UNIT_ZONE,null,UNIT_ST_OBJ);

if (u==null)
 u:=findunit(self,arg,FIND_UNIT_WORLD,null,UNIT_ST_NPC);
if (u==null)
 u:=findunit(self,arg,FIND_UNIT_WORLD,null,UNIT_ST_OBJ);


if (u==null)
 {
act ("No such thing '$2t' to purge.",
A_ALWAYS,self,arg,null,TO_CHAR);
quit;
}

if (not(visible(self,u)))
 {
act ("No such thing '$2t' to purge.",
A_ALWAYS,self,arg,null,TO_CHAR);
quit;
}

if (u.type==UNIT_ST_PC)
{
if (u.level>=self.level)
{
act("$3n would not like that.",
A_SOMEONE,self,null,u,TO_CHAR);
quit;
}
 }

:purge_one:
act ("$1n disintegrates $3n.",
A_SOMEONE,self,null,u,TO_NOTVICT);
act ("You disintegrate $3n.",
A_SOMEONE,self,null,u,TO_CHAR);
if (IS_CORPSE(u))
dilcopy ("death_clear@death()",u);
else
destroy(u);
quit;

:old_purge:
foreach (UNIT_ST_NPC|UNIT_ST_OBJ,u)
  {
  if ((u.type==UNIT_ST_PC) or (u.type==UNIT_ST_ROOM))
    continue;
	if ((u.type==UNIT_ST_OBJ) and
	  (not(isset(u.manipulate,MANIPULATE_TAKE))))
	  continue;
	  if ((IS_CORPSE(u)) and
	   (u.value[2]==1))
  continue;
	    destroy (u);
  }

  act ("$1n gestures... You are surrounded by scorching flames.",
  A_SOMEONE,self,null,null,TO_REST);
  act ("You are surrounded by scorching flames.",
  A_SOMEONE,self,null,null,TO_CHAR);
quit;
}
dilend

dilbegin force (arg:string);
var
 u:unitptr;
 all_arg:string;
code
{

if (self.type!=UNIT_ST_PC)
	quit;

 u:=findunit(self,arg,FIND_UNIT_GLOBAL,null,UNIT_ST_PC);
if (u==null)
 u:=findunit(self,arg,FIND_UNIT_HERE,null,UNIT_ST_NPC);
if (u==null)
 u:=findunit(self,arg,FIND_UNIT_ZONE,null,UNIT_ST_NPC);
if (u==null)
 u:=findunit(self,arg,FIND_UNIT_WORLD,null,UNIT_ST_NPC);

if (u==null)
 {
all_arg:=getword(arg);
if (all_arg=="all")
  goto force_all;
  sendtext("Who would you like to force to do what?<br/>",self);
  quit;
  }

  :force_one:
if (self.level < u.level)
{
if (visible(self,u))
act("You can't force $3n to do that.",
A_ALWAYS,self,null,u,TO_CHAR);
else
sendtext("Who would you like to force to do what?<br/>",self);
quit;
}

  act ("Forcing $3n to '$2t'",
  A_ALWAYS,self,arg,u,TO_CHAR);
act("$1n has forced you to '$2t'",
A_SOMEONE,self,arg,u,TO_VICT);

exec (arg,u);
sendtext("Done<br/>",self);
quit;

:force_all:
u:=pc_head();
while (u.type==UNIT_ST_PC)
{
if (u==self)
 {
 u:=u.gnext;
 continue;
 }
if (self.level > u.level)
{
act("$1n has forced you to '$2t'",
A_SOMEONE,self,arg,u,TO_VICT);

 	exec (arg,u);
}
 else if (visible(self,u))
 act("You can't force $3n to do that.",
 A_ALWAYS,self,null,u,TO_CHAR);

 u:=u.gnext;
 }
sendtext("Done<br/>",self);
 quit;
 }
 dilend



/* allows the use of  extra {"$smell"} on rooms */
dilbegin smell (arg:string);
code
{
   heartbeat:=PULSE_SEC*60;
   :start:
   act ("You take a long sniff at the air...",
       A_ALWAYS,self,null,null,TO_CHAR);
   act ("$1n takes a long sniff at the air, and looks contemplative.",
       A_SOMEONE,self,null,null,TO_REST);

if (self.outside.extra.["$smell"]!=null)
   act (self.outside.extra.["$smell"].descr+"",
       A_ALWAYS,self,null,null,TO_CHAR);

quit;
}
dilend

/*allows the use of extra {"$listen"}  on rooms */
dilbegin listen (arg:string);
code
{
   act ("You perk up your ears and listen carefully...",
       A_ALWAYS,self,null,null,TO_CHAR);
   act ("$1n perks up $1s ears and starts listening carefully to the surroundings.",
       A_SOMEONE,self,null,null,TO_REST);

	   if (self.outside.extra.["$listen"]!=null)
   act (self.outside.extra.["$listen"].descr+"",
       A_ALWAYS,self,null,null,TO_CHAR);

quit;
}
dilend

dilbegin integer wear(ch : unitptr, obj : unitptr,
                      keyword : integer, arg : string, err : integer,
                      cmd_str : string);
external
	unit_msg(ch : unitptr, obj : unitptr, ex_str : string,
                  act_self : string, act_other : string);
	integer hands_used(ch : unitptr);
	string obj_wear_size(ch : unitptr, obj : unitptr, keyword : integer);
	integer two_handed(i : integer);
	string wear_rating(wpn:integer);
var
errstr : string;
c : string;
hands : integer;
two : integer;
rating : string;
code
{
errstr := "";
if((obj.type != UNIT_ST_OBJ) or
   (obj.equip))
	return(FALSE);

if(keyword == WEAR_UNUSED)
{
 if(equipment(ch,WEAR_UNUSED))
  sendtext("DOUBLE ERROR! UNUSED ALREADY USED! REPORT!<br/>",ch);
 else
  sendtext("UNUSED EQUIPMENT ERROR! Please report!<br/>", ch);

 return(FALSE);
}
else if((keyword == WEAR_FINGER_L) or
        (keyword == WEAR_FINGER_R))
{
 if(not (obj.manipulate & MANIPULATE_WEAR_FINGER))
  errstr := "You can't wear that on your finger.";
 else if(not (equipment(ch,WEAR_FINGER_L)))
 {
   c := obj_wear_size(ch,obj,keyword);

   if(c != "")
   {
    act("$3n is $2t to fit on your finger.",
    	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
   }

   unit_msg(ch,obj,"$wear",
            "You put $2n on your left hand's ringfinger.",
            "$1n puts $2n on $1s left hand's ringfinger.");

   addequip(obj,WEAR_FINGER_L);
 }
 else if(not (equipment(ch,WEAR_FINGER_R)))
 {
   c := obj_wear_size(ch,obj,keyword);

   if(c != "")
   {
    act("$3n is $2t to fit on your finger.",
    	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
   }

   unit_msg(ch,obj,"$wear",
            "You put $2n on your right hand's ringfinger.",
            "$1n puts $2n on $1s right hand's ringfinger.");

   addequip(obj,WEAR_FINGER_R);
 }
 else
   errstr := "You're already using two rings.";
}
else if((keyword == WEAR_NECK_1) or
   (keyword == WEAR_NECK_2))
{
 if(not (obj.manipulate & MANIPULATE_WEAR_NECK))
   errstr := "You can't wear that around your neck.";
 else if(not (equipment(ch,WEAR_NECK_1)))
 {
   c := obj_wear_size(ch,obj,keyword);

   if(c != "")
   {
    act("$3n is $2t to fit around your neck.",
    	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
   }

   unit_msg(ch, obj, "$wear",
		    "You wear $2n around your neck.",
		    "$1n wears $2n around $1s neck.");

    addequip(obj,WEAR_NECK_1);
 }
 else if(not (equipment(ch,WEAR_NECK_2)))
 {
   c := obj_wear_size(ch,obj,keyword);

   if(c != "")
   {
    act("$3n is $2t to fit around your neck.",
    	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
   }

   unit_msg(ch, obj, "$wear",
		    "You wear $2n around your neck.",
		    "$1n wears $2n around $1s neck.");

    addequip(obj,WEAR_NECK_2);
 }
 else
   errstr := "You can't wear any more around your neck.";
}
else if(keyword == WEAR_BODY)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_BODY))
   errstr := "You can't wear that on your body.";
 else if(not (equipment(ch,WEAR_BODY)))
 {
   c := obj_wear_size(ch,obj,keyword);

   if(c != "")
   {
   act("$3n is $2t to fit your body.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
   return(FALSE);
   }

   unit_msg(ch, obj, "$wear",
		    "You put $2n on your body.",
		    "$1n puts $2n on $1s body.");

   addequip(obj,WEAR_BODY);
 }
 else
   errstr := "You already wear something on your body.";
}
else if(keyword == WEAR_HEAD)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_HEAD))
   errstr := "You can't wear that on your head.";
 else if(not (equipment(ch,WEAR_HEAD)))
 {
   c := obj_wear_size(ch,obj,keyword);

   if(c != "")
   {
   act("$3n is $2t to fit your head.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
   return(FALSE);
   }

   unit_msg(ch, obj, "$wear",
		    "You wear $2n on your head.",
		    "$1n wears $2n on $1s head.");

   addequip(obj,WEAR_HEAD);
 }
 else
   errstr := "You already wear something on your head.";
}
else if(keyword == WEAR_LEGS)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_LEGS))
   errstr := "You can't wear that on your legs.";
 else if(not (equipment(ch,WEAR_LEGS)))
 {
   c := obj_wear_size(ch,obj,keyword);

   if(c != "")
   {
   act("$3n are $2t to fit your legs.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
   return(FALSE);
   }

   unit_msg(ch, obj, "$wear",
		    "You put $2n on your legs.",
		    "$1n puts $2n on $1s legs.");

   addequip(obj,WEAR_LEGS);
 }
 else
   errstr := "You already wear something on your legs.";
}
else if(keyword == WEAR_FEET)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_FEET))
   errstr := "You can't wear that on your feet.";
 else if(not (equipment(ch,WEAR_FEET)))
 {
   c := obj_wear_size(ch,obj,keyword);

   if(c != "")
   {
   act("$3n are $2t to fit your feet.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
   return(FALSE);
   }

   unit_msg(ch, obj, "$wear",
		    "You put $2n on your feet.",
		    "$1n puts $2n on $1s feet.");

   addequip(obj,WEAR_FEET);
 }
 else
   errstr := "You already wear something on your feet.";
}
else if(keyword == WEAR_HANDS)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_HANDS))
   errstr := "You can't wear that on your hands.";
 else if(not (equipment(ch,WEAR_HANDS)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n are $2t to fit your hands.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    unit_msg(ch, obj, "$wear",
		    "You start using $2n.",
		    "$1n starts using $2n.");
    addequip(obj,WEAR_HANDS);
 }
 else
    errstr := "You already wear something on your hands.";
}
else if(keyword == WEAR_ARMS)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_ARMS))
   errstr := "You can't wear that on your arms.";
 else if(not (equipment(ch,WEAR_ARMS)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n are $2t to fit your arms.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }
    unit_msg(ch, obj, "$wear",
		    "You wear $2n on your arms.",
		    "$1n wears $2n on $1s arms.");
    addequip(obj,WEAR_ARMS);
 }
 else
    errstr := "You already wear something on your arms.";
}
else if(keyword == WEAR_ABOUT)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_ABOUT))
   errstr := "You can't wear that about your body.";
 else if(not (equipment(ch,WEAR_ABOUT)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit about your body.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }
    unit_msg(ch, obj, "$wear",
		    "You wrap $2n about your body.",
		    "$1n wraps $2n about $1s body.");
    addequip(obj,WEAR_ABOUT);
 }
 else
    errstr := "You already wear something about your body.";
}
else if(keyword == WEAR_WAIST)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_WAIST))
    errstr := "You can't wear that about your waist.";
 else if(not (equipment(ch,WEAR_WAIST)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit around your waist.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }
    unit_msg(ch, obj, "$wear",
		    "You strap $2n about your waist.",
		    "$1n straps $2n about $1s waist.");
    addequip(obj,WEAR_WAIST);
 }
 else
    errstr := "You already wear something about your waist.";
}
else if((keyword == WEAR_WRIST_L) or
        (keyword == WEAR_WRIST_R))
{
 if(not (obj.manipulate & MANIPULATE_WEAR_WRIST))
    errstr := "You can't wear that around your wrist.";
 else if(not (equipment(ch,WEAR_WRIST_L)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit around your wrist.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }
    unit_msg(ch, obj, "$wear",
		    "You wear $2n around your left wrist.",
		    "$1n wears $2n around $1s left wrist.");
    addequip(obj,WEAR_WRIST_L);
 }
 else if(not (equipment(ch,WEAR_WRIST_R)))
 {
   c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit around your wrist.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }
    unit_msg(ch, obj, "$wear",
		    "You wear $2n around your right wrist.",
		    "$1n wears $2n around $1s right wrist.");
    addequip(obj,WEAR_WRIST_R);
 }
 else
    errstr := "You already wear something around both your wrists.";
}
else if(keyword == WEAR_WIELD)
{
 hands := hands_used(ch);
 if (obj)
 two := two_handed(obj.value[0]);
 else
 two:=FALSE;

 if(not (obj.manipulate & MANIPULATE_WIELD))
    errstr := "You can't wield that.";
 else if(hands >= 2)
    errstr := "You have no free hands.";
 else if((two == TRUE) and (hands > 0))
    errstr := "You need two free hands to wield this weapon.";
 else if(not (equipment(ch,WEAR_WIELD)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to be wielded by you.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    if(two == TRUE)
     unit_msg(ch, obj, "$wear",
		      "You wield $2n two-handedly.",
		      "$1n wields $2n two-handedly.");
    else
     unit_msg(ch, obj, "$wear",
		      "You wield $2n.",
		      "$1n wields $2n.");

    addequip(obj,WEAR_WIELD);

    if((ch.type == UNIT_ST_PC) and (obj.objecttype == ITEM_WEAPON))
    {
    rating := wear_rating(ch.weapons[obj.value[0]]);
    act("$2t at fighting with $3n.",
    	A_ALWAYS, ch, rating, obj, TO_CHAR);
    }
 }
 else
    errstr := "You are already wielding something.";
}
else if(keyword == WEAR_HOLD)
{
 hands := hands_used(ch);


 if(obj.objecttype == ITEM_WEAPON)
    two := two_handed(obj.value[0]);
 else
    two := FALSE;

 if(not (obj.manipulate & (MANIPULATE_HOLD|MANIPULATE_WIELD)))
    errstr := "You can't hold this.";
 else if(hands >= 2)
    errstr := "Your hands are full.";
 else if(not (equipment(ch,WEAR_HOLD)))
 {

    if((two == TRUE) and (hands > 0))
    {
     errstr := "It requires two free hands to use!";
     goto err;
    }

    if(obj.objecttype == ITEM_WEAPON)
    {

      if(isset(obj.objectflags,OBJ_NO_DUAL))
      {
       errstr := "This weapon is too large to be used as a second "+
		 "weapon.";
       goto err;
      }

      c := obj_wear_size(ch,obj,keyword);

      if(c != "")
      {
      act("$3n is $2t to be wielded by you.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
      return(FALSE);
      }
    }

   unit_msg(ch, obj, "$wear",
		    "You start holding $2n.",
		    "$1n starts holding $2n.");

   addequip(obj,WEAR_HOLD);
 }
 else
   errstr := "You are already holding something.";
}
else if(keyword == WEAR_SHIELD)
{
 hands := hands_used(ch);

 if(not (obj.manipulate & MANIPULATE_WEAR_SHIELD))
    errstr := "You can't use that as a shield.";
 else if(obj.objecttype != ITEM_SHIELD)
    errstr := "That is not a shield.";
 else if(hands >= 2)
    errstr := "Your hands are full.";
 else if(not (equipment(ch,WEAR_SHIELD)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n are $2t to fit your arms.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    unit_msg(ch, obj, "$wear",
		    "You strap $2n to your arm.",
		    "$1n straps $2n on $1s arm.");
    addequip(obj,WEAR_SHIELD);
 }
 else
    errstr := "You are already using a shield.";
}
else if(keyword == WEAR_CHEST)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_CHEST))
    errstr := "You can't wear that across your chest.";
 else if(not (equipment(ch,WEAR_CHEST)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit your chest.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    unit_msg(ch, obj, "$wear",
		    "You strap $2n across your chest.",
		    "$1n straps $2n across $1s chest.");
    addequip(obj,WEAR_CHEST);
 }
 else
    errstr := "You already wear something across your chest.";
}
else if(keyword == WEAR_BACK)
{
 if(not (obj.manipulate & MANIPULATE_WEAR_BACK))
    errstr := "You can't wear that on your back.";
 else if(not (equipment(ch,WEAR_BACK)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit on your back.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    unit_msg(ch, obj, "$wear",
		    "You strap $2n on your back.",
		    "$1n straps $2n around $1s back.");
    addequip(obj,WEAR_BACK);
 }
 else
    errstr := "You already wear something on your back.";
}
else if((keyword == WEAR_EAR_L) or
        (keyword == WEAR_EAR_R))
{
 if(not (obj.manipulate & MANIPULATE_WEAR_EAR))
    errstr := "You can't wear that on your ear.";
 else if(not (equipment(ch,WEAR_EAR_L)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit your ear.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    unit_msg(ch, obj, "$wear",
		    "You wear $2n on your left ear.",
		    "$1n wears $2n on $1s left ear.");
    addequip(obj,WEAR_EAR_L);
 }
 else if(not (equipment(ch,WEAR_EAR_R)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit your ear.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    unit_msg(ch, obj, "$wear",
		    "You wear $2n on your right ear.",
		    "$1n wears $2n on $1s right ear.");
    addequip(obj,WEAR_EAR_R);
 }
 else
    errstr := "You can't wear anything else on your ear.";
}
else if((keyword == WEAR_ANKLE_L) or
        (keyword == WEAR_ANKLE_R))
{
 if(not (obj.manipulate & MANIPULATE_WEAR_ANKLE))
    errstr := "You can't wear that on your ankle.";
 else if(not (equipment(ch,WEAR_ANKLE_L)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit your ankle.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    unit_msg(ch, obj, "$wear",
		    "You wear $2n around your left ankle.",
		    "$1n wears $2n around $1s left ankle.");
    addequip(obj,WEAR_ANKLE_L);
 }
 else if(not (equipment(ch,WEAR_ANKLE_R)))
 {
    c := obj_wear_size(ch,obj,keyword);

    if(c != "")
    {
    act("$3n is $2t to fit your ankle.",
	A_ALWAYS, ch, c, obj, TO_CHAR);
    return(FALSE);
    }

    unit_msg(ch, obj, "$wear",
		    "You wear $2n around your right ankle.",
		    "$1n wears $2n around $1s right ankle.");
    addequip(obj,WEAR_ANKLE_R);
 }
 else
    errstr := "You can't wear anything else on your ankles.";
}
else if(keyword == -1)
    errstr := "Wear $2n where?";
else if(keyword == -2)
    errstr := "You can not wear $2n.";
else
{
    errstr := "Unknown weartype for $2n. Please report.";
    log("Unknown type ("+itoa(keyword)+") called in wear.");
}

if(errstr == "")
{
 send_done(cmd_str,ch,obj,null,0,arg,null);
 return(TRUE);
}

:err:
if(err)
{
 act(errstr, A_ALWAYS, ch, obj, null, TO_CHAR);
 return(FALSE);
}
else return(FALSE);

}
dilend

dilbegin do_wear(arg : string);
external
	integer wear(ch : unitptr, obj : unitptr,
                      keyword : integer, arg : string, err : integer,
                      cmd_str : string);
	integer search_list(s : string, lst : stringlist);
	integer getkeyword(obj : unitptr);
var
obj : unitptr;
keywords : stringlist;
keytrans : intlist;
str : string;
keyword : integer;
worn : integer;
nxt : unitptr;
equipped : integer;
code
{

 if(arg == "")
 {
  sendtext("Wear what (where)?<br/>", self);
  quit;
 }

 keywords :=
{"finger","neck","body","head","legs","feet","hands","arms",
 "about","waist","wrist","shield","chest","back","ear",
 "ankle"};

 keytrans :=
{WEAR_FINGER_L,WEAR_NECK_1,WEAR_BODY,WEAR_HEAD,WEAR_LEGS,
 WEAR_FEET,WEAR_HANDS,WEAR_ARMS,WEAR_ABOUT,WEAR_WAIST,
 WEAR_WRIST_L,WEAR_SHIELD,WEAR_CHEST,WEAR_BACK,WEAR_EAR_L,
 WEAR_ANKLE_L};


 if(left(arg,3) == "all")
 {

 obj := self.inside;

 while(obj != null)
 {
 nxt := obj.next;

 if((obj.type == UNIT_ST_OBJ) and (not (obj.equip)))
 {
  keyword := getkeyword(obj);
  worn := wear(self,obj,keyword,arg,FALSE,cmdstr);
  if(worn) equipped := TRUE;
 }

 obj := nxt;
 }


 if(not (equipped))
  sendtext("You have nothing to wear.<br/>", self);

 }
 else
{
 obj := findunit(self,arg,FIND_UNIT_INVEN,null);

 if((obj == null) or (not visible(self,obj)))
 {
  sendtext("You are carrying no such thing.<br/>", self);
  quit;
 }
 else if(obj.type != UNIT_ST_OBJ)
 {
  sendtext("You can't wear that.<br/>", self);
  quit;
 }

 str := getword(arg); /* finger..legs..possibly? */

 if(str != "")
 {
  keyword := search_list(str,keywords);

  if(keyword == -1)
   act("$2t is an unknown body location.",A_ALWAYS, self, str, null, TO_CHAR);
  else
   worn := wear(self,obj,keytrans.[keyword],str,TRUE,cmdstr);
 }
 else
 {
  keyword := getkeyword(obj);
  worn := wear(self,obj,keyword,arg,TRUE,cmdstr);
 }
}
quit;
}
dilend

dilbegin do_hold(arg : string);
external
	integer wear(ch : unitptr, obj : unitptr,
                      keyword : integer, arg : string, err : integer,
                      cmd_str : string);
var
obj : unitptr;
worn : integer;
code
{

 if(arg == "")
 {
  sendtext("Hold what?<br/>", self);
  quit;
 }

 obj := findunit(self,arg,FIND_UNIT_INVEN,null);

 if((obj == null) or (not visible(self,obj)))
 {
  sendtext("You are carrying no such thing.<br/>", self);
  quit;
 }
 else if(obj.type != UNIT_ST_OBJ)
 {
  sendtext("You can't hold that in your hand.<br/>", self);
  quit;
 }
 else
  worn := wear(self,obj,WEAR_HOLD,arg,TRUE,"hold");

quit;
}
dilend

dilbegin do_grab(arg : string);
external
	integer wear(ch : unitptr, obj : unitptr,
                      keyword : integer, arg : string, err : integer,
                      cmd_str : string);
var
obj : unitptr;
worn : integer;
code
{

 if(arg == "")
 {
  sendtext("Grab what?<br/>", self);
  quit;
 }

 obj := findunit(self,arg,FIND_UNIT_INVEN,null);

 if((obj == null) or (not visible(self,obj)))
 {
  sendtext("You are carrying no such thing.<br/>", self);
  quit;
 }
 else if(obj.type != UNIT_ST_OBJ)
 {
  sendtext("You can't hold that in your hand.<br/>", self);
  quit;
 }
 else
  worn := wear(self,obj,WEAR_HOLD,arg,TRUE,"grab");

quit;
}
dilend

dilbegin do_wield(arg : string);
external
	integer wear(ch : unitptr, obj : unitptr,
                      keyword : integer, arg : string, err : integer,
                      cmd_str : string);
var
obj : unitptr;
worn : integer;
code
{

if(arg == "")
{
  sendtext("Wield which weapon?<br/>", self);
  quit;
}

obj := findunit(self,arg,FIND_UNIT_INVEN,null);

if((obj == null) or (not visible(self,obj)))
{
  sendtext("You are carrying no such weapon.<br/>", self);
  quit;
}
else if((obj.type == UNIT_ST_OBJ) and (obj.objecttype == ITEM_WEAPON))
  worn := wear(self,obj,WEAR_WIELD,arg,TRUE,"wield");
else
  sendtext("That is not a proper weapon.<br/>", self);

quit;
}
dilend


dilbegin integer remove_equip(ch : unitptr, obj : unitptr,
                        cmd_str : string, arg : string);
external
	unit_msg(ch : unitptr, obj : unitptr, ex_str : string,
                  act_self : string, act_other : string);
code
{

 if((isset(obj.flags,OBJ_NO_UNEQUIP))or
 (isaff(obj, ID_CURSE)))
 {
  act("The $3n is cursed, you can't remove it!",
   A_SOMEONE, ch, null, obj, TO_CHAR);
  act("$1n tries to get rid of $3n, but in vain!",
   A_HIDEINV, ch, null, obj, TO_REST);

  return(FALSE);
 }

 unequip(obj);

 unit_msg(ch, obj, "$rem", "You stop using $2n.", "$1n stops using $2n.");

 send_done(cmd_str,ch,obj,null,0,arg,null);

 return(TRUE);
}
dilend

dilbegin do_remove(arg : string);
external
	integer remove_equip(ch : unitptr, obj : unitptr,
                        cmd_str : string, arg : string);
var
obj : unitptr;
removed : integer;
nxt : unitptr;
code
{

 if(arg == "")
 {
  sendtext("Remove what?<br/>", self);
  quit;
 }
 else if(left(arg,3) == "all")
 {

  obj := self.inside;

  while(obj != null)
  {
   nxt := obj.next;

   if((obj.type == UNIT_ST_OBJ) and (obj.equip))
    removed := remove_equip(self,obj,cmdstr,arg);

   obj := nxt;
  }

  if(not removed)
   sendtext("There was nothing to remove.",self);
 }
else
{
 obj := findunit(self,arg,FIND_UNIT_EQUIP,null);

 if((obj == null) or (not visible(self,obj)))
  sendtext("You are using no such thing.<br/>", self);
 else
  removed := remove_equip(self,obj,cmdstr,arg);
}

quit;
}
dilend


dilbegin string wear_rating(wpn:integer);
code
{
if (wpn<10)
 return ("You are utterly hopeless");
else if (wpn<25)
 return ("You are impossible");
else if (wpn<40)
 return ("You are poor");
else  if (wpn<50)
 return ("You are good");
else if (wpn<70)
 return("You are skilled");
else if (wpn<90)
 return ("You are specialized");
else if (wpn < 100)
 return ("You are supreme");
else if (wpn<150)
 return ("You are expert");
else
 return ("You are godly");

}
dilend


dilbegin integer search_list(s : string, lst : stringlist);
var
i : integer;
ln:integer;
code
{
i := 0;
ln:=length(lst);

while(i < ln)
{

 if(left(lst.[i],length(s)) == s)
 	return(i);
 else
 	i := i + 1;
}

return(-1);
}
dilend

dilbegin unit_msg(ch : unitptr, obj : unitptr, ex_str : string,
                  act_self : string, act_other : string);
var
str_self : string;
str_other : string;
code
{
str_self := ex_str+"_s";
str_other := ex_str+"_o";

if(obj.extra.[str_self].descr != "")
 act(obj.extra.[str_self].descr, A_ALWAYS, self, obj, null, TO_CHAR);
else
 act(act_self, A_ALWAYS, self, obj, null, TO_CHAR);

if(obj.extra.[str_other].descr != "")
 act(obj.extra.[str_other].descr, A_SOMEONE, self, obj, null ,TO_REST);
else
 act(act_other, A_SOMEONE, self, obj, null, TO_REST);

return;
}
dilend

/* Return 0 = No hands used                      */
/*        1 = One hand used                      */
/*        2 = Two hands used                     */
/*        2+ = Uhm???                            */
dilbegin integer hands_used(ch : unitptr);
external
	integer two_handed(i : integer);
var
ins : unitptr;
hands : integer;
two : integer;
nxt : unitptr;
code
{

 ins := ch.inside;
 hands := 0;

/* Supposidly faster than calling equipment() */
 while(ins != null)
 {
 nxt := ins.next;

  if((ins.type == UNIT_ST_OBJ) and (ins.equip))
  {
   if((ins.equip == WEAR_WIELD) or
      (ins.equip == WEAR_HOLD) or
      (ins.equip == WEAR_SHIELD))
	hands := hands + 1;

   if(ins.objecttype == ITEM_WEAPON)
   {
   two := two_handed(ins.value[0]);
   if(two == TRUE)
	hands := hands + 1;
   }

   }

  ins := nxt;
 }

 return(hands);
}
dilend

dilbegin integer getkeyword(obj : unitptr);
var
mani : integer;
keyword : integer;
code
{
mani := obj.manipulate;
keyword := -2;

if(UNIT_WEAR(mani,MANIPULATE_WEAR_SHIELD)) keyword := WEAR_SHIELD;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_FINGER)) keyword := WEAR_FINGER_L;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_NECK)) keyword := WEAR_NECK_1;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_WRIST)) keyword := WEAR_WRIST_L;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_WAIST)) keyword := WEAR_WAIST;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_ARMS)) keyword := WEAR_ARMS;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_HANDS)) keyword := WEAR_HANDS;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_FEET)) keyword := WEAR_FEET;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_LEGS)) keyword := WEAR_LEGS;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_ABOUT)) keyword := WEAR_ABOUT;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_HEAD)) keyword := WEAR_HEAD;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_BODY)) keyword := WEAR_BODY;
if(UNIT_WEAR(mani,MANIPULATE_WIELD)) keyword := WEAR_WIELD;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_CHEST)) keyword := WEAR_CHEST;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_BACK)) keyword := WEAR_BACK;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_EAR)) keyword := WEAR_EAR_L;
if(UNIT_WEAR(mani,MANIPULATE_WEAR_ANKLE)) keyword := WEAR_ANKLE_L;

return(keyword);
}
dilend

dilbegin string wear_size(ch : unitptr,obj : unitptr,vari : integer);
var
percent : integer;
code
{

if(ch.height == 0)
	return("error");

if(ch.height > 0)
	percent := (100*obj.height) / ch.height;
else
	percent := 100*obj.height;

if(percent < 100-vari-(100-vari)/2)
	return("way too small");
else if (percent < (100-vari))
	return("too small");
else if (percent > 100+vari+(100+vari)/2)
	return("way too large");
else if (percent > (100+vari))
	return("too large");
else
	return("");
}
dilend

dilbegin string obj_wear_size(ch : unitptr, obj : unitptr, keyword : integer);
external
	integer getkeyword(obj : unitptr);
	string wear_size(ch : unitptr,obj : unitptr,vari : integer);
var
ret : string;
code
{
ret := "";

 if(keyword == -1)
 	keyword := getkeyword(obj);

 if((keyword == WEAR_FINGER_L) or
    (keyword == WEAR_FINGER_R))
    	ret := wear_size(ch,obj,50);

 else if((keyword == WEAR_NECK_1) or
         (keyword == WEAR_NECK_2))
	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_BODY)
 	ret := wear_size(ch,obj,40);

 else if(keyword == WEAR_HEAD)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_LEGS)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_FEET)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_HANDS)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_ARMS)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_ABOUT)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_WAIST)
 	ret := wear_size(ch,obj,50);

 else if((keyword == WEAR_WRIST_L) or
         (keyword == WEAR_WRIST_R))
	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_WIELD)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_HOLD)
 {
  if(obj.objecttype == ITEM_WEAPON)
  	ret := wear_size(ch,obj,50);
 }

 else if(keyword == WEAR_SHIELD)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_CHEST)
 	ret := wear_size(ch,obj,50);

 else if(keyword == WEAR_BACK)
 	ret := wear_size(ch,obj,50);

 else if((keyword == WEAR_EAR_L) or
         (keyword == WEAR_EAR_R))
	ret := wear_size(ch,obj,50);

 else if((keyword == WEAR_ANKLE_L) or
         (keyword == WEAR_ANKLE_R))
	ret := wear_size(ch,obj,50);

return(ret);
}
dilend

dilbegin integer two_handed(i : integer);
var
wpns : intlist;
code
{
wpns:=weapon_info(i);

if (wpns.[0]==2)
	return (TRUE);

return (FALSE);



}
dilend



dilbegin zoneptr get_zone(s : string);
var
zn : zoneptr;
code
{

zn := zhead();

while(zn)
{

	if(zn.name == s)
		break;

	zn := zn.next;
}


return(zn); /* will return null if no zone found */
}
dilend

dilbegin do_goto(arg : string);
external
	integer may_tele_away@function(u : unitptr);
	unitptr unit_char@function(u : unitptr);
	zoneptr get_zone(s : string);
var
zonestr : string;
tgt : unitptr;
i : integer;
z : zoneptr;
ins : unitptr;
code
{

 if(self.type != UNIT_ST_PC)
 	quit;

 if(arg == "")
 {
  sendtext("You must supply a unit name or zone reference.<br/>", self);
  quit;
 }

 if("@" in arg)
 {
  tgt := findsymbolic(arg);
  while((tgt.type != UNIT_ST_ROOM) and
       (not isset(tgt.manipulate,MANIPULATE_ENTER)))
       tgt := tgt.outside;

  goto got_one;
 }

 if("corpse" in arg)
 {
  tgt := findunit(self,arg,FIND_UNIT_GLOBAL,null,UNIT_ST_OBJ);
  while((tgt.type != UNIT_ST_ROOM) and
       (not isset(tgt.manipulate,MANIPULATE_ENTER)))
       tgt := tgt.outside;
if (tgt!=null)
  goto got_one;
 }


   z := get_zone(arg);
  if(z)
  	{
      tgt := z.rooms;
	    goto got_one;
		}

 tgt := findunit(self,arg,FIND_UNIT_GLOBAL,null,UNIT_ST_PC);
 if (tgt!=null)
    goto got_one;

	 tgt := findunit(self,arg,FIND_UNIT_GLOBAL,null,UNIT_ST_ROOM);
 if (tgt!=null)
    goto got_one;

		 tgt := findunit(self,arg,FIND_UNIT_GLOBAL,null,UNIT_ST_NPC);
 if (tgt!=null)
    goto got_one;

			 tgt := findunit(self,arg,FIND_UNIT_GLOBAL,null,UNIT_ST_OBJ);
			  if (tgt!=null)
    goto got_one;

 if(tgt ==null)
  {
   arg := arg+"@"+self.zone;
   tgt := findsymbolic(arg);
  }

 :got_one:

 if(not tgt)
 {
  sendtext("No such place around.<br/>", self);
  quit;
 }

   while((tgt.type != UNIT_ST_ROOM) and
       (not isset(tgt.manipulate,MANIPULATE_ENTER)))
       tgt := tgt.outside;



 if(isset(tgt.flags,UNIT_FL_PRIVATE))
 {
  ins := tgt.inside;
  i := 0;

  while(ins)
  {
   if(ins.type == UNIT_ST_PC)
    i := i + 1;

   ins := ins.next;
  }

  if(i > 1)
  {
   sendtext("There's a private conversation going on in that room.<br/>",self);
   quit;
  }
 }

 ins := unit_char@function(tgt);

 if(ins == self)
 {
  sendtext("Recursive goto. Would destroy the universe.<br/>",self);
  quit;
 }

 i := may_tele_away@function(tgt);

 if(i == FALSE)
  sendtext("WARNING - this is a no teleport environment.<br/>", self);

 if(self.extra.["$bamfout"].descr != "")
  act(self.extra.["$bamfout"].descr,A_HIDEINV, self, null, null, TO_ROOM);
 else
  act("$1n disappears into thin air.",
  	A_HIDEINV, self, null, null, TO_ROOM);

  link(self,tgt);

 if(self.extra.["$bamfin"].descr != "")
  act(self.extra.["$bamfin"].descr,A_HIDEINV, self, null, null, TO_ROOM);
 else
  act("$1n appears from thin air.",
  	A_HIDEINV, self, null, null, TO_ROOM);

 exec("look", self);

 send_done("goto",self,null,tgt,0,arg,null);
quit;
}
dilend

dilbegin do_quests(arg : string);
var
ex : extraptr;
str : string;
code
{

ex := self.quests;
str := "";

if(arg != "")
{

 sendtext("Quests containing '"+arg+"'.<br/>", self);

 while(ex != null)
 {
  if((left(ex.names.[0],1) != "$") and
     (arg in ex.names.[0]))
  {

   str := str+ex.names.[0]+"<br/>";
  }

  ex := ex.next;
 }

 if(str == "") str := "None.<br/>";

 str := textformat(str);
 pagestring(str,self);
}
else
{

while(ex != null)
{

 if(left(ex.names.[0],1) != "$")
 {
  str := str+ex.names.[0]+"<br/>";
 }
 ex := ex.next;
}

if(str == "") str := "You have not completed any quests.<br/>";

str := textformat(str);
pagestring(str,self);

}
send_done("quests",self,null,null,0,arg,null);
quit;
}
dilend


dilbegin do_news(arg : string);
var
err : integer;
news : string;
code
{

err := loadstr("news",news);

if(err > 0)
{
        news := "<br/>" + textformat(news);
        pagestring(news,self);
}

send_done("news",self,null,null,0,arg,null);

quit;
}
dilend

dilbegin do_contrib(arg : string);
var
err : integer;
contrib : string;
code
{

err := loadstr("contrib",contrib);

if(err > 0)
{
        contrib := "<br/>" + textformat(contrib);
        pagestring(contrib,self);
}

send_done("contrib",self,null,null,0,arg,null);

quit;
}
dilend

dilbegin do_credits(arg : string);
var
err : integer;
credits : string;
code
{

err := loadstr("credits",credits);

if(err > 0)
{
        credits := "<br/>" + textformat(credits);
        pagestring(credits,self);
}

send_done("credits",self,null,null,0,arg,null);

quit;
}
dilend

dilbegin do_wizlist(arg : string);
var
err : integer;
wizlist : string;
code
{

err := loadstr("wizlist",wizlist);

if(err > 0)
{
        wizlist := "<br/>" + textformat(wizlist);
        pagestring(wizlist,self);
}

send_done("wizlist",self,null,null,0,arg,null);

quit;
}
dilend

dilbegin do_not_here(arg : string);
code
{

 sendtext("Sorry, but you cannot do that here!<br/>", self);

 quit;
}
dilend

dilbegin attack_switch(arg : string);
var
lst : stringlist;
wpn : intlist;
i : integer;
fnd : integer;
str : string;
code
{

if(arg == "")
{
sendtext("Your current attack type is "+
weapon_name(self.attack_type)+".<br/>", self);
quit;
}

lst :=
{"fist","kick","knee","elbow"};

wpn :=
{WPN_FIST,WPN_KICK,WPN_KNEE,WPN_ELBOW};

i := 0;

while(i < length(lst))
{

 if(left(lst.[i], length(arg)) == arg)
 {
 fnd := TRUE;
 break;
 }

 i := i + 1;
}

if(fnd != TRUE)
{
	str := lst.[0];
	i := 1;
	while(i < length(lst))
	{
	str := str+", "+lst.[i];
	i := i + 1;
	}

sendtext("That option is not available("+str+"</div>).<br/>",self);
}
else
{
	self.attack_type := wpn.[i];
	sendtext("Attack type set to "+lst.[i]+".<br/>",self);

	send_done("attackswitch",self,null,null,0,arg,null);
}

quit;
}
dilend

dilbegin send_to_world(s : string);
var
u : unitptr;
code
{

u := ghead();

while(u.type == UNIT_ST_PC)
{
 sendtext(s,u);
 u := u.gnext;
}

return;
}
dilend
dilbegin rebooting(s : string);
external
	send_to_world(s : string);
var
j : integer;
u : unitptr;
str : string;
i : integer;
code
{
i := atoi(s);
if(i == 0) goto go_now;

if(i > 1) str := "minutes";
else str := "minute";


/* Only tell the players it will reboot if it's under 20 */
 if(i < 20)
 send_to_world("The mud will reboot in "+itoa(i)+" "+str+".</br>");

heartbeat := PULSE_SEC * SECS_PER_REAL_MIN;

while(i > 1)
{
 wait(SFB_TICK, TRUE);

 if((i == 10) or (i == 5))
 send_to_world("The mud will reboot in "+itoa(i)+" minutes.<br/>");

 i := i - 1;
}


j := SECS_PER_REAL_MIN;

heartbeat := PULSE_SEC;

while(j > 0)
{

 wait(SFB_TICK, TRUE);

 if(j == 30)
 send_to_world("The mud will reboot in 30 seconds.<br/>");

 if(j == 10)
 send_to_world("The mud will reboot in 10 seconds.<br/>");

 j := j - 1;
}

:go_now:
send_to_world("Rebooting...<br/>");
u:=pc_head();
while (u.type==UNIT_ST_PC)
{
u:=u.gnext;
}
reboot;
quit;
}
dilend

dilbegin cmd_reboot(arg : string);
external
	send_to_world(s : string);
var
void : unitptr;
i : integer;
str : string;
code
{


/* No need to double check for the void, if basis isn't in the
   game, the game is not running :P */
void := findroom("void@basis");


if(arg == "")
 {
 if(dilfind("rebooting@commands",void))
 {
 sendtext("There is a reboot in progress, use the cancel option.<br/>",self);
 quit;
 }
 dilcopy("rebooting@commands("+itoa(1)+")", void);
 sendtext("Reboot set for 1 minute.<br/>", self);
 quit;
 }
else if("now" in arg)
 {
 dilcopy("rebooting@commands("+itoa(0)+")", void);
 quit;
 }
else if("cancel" in arg)
{
 if(dilfind("rebooting@commands",void))
 {
 i := dildestroy("rebooting@commands",void);
 sendtext("Reboot cancelled.<br/>", self);
 send_to_world("The reboot has been halted..<br/>");
 }
 else
 {
 sendtext("There is no reboot scheduled.<br/>", self);
 }
 quit;
}
else
{
str := getword(arg);
if(atoi(str) > 0)
{
 if(dilfind("rebooting@commands",void))
 {
 sendtext("There is a reboot in progress, use the cancel option.<br/>",self);
 quit;
 }
 sendtext("Reboot set for "+str+" minutes.<br/>", self);
 dilcopy("rebooting@commands("+str+")",void);
 quit;
}

sendtext("Usage: <br/>Reboot<br/>Reboot now<br/>"+
 "Reboot cancel<br/>Reboot #(in minutes)<br/>", self);
quit;
}

quit;
}
dilend


dilbegin aware do_reroll( arg : string );
var
	tval:integer;
   exdp      : extraptr;



   s         : string;

   g1        : integer;
   g2        : integer;
   g3        : integer;

   data_list : stringlist;
   gug       : stringlist;
   ini       : stringlist;

   gp        : extraptr;

   guild1    : string;
   guild2    : string;
   guild3    : string;

   gl1       : integer;
   gl2       : integer;
   gl3       : integer;

   	err:integer;
	buff:string;
	guild_str:string;
	choice:integer;
	i:integer;
	tempu:unitptr;
	item:unitptr;

   age       : integer;  /* starting age for race */
   de         : integer;  /* dice */
   df         : integer;  /* dice */
   dg         : integer;  /* dice */
   dh         : integer;  /* dice */
   di         : integer;  /* dice */
   dj         : integer;  /* dice */
   rm:unitptr;


code
{
if ("$NOREROLL" in self.extra){
sendtext ("You have either rerolled already or logged on after the rerolls were announced.<br/>",self);
sendtext ("Either way you are out of luck and can not get a reroll.<br/>",self);
quit;
}


   gug := null;
   ini := null;

   addstring(gug, "-");
   addstring(gug, "Udgaard Fighter");    /* 1 */
   addstring(gug, "Udgaard Thief");      /* 2 */
   addstring(gug, "Udgaard Healer");     /* 3 */
   addstring(gug, "Udgaard Conjurer");   /* 4 */
   addstring(gug, "Nymgaard Ranger");    /* 5 */
   addstring(gug, "Midgaard Paladin");   /* 6 */
   addstring(gug, "Midgaard Sorcerer");  /* 7 */
   addstring(gug, "Khorsabad Assassin"); /* 8 */
   addstring(gug, "Necromancer");        /* 9 */
   addstring(gug, "Nymgaard Druid");     /*10 */
   addstring(gug, "Midgaard Dark Knight");     /*11 */
   addstring(ini, "-");
   addstring(ini, "F");    /* 1 */
   addstring(ini, "T");    /* 2 */
   addstring(ini, "H");    /* 3 */
   addstring(ini, "C");    /* 4 */
   addstring(ini, "R");    /* 5 */
   addstring(ini, "P");    /* 6 */
   addstring(ini, "S");    /* 7 */
   addstring(ini, "A");     /* 8 */
   addstring(ini, "N");     /* 9 */
   addstring(ini, "D");     /*10 */
   addstring(ini, "DK");     /* 9 */
   :start:


gamestate(self, GS_MENU);
if ("$pireroll" in self.extra)
{
                           					err:=loadstr("reroll.pi",buff);
if (err<1)
	{
	log ("10:  Error in reroll PI menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

              buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
	if ((choice==0) or (choice>21))
	goto quit_reroll;

	on choice goto quit_reroll, pi_1, pi_2, pi_3, pi_4,pi_5,pi_6,pi_7,pi_8, pi_9, pi_10, pi_11, pi_12, pi_13,pi_14,pi_15,pi_16,pi_17,pi_18,pi_19,pi_20,pi_21;

		goto quit_reroll;
:pi_1:
/*Udgaard Fighter    / Nymgaard Ranger*/
guild_str:="Necromancer / Fighter / Ranger";

         g1 := 9;
         g2 := 1;
         g3 := 5;

goto pi_end;

:pi_2:
/*Udgaard Fighter    / Nymgaard Ranger*/
guild_str:="Ranger / Fighter / Necromancer";

         g1 := 5;
         g2 := 1;
         g3 := 9;

goto pi_end;

:pi_3:
/*Udgaard Fighter    / sorc*/
guild_str:="Ranger / Fighter / Sorcerer";

         g1 := 5;
         g2 := 1;
         g3 := 7;

goto pi_end;



:pi_4:
/*Nymgaard Ranger*/
guild_str:="Ranger / Necromancer / Thief";

         g1 := 5;
         g2 := 9;
         g3 := 2;

goto pi_end;
:pi_5:
/*Nymgaard Ranger    / Udgaard conjurer / Udgaard Fighter */
guild_str:="Ranger / Conjurer / Fighter";


         g1 := 5;
g2 := 4;         
         g3 := 1;         
goto pi_end;

:pi_6:
//  5)  Udgaard Healer Nymgaard Druid Midgaard Dark Knight 
guild_str:="Healer / Druid / Dark Knight";


         g1 := 3;
g2 := 10;         
         g3 := 11;         
goto pi_end;

:pi_7:
//  5)  Udgaard Thief Udgaard Healer Udgaard Conjurer
guild_str:="Thief / Healer / Conjurer";

         g1 := 2;
g2 := 3;         
         g3 := 4;         
goto pi_end;

:pi_8:
/*Udgaard Fighter    / Nymgaard Druid*/
guild_str:="Ranger / Druid / Sorcerer";

         g1 := 5;
         g2 := 10;
         g3 := 7;

goto pi_end;

:pi_9:
//  5)  NecromancerNymgaard Druid Midgaard Dark Knight 
guild_str:="Necromancer / Druid / Dark Knight";


         g1 := 9;
g2 := 10;         
         g3 := 11;         
goto pi_end;

:pi_10:
guild_str:="Ranger / Druid / Necro";

         g1 := 5;
         g2 := 10;
         g3 := 9;         

goto pi_end;

:pi_11:
//  5)  Midgaard Dark Knight 
guild_str:="Dark Knight / Sorcerer / Conjurer";


         g1 := 11;
g2 := 7;         
         g3 := 4;         
goto pi_end;
 
:pi_12:
/*Udgaard conjurer / Udgaard Fighter / Udgaard Healer */
guild_str:="Conjurer / Fighter / Healer";



g1 := 4;         
         g2 := 1;         
         g3 := 3;         
goto pi_end;

:pi_13:
/*Udgaard conjurer / Udgaard Healer / Midgaard Paladin*/
guild_str:="Conjurer / Healer / Paladin";



g1 := 4;         
         g2 := 3;         
         g3 := 6;
goto pi_end;

:pi_14:
guild_str:="Ranger / Dark Knight / Necro";

         g1 := 5;
         g2 := 11;
         g3 := 9;         

goto pi_end;

:pi_15:
//  Udgaard Fighter / Udgaard Thief Udgaard Healer
guild_str:="fighter / Thief / Healer";

         g1 := 1;         
         g2 := 2;
g3 := 3;         

goto pi_end;


:pi_16:
/*Udgaard Fighter    / necro*/
guild_str:="Ranger / Fighter / Necro";

         g1 := 5;
         g2 := 1;
         g3 := 9;

goto pi_end;

:pi_17:
//  Udgaard Fighter / Udgaard Thief Udgaard Healer
guild_str:="fighter / Thief / Sorcerer";

         g1 := 1;         
         g2 := 2;
g3 := 7;         

goto pi_end;

:pi_18:
/*Nymgaard Ranger*/
guild_str:="Ranger / Sorcerer / Thief";

         g1 := 5;
         g2 := 7;
         g3 := 2;

goto pi_end;

:pi_19:
guild_str:="Ranger / Dark Knight / Sorcerer";

         g1 := 5;
         g2 := 11;
         g3 := 7;
goto pi_end;

:pi_20:
//  5)  Udgaard Thief Udgaard Conjurer Udgaard Healer 
guild_str:="Thief / Conjurer / Healer";

         g1 := 2;
g2 := 4;
         g3 := 3;
goto pi_end;

:pi_21:
guild_str:="Fighter / Ranger / Sorcerer";

         g1 := 1;
         g2 := 5;
         g3 := 7;

goto pi_end;


:pi_end:
                      sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to PI paths menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>3))
	goto quit_reroll;

 on choice goto quit_reroll,end_reroll,start,quit_reroll;
goto quit_reroll;


}

err:=loadstr("reroll.txt",buff);
if (err<1)
	{
	log ("01:  Error in reroll main menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}
	   :main_menu:
buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x"){
	  	  gamestate(self, GS_PLAY);

	quit;
	}

if ((choice==0) or (choice>11))
	goto quit_reroll;


	on choice goto quit_reroll,fighter_menu,thief_menu,healer_menu,conjurer_menu,paladin_menu,
	sorcerer_menu,dk_menu,
					ranger_menu,druid_menu, Assassin_menu, necro_menu;
goto quit_reroll;

					:fighter_menu:
					err:=loadstr("reroll.fighter",buff);
if (err<1)
	{
	log ("02:  Error in reroll fighter menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>15))
	goto quit_reroll;


	on choice goto quit_reroll,fighter_1,fighter_2,fighter_3,fighter_4,fighter_5,fighter_6,
			fighter_7,fighter_8,fighter_9,fighter_10,fighter_11,fighter_12,fighter_13,fighter_14,fighter_15;
goto quit_reroll;
:fighter_1:
/*			  Khorsabad Assassin / Udgaard Thief*/
guild_str:="Fighter / Assassin / Thief";

         g1 := 1;
         g2 := 8;
         g3 := 2;

goto fighter_end;
:fighter_2:
/*Udgaard Conjurer / Khorsabad Assassin*/
guild_str:="Fighter / Conjurer / Assassin";

g1 := 1;
g2 := 4;
g3 := 8;

goto fighter_end;
:fighter_3:
/*Midgaard Paladin / Nymgaard Ranger*/
guild_str:="Fighter / Paladin / Ranger";

g1 := 1;
g2 := 6;
g3 := 5;

goto fighter_end;
:fighter_4:
/*Midgaard Paladin / Udgaard Healer*/
guild_str:="Fighter / Paladin / Healer";

g1 := 1;
g2 := 6;
g3 := 3;

goto fighter_end;
:fighter_5:
/*Midgaard Paladin / Nymgaard Druid*/
guild_str:="Fighter / Paladin / Druid";

g1 := 1;
g2 := 6;
g3 := 10;

goto fighter_end;
:fighter_6:
/*Nymgaard Ranger / Udgaard Healer*/
guild_str:="Fighter / Ranger / Healer";

g1 := 1;
g2 := 5;
g3 := 3;

goto fighter_end;
:fighter_7:
/*Nymgaard Ranger / Nymgaard Druid*/
guild_str:="Fighter / Ranger / Druid";

g1 := 1;
g2 := 5;
g3 := 10;

goto fighter_end;
:fighter_8:
/*Nymgaard Ranger / Udgaard Thief*/
guild_str:="Fighter / Ranger / Thief";

         g1 := 1;
         g2 := 5;
         g3 := 2;

goto fighter_end;
:fighter_9:
/*Nymgaard Ranger / Midgaard Paladin*/
guild_str:="Fighter / Ranger / Paladin";

         g1 := 1;
         g2 := 5;
         g3 := 6;

goto fighter_end;
:fighter_10:
/*Udgaard Thief / Nymgaard Ranger*/
guild_str:="Fighter / Thief / Ranger";

         g1 := 1;
         g2 := 2;
         g3 := 5;
goto fighter_end;
:fighter_11:
/*Udgaard Thief / Khorsabad Assassin*/
guild_str:="Fighter / Thief / Assassin";

         g1 := 1;
         g2 := 2;
         g3 := 8;
goto fighter_end;
:fighter_12:
/*Udgaard Thief / Udgaard Conjurer*/
guild_str:="Fighter / Thief / Conjurer";

         g1 := 1;
         g2 := 2;
         g3 := 4;
		 goto fighter_end;
:fighter_13:
/*Nymgaard Ranger / Udgaard Dark Knight*/
guild_str:="Fighter / Ranger / Dark Knight";

g1 := 1;
g2 := 5;
g3 := 11;
goto fighter_end;
:fighter_14:
/*Udgaard Thief / Midgaard Dark Knight*/
guild_str:="Fighter / Thief / Dark Knight";

         g1 := 1;
         g2 := 2;
         g3 := 11;
		 goto fighter_end;
:fighter_15:
/*Nymgaard Druid / Midgaard Dark Knight*/
guild_str:="Fighter / Druid / Dark Knight";

         g1 := 1;
         g2 := 10;
         g3 := 11;


:fighter_end:

sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Fighter paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	 goto quit_reroll;


 on choice goto quit_reroll,end_reroll,fighter_menu,start,quit_reroll;
goto quit_reroll;

:thief_menu:
					err:=loadstr("reroll.thief",buff);
if (err<1)
	{
	log ("03:  Error in reroll thief menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

              buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>11))
	goto quit_reroll;

	on choice goto quit_reroll,thief_1,thief_2,thief_3,thief_4,thief_5,thief_6,
			thief_7,thief_8,thief_9,thief_10,thief_11;
			goto quit_reroll;

:thief_1:
/*Khorsabad Assassin / Udgaard Fighter*/
guild_str:="Thief / Assassin / Fighter";
         g1 := 2;
         g2 := 8;
         g3 := 1;

goto thief_end;
:thief_2:
/*Khorsabad Assassin / Midgaard Sorcerer*/
guild_str:="Thief / Assassin / Sorcerer";
         g1 := 2;
         g2 := 8;
         g3 := 7;
goto thief_end;
:thief_3:
/*Udgaard Conjurer   / Khorsabad Assassin*/
guild_str:="Thief / Conjurer / Assassin";

         g1 := 2;
         g2 := 4;
         g3 := 8;
goto thief_end;
:thief_4:
/*Udgaard Conjurer   / Midgaard Sorcerer*/
guild_str:="Thief / Conjurer / Sorcerer";


         g1 := 2;
         g2 := 4;
         g3 := 7;

goto thief_end;
:thief_5:
/*Udgaard Fighter    / Khorsabad Assassin*/
guild_str:="Thief / Fighter / Assassin";


         g1 := 2;
         g2 := 1;
         g3 := 8;
goto thief_end;
:thief_6:
/*Udgaard Fighter    / Nymgaard Ranger*/
guild_str:="Thief / Fighter / Ranger";

         g1 := 2;
         g2 := 1;
         g3 := 5;
goto thief_end;
:thief_7:
/*Midgaard Sorcerer  / Udgaard Conjurer*/
guild_str:="Thief / Sorcerer / Conjurer";

         g1 := 2;
         g2 := 7;
         g3 := 4;

goto thief_end;
:thief_8:
/*Nymgaard Ranger    / Udgaard Fighter*/
guild_str:="Thief / Ranger / Fighter";


         g1 := 2;
         g2 := 5;
         g3 := 1;

goto thief_end;
:thief_9:
/*Nymgaard Ranger    / Nymgaard Druid*/
GUILD_STR:="Thief / Ranger / Druid";

         g1 := 2;
         g2 := 5;
         g3 := 10;

		 goto thief_end;
:thief_10:
/*Nymgaard Ranger    / Midgaard Dark Knight*/

GUILD_STR:="Thief / Ranger / Dark Knight";

         g1 := 2;
         g2 := 5;
         g3 := 11;

		 goto thief_end;
:thief_11:
/*Nymgaard Druid    / Midgaard Dark Knight*/

GUILD_STR:="Thief / Druid / Dark Knight";

         g1 := 2;
         g2 := 11;
         g3 := 11;

:thief_end:

sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Thief paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;


 on choice goto quit_reroll,end_reroll,thief_menu,start,quit_reroll;
goto quit_reroll;

:healer_menu:
					err:=loadstr("reroll.healer",buff);
if (err<1)
	{
	log ("03:  Error in reroll healer menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

              buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>8))
	goto quit_reroll;

	on choice goto quit_reroll,healer_1,healer_2,healer_3,healer_4,healer_5,healer_6,
			healer_7,healer_8;
goto quit_reroll;

:healer_1:
/*Udgaard Fighter    / Midgaard Paladin*/
guild_str:="Healer / Fighter / Paladin";


         g1 := 3;
         g2 := 1;
         g3 := 6;

goto healer_end;
:healer_2:
/*Udgaard Fighter    / Nymgaard Ranger */
guild_str:="Healer / Fighter / Ranger";

         g1 := 3;
         g2 := 1;
         g3 := 5;

goto healer_end;
:healer_3:
/*Midgaard Paladin   / Udgaard Fighter*/
guild_str:="Healer / Paladin / Fighter";

         g1 := 3;
         g2 := 6;
         g3 := 1;

goto healer_end;
:healer_4:
/*Midgaard Paladin   / Nymgaard Druid*/
guild_str:="Healer / Paladin / Druid";

         g1 := 3;
         g2 := 6;
         g3 := 10;
goto healer_end;
:healer_5:
/*Nymgaard Ranger    / Udgaard Fighter*/
guild_str:="Healer / Ranger / Fighter";

         g1 := 3;
         g2 := 5;
         g3 := 1;

goto healer_end;
:healer_6:
/*Nymgaard Ranger    / Nymgaard Druid*/
guild_str:="Healer / Ranger / Druid";

         g1 := 3;
         g2 := 5;
         g3 := 10;

goto healer_end;
:healer_7:
/*Nymgaard Druid     / Nymgaard Ranger*/
guild_str:="Healer / Druid / Ranger";

         g1 := 3;
         g2 := 10;
         g3 := 5;

goto healer_end;
:healer_8:
/*Udgaard Healer     / Nymgaard Druid     / Midgaard Paladin*/
guild_str:="Healer / Druid / Paladin";

         g1 := 3;
         g2 := 10;
         g3 := 6;

:healer_end:

sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Healer paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;


 on choice goto quit_reroll,end_reroll,healer_menu,start,quit_reroll;
goto quit_reroll;

:conjurer_menu:
     					err:=loadstr("reroll.conjurer",buff);
if (err<1)
	{
	log ("04:  Error in reroll conjurer menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);

		  	  gamestate(self, GS_PLAY);

	quit;
	}

              buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>8))
	goto quit_reroll;

	on choice goto quit_reroll,conjurer_1,conjurer_2,conjurer_3,conjurer_4,
	conjurer_5,conjurer_6,conjurer_7,conjurer_8;
	goto quit_reroll;

:conjurer_1:
/*Khorsabad Assassin / Udgaard Thief*/
guild_str:="Conjurer / Assassin / Thief";

         g1 := 4;
         g2 := 8;
         g3 := 2;
goto conjurer_end;
:conjurer_2:
/*Khorsabad Assassin / Midgaard Sorcerer*/
guild_str:="Conjurer / Assassin / Sorcerer";

         g1 := 4;
         g2 := 8;
         g3 := 7;
goto conjurer_end;
:conjurer_3:
/*Midgaard Sorcerer  / Khorsabad Assassin*/
guild_str:="Conjurer / Sorcerer / Assassin";

         g1 := 4;
         g2 := 7;
         g3 := 8;
goto conjurer_end;
:conjurer_4:
/*Udgaard Thief      / Khorsabad Assassin*/
guild_str:="Conjurer / Thief / Assassin";

         g1 := 4;
         g2 := 2;
         g3 := 8;
goto conjurer_end;
:conjurer_5:
/*Udgaard Thief      / Udgaard Fighter*/
guild_str:="Conjurer / Thief / Fighter";

         g1 := 4;
         g2 := 2;
         g3 := 1;
goto conjurer_end;
:conjurer_6:
/*Udgaard Fighter / Midgaard Sorcerer*/
guild_str:="Conjurer Fighter Sorcerer";
         g1 := 4;
         g2 := 1;
         g3 := 7;


goto conjurer_end;
:conjurer_7:
/*Midgaard Sorcerer  / Udgaard Fighter*/
guild_str:="Conjurer Sorcerer Fighter";
         g1 := 4;
         g2 := 7;
         g3 := 1;
goto conjurer_end;
:conjurer_8:
/*Midgaard Sorcerer  / Midgaard Dark Knight*/
guild_str:="Conjurer / Sorcerer / Dark Knight";

         g1 := 4;
         g2 := 7;
         g3 := 11;


:conjurer_end:
sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Conjurer paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;


 on choice goto quit_reroll,end_reroll,conjurer_menu,start,quit_reroll;
goto quit_reroll;

:dk_menu:
     					err:=loadstr("reroll.darkknight",buff);
if (err<1)
	{
	log ("07:  Error in reroll Dark Knight menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>13))
	goto quit_reroll;

	on choice goto quit_reroll,dk_1,dk_2,dk_3,dk_4,dk_5,
	dk_6,dk_7,dk_8,dk_9,dk_10,dk_11,dk_12,dk_13;
		goto quit_reroll;

:dk_1:

guild_str:="Dark Knight / Fighter / Ranger";


         g1 := 11;
         g2 := 1;
         g3 := 5;
goto dk_end;
:dk_2:

guild_str:="Dark Knight / Fighter / Druid";


         g1 := 11;
         g2 := 1;
         g3 := 11;
goto dk_end;
:dk_3:

guild_str:="Dark Knight / Fighter / Necromancer";


         g1 := 11;
         g2 := 1;
         g3 := 9;

goto dk_end;
:dk_4:

guild_str:="Dark Knight / Thief / Fighter";


         g1 := 11;
         g2 := 2;
         g3 := 1;
goto dk_end;
:dk_5:

guild_str:="Dark Knight / Thief / Ranger";


         g1 := 11;
         g2 := 2;
         g3 := 5;
goto dk_end;
:dk_6:

guild_str:="Dark Knight / Thief / Druid";


         g1 := 11;
         g2 := 2;
         g3 := 10;
goto dk_end;
:dk_7:

guild_str:="Dark Knight / Thief / Necromancer";


         g1 := 11;
         g2 := 2;
         g3 := 9;
goto dk_end;
:dk_8:

guild_str:="Dark Knight / Druid / Ranger";

         g1 := 11;
         g2 := 10;
         g3 := 5;
goto dk_end;
:dk_9:

guild_str:="Dark Knight / Druid / Necromancer";

         g1 := 11;
         g2 := 10;
         g3 := 9;
goto dk_end;
:dk_10:

guild_str:="Dark Knight / Ranger / Druid";

         g1 := 11;
         g2 := 5;
         g3 := 10;
goto dk_end;

:dk_11:

guild_str:="Dark Knight / Ranger / Necromancer";

         g1 := 11;
         g2 := 5;
         g3 := 9;
goto dk_end;
:dk_12:

guild_str:="Dark Knight / Necromancer / Ranger";

         g1 := 11;
         g2 := 9;
         g3 := 5;
goto dk_end;

:dk_13:

guild_str:="Dark Knight / Necromancer / Druid";

         g1 := 11;
         g2 := 9;
         g3 := 10;

:dk_end:
sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Dark Knight paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;

 on choice goto quit_reroll,end_reroll,dk_menu,start,quit_reroll;
goto quit_reroll;

:ranger_menu:
     					err:=loadstr("reroll.ranger",buff);
if (err<1)
	{
	log ("07:  Error in reroll ranger menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>12))
	goto quit_reroll;

	on choice goto quit_reroll,ranger_1,ranger_2,ranger_3,ranger_4,ranger_5,
	ranger_6,ranger_7,ranger_8,ranger_9,ranger_10,ranger_11,ranger_12;
		goto quit_reroll;

:ranger_1:
/*Udgaard Healer     / Udgaard Fighter*/
guild_str:="Ranger / Healer / Fighter";

         g1 := 5;
         g2 := 3;
         g3 := 1;
goto ranger_end;
:ranger_2:
/*Udgaard Healer     / Midgaard Paladin*/
guild_str:="Ranger / Healer / Paladin";

         g1 := 5;
         g2 := 3;
         g3 := 6;

goto ranger_end;
:ranger_3:
/*Udgaard Healer     / Nymgaard Druid*/
guild_str:="Ranger / Healer / Druid";

         g1 := 5;
         g2 := 3;
         g3 := 10;
goto ranger_end;
:ranger_4:
/*Udgaard Fighter    / Udgaard Healer*/
guild_str:="Ranger / Fighter / Healer";

         g1 := 5;
         g2 := 1;
         g3 := 3;

goto ranger_end;
:ranger_5:
/*Udgaard Fighter    / Midgaard Paladin*/
guild_str:="Ranger / Fighter / Paladin";

         g1 := 5;
         g2 := 1;
         g3 := 6;
goto ranger_end;
:ranger_6:
/*Midgaard Paladin   / Udgaard Fighter*/
guild_str:="Ranger / Paladin / Fighter";

         g1 := 5;
         g2 := 6;
         g3 := 1;

goto ranger_end;
:ranger_7:
/*Midgaard Paladin   / Nymgaard Druid*/
guild_str:="Ranger / Paladin / Druid";

         g1 := 5;
         g2 := 6;
         g3 := 10;

goto ranger_end;
:ranger_8:
/*Midgaard Paladin   / Udgaard Healer*/
guild_str:="Ranger / Paladin / Healer";

         g1 := 5;
         g2 := 6;
         g3 := 3;

goto ranger_end;
:ranger_9:
/*Nymgaard Druid     / Midgaard Paladin*/
guild_str:="Ranger / Druid / Paladin";

         g1 := 5;
         g2 := 10;
         g3 := 6;

goto ranger_end;
:ranger_10:
/*Nymgaard Druid     / Udgaard Healer*/
guild_str:="Ranger / Druid / Healer";

         g1 := 5;
         g2 := 10;
         g3 := 3;
goto ranger_end;
:ranger_11:
/*Nyymgaard Druid Midgaard Dark Knight*/
guild_str:="Ranger / Druid / Dark Knight";

         g1 := 5;
         g2 := 10;
         g3 := 11;

goto ranger_end;

:ranger_12:
/*Udgaard Fighter    / Midgaard Dark Knight*/
guild_str:="Ranger / Fighter / Dark Knight";

         g1 := 5;
         g2 := 1;
         g3 := 11;



:ranger_end:
sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Ranger paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;

 on choice goto quit_reroll,end_reroll,ranger_menu,start,quit_reroll;
goto quit_reroll;

:paladin_menu:
                  					err:=loadstr("reroll.paladin",buff);
if (err<1)
	{
	log ("05:  Error in reroll ranger menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>9))
	goto quit_reroll;

	on choice goto quit_reroll,paladin_1,paladin_2,paladin_3,paladin_4,paladin_5,
	paladin_6,paladin_7,paladin_8,paladin_9;
		goto quit_reroll;


:paladin_1:
/*Udgaard Fighter    / Udgaard Healer*/
guild_str:="Paladin / Fighter / Healer";

         g1 := 6;
         g2 := 1;
         g3 := 3;

goto paladin_end;
:paladin_2:
/*Udgaard Fighter    / Nymgaard Ranger*/
guild_str:="Paladin / Fighter / Ranger";

         g1 := 6;
         g2 := 1;
         g3 := 5;

goto paladin_end;
:paladin_3:
/*Udgaard Healer     / Udgaard Fighter*/
guild_str:="Paladin / Healer / Fighter";

         g1 := 6;
         g2 := 3;
         g3 := 1;

goto paladin_end;
:paladin_4:
/*Udgaard Healer     / Nymgaard Ranger*/
guild_str:="Paladin / Healer / Ranger";

         g1 := 6;
         g2 := 3;
         g3 := 5;
goto paladin_end;
:paladin_5:
/*Udgaard Healer     / Nymgaard Druid*/
guild_str:="Paladin / Healer / Druid";

         g1 := 6;
         g2 := 3;
         g3 := 10;

goto paladin_end;
:paladin_6:
/*Nymgaard Ranger    / Udgaard Healer*/
guild_str:="Paladin / Ranger / Healer";

         g1 := 6;
         g2 := 5;
         g3 := 3;
goto paladin_end;
:paladin_7:
/*Nymgaard Ranger    / Nymgaard Druid*/
guild_str:="Paladin / Ranger / Druid";

         g1 := 6;
         g2 := 5;
         g3 := 10;

goto paladin_end;
:paladin_8:
/*Nymgaard Druid     / Udgaard Healer*/
guild_str:="Paladin / Druid / Healer";

         g1 := 6;
         g2 := 10;
         g3 := 3;

goto paladin_end;
:paladin_9:
/*Nymgaard Druid     / Nymgaard Ranger*/
guild_str:="Paladin / Druid / Ranger";

         g1 := 6;
         g2 := 10;
         g3 := 5;


:paladin_end:
        sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Paladin paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;

 on choice goto quit_reroll,end_reroll,paladin_menu,start,quit_reroll;
goto quit_reroll;

:sorcerer_menu:
                           					err:=loadstr("reroll.sorcerer",buff);
if (err<1)
	{
	log ("06:  Error in reroll sorcerer menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

              buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>9))
	goto quit_reroll;

	on choice goto quit_reroll,sorcerer_1,sorcerer_2,sorcerer_3,sorcerer_4,sorcerer_5,
	sorcerer_6,sorcerer_7,sorcerer_8,sorcerer_9;
		goto quit_reroll;

:sorcerer_1:
/*Khorsabad Assassin / Udgaard Conjurer*/
guild_str:="Sorcerer / Assassin / Conjurer";

         g1 := 7;
         g2 := 8;
         g3 := 4;

goto sorcerer_end;
:sorcerer_2:
/*Khorsabad Assassin / Udgaard Thief*/
guild_str:="Sorcerer / Assassin / Thief";

         g1 := 7;
         g2 := 8;
         g3 := 2;

goto sorcerer_end;
:sorcerer_3:
/*Udgaard Conjurer   / Khorsabad Assassin*/
guild_str:="Sorcerer / Conjurer / Assassin";

         g1 := 7;
         g2 := 4;
         g3 := 8;

goto sorcerer_end;
:sorcerer_4:
/*Udgaard Conjurer   / Udgaard Thief*/
guild_str:="Sorcerer / Conjurer / Thief";

         g1 := 7;
         g2 := 4;
         g3 := 2;

goto sorcerer_end;
:sorcerer_5:
/*Udgaard Thief      / Khorsabad Assassin*/
guild_str:="Sorcerer / Thief / Assassin";

         g1 := 7;
         g2 := 2;
         g3 := 8;

goto sorcerer_end;
:sorcerer_6:
/*Udgaard Thief      / Udgaard Conjurer*/
guild_str:="Sorcerer / Thief / Conjurer";

         g1 := 7;
         g2 := 2;
         g3 := 4;

goto sorcerer_end;
:sorcerer_7:
/*Udgaard Conjurer   / Udgaard Fighter*/
guild_str:="Sorcerer / Conjurer / Fighter";

         g1 := 7;
         g2 := 4;
         g3 := 1;
goto sorcerer_end;
:sorcerer_8:
/*Udgaard Fighter      / Udgaard Conjurer*/
guild_str:="Sorcerer / Fighter / Conjurer";

         g1 := 7;
         g2 := 1;
         g3 := 4;
goto sorcerer_end;
:sorcerer_9:
/*Udgaard Conjurer   / Midgaard Dark Knight*/
guild_str:="Sorcerer / Conjurer / Dark Knight";

         g1 := 7;
         g2 := 4;
         g3 := 11;



:sorcerer_end:
                      sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Sorcerer paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;

 on choice goto quit_reroll,end_reroll,sorcerer_menu,start,quit_reroll;
goto quit_reroll;

:assassin_menu:
                           					err:=loadstr("reroll.assassin",buff);
if (err<1)
	{
	log ("09:  Error in reroll Assassin menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

              buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>9))
	goto quit_reroll;

	on choice goto quit_reroll,assassin_1,assassin_2,assassin_3,assassin_4,assassin_5,
	assassin_6,assassin_7,assassin_8,assassin_9;
		goto quit_reroll;

:assassin_1:
/*Udgaard Conjurer   / Midgaard Sorcerer*/
guild_str:="Assassin / Conjurer / Sorcerer";

         g1 := 8;
         g2 := 4;
         g3 := 7;

goto assassin_end;
:assassin_2:
/*Udgaard Conjurer   / Udgaard Thief*/
guild_str:="Assassin / Conjurer / Thief";

         g1 := 8;
         g2 := 4;
         g3 := 2;

goto assassin_end;
:assassin_3:
/*Udgaard Fighter    / Udgaard Conjurer*/
guild_str:="Assassin / Fighter / Conjurer";

         g1 := 8;
         g2 := 1;
         g3 := 4;

goto assassin_end;
:assassin_4:
/*Midgaard Sorcerer  / Udgaard Conjurer*/
guild_str:="Assassin / Sorcerer / Conjurer";

         g1 := 8;
         g2 := 7;
         g3 := 4;

goto assassin_end;
:assassin_5:
	/*Midgaard Sorcerer / Udgaard Thief*/
guild_str:="Assassin / Sorcerer / Thief";

         g1 := 8;
         g2 := 7;
         g3 := 2;

	goto assassin_end;
	:assassin_6:
/*Udgaard Thief / Udgaard Conjurer*/
guild_str:="Assassin / Thief / Conjurer";

         g1 := 8;
         g2 := 2;
         g3 := 4;
goto assassin_end;
:assassin_7:
/*Udgaard Thief / Udgaard Fighter*/
guild_str:="Assassin / Thief / Fighter";

         g1 := 8;
         g2 := 2;
         g3 := 1;

goto assassin_end;
:assassin_8:
/*Udgaard Thief / Nymgaard Ranger*/
guild_str:="Assassin / Thief / Ranger";

         g1 := 8;
         g2 := 2;
         g3 := 5;

goto assassin_end;
:assassin_9:
/*Nymgaard Ranger / Udgaard Thief*/
guild_str:="Assassin / Ranger / Thief";

         g1 := 8;
         g2 := 5;
         g3 := 2;

:assassin_end:
                      sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Assassin paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;

 on choice goto quit_reroll,end_reroll,assassin_menu,start,quit_reroll;
goto quit_reroll;



:necro_menu:
                           					err:=loadstr("reroll.necro",buff);
if (err<1)
	{
	log ("10:  Error in reroll Necro menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

              buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>8))
	goto quit_reroll;

	on choice goto quit_reroll,necro_1,necro_2,necro_3,
	necro_4,necro_5,necro_6,necro_7,necro_8;

		goto quit_reroll;
:necro_1:
/*Udgaard Fighter    / Khorsabad Assassin*/
guild_str:="Necromancer / Fighter / Assassin";

         g1 := 9;
         g2 := 1;
         g3 := 8;

goto necro_end;
:necro_2:
/*Udgaard Fighter    / Nymgaard Druid*/
guild_str:="Necromancer / Fighter / Druid";

         g1 := 9;
         g2 := 1;
         g3 := 10;

goto necro_end;
:necro_3:
/*Nymgaard Druid     / Udgaard Fighter*/
guild_str:="Necromancer / Druid / Fighter";

         g1 := 9;
         g2 := 10;
         g3 := 1;

goto necro_end;
:necro_4:
/*Nymgaard Druid     / Udgaard Thief*/
guild_str:="Necromancer / Druid / Thief";

         g1 := 9;
         g2 := 10;
         g3 := 2;
		 goto necro_end;
:necro_5:
/*Midgaard Fighter     / Udgaard Thief*/
guild_str:="Necromancer / Fighter / Thief";

         g1 := 9;
         g2 := 1;
         g3 := 2;
goto necro_end;
:necro_6:
/*Udgaard Fighter / Midgaard Dark Knight **/
guild_str:="Necromancer / Fighter / Dark Knight";

         g1 := 9;
         g2 := 1;
         g3 := 11;
goto necro_end;
:necro_7:
/*Nymgaard Druid     / Midgaard Dark Knight*/
guild_str:="Necromancer / Druid / Dark Knight";

         g1 := 9;
         g2 := 10;
         g3 := 11;
goto necro_end;
:necro_8:
/*Udgaard Thief / Midgaard Dark Knight*/
guild_str:="Necromancer / Thief / Dark Knight";

         g1 := 9;
         g2 := 2;
         g3 := 11;

:necro_end:
                      sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Necromancer paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;

 on choice goto quit_reroll,end_reroll,necro_menu,start,quit_reroll;
goto quit_reroll;

:druid_menu:
     					err:=loadstr("reroll.druid",buff);
if (err<1)
	{
	log ("08:  Error in reroll ranger menu");
	sendtext ("Reroll is not working contact an admin to fix it.<br/>",self);
		  	  gamestate(self, GS_PLAY);

	quit;
	}

buff:=textformat(buff);
	pagestring (buff,self);

	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);
if (cmdstr=="x")
	goto start;
if ((choice==0) or (choice>12))
	goto quit_reroll;

	on choice goto quit_reroll,druid_1,druid_2,druid_3,druid_4,druid_5,
	druid_6,druid_7,druid_8,druid_9,druid_10,
	druid_11,druid_12;
		goto quit_reroll;

:druid_1:
/*Udgaard Healer     / Nymgaard Ranger*/
guild_str:="Druid / Healer / Ranger";

         g1 := 10;
         g2 := 3;
         g3 := 5;

goto druid_end;
:druid_2:
/*Udgaard Healer     / Midgaard Paladin*/
guild_str:="Druid / Healer / Paladin";

         g1 := 10;
         g2 := 3;
         g3 := 6;

goto druid_end;
:druid_3:
/*Udgaard Healer     / Udgaard Fighter*/
guild_str:="Druid / Healer / Fighter";

         g1 := 10;
         g2 := 3;
         g3 := 1;

goto druid_end;
:druid_4:
/*Nymgaard Ranger    / Udgaard Fighter*/
guild_str:="Druid / Ranger / Fighter";

         g1 := 10;
         g2 := 5;
         g3 := 1;

goto druid_end;
:druid_5:
/*Nymgaard Ranger    / Udgaard Healer*/
guild_str:="Druid / Ranger / Healer";

         g1 := 10;
         g2 := 5;
         g3 := 3;

goto druid_end;
:druid_6:
/*Nymgaard Ranger    / Midgaard Paladin*/
guild_str:="Druid / Ranger / Paladin";

         g1 := 10;
         g2 := 5;
         g3 := 6;

goto druid_end;
:druid_7:
/*Midgaard Paladin   / Udgaard Fighter*/
guild_str:="Druid / Paladin / Fighter";

         g1 := 10;
         g2 := 6;
         g3 := 1;

goto druid_end;
:druid_8:
/*Midgaard Paladin   / Nymgaard Ranger*/
guild_str:="Druid / Paladin / Ranger";

         g1 := 10;
         g2 := 6;
         g3 := 5;


goto druid_end;
:druid_9:
/*Midgaard Paladin   / Udgaard Healer*/
guild_str:="Druid / Paladin / Healer";

         g1 := 10;
         g2 := 6;
         g3 := 3;

goto druid_end;
:druid_10:
/*Necromancer        / Udgaard Fighter*/
guild_str:="Druid / Necromancer / Fighter";

         g1 := 10;
         g2 := 9;
         g3 := 1;
goto druid_end;
:druid_11:
/*Necromancer        / Midgaard Dark Knight*/
guild_str:="Druid / Necromancer / Dark Knight";

         g1 := 10;
         g2 := 9;
         g3 := 11;

		 goto druid_end;
:druid_12:
/*Nymgaard Ranger        / Midgaard Dark Knight*/
guild_str:="Druid / Ranger / Dark Knight";

         g1 := 10;
         g2 := 5;
         g3 := 11;


:druid_end:
                      sendtext ("Is "+guild_str+" the guild path you want?<br/><br/>",self);
sendtext ("1)  Yes<br/>",self);
sendtext ("2)  No return to Druid paths menu<br/>",self);
sendtext ("3)  No return to main guild menu<br/>",self);
sendtext ("4)  No quit reroll<br/><br/>",self);
sendtext ("Please select 1 -4:",self);


	wait(SFB_CMD, TRUE);

choice:=atoi(cmdstr);

if ((choice==0) or (choice>4))
	goto quit_reroll;

 on choice goto quit_reroll,end_reroll,druid_menu,start,quit_reroll;
goto quit_reroll;

:end_reroll:

if ("$pireroll" in self.extra)
subextra(self.extra,"$pireroll");


item:=self.inside;
while (item!=null){
	if (item.equip!=0){
	unequip(item);
	}
	item:=item.next;
	}


/* Remove affects */
:loop:
   if (isaff(self, ID_BLESS))
     subaff(self, ID_BLESS);
   else   if (isaff(self, ID_NBLESS))
     subaff(self, ID_NBLESS);
   else if (isaff(self, ID_DETECT_ALIGN))
     subaff(self, ID_DETECT_ALIGN);
   else if (isaff(self, ID_DETECT_INVISIBLE))
     subaff(self, ID_DETECT_INVISIBLE);
   else if (isaff(self, ID_DETECT_MAGIC))
     subaff(self, ID_DETECT_MAGIC);
   else if (isaff(self, ID_DETECT_POISON))
     subaff(self, ID_DETECT_POISON);
   else if (isaff(self, ID_DETECT_UNDEAD))
     subaff(self, ID_DETECT_UNDEAD);
   else if (isaff(self, ID_DETECT_CURSE))
     subaff(self, ID_DETECT_CURSE);
   else if (isaff(self, ID_DETECT_LIFE))
     subaff(self, ID_DETECT_LIFE);
   else if (isaff(self, ID_ENCHANT_WEAPON))
     subaff(self, ID_ENCHANT_WEAPON);
   else if (isaff(self, ID_ENCHANT_ARMOUR))
     subaff(self, ID_ENCHANT_ARMOUR);
   else if (isaff(self, ID_ABSORBTION))
     subaff(self, ID_ABSORBTION);
   else if (isaff(self, ID_INVISIBILITY))
     subaff(self, ID_INVISIBILITY);
   else if (isaff(self, ID_HOLD))
     subaff(self, ID_HOLD);
   else if (isaff(self, ID_CHARM))
     subaff(self, ID_CHARM);
   else if (isaff(self, ID_MAGIC_LIGHT))
     subaff(self, ID_MAGIC_LIGHT);
   else if (isaff(self, ID_MAGIC_DARK))
     subaff(self, ID_MAGIC_DARK);
   else if (isaff(self, ID_SPL_RAISE_MAG))
     subaff(self, ID_SPL_RAISE_MAG);
   else if (isaff(self, ID_SPL_RAISE_DIV))
     subaff(self, ID_SPL_RAISE_DIV);
   else if (isaff(self, ID_SPL_RAISE_STR))
     subaff(self, ID_SPL_RAISE_STR);
   else if (isaff(self, ID_SPL_RAISE_DEX))
     subaff(self, ID_SPL_RAISE_DEX);
   else if (isaff(self, ID_SPL_RAISE_CON))
     subaff(self, ID_SPL_RAISE_CON);
   else if (isaff(self, ID_SPL_RAISE_CHA))
     subaff(self, ID_SPL_RAISE_CHA);
   else if (isaff(self, ID_SPL_RAISE_BRA))
     subaff(self, ID_SPL_RAISE_BRA);
   else if (isaff(self, ID_SPL_RAISE_HPP))
     subaff(self, ID_SPL_RAISE_HPP);
   else if (isaff(self, ID_SPL_RAISE_DIVINE))
     subaff(self, ID_SPL_RAISE_DIVINE);
   else if (isaff(self, ID_SPL_RAISE_SUMMONING))
     subaff(self, ID_SPL_RAISE_SUMMONING);
   else if (isaff(self, ID_SPL_RAISE_MIND))
     subaff(self, ID_SPL_RAISE_MIND);
   else if (isaff(self, ID_SPL_RAISE_HEAT))
     subaff(self, ID_SPL_RAISE_HEAT);
   else if (isaff(self, ID_SPL_RAISE_COLD))
     subaff(self, ID_SPL_RAISE_COLD);
   else if (isaff(self, ID_SPL_RAISE_CELL))
     subaff(self, ID_SPL_RAISE_CELL);
   else if (isaff(self, ID_SPL_RAISE_INTERNAL))
     subaff(self, ID_SPL_RAISE_INTERNAL);
   else if (isaff(self, ID_SPL_RAISE_EXTERNAL))
     subaff(self, ID_SPL_RAISE_EXTERNAL);
   else if (isaff(self, ID_RAISE_MAG))
     subaff(self, ID_RAISE_MAG);
   else if (isaff(self, ID_RAISE_DIV))
     subaff(self, ID_RAISE_DIV);
   else if (isaff(self, ID_RAISE_STR))
     subaff(self, ID_RAISE_STR);
   else if (isaff(self, ID_RAISE_DEX))
     subaff(self, ID_RAISE_DEX);
   else if (isaff(self, ID_RAISE_CON))
     subaff(self, ID_RAISE_CON);
   else if (isaff(self, ID_RAISE_CHA))
     subaff(self, ID_RAISE_CHA);
   else if (isaff(self, ID_RAISE_BRA))
     subaff(self, ID_RAISE_BRA);
   else if (isaff(self, ID_RAISE_HPP))
     subaff(self, ID_RAISE_HPP);
   else if (isaff(self, ID_RAISE_DIVINE))
     subaff(self, ID_RAISE_DIVINE);
   else if (isaff(self, ID_RAISE_SUMMONING))
     subaff(self, ID_RAISE_SUMMONING);
   else if (isaff(self, ID_RAISE_MIND))
     subaff(self, ID_RAISE_MIND);
   else if (isaff(self, ID_RAISE_HEAT))
     subaff(self, ID_RAISE_HEAT);
   else if (isaff(self, ID_RAISE_COLD))
     subaff(self, ID_RAISE_COLD);
   else if (isaff(self, ID_RAISE_CELL))
     subaff(self, ID_RAISE_CELL);
   else if (isaff(self, ID_RAISE_INTERNAL))
     subaff(self, ID_RAISE_INTERNAL);
   else if (isaff(self, ID_RAISE_EXTERNAL))
     subaff(self, ID_RAISE_EXTERNAL);
   else if (isaff(self, ID_POISON))
     subaff(self, ID_POISON);
   else if (isaff(self, ID_SPEED))
     subaff(self, ID_SPEED);
  else if (isaff(self, ID_FOCUS))
     subaff(self, ID_FOCUS);
  else if (isaff(self, ID_MIRE))
   subaff(self, ID_MIRE);
  else if (isaff(self, ID_CONDEMN))
   subaff(self, ID_CONDEMN);
   else
   {
   	sendtext("Affects removed<br/>",self);
	goto end_aff;
   }
   goto loop;
   :end_aff:

/* First reduce skills by 75% */

   while (i <= LAST_SKILL)
   {
   if (self.skills[i]>10){
   tval:=self.skills[i];
   tval:=tval*25;
	tval:=tval/100;
      self.skills[i] :=tval;
	  }
      i := i + 1;
   }
sendtext("Skills set.<br/>",self);
   i := 0;

/* Now spells */

   while (i <=LAST_SPELL)
   {
   if (self.spells[I]>10){
      tval:=self.spells[i];
	  tval:=tval*25;
	  tval:=tval/100;
	  	        self.spells[i] :=tval;
							}
      i := i + 1;
   }
                  sendtext("Spells set.<br/>",self);
   i := 0;

/* Now weapons */

   while (i <= LAST_WEAPON)
   {
   if (self.weapons[i]>10){
      tval:=self.weapons[i];
	  tval:=tval*25;
	  tval:=tval/100;
	  	        self.weapons[i]:=tval;

			}
      i := i + 1;
   }
   sendtext ("Weapons set.<br/>",self);

      subextra(self.quests, "$path");
	  :remove_guilds:

   if ("$guild" in self.quests)
   {
      subextra(self.quests, "$guild");
      goto remove_guilds;
   }
sendtext ("Guilds removed.<br/>",self);

   if (dilfind("no_kill@basis", self))
   	{
      i := dildestroy("no_kill@basis", self);
	       set(self.pcflags, PC_PK_RELAXED);
   }

      unset(self.pcflags, PC_PK_RELAXED);
	        set(self.charflags, CHAR_PROTECTED);
			self.crimes:=0;
	  sendtext ("Book of blood status cleared.<br/>",self);

reset_level(self);
   reset_race(   self);   /* Reset my race attributes - age, costs, etc */
   reset_vlevel(self);



   if (self.race==RACE_HUMAN)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 4;

   }
   else if (self.race==RACE_DWARF)
   {
      self.abilities[ABIL_STR] := 6;
      self.abilities[ABIL_CON] := 2;
      self.abilities[ABIL_HP ] := 6;
      self.abilities[ABIL_DEX] := 2;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 2;

   }
   else if (self.race==RACE_ELF)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_CHA] := 6;
      self.abilities[ABIL_DIV] := 6;
      self.abilities[ABIL_MAG] := 4;


   }
   else if (self.race==RACE_HALFLING)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 6;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 6;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 2;

   }
   else if (self.race==RACE_GNOME)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 6;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 4;

   }
   else if (self.race==RACE_HALF_OGRE)
   {
      self.abilities[ABIL_STR] := 6;
      self.abilities[ABIL_CON] := 6;
      self.abilities[ABIL_HP ] := 6;
      self.abilities[ABIL_DEX] := 2;
      self.abilities[ABIL_BRA] := 2;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 2;

   }
   else if (self.race==RACE_HALF_ORC)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 2;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 2;


   }
   else if (self.race==RACE_BROWNIE)
   {
      self.abilities[ABIL_STR] := 2;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 6;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_DIV] := 2;
      self.abilities[ABIL_MAG] := 6;

   }
   else if (self.race==RACE_HALF_ELF)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_MAG] := 4;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_HP ] := 4;


   }
   else if (self.race==RACE_GROLL)
   {
      self.abilities[ABIL_STR] := 6;
      self.abilities[ABIL_DEX] := 2;
      self.abilities[ABIL_CON] := 8;
      self.abilities[ABIL_MAG] := 2;
      self.abilities[ABIL_DIV] := 2;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_BRA] := 2;
      self.abilities[ABIL_HP ] := 8;


   }
   else if (self.race==RACE_DARK_ELF)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_MAG] := 6;
      self.abilities[ABIL_DIV] := 2;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_BRA] := 6;
      self.abilities[ABIL_HP ] := 4;

   }
   sendtext ("Set base stats.<br/>",self);

self.guild := gug.[g1];
sendtext ("Set Guild path.<br/>",self);

self.ability_points:=40;
self.skill_points:=80;
sendtext("Set training points for first level.<br/>",self);

   if (self.guild == GUILD_UDG_FIGHTER)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+2;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+0;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+2;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+2;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]-0;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+0;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]-0;

      self.weapons[WPN_AXE_HAM] := self.weapons[WPN_AXE_HAM] + 5;
      self.weapons[WPN_UNARMED] := self.weapons[WPN_UNARMED] + 5;
      self.weapons[WPN_SWORD]   := self.weapons[WPN_SWORD] + 5;

      self.weapons[WPN_FIST]        := self.weapons[WPN_FIST] + 5;
      self.weapons[WPN_BATTLE_AXE]  := self.weapons[WPN_BATTLE_AXE] + 5;
      self.weapons[WPN_LONG_SWORD]  := self.weapons[WPN_LONG_SWORD] + 5;
      self.weapons[WPN_SHORT_SWORD] := self.weapons[WPN_SHORT_SWORD] + 5;
   }

   else if (self.guild == GUILD_UDG_THIEF)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+4;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+0;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]-0;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+0;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]-0;

      self.skills[SKI_SHIELD] := self.skills[SKI_SHIELD] + 5;
      self.skills[SKI_SEARCH] := self.skills[SKI_SEARCH] + 5;
      self.skills[SKI_HIDE]   := self.skills[SKI_HIDE] + 5;
      self.skills[SKI_SNEAK]  := self.skills[SKI_SNEAK] + 5;

      self.weapons[WPN_FIST]         := self.weapons[WPN_FIST] + 5;
      self.weapons[WPN_UNARMED]      := self.weapons[WPN_UNARMED] + 5;
      self.weapons[WPN_SWORD]        := self.weapons[WPN_SWORD] + 5;
      self.weapons[WPN_SHORT_SWORD]  := self.weapons[WPN_SHORT_SWORD] + 5;
      self.weapons[WPN_DAGGER]       := self.weapons[WPN_DAGGER] + 5;
   }

   else if (self.guild == GUILD_UDG_CLERIC)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+0;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+0;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]+2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+2;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+0;

      self.weapons[WPN_CLUB_MACE]     := self.weapons[WPN_CLUB_MACE] + 5;
      self.weapons[WPN_MACE]          := self.weapons[WPN_MACE] + 5;

      self.spells[SPL_DIVINE]         := self.spells[SPL_DIVINE] + 5;
      self.spells[SPL_MIND]           := self.spells[SPL_MIND] + 5;

      self.spells[SPL_CURE_WOUNDS_1]  := self.spells[SPL_CURE_WOUNDS_1] + 5;
      self.spells[SPL_CAUSE_WOUNDS_1] := self.spells[SPL_CAUSE_WOUNDS_1] +
                                         5;
      self.skills[SKI_FIRST_AID]      := self.skills[SKI_FIRST_AID] + 5;
   }

   else if ((self.guild == GUILD_UDG_MAGE) or (self.guild == GUILD_SORCERER))
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]-0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+2;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]-0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]-0;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]+2;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+2;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+2;

      self.weapons[WPN_SWORD]        := self.weapons[WPN_SWORD] + 5;
      self.weapons[WPN_DAGGER]       := self.weapons[WPN_DAGGER] + 5;

      self.skills[SKI_SCROLL_USE]    := self.skills[SKI_SCROLL_USE] + 5;
      self.skills[SKI_WAND_USE]      := self.skills[SKI_WAND_USE] + 5;

      self.spells[SPL_DETECTION]     := self.spells[SPL_DETECTION] + 5;
      self.spells[SPL_DET_INVISIBLE] := self.spells[SPL_DET_INVISIBLE] + 5;

      self.spells[SPL_DETECTION]     := self.spells[SPL_DETECTION] + 5;
      self.spells[SPL_DET_MAGIC]     := self.spells[SPL_DET_MAGIC] + 5;

      self.spells[SPL_SUMMONING]     := self.spells[SPL_SUMMONING] + 5;
      self.spells[SPL_ENERGY_BOLT]   := self.spells[SPL_ENERGY_BOLT] + 5;
   }

   else if (self.guild == GUILD_PALADIN)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+2;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+2;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+0;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]+2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+2;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+0;

      self.weapons[WPN_FIST]          := self.weapons[WPN_FIST] + 5;
      self.weapons[WPN_DAGGER]        := self.weapons[WPN_DAGGER] + 5;

      self.spells[SPL_DIVINE]         := self.spells[SPL_DIVINE] + 5;
      self.spells[SPL_MIND]           := self.spells[SPL_MIND] + 5;

      self.skills[SKI_SHIELD]      := self.skills[SKI_SHIELD] + 5;
      self.skills[SKI_RESCUE]      := self.skills[SKI_RESCUE] + 5;
   }
   else if (self.guild == GUILD_KNIGHT)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+2;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+2;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+0;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]+2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+2;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+0;

      self.weapons[WPN_FIST]          := self.weapons[WPN_FIST] + 5;
      self.weapons[WPN_DAGGER]        := self.weapons[WPN_DAGGER] + 5;

      self.spells[SPL_DIVINE]         := self.spells[SPL_DIVINE] + 5;
      self.spells[SPL_MIND]           := self.spells[SPL_MIND] + 5;

      self.skills[SKI_SHIELD]      := self.skills[SKI_SHIELD] + 5;
      self.skills[SKI_RESCUE]      := self.skills[SKI_RESCUE] + 5;
   }


   else if (self.guild == GUILD_NYM_RANGER)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+2;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+2;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]+2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+0;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+2;

      self.weapons[WPN_FIST]       := self.weapons[WPN_FIST] + 5;
      self.weapons[WPN_SLING]      := self.weapons[WPN_SLING] + 5;

      self.spells[SPL_HEAL_ANIMAL] := self.spells[SPL_HEAL_ANIMAL] + 5;

      self.skills[SKI_SHIELD]      := self.skills[SKI_SHIELD] + 5;
      self.skills[SKI_RESCUE]      := self.skills[SKI_RESCUE] + 5;
      self.skills[SKI_SEARCH]      := self.skills[SKI_SEARCH] + 5;
      self.skills[SKI_SCAN]        := self.skills[SKI_SCAN] + 5;
   }

   else if (self.guild == GUILD_NYM_DRUID)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+0;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+0;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]+2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+2;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+2;

      self.weapons[WPN_FIST]         := self.weapons[WPN_FIST] + 5;
      self.weapons[WPN_QUARTERSTAFF] := self.weapons[WPN_QUARTERSTAFF] + 5;

      self.spells[SPL_THORN_STRIKE] := self.spells[SPL_THORN_STRIKE] + 5;

      self.skills[SKI_WAND_USE]       := self.skills[SKI_WAND_USE] + 5;
      self.skills[SKI_HERBS]        := self.skills[SKI_HERBS] + 5;
      self.skills[SKI_FLEE]        := self.skills[SKI_FLEE] + 5;
   }

   else if (self.guild == GUILD_NECROMANCER)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+0;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+0;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]+2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+0;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+2;

      self.weapons[WPN_DAGGER]        := self.weapons[WPN_DAGGER] + 5;
      self.weapons[WPN_FIST]          := self.weapons[WPN_FIST] + 5;

      self.spells[SPL_RAISE_DIV]      := self.spells[SPL_RAISE_DIV] + 5;
      self.spells[SPL_DET_UNDEAD]     := self.spells[SPL_DET_UNDEAD] + 5;
      self.spells[SPL_CAUSE_WOUNDS_1] := self.spells[SPL_CAUSE_WOUNDS_1] +
                                         5;
      self.skills[SKI_WAND_USE]       := self.skills[SKI_WAND_USE] + 5;
      self.skills[SKI_FLEE]           := self.skills[SKI_FLEE] + 5;
   }

   else if (self.guild == GUILD_ASSASSIN)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+4;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP]  :=self.abilities[ABIL_HP]+2;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]-0;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]-0;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+0;

      self.skills[SKI_DIAGNOSTICS] := self.skills[SKI_DIAGNOSTICS] + 5;
      self.skills[SKI_CONSIDER]    := self.skills[SKI_CONSIDER] + 5;
      self.skills[SKI_HIDE]        := self.skills[SKI_HIDE] + 5;
      self.skills[SKI_SNEAK]       := self.skills[SKI_SNEAK] + 5;
      self.skills[SKI_FLEE]        := self.skills[SKI_FLEE] + 5;
      self.skills[SKI_BACKSTAB]    := self.skills[SKI_BACKSTAB] + 5;
      self.skills[SKI_CLIMB]       := self.skills[SKI_CLIMB] + 5;

      self.weapons[WPN_FIST]         := self.weapons[WPN_FIST] + 5;
      self.weapons[WPN_DAGGER]       := self.weapons[WPN_DAGGER] + 5;
   }

   if (self.abilities[ABIL_STR] < 2) self.abilities[ABIL_STR] := 2;
   if (self.abilities[ABIL_DEX] < 2) self.abilities[ABIL_DEX] := 2;
   if (self.abilities[ABIL_CON] < 2) self.abilities[ABIL_CON] := 2;
   if (self.abilities[ABIL_CHA] < 2) self.abilities[ABIL_CHA] := 2;
   if (self.abilities[ABIL_BRA] < 2) self.abilities[ABIL_BRA] := 2;
   if (self.abilities[ABIL_MAG] < 2) self.abilities[ABIL_MAG] := 2;
   if (self.abilities[ABIL_DIV] < 2) self.abilities[ABIL_DIV] := 2;
   if (self.abilities[ABIL_HP] < 2) self.abilities[ABIL_HP] := 2;

sendtext("Modified stats to guild path.<br/>",self);

addstring(data_list, "$path");
addstring(data_list, gug.[g1]);
addstring(data_list, gug.[g2]);
addstring(data_list, gug.[g3]);
addstring(data_list, "1");
addstring(data_list, "0");
addstring(data_list, "0");
addstring(data_list, "1");

addextra(self.quests, data_list, ini.[g1] + " / " + ini.[g2] + " / " +
ini.[g3] + "</div>");


      gp := "$path" in self.quests;

      guild1 := gp.names.[1];
      guild2 := gp.names.[2];
      guild3 := gp.names.[3];

      gl1    := atoi(gp.names.[4]);
      gl2    := atoi(gp.names.[5]);
      gl3    := atoi(gp.names.[6]);

      data_list := null;
      if (gl1 > 0)
      {
         addstring(data_list, "$" + guild1);
         addstring(data_list, itoa(gl1));
         addstring(data_list, "$guild");
         addextra(self.quests, data_list, itoa(realtime - 1000));
      }

      data_list := null;
      if (gl2 > 0)
      {
         addstring(data_list, "$" + guild2);
         addstring(data_list, itoa(gl2));
         addstring(data_list, "$guild");
         addextra(self.quests, data_list, itoa(realtime - 1000));
      }

      data_list := null;
      if (gl3 > 0)
      {
         addstring(data_list, "$" + guild3);
         addstring(data_list, itoa(gl3));
         addstring(data_list, "$guild");
         addextra(self.quests, data_list, itoa(realtime - 1000));
	  }


   tempu := load("guild_medallion@guild_paths");
    tempu.height := self.height;

   link(tempu,self);

   self.hp := self.max_hp;
   self.endurance := self.max_endurance;
   self.mana := self.max_mana;
                            position_update(self);

   sendtext("Loaded guild transport medallion.<br/>",self);

	self.weight:=self.baseweight;
	item:=self.inside;
	while (item)
		{
		self.weight:=self.weight+item.weight;
		item:=item.next;
		}
	sendtext ("Weight fixed.<br/>",self);
    self.max_hp:=3*self.abilities[ABIL_HP]+20;
   self.hp := self.max_hp;
   self.endurance := self.max_endurance;
   self.mana := self.max_mana;

	addextra (self.extra,{"$NOREROLL"},"command");
addextra (self.extra,{"$rerollexp"},itoa(self.exp));
      sendtext ("You have been rerolled check your self and make sure it all worked.<br/>",self);
	  	  gamestate(self, GS_PLAY);

	  quit;

	  :quit_reroll:
	  sendtext("Aborting the reroll command.  Yall come back ya here?<br/>",self);
	  gamestate(self, GS_PLAY);

	  quit;

}
dilend/*reroll end*/



dilbegin string eq_string(i : integer,ting : unitptr);
external
        integer two_handed(i : integer);
var
two : integer;
code
{
   if(i == WEAR_FINGER_R)
      return("worn on right finger");
   else if(i == WEAR_FINGER_L)
      return("worn on left finger");
   else if((i == WEAR_NECK_1) or (i == WEAR_NECK_2))
      return("worn around neck");
   else if(i == WEAR_BODY)
      return("worn on body");
   else if(i == WEAR_HEAD)
      return("worn on head");
   else if(i == WEAR_LEGS)
      return("worn on legs");
   else if(i == WEAR_FEET)
      return("worn on feet");
   else if(i == WEAR_HANDS)
      return("worn on hands");
   else if(i == WEAR_ARMS)
      return("worn on arms");
   else if(i == WEAR_SHIELD)
      return("worn as shield");
   else if(i == WEAR_ABOUT)
      return("worn about body");
   else if(i == WEAR_WAIST)
      return("worn about waist");
   else if((i == WEAR_WRIST_R) or (i == WEAR_WRIST_L))
      return("worn around wrist");
   else if(i == WEAR_WIELD)
   {
      if (ting)
         two := two_handed(ting.value[0]);
      else
         two:=FALSE;
      if(two == TRUE)
         return("two hand wielded");
      else
         return("wielded");
   }
   else if(i == WEAR_HOLD)
   {
      if (ting)
         two := two_handed(ting.value[0]);
      else
         two:=FALSE;
      if(two == TRUE)
         return("two hand held");
      else
         return("held");
   }
   else if(i == WEAR_CHEST)
      return("worn across chest");
   else if(i == WEAR_BACK)
      return("worn on back");
   else if(i == WEAR_EAR_L)
      return("worn on left ear");
   else if(i == WEAR_EAR_R)
      return("worn on right ear");
   else if((i == WEAR_ANKLE_L) or (i == WEAR_ANKLE_R))
      return("worn on ankle");
   else
      return("report to an admin");
}
dilend



dilbegin do_equipment(arg : string);
external
        string eq_string(i : integer,ting : unitptr);
        string get_eq_in_order();
var
obj : unitptr;
str : string;
cnt : integer;
len : integer;
pge : string;
lit : string;
code
{
   if(arg == "")
   {
      pge := "<u>You are using:</u><br/>";

      obj := self.inside;
      pge := pge + "<table class='colh2'>";
      while(obj != null)
      {
         if(obj.equip)
         {
            if (obj.bright > 0)
               lit := " (light)";
            else if (obj.bright < 0)
               lit := " (dark)";
            else
               lit := "";

            str := eq_string(obj.equip,obj);
            pge := pge+"<tr><td>&lt;"+str+"&gt;</td>"+
                     "<td><div class='worn'>"+obj.title+lit+"</div></td></tr>";
            cnt := cnt + 1;
         }
         obj := obj.next;
      } // end while

      pge := pge + "</table>";

      if(cnt < 1)
         pge := pge+"Nothing!<br/>";

      sendtext(pge, self);
   } // arg == ""
   else if(arg == "all")
   {
      str := get_eq_in_order(); // xxx
      sendtext(str,self);
   }
   else
   {
      sendtext("Not sure what that means... Try equipment or equipment all<br/>",self);
   }

   send_done("equipment",self,null,null,0,arg,null);
   quit;
}
dilend


dilbegin string get_eq_in_order();
external
        string eq_string(i : integer,ting : unitptr);
        integer two_handed(i : integer);
var
ret : string;
il  : intlist;
i   : integer;
str : string;
obj : unitptr;
len : integer;
two : integer;
lit : string;

code
{
   /* Equipment in order from head to toe */
   il := {WEAR_HEAD,WEAR_EAR_R,WEAR_EAR_L,WEAR_NECK_1,WEAR_NECK_2,WEAR_BACK,
   WEAR_ABOUT,WEAR_ARMS,WEAR_WRIST_R,WEAR_WRIST_L,WEAR_HANDS,WEAR_FINGER_R,
   WEAR_FINGER_L,WEAR_WIELD,WEAR_HOLD,WEAR_SHIELD,WEAR_BODY,WEAR_CHEST,WEAR_WAIST,
   WEAR_LEGS,WEAR_ANKLE_R,WEAR_ANKLE_L,WEAR_FEET};

   i := 0;
   ret := "<u>You are using:</u><br/><table>";

   while (i < length(il))
   {
      /* This isnt working (cant see my torch), and I dont see why it is needed
      if (il.[i] == WEAR_HOLD)
      {
         if (equipment(self,WEAR_SHIELD))
         {
            i := i + 1;
            continue;
         }

         obj := equipment(self,WEAR_WIELD);
         if (obj!=null)
         {
            two := two_handed(obj.value[0]);
            if(two == TRUE)
            {
               i := i + 1;
               continue;
            }
         }
      }
      else if((il.[i] == WEAR_SHIELD) and (equipment(self,WEAR_SHIELD) == null))
      {
            i := i + 1;
            continue;
      }*/

      obj := equipment(self,il.[i]);
      str := eq_string(il.[i],obj);

      if(obj != null)
      {
         if (obj.bright > 0)
            lit := " (light)";
         else if (obj.bright < 0)
            lit := " (dark)";
         else
            lit := "";

         ret := ret+"<tr><td>&lt;"+str+"&gt;</td><td><div class='worn'>"+obj.title+lit+"</div></td></tr>";
      }
      else
         ret := ret+"<tr><td>&lt;"+str+"&gt;</td><td>nothing</td></tr>";
      i := i + 1;
   }

   ret := ret + "</table>";
   return(ret);
}
dilend




dilbegin do_quit(arg : string);
var
err : integer;

goodbye : string;
 tt:integer;
 minutes:integer;
 seconds:integer;
u : unitptr;
quit_str:string;

code
{
         if (quit_str=="logging on")
          quit;

heartbeat := PULSE_SEC;

if (excmdstr!="quit"){
	sendtext ("You must type 'quit' no less to quit!<br/>",self);
	quit;
	}


if(self.type != UNIT_ST_PC) quit;
if(self.position == POSITION_FIGHTING)
{
 sendtext("Not while fighting!<br/>", self);
 quit;
}


tt:=atoi(self.extra.["$PK_TIMER"].descr);
if(realtime-tt>600)
goto cont_quit;
seconds:=0;
minutes:=0;
seconds:=realtime-tt;
seconds:=600-seconds;
minutes:=seconds/60;
 sendtext("You are not permitted to log off so soon after a PK fight.<br/>",self);

if (minutes<1){
if (seconds==1)
sendtext ("You have 1 more second before you can log off.<br/>",self);
	else
                 sendtext ("You have "+itoa(seconds)+" more seconds before you can log off.<br/>",self);
				 quit;
				 }
else
 {
 seconds :=seconds-(minutes*60);
if ((minutes==1) and (seconds==1))
sendtext ("You have 1 minute and 1 second before you can log off.<br/>",self);
else if (minutes==1)
sendtext ("You have 1 minute and "+itoa(seconds)+" seconds before you can log off.<br/>",self);
else if (seconds==1)
sendtext ("You have "+itoa(minutes)+" minutes and 1 second before you can log off.<br/>",self);
else
sendtext ("You have "+itoa(minutes)+" minutes and "+itoa(seconds)+" seconds before you can log off.<br/>",self);
 quit;
}

:cont_quit:
foreach(UNIT_ST_PC,u)
{

 if(u != self)
 {
  if(visible(u,self))
   sendtext(self.name+" has left the game.<br/>",u);
 }
}


err := loadstr("goodbye",goodbye);

if(err > 0)
{
        goodbye := textformat(goodbye);
        sendtext("<br/><br/>"+goodbye, self);
}

sendtext("Goodbye, friend.. Come back soon!<br/>", self);
quit_str:="logging on";
gamestate(self, GS_QUIT);
quit;
}
dilend

dilbegin aware do_password (arg:string);
var
	prmt:string;
 firstpwd:string;

 i:integer;
 tlist:stringlist;

code
{

if (excmdstr!="password"){
sendtext ("You must type 'password', no less to be able to set your password!<br/>",self);
quit;
}


if(self.type != UNIT_ST_PC) quit;
arg:="";
prmt:=self.prompt;
self.prompt:="Enter new password:  ";
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

wait (SFB_CMD,self==activator);
block;
tlist:=getwords (excmdstr_case);
if (length(tlist)>1){
sendtext ("Password must be only one word.  Try again.<br/>",self);
self.prompt:=prmt;
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

quit;
}
if (length(excmdstr_case)<5){
	sendtext ("Password to short. Password must be 5 characters or longer.  Try again.<br/>",self);
	self.prompt:=prmt;
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

	quit;
	}

if (length(excmdstr_case)>16){
	sendtext ("Password to long. Try again.<br/>",self);
	self.prompt:=prmt;
    i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

	quit;
	}

	firstpwd:=excmdstr_case;
	self.prompt:="Enter password again:  ";

wait (SFB_CMD,self==activator);
block;
if (strcmp(excmdstr_case,firstpwd)!=0){
sendtext ("Passwords do not match try again.<br/>",self);
self.prompt:=prmt;
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

quit;
}
set_password(self,excmdstr_case);
sendtext ("Password Changed.<br/>",self);
self.prompt:=prmt;
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

quit;
}
dilend

dilbegin aware do_delete (arg:string);
var
	temp:string;
	err:integer;
	pc:unitptr;
code
{

/*
if (excmdstr!="delete"){
sendtext("You must type the full command 'delete' for this to work!<br/>",self);
quit;
}
*/

if(self.type != UNIT_ST_PC) quit;

if ((self.level>200) or (self.name=="ginger"))
	goto admin_delete;

:char_delete:
	if (arg!="self forever")
		{
		sendtext ("To delete your char type:  'delete self forever'<br/>",self);
		quit;
		}

err:=loadstr("delete.txt",temp);

if (err<1)
	goto no_insure;

sendtext (temp,self);

sendtext ("If your sure you still want to delete your character, 'say delete me'<br/>",self);
sendtext ("Doing anything else will abort the deletion.<br/>",self);

wait (SFB_CMD, self==activator);
if (command ("say"))

	if (argument=="delete me")
	{
	if (self.extra.[CLAN_RANK]!=null)
		exec ("cdefect now",self);
		delete_player(self.name);
		}

sendtext("Deletion aborted<br/>",self);

quit;

	:no_insure:
		if (self.extra.[CLAN_RANK]!=null)
		exec ("cdefect",self);
			delete_player(self.name);

quit;
	:admin_delete:
	if (arg=="self forever")
		goto char_delete;
if (arg==""){
sendtext("You must supply a characters name to delete one.<br/>",self);
quit;
}

if (arg==self.name){
sendtext ("To delete self you need to type 'delete self forever'<br/>",self);
quit;
}
pc:=pc_head();
while(pc.type==UNIT_ST_PC)
{
if (pc.name==arg)
goto deletem;
pc:=pc.gnext;
}

if (not isplayer(arg))
	{
	sendtext (arg+" is not a character.<br/>",self);
	quit;
	}
	:deletem:
	sendtext (arg+" has been deleted.<br/>",self);
quit;
}
dilend


dilbegin do_motd(arg : string);
var
err : integer;
motd : string;
code
{

err := loadstr("motd",motd);

if(err > 0)
{
        motd := "<br/>" + textformat(motd);
        pagestring(motd,self);
}

send_done("motd",self,null,null,0,arg,null);

quit;
}
dilend


dilbegin dig(arg : string);
var
u : unitptr;
i : integer;
f : integer;
code
{
f:=FALSE;


	foreach(UNIT_ST_OBJ | UNIT_ST_NPC | UNIT_ST_PC,u)
	{
	if(isset(u.flags,UNIT_FL_BURIED))
	{

	unset(u.flags, UNIT_FL_BURIED);
		  act ("You dig up $3n.",A_SOMEONE,self,null,u,TO_CHAR);
	  	  act ("$1n digs up $3n.",A_SOMEONE,self,null,u,TO_REST);

	i := dildestroy("buried_timer@commands",u);
	f := TRUE;
	break;
	}

	}


if (f!=TRUE)
{
act("There seems to be nothing to dig up.",A_ALWAYS,self,null,null,TO_CHAR);
act("$1n digs around but doesn't find anything.",A_ALWAYS,self,null,null,TO_REST);
}
send_done("dig",self,u,null,0,arg,null);

quit;
}
dilend

/* Timer for buried objects */
dilbegin buried_timer(amount : integer); /*Amount in real time minutes */
var
time : integer;
code
{

if(self.type != UNIT_ST_OBJ) quit; /* shrug..I don't know */
if(not (isset(self.flags, UNIT_FL_BURIED))) quit;
if((self.nameidx+"@"+self.zoneidx) == "corpse@death") quit;


heartbeat := PULSE_SEC * SECS_PER_REAL_MIN;
time := amount;

while(time > 0)
{
	wait(SFB_TICK, TRUE);

	time := time - 1;
}

if(isset(self.flags, UNIT_FL_BURIED)) destroy(self);
quit;
}
dilend

/* Updated bury dil */

/* Made by whistler, modified/tested by Mesmer, modified by Azzurathe to
check for cant bury flags */
dilbegin bury (arg:string);
var
count:integer;
args:stringlist;
  item:unitptr;
  temp:unitptr;



  ln:integer;
  buried:integer;


  code
  {
  count:=0;
  buried:=0;
  count:=0;
  if (arg=="") {
  act ("Bury what?", A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (self.fighting!=null) {
  act ("No Way! Your fighting for your life!",A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (self.outside.type!=UNIT_ST_ROOM) {
  act ("You can't bury stuff here.",A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

  args:=split(arg,".");
  ln:=length (args);
  if (ln>1)
  {
  	arg:=args.[1];
	if (args.[0]=="all")
	count:=-1;
	else
	count:=atoi(args.[0]);
	}
else
count:=1;


item:=self.outside.inside;
while (item!=null){
if (arg=="all")
{
if ((not(visible(self,item))) or
(item.type!=UNIT_ST_OBJ) or
   ( not(isset (item.manipulate,MANIPULATE_TAKE))) or
(isset(item.flags,UNIT_FL_BURIED))){
item:=item.next;
continue;
}
}
else if ((arg!="all") and (arg in item.names)){
if ((not(visible(self,item))) or
(isset(item.flags,UNIT_FL_BURIED))){
item:=item.next;
continue;
}
else if (count>1){
count:=count-1;
item:=item.next;
continue;
}
}
else
{
item:=item.next;
continue;
}

if ((item.type!=UNIT_ST_OBJ) or
   ( not(isset (item.manipulate,MANIPULATE_TAKE))))
  {
    act ("You can't bury $2n",A_ALWAYS,self,item,null,TO_CHAR);
	}
	else
	{
	buried:=buried+1;
	  act ("$1n buries $3n.",A_SOMEONE,self,null,item,TO_REST);
  act ("You bury $3n that was laying on the ground.",A_SOMEONE,self,null,item,TO_CHAR);
  set (item.flags,UNIT_FL_BURIED);
  dilcopy("buried_timer@commands(60)", item);
  link (item,self.outside);
  send_done("bury",self,item,null,0,arg,null);
  }
  	if ((count==-1) or (arg=="all"))
	{
	item:=item.next;
	continue;
	}
	quit;
	}
if ((arg=="all") and (buried==0))
{
sendtext ("Couldn't find anything to bury.<br/>",self);
quit;
}

if (arg=="all")
 quit;


	if ((buried>0) and (count!=-1))
		quit;

	item:=self.inside;
	while (item!=null){
	if ((item.equip!=0) or
(not(visible(self,item))) or
(isset(item.flags,UNIT_FL_BURIED)) or
(not(arg in item.names)) or
(count>1))
{
if (count>1)
count:=count-1;
item:=item.next;
continue;
}

if ((item.type!=UNIT_ST_OBJ) or
   (not(isset (item.manipulate,MANIPULATE_TAKE))))
  {
    act ("You can't bury $2n",A_ALWAYS,self,item,null,TO_CHAR);
	}
	else
	{
	buried:=buried+1;
	  act ("$1n buries $3n.",A_SOMEONE,self,null,item,TO_REST);
  act ("You bury $3n from your inventory.",A_SOMEONE,self,null,item,TO_CHAR);
  set (item.flags,UNIT_FL_BURIED);
  dilcopy("buried_timer@commands(60)", item);
  temp:=item.next;
  link (item,self.outside);
  send_done("bury",self,item,null,0,arg,null);
  }
  	if (count==-1)
	{
	item:=temp;
	continue;
	}
	quit;
	}

if (buried==0)
{
	act("No "+arg+" to bury here!",
	A_ALWAYS, self, null, null, TO_CHAR);
	quit;
	}


	quit;
}
dilend

dilbegin cmd_copy(arg : string);
var
u: unitptr;
s: string;

code
{

      s := getword(arg);

      if (s == "room")
      u := self.outside;

   else if (s == "self")
      u := self;

   else if ("@" in s)
      {
      u := findsymbolic(s);

      if (u.type != UNIT_ST_ROOM)
         {
         sendtext("Copying on symbolic units other than rooms "+
            "is denied.<br/>", self);
         quit;
         }
      }

   else
      {
      arg := s + " " + arg;
      u := findunit(self, arg, FIND_UNIT_HERE, null);
      }

   if (u)
   {
  if (u.zoneidx=="treasure")
  {
   act ("You can not copy to that.",A_ALWAYS, self,null,null,TO_CHAR);
  quit;
     }
      dilcopy(arg, u);
      act("Attempted to copy "+arg+" to unit "+u.name+"", A_ALWAYS, self, null,
null, TO_CHAR);
   }
   else
     act("No such unit found to copy a dil upon.", A_ALWAYS, self, null,
null, TO_CHAR);

quit;
}
dilend

dilbegin cmd_zap(arg : string);
var
u: unitptr;
s: string;
i: integer;

code
{

   s := getword(arg);

   if (s == "room")
      {
      u := self.outside;
      }

   else if (s == "self")
      {
      u := self;
      }

   else if ("@" in s)
      {
      u := findsymbolic(s);

      if (u.type != UNIT_ST_ROOM)
         {
         sendtext("Copying on symbolic units other than rooms "+
            "is denied.<br/>", self);
         quit;
         }
      }

   else
      {
      arg := s + " " + arg;
      u := findunit(self, arg, FIND_UNIT_HERE, null);
      }

   if (u)
   {
  if (u.zoneidx=="treasure")
  {
   act ("You can not zap from that.", A_ALWAYS, self,null,null,TO_CHAR);
  quit;
  }

      s := getword(arg);
      i := dildestroy(s, u);

      if (i)
         act("DIL successfully removed.", A_ALWAYS, self, null, null,
TO_CHAR);
      else
         act("Unable to remove the DIL in question.",A_ALWAYS, self, null,
null, TO_CHAR);
   }
   else
     act("No such unit found to zap.", A_ALWAYS, self, null, null, TO_CHAR);

quit;
}
dilend


/* Mesmer = Lazy */
#define DO_ACT(ACT) act(ACT, A_SOMEONE, self, null, null, TO_CHAR);

dilbegin do_stand(arg : string);
code
{

  /* horse ?*/
  if(self.outside.type & (UNIT_ST_NPC | UNIT_ST_PC))
  {
   DO_ACT("Not here you don't.")
   return;
  }

/*
    Skills.def will prevent this action unless you position is > resting
*/

  if(self.position == POSITION_FIGHTING)
  {
   DO_ACT("Do you not consider fighting as standing?")
   return;
  }
  else if(self.position == POSITION_STANDING)
   {
    DO_ACT("You are already standing.")
    return;
   }
 else  if (((dilfind("tripped@skills",self))) and (self.position == POSITION_SITTING))
    {
	DO_ACT("You just got knocked on your butt, "+
	"maybe you should regain your senses first!")
    return;
	}

  else if(self.position == POSITION_SITTING)
  {
   DO_ACT("You stand up.")
   act("$1n clambers on $1s feet.", A_HIDEINV, self, null, null, TO_REST);
   self.position := POSITION_STANDING;

    send_done("stand",self,null,null,0,arg,null);


   return;
  }

  else if(self.position == POSITION_RESTING)
  {
   DO_ACT("You stop resting, and stand up.")
   act("$1n stops resting, and clambers on $1s feet.", A_HIDEINV, self,
null, null, TO_REST);
   self.position := POSITION_STANDING;

    send_done("stand",self,null,null,0,arg,null);


   return;
  }
  else /* shrug, ask papi */
  {
   DO_ACT("You stop floating around, and put your feet on the ground.")
   act("$1n stops floating around, and puts $1s feet on the ground.",
   A_HIDEINV, self, null, null, TO_REST);
   self.position := POSITION_STANDING;

    send_done("stand",self,null,null,0,arg,null);


   return;
  }

 return;

}
dilend

dilbegin do_sit(arg : string);
code
{

 if(self.position == POSITION_STANDING)
  {
   DO_ACT("You sit down.")
   act("$1n sits down.",
      A_HIDEINV, self, null, null, TO_REST);
   self.position := POSITION_SITTING;

    send_done("sit",self,null,null,0,arg,null);


   }
 else if(self.position == POSITION_SITTING)
  {
   DO_ACT("You are sitting already.")
  }
 else if(self.position == POSITION_RESTING)
  {
   DO_ACT("You stop resting, and sit up.")
   act("$1n stops resting.",
     A_HIDEINV, self, null, null, TO_REST);
   self.position := POSITION_SITTING;

    send_done("sit",self,null,null,0,arg,null);


  }
 else if(self.position == POSITION_FIGHTING)
  {
   DO_ACT("Sit down while fighting? are you MAD?")
  }
 else
  {
   DO_ACT("You stop floating around, and sit down.")
   act("$1n stops floating around, and sits down.",A_HIDEINV, self, null,
null, TO_REST);
   self.position := POSITION_SITTING;

    send_done("sit",self,null,null,0,arg,null);


  }

 return;

}
dilend

dilbegin do_rest(arg : string);
code
{

  if(self.position == POSITION_STANDING)
   {
    DO_ACT("You sit down and rest your tired bones.")
    act("$1n sits down and rests.", A_HIDEINV, self, null, null, TO_REST);
    self.position := POSITION_RESTING;

    send_done("rest",self,null,null,0,arg,null);


   }
  else if(self.position == POSITION_SITTING)
  {
    DO_ACT("You rest your tired bones.")
    act("$1n rests.", A_HIDEINV, self, null, null, TO_REST);
    self.position := POSITION_RESTING;

    send_done("rest",self,null,null,0,arg,null);

  }
  else if(self.position == POSITION_RESTING)
  {
   DO_ACT("You are already resting.")
  }
  else if(self.position == POSITION_FIGHTING)
  {
   DO_ACT("Rest while fighting? are you MAD?")
  }
  else
  {
   DO_ACT("You stop floating around, and stop to rest your tired bones.")
   act("$1n stops floating around, and rests.",
     A_HIDEINV, self, null, null, TO_REST);
   self.position := POSITION_RESTING;

    send_done("rest",self,null,null,0,arg,null);

  }

 return;
}
dilend

dilbegin do_sleep(arg : string);
code
{

  if((self.position == POSITION_STANDING) or
     (self.position == POSITION_RESTING) or
     (self.position == POSITION_SITTING))
  {
   DO_ACT("You go to sleep.")
   act("$1n lies down and falls asleep.",
      A_HIDEINV, self, null, null, TO_REST);
   self.position := POSITION_SLEEPING;

    send_done("sleep",self,null,null,0,arg,null);

  }
  else if(self.position == POSITION_SLEEPING)
  {
   sendtext("You are already sound asleep.", self);
  }
  else if(self.position == POSITION_FIGHTING)
  {
   DO_ACT("Sleep while fighting? are you MAD?")
  }
  else
  {
   DO_ACT("You stop floating around, and lie down to sleep.")
   act("$1n stops floating around, and lie down to sleep.",A_HIDEINV, self,
null, null, TO_REST);
   self.position := POSITION_SLEEPING;

    send_done("sleep",self,null,null,0,arg,null);

  }

 return;

}
dilend

dilbegin do_wake(arg : string);
var
vict: unitptr;

code
{

   if(arg == "")
   {
      if(self.position > POSITION_SLEEPING)
         DO_ACT("You are already awake.")
      else
      {
         sendtext("You awaken, and start resting.<br/>",self);
         act("$1n awakens.", A_HIDEINV, self, null, null, TO_REST);
         self.position := POSITION_RESTING;
         send_done("wake",self,null,null,0,arg,null);
     }
      return;
   }
   else
   {
      if(self.position == POSITION_SLEEPING)
         DO_ACT("You can't wake people up if you are asleep yourself!<br>")
      else
      {
         vict := findunit(self, arg, FIND_UNIT_SURRO, null);

         if((vict == null) or (not(vict.type & (UNIT_ST_NPC | UNIT_ST_PC)))
            or not(visible(self,vict)))
         {
            DO_ACT("You do not see that person here.")
            return;
         }

         if(vict == self)
         {
            DO_ACT("If you want to wake yourself up, just type 'wake'")
            return;
         }

         if(vict.position < POSITION_SLEEPING)
         {
            act("You can't wake $3m up!",
               A_SOMEONE, self, null, vict, TO_CHAR);
            return;
         }

         if(vict.position > POSITION_SLEEPING)
         {
            act("$3n is already awake.",
               A_SOMEONE, self, null, vict, TO_CHAR);
            return;
         }

         if(vict.position == POSITION_SLEEPING)
         {
            vict.position := POSITION_RESTING;
            act("You wake $3m up.",
                  A_SOMEONE, self, null, vict, TO_CHAR);
            act("$3n is awakened by $1n.",
                  A_SOMEONE, self, null, vict, TO_NOTVICT);
            act("You are awakened by $1n.", A_SOMEONE, self, null, vict, TO_VICT);

            send_done("wake",vict,null,self,0,arg,null);
         }
         return;
      }
      return;
   }
}
dilend


dilbegin string getstring (sl:stringlist,i:integer,ln:integer);
var size:integer;
start:integer;
 temp:string;
code
{
size:=length (sl);
if (i+ln>=size)
 return ("");

size:=i+ln;
start:=i;
while (i<size)
 {
 if (start==i)
  temp:=sl.[i];
 else
  temp:=" "+sl.[i];
  i:=i+1;
  }

return (temp);
}
dilend

dilbegin stringlist  add_in_order (sl:stringlist,s:string);
var
 i:integer;
 ln:integer;
sln:integer;

code
{
if (length(sl)==0)
 {
 addstring (sl,s);
 return (sl);
 }

sln:=length(s);
ln:=length(sl);
i:=0;
while (i<ln)
 {
 if (length(sl.[i]) <=sln)
  {
  insert (sl,i,s);
 return(sl);
 }
 i:=i+1;
 }

addstring (sl,s);
return (sl);
}
dilend

dilbegin stringlist make_names (s:string);
external
 stringlist add_in_order (sl:stringlist,s:string);
 string getstring (sl:stringlist,i:integer,ln:integer);

var
 ln:integer;
 i:integer;
 count:integer;
 temp:string;
 sl:stringlist;
 slist:stringlist;
code
{
addstring (slist,s);
sl:=getwords (s);
ln:=length(sl);
i:=0;
while (i<ln)
 {
 slist:=add_in_order(slist,sl.[i]);
 i:=i+1;
 }

count:=ln;
count:=count-1;
while (count>1)
 {
 i:=0;
 while (i<ln)
  {
  temp:=getstring(sl,i,count);
  slist:=add_in_order(slist,temp);
  i:=i+1;
  }
 count:=count-1;
 }

return (slist);
}
dilend


dilbegin aware  piset(arg:string);
external
 stringlist make_names(s:string);
var
 i:integer;
  ln:integer;
  temp:string;
  tmp:string;
  u:unitptr;
  j:integer;
jln:integer;
  action:string;
  slist:stringlist;
code
{

if (arg=="")
 {
 sendtext ("piset what?<br/>",self);
 quit;
 }

u:=findunit(self,arg,FIND_UNIT_INVEN,null);
if (u==null)
 {
 sendtext("No such object found.<br/>",self);
 quit;
 }

if (u.type!=UNIT_ST_OBJ)
 {
 sendtext("No such object found.<br/>",self);
 quit;
 }

if (u.zoneidx!="treasure")
 {
 sendtext(u.title+" is not a Power Item.<br/>",self);
 quit;
 }

if ("$no_rename" in u.extra)
{
sendtext(u.title+" is a unique item that can not be renamed.<br/>",self);
quit;
}

secure(u,lostu);
action:=getword (arg);
if (action==left("title",length(action)))
 goto do_title;
else if (action==left("shortdescr",length(action)))
 goto do_shortdescr;
else if (action==left("descr",length(action)))
 goto do_descr;
else
 {
 sendtext ("Incorrect argument to piset please see <help piset><br/>",self);
 quit;
 }
:arg_title:
arg:=argument;
goto do_title;
:arg_title2:
arg:=excmdstr+" "+argument;
:do_title:
if (u.extra.["$pititle"].descr=="true")
 {
 sendtext ("You have already set this objects title.<br/>",self);
 quit;
 }


temp:=self.prompt;
self.prompt:="Is "+arg+" the title you want? ([Q]uit, [Y]es, or (N)o";
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

wait (SFB_CMD,self==activator);
self.prompt:=temp;
if (excmdstr==left("quit",length(excmdstr)))
 {
 block;
 sendtext ("Command Canceled.<br/>",self);
 i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

 quit;
 }
else if (excmdstr==left("yes",length(excmdstr)))
 {
 block;
 goto cont_title;
 }

block;
temp:=self.prompt;
self.prompt:="Enter a new title:  ";
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

wait (SFB_CMD,self==activator);
block;
self.prompt:=temp;
goto arg_title2;

:cont_title:

slist:=make_names(arg);
ln:=length(slist);
i:=0;
while (i<ln)
 {
 if (slist.[i] in u.names)
  {
  i:=i+1;
  continue;
  }
 j:=0;
jln:=length(u.names);
while (j<jln)
{
 if (length(slist.[i])>length(u.names.[j]))
 break;
  j:=j+1;
}
 insert (u.names,j,slist.[i]);
 i:=i+1;
 }
u.title:=arg;
addextra (u.extra,{"$pititle"},"true");
sendtext("Title set.<br/>",self);
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

quit;
:arg_shortdescr:
arg:=argument;
goto do_shortdescr;
:arg_shortdescr2:
arg:=excmdstr+" "+argument;
:do_shortdescr:
if (u.extra.["$pishortdescr"].descr=="true")
 {
 sendtext ("You have already set this objects short description.<br/>",self);
 quit;
 }


temp:=self.prompt;
self.prompt:="Is "+arg+" the short description you want? ([Q]uit, [Y]es, or (N)o";
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

wait (SFB_CMD,self==activator);
self.prompt:=temp;
if (excmdstr==left("quit",length(excmdstr)))
 {
 block;
 sendtext ("Command Canceled.<br/>",self);
 i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

 quit;
 }
else if (excmdstr==left("yes",length(excmdstr)))
 {
 block;
 goto cont_shortdescr;
 }

block;
temp:=self.prompt;
self.prompt:="Enter a new short description:  ";
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

wait (SFB_CMD,self==activator);
block;
self.prompt:=temp;
goto arg_shortdescr2;


:cont_shortdescr:

slist:=make_names(arg);
ln:=length(slist);
i:=0;
while (i<ln)
 {
 if (slist.[i] in u.names)
  {
  i:=i+1;
  continue;
  }
 j:=0;
jln:=length(u.names);
while (j<jln)
{
 if (length(slist.[i])>length(u.names.[j]))
 break;
  j:=j+1;
}

 insert (u.names,j,slist.[i]);
 i:=i+1;
 }
u.outside_descr:=arg;
addextra (u.extra,{"$pishortdescr"},"true");
sendtext("Short description set.<br/>",self);
self.prompt:=temp;
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

quit;

:do_descr:
if (u.extra.["$pidescr"].descr=="true")
 {
 sendtext ("You have already set this objects description.<br/>",self);
 i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

 quit;
 }

sendtext ("Enter item descr.  type '@' to end descr<br/>",self);
   beginedit(self);
   wait(SFB_EDIT, self == activator);
   temp := argument;
   if (length(getwords(temp)) < 1)
   {
      sendtext("Insufficient description.  Exiting.<br/>", self);
      i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

      quit;
   }
/*temp:=replace ("&h","",temp);*/
temp:=textformat(temp);
tmp:=self.prompt;
sendtext (textformat(temp),self);
      i:=dildestroy("send_prompt@update",self);
self.prompt:="Is this the description you want? ([Q]uit, [Y]es, or (N)o ";
dilcopy ("send_prompt@update",self);

wait (SFB_CMD,self==activator);
self.prompt:=tmp;
if (excmdstr==left("quit",length(excmdstr)))
 {
block;
 sendtext ("Command Canceled.<br/>",self);
 i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

 quit;
 }
else if (excmdstr==left("yes",length(excmdstr)))
{
block;
 goto cont_descr;
 }

block;
tmp:=self.prompt;
sendtext("Enter a new description:  <br/>",self);
goto do_descr;

:cont_descr:
addextra (u.extra,null,textformat (temp));
addextra (u.extra,{"$pidescr"},"true");
 sendtext("Description set.<br/>",self);
 i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

quit;

:lostu:
i:=dildestroy("send_prompt@update",self);
dilcopy ("send_prompt@update",self);

quit;
}
dilend



dilbegin cmd_clear(arg:string);
code
{
if (arg=="tell")
{
subextra(self.extra,self.extra.["$tell_history"].names.[0]);
sendtext ("Clearing tell history",self);
}
else
sendtext ("",self);
return ;

}
dilend


dilbegin stringlist shell(s:stringlist);
var
   ln:integer;
   imax:integer;
   i:integer;
   iVal:string;
   inc:integer;
   j:integer;
code
{
   iMax:=length(s);
   inc:=0;

   while (inc < iMax)
      inc := inc *3+1;

inc:=inc/3;
while(inc > 0)
 {
 i:=inc;
 while (i < iMax)
  {
  iVal := s.[i];
  j:=i;
  while(j > (inc-1))
   {
   if(iVal < s.[j - inc])
    {
    s.[j] := s.[j - inc];
    }
   else
    break;
   j:=j-inc;
   }
  s.[j] := iVal;
  i:=i+1;
  }
 inc := inc /3;
 }

return (s);
}
dilend

dilbegin comm_dil(arg : string);
external
 stringlist shell (s:stringlist);
var
 newlist:stringlist;
 istart:integer;
  cmd : cmdptr;
  i : integer;
 cmdlist:stringlist;
 imax:integer;
 ln:integer;
 buff:string;
code
{
   istart:=0;

   cmd := chead();
   while (cmd)
   {
      if ((cmd.level<=self.level) and
         (cmd.type!=TYPE_SOCIAL) and
         (cmd.type!=TYPE_SKILL))
          addstring (cmdlist,cmd.name);
      cmd := cmd.next;
   }

   newlist:=shell(cmdlist);
   i:=0;
   buff:="<u>The following commands are available:</u><br/>";
   iMax:=length(newlist);

   buff := buff + "<div class='fourcol'>";
   while (i<iMax)
   {
      buff:=buff+newlist.[i] + "<br/>";
      i:=i+1;
   } /* end while */
 
   buff :=buff+"</div>";

   pagestring (buff,self);
   quit;
}
dilend


dilbegin soc_dil(arg : string);
external
 stringlist shell (s:stringlist);
var
 buff:string;
newlist:stringlist;
  cmd : cmdptr;
  i : integer;
 ln:integer;
 cmdlist:stringlist;
 imax:integer;
code
{
   cmd := chead();
 while (cmd)
 {
 if ((cmd.level<=self.level) and
 (cmd.type==TYPE_SOCIAL))
 addstring (cmdlist,cmd.name);
 cmd := cmd.next;
 }

   newlist:=shell(cmdlist);
   i:=0;
   buff:="<u>The following socials are available:</u><br/><div class='fourcol'>";
   iMax:=length (newlist);
   while (i<iMax)
   {
      buff:=buff+newlist.[i] + "<br/>";
      i:=i+1;
   }
   buff:=buff + "</div>";

   pagestring (buff,self);
   quit;
}
dilend

dilbegin ski_dil(arg : string);
external
   stringlist shell(s:stringlist);
var
   buff:string;
   newlist:stringlist;
   cmd : cmdptr;
   i : integer;
   ln:integer;
   cmdlist:stringlist;
   imax:integer;

code
{
   cmd := chead();
   while (cmd)
   {
      if ((cmd.level<=self.level) and (cmd.type==TYPE_SKILL))
         addstring(cmdlist,cmd.name);
      cmd := cmd.next;
   }

   addstring(cmdlist,"dual wield");
   addstring(cmdlist,"shield");
   addstring(cmdlist,"climb");
   addstring(cmdlist,"leadership");

   newlist:=shell(cmdlist);

   i:=0;
   buff:="<u>The following skills are available:</u><br/><div class='fourcol'>";
   iMax:=length(newlist);
   while (i<iMax)
   {
      buff:=buff+newlist.[i]+"<br/>";
      i := i + 1;
   }
   buff:=buff+"</div>";

   pagestring (buff,self);
   quit;
}
dilend

dilbegin wizhelp(arg : string);
external
 stringlist shell (s:stringlist);
var
 buff:string;
newlist:stringlist;
  cmd : cmdptr;
  i : integer;
 ln:integer;
 cmdlist:stringlist;
 imax:integer;
code
{
   cmd := chead();
 while (cmd)
 {
 if ((cmd.level<=self.level) and
 (cmd.level>=200) and
 (cmd.type!=TYPE_SOCIAL))
 addstring (cmdlist,cmd.name+"<"+itoa(cmd.level)+">");
 cmd := cmd.next;
 }

   newlist:=shell(cmdlist);
   i:=0;
   buff:="<u>The following Admin commands are available:</u><br/><div class='fourcol'>";
   iMax:=length (newlist);
   while (i<iMax)
   {
      buff:=buff+newlist.[i]+"<br/>";
      i:=i+1;
   }
   buff:=buff+"</div>";
   pagestring (buff,self);
   quit;
}
dilend



dilbegin wizsoc(arg : string);
external
 stringlist shell (s:stringlist);
var
 buff:string;
newlist:stringlist;
  cmd : cmdptr;
  i : integer;
 ln:integer;
 cmdlist:stringlist;
 imax:integer;
code
{
   cmd := chead();
 while (cmd)
 {
 if ((cmd.level<=self.level) and
 (cmd.level>=200) and
 (cmd.type==TYPE_SOCIAL))
 addstring (cmdlist,cmd.name+"<"+itoa(cmd.level)+">");
 cmd := cmd.next;
 }

   newlist:=shell(cmdlist);
   i:=0;
   buff:="<u>The following Admin socials are available:</u><br/><div class='fourcol'>";
   iMax:=length (newlist);
   while (i<iMax)
   {
      buff:=buff+newlist.[i]+"<br/>";
   i:=i+1;
   }
   buff:=buff+"</div>";
   pagestring (buff,self);
   quit;
}
dilend




dilbegin aware cmd_bugs(st : string);
var
   t : string;
   z : unitptr;
   i : integer;
code
{
if (self.type!=UNIT_ST_PC)
 return;
   sendtext("Enter your bug reports. You have approximately 4000 "+
            "characters to work with. Note that if you input only a "+
            "single word or nothing at all, it will abort.<br/>", self);
   beginedit(self);
   wait(SFB_EDIT, self == activator);
   t := argument;
   if (length(getwords(t)) < 2)
   {
      sendtext("Insufficient report. Exiting.<br/>", self);
      quit;
   }
   z := self.outside;
   while (z.type != UNIT_ST_ROOM)
      z := z.outside;
   t := z.nameidx+"@"+z.zoneidx+" ["+self.name+"] "+asctime(realtime)+
        argument+"<br/><br/>";
   t := textformat(t);
   i := flog("bugs", t, "a");
   sendtext("Thank you. They will be corrected.<br/>", self);
   quit;
}
dilend


dilbegin aware cmd_ideas(st : string);
var
   t : string;
   z : unitptr;
   i : integer;
code
{
if (self.type!=UNIT_ST_PC)
 return;
   sendtext("Enter your ideas. You have approximately 4000 characters "+
            "to work with. Note that if you input only a single word or "+
            "nothing at all, it will abort.<br/>", self);
   beginedit(self);
   wait(SFB_EDIT, self == activator);
   t := argument;
   if (length(getwords(t)) < 2)
   {
      sendtext("Insufficient report. Exiting.<br/>", self);
      quit;
   }
   z := self.outside;
   while (z.type != UNIT_ST_ROOM)
      z := z.outside;
   t := z.nameidx+"@"+z.zoneidx+" ["+self.name+"] "+asctime(realtime)+
        argument+"<br/><br/>";
   t := textformat(t);
   i := flog("ideas", t, "a");
   sendtext("Thank you for your comments.<br/>", self);
   quit;
}
dilend

dilbegin aware cmd_typos(st : string);
var
   t : string;
   z : unitptr;
   i : integer;
code
{
if (self.type!=UNIT_ST_PC)
 return;
   sendtext("Enter your typo reports. You have approximately 4000 "+
            "characters to work with. Note that if you input only a "+
            "single word or nothing at all, it will abort.<br/>", self);
   beginedit(self);
   wait(SFB_EDIT, self == activator);
   t := argument;
   if (length(getwords(t)) < 2)
   {
      sendtext("Insufficient report. Exiting.<br/>", self);
      quit;
   }
   z := self.outside;
   while (z.type != UNIT_ST_ROOM)
      z := z.outside;
   t := z.nameidx+"@"+z.zoneidx+" ["+self.name+"] "+asctime(realtime)+
        argument+"<br/><br/>";
   t := textformat(t);
   i := flog("typos", t, "a");
   sendtext("Thank you. They will be corrected.<br/>", self);
   quit;
}
dilend


dilbegin string alignstring();
code
{
   if (self.alignment < -349)
      return("Evil");
   else if (self.alignment > 349)
      return("Good");
   else
      return("Neutral");
}
dilend

dilbegin string genderstring();
code
{
   if (self.sex == SEX_MALE)
      return("male");
   else if (self.sex == SEX_FEMALE)
      return("female");
   else
      return("neuter");
}
dilend

dilbegin string couragestring();
code
{
   if (isset(self.charflags, CHAR_WIMPY))
      return("wimpy");
   else
      return("brave");
}
dilend

dilbegin string agestring(rce : integer);
external
   string genderstring();
   string racestring(rce : integer);

code
{
   return("You are a " + itoa((realtime - self.birth) / SECS_PER_MUD_YEAR) +
          " years old " + genderstring() + " " + racestring(rce) + " at level " + 
          itoa(self.vlevel) + ".<br/>");
}
dilend

dilbegin string titlestring();
external
   string alignstring();
code
{
   return(self.name + " <div class='who_title'>" + self.title + "</div> <div class='score'>(" + alignstring() + " alignment (" + itoa(self.alignment) + "))</div><br/>");
}
dilend

dilbegin string playingstring();
var
   tf:integer;
   tmp_played:integer;
   hours_played : integer;
   days_played  : integer;
   years_played  : integer;
   time_str:string;

code
{
   tmp_played:=0;
   tmp_played:= self.playtime / 3600;
   hours_played:= tmp_played % 24;
   days_played:=((tmp_played/24)%365);
   years_played:=((tmp_played/24)/365);

   tf:=FALSE;
   time_str:="You have been playing for";

   if (years_played >0)
   {
      time_str:=time_str+" "+ itoa(years_played)+" years";
      tf:=TRUE;
   }

   if ((days_played>0) and (tf==TRUE))
   {
      time_str:=time_str+", "+itoa(days_played)+" days";
   }
   else if (days_played>0)
   {
      time_str:=time_str+" "+itoa(days_played)+" days";
      tf:=TRUE;
   }

   if ((hours_played>0) and (tf==TRUE))
   {
      time_str:=time_str+", "+itoa(hours_played)+" hours";
   }
   else if (hours_played>0)
   {
      time_str:=time_str+", and "+itoa(hours_played)+" hours";
      tf:=TRUE;
   }

   if (tf!=TRUE)
      time_str:=time_str+" Less than an hour.<br/>";
   else
      time_str:=time_str+".<br/>";

   return(time_str);
}
dilend


/* do_status */
dilbegin cmd_stat(arg:string);
external
   path_update@guild_paths(u : unitptr);
   string wpn_rating (wpn:integer);
   string ski_rating (ski:integer);
   string sp_rating (sp:integer);
   string titlestring();
   string couragestring();

var
   remain:integer;
   remain_str:string;
   skilist:stringlist;
   wpnlist:stringlist;
   total_hours  : integer;

   last_lev     : integer;
   gl1          : integer;
   gl2          : integer;
   gl3          : integer;

   data_list    : stringlist;

   guild1       : string;
   guild2       : string;
   guild3       : string;
   desc         : string;

   prof_string  : string;
   guild_string : string;

   expd         : extraptr;

   ln1:string;
   ln2:string;
   temp:string;
   buff:string;
   maglist:stringlist;
   divlist:stringlist;
   realm:integer;
   waist:integer;
   waist1:integer;
   waist2:integer;
   waist3:integer;
   waist4:integer;
   waist5:integer;
   waist6:integer;
   i:integer;
   ln:integer;
   len:integer;
   endcost:integer;

code
{
   if (self.type!=UNIT_ST_PC)
      quit;

   if (arg=="")
      goto start;
   if (arg==left("weapons",length(arg)))
      goto wpn_stat;
   if (arg==left("skills",length(arg)))
      goto ski_stat;
   if (arg==left("spells",length(arg)))
      goto sp_stat;

   :start:
   if ((self.type == UNIT_ST_PC) and (self.level < IMMORTAL_LEVEL))
   {
      if(self.endurance < endcost)
      {
         act("You are too exhausted.", A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
      else
         self.endurance:= self.endurance - endcost;
      position_update (self);
   }

   if ("$morphed" in self.extra)
      goto morphed;

   expd := "$path" in self.quests;

   if (expd == null)
   {
      guild_string := "Contact they Mayor of Midgaard to set your Guild Paths.<br/>";
      goto cont;
   }

   if (self.vlevel <= atoi(expd.names.[7]))
      goto keep_on;

   path_update@guild_paths(self);

   :keep_on:
   expd := "$path" in self.quests;
   if (expd == null) quit;
   guild_string := "Your guild path is: " +
   expd.names.[1] + " / " + expd.names.[2] + " / " + expd.names.[3] +
   ".<br/>Your guild path levels are: " + expd.names.[4] + " / " +
   expd.names.[5] + " / " + expd.names.[6] + ".<br/>";

   :cont:
   if ((self.profession >= 0) and (self.profession < PROFESSION_MAX))
   {
      data_list := { PROFESSION_STRINGS };
      prof_string := "Your profession is: " + data_list.[self.profession] +  "<br/>";

   }
   else
      prof_string := "Your profession is undefined, please visit father Nicholas in the Udgaard temple healer room.<br/>";

   /* MS2020 ???  remain:=self.level*40;
   if (remain >2000)
      remain:=0;
   else
      remain:=2000-remain;

	if ((remain==0) and (self.ability_points==0))
      remain_str:="";
   else if (remain==0)
      remain_str:="You have "+itoa(self.ability_points)+" ability points left.<br/>";
   else*/

   remain_str:="You have " +itoa(self.skill_points)+" remaining skill points and "+ itoa(self.ability_points) + " ability points available.<br/>";
   
  act(titlestring()+
       guild_string + prof_string +
       "Str " + itoa(self.abilities[ABIL_STR]) + ", " +
       "Dex " + itoa(self.abilities[ABIL_DEX]) + ", " +
       "Con " + itoa(self.abilities[ABIL_CON]) + ", " +
       "Cha " + itoa(self.abilities[ABIL_CHA]) + ", " +
       "Bra " + itoa(self.abilities[ABIL_BRA]) + ", " +
       "Mag " + itoa(self.abilities[ABIL_MAG]) + ", " +
       "Div " + itoa(self.abilities[ABIL_DIV]) + ", " +
       "Hit " + itoa(self.abilities[ABIL_HP]) + " (" +
       itoa(self.hp) + "/" + itoa(self.max_hp) + ")" +
       "<br/>" +
       "Your combat Dexterity is " + itoa(getinteger(DIL_GINT_EFFDEX, self, 0)) + " as a result of your armor.<br/>"+
       remain_str+
       "You have " + itoa(self.skill_points) + " skill practice points.<br/>" +
       "You are in " + couragestring() + " mode.<br/>"+
       "More: '<a cmd='#'>status skills</a>', '<a cmd='#'>status weapons</a>' and '<a cmd='#'>status spells</a>'."
       , A_ALWAYS, self, null, null, TO_CHAR);
   quit;


:morphed:
   act(titlestring()+
       "Str " + itoa(self.abilities[ABIL_STR]) + ", " +
       "Dex " + itoa(self.abilities[ABIL_DEX]) + ", " +
       "Con " + itoa(self.abilities[ABIL_CON]) + ", " +
       "Cha " + itoa(self.abilities[ABIL_CHA]) + ", " +
       "Bra " + itoa(self.abilities[ABIL_BRA]) + ", " +
       "Mag " + itoa(self.abilities[ABIL_MAG]) + ", " +
       "Div " + itoa(self.abilities[ABIL_DIV]) +
       "<br/>" +
       "You are in " + couragestring() + " mode.",
       A_ALWAYS, self, null, null, TO_CHAR);

   quit;

   :imm:
   :wpn_stat:
   i:=7;
   buff:="";
   ln1:="";
   ln2:="";
   wpnlist:=null;

   while (weapon_name(i)!=null)
   {
      if ((self.weapons[i]<=0) or (weapon_name(i) == ""))
      {
         i:=i+1;
         continue;
      }

      ln1 := weapon_name(i) + " (" + wpn_rating(self.weapons[i]) + ")";
      addstring (wpnlist, itoa(self.weapons[i]) + "% " + ln1);
      i:=i+1;
   }

   len:=length (wpnlist);
   if (len<=0)
   {
      sendtext ("You are not skilled in any weapons.<br/>",self);
      quit;
   }

   buff:=buff+"<div class='twocol'>";
   i:=0;
   while (i<len)
   {
      buff := buff + wpnlist.[i] + "<br/>";
      i:=i+1;
   }
   buff:=buff+"</div>";
   pagestring(buff,self);
   quit;


:sp_stat:
i:=12;
realm:=0;
buff:="";
divlist:=null;
maglist:=null;
ln1:="";
ln2:="";
while (i<=LAST_SPELL)
 {
 if (self.spells[i]<=0)
  {
  i:=i+1;
  continue;
  }

 ln1:=spellinfo(i,realm,waist,waist1,waist2,waist3,waist4,waist5) + " (" + sp_rating(self.spells[i]) + ")";
 if (realm==ABIL_MAG)
  addstring(maglist, itoa(self.spells[i]) + "% " + ln1);
 else
  addstring(divlist, itoa(self.spells[i]) + "% " + ln1);
 i:=i+1;
 }

len:=length(maglist);
i:=length(divlist);
if ((i==0) and (len==0))
 {
 sendtext("You're not skilled in any spells.<br/>",self);
 quit;
 }

if (len==0)
 goto div_sp;
i:=0;

buff:=buff+"<u>Spells known through your magic essence mastery:</u><br/><div class='twocol'>";
while (i<len)
{
   buff := buff + maglist.[i] + "<br/>"; 
   i:=i+1;
 }
 buff:=buff+"</div>";

:div_sp:
len:=length(divlist);
if (len==0)
 goto end_sp;

buff:=buff+"<u>Spells known through your divine channeling powers:</u><br/>";
buff:=buff+"<div class='twocol'>";

i:=0;
while (i<len)
{
   buff := buff + divlist.[i] + "<br/>";
   i:=i+1;
}

:end_sp:

pagestring(buff,self);
quit;


   :ski_stat:
   i:=0;
   buff:="";
   ln1:="";
   ln2:="";
   skilist:=null;
   while (skill_name(i)!="")
   {
      if (self.skills[i]<=0)
      {
         i:=i+1;
         continue;
      }

      ln1:= skill_name(i) + " (" + ski_rating(self.skills[i]) + ")";
      addstring (skilist,itoa(self.skills[i]) + "% " + ln1);
      i:=i+1;
   }
   len:=length(skilist);
   if (len==0)
   {
      sendtext ("You have no special skills.<br/>",self);
      quit;
   }

   buff:=buff+"<div class='twocol'>";

   i:=0;
   while (i<len)
   {
      buff := buff + skilist.[i] + "<br/>";
      i:=i+1;
   }
   buff:=buff+"</div>";
   pagestring(buff,self);

   :end:
   quit;
}
dilend



dilbegin string racestring (i:integer);
code
{
   if (i == RACE_HUMAN)
      return("human");
   else if (i == RACE_ELF)
      return("elf");
   else if (i == RACE_DWARF)
      return("dwarf");
   else if (i == RACE_HALFLING)
      return("halfling");
   else if (i == RACE_GNOME)
      return("gnome");
   else if (i == RACE_HALF_ORC)
      return("half-orc");
   else if (i == RACE_HALF_OGRE)
      return("half-ogre");
   else if (i == RACE_HALF_ELF)
      return("half-elf");
   else if (i == RACE_BROWNIE)
      return("brownie");
   else if (i == RACE_GROLL)
      return("groll");
   else if (i == RACE_DARK_ELF)
      return("darkelf");
   else if (i==RACE_GIANT)
      return("giant");
   else if (i == RACE_BIRD)
      return ("phoenix");
   else if (i== RACE_SNAKE)
      return ("viper");
   else if (i == RACE_VAMPIRE)
      return ("vampire");
   else if (i == RACE_DRAGON_RED)
      return ("red dragon");
   else if (i == RACE_ELEMENTAL_FROST)
      return ("ice elemental");
   else if (i == RACE_LION)
      return("lion");
   else if (i == RACE_SHADOW_DEVIL)
      return ("shadow demon");
   else if (i == RACE_CAT)
      return ("black panther");
   else if (i == RACE_DINOSAUR)
      return ("basilisk");

   return ("Not A Race");
}
dilend


dilbegin string wpn_rating (wpn:integer);
code
{
if (wpn<10)
 return ("utterly hopeless");
else if (wpn<25)
 return ("impossible");
else if (wpn<40)
 return ("poor");
else  if (wpn<50)
 return ("good");
else if (wpn<70)
 return("skilled");
else if (wpn<90)
 return ("specialized");
else if (wpn < 100)
 return ("supreme");
else if (wpn<150)
 return ("expert");
else
 return ("godly");

}
dilend

dilbegin string ski_rating (ski:integer);
code
{
if (ski<10)
 return("utterly hopeless");
else if (ski<25)
  return("impossible");
else if (ski<40)
  return("poor");
else if (ski<50)
  return("good");
else if (ski<70)
  return("skilled");
else if (ski<90)
  return("specialized");
else if (ski<100)
  return("supreme");
else if (ski<150)
  return("expert");
else
  return("godly");

}
dilend

dilbegin string sp_rating (sp:integer);
code
{
if (sp<=10)
 return ("might remember");
else if (sp<=25)
  return ("almost remember");
else if (sp<=40)
  return ("remember");
else if (sp<=50)
  return ("practiced");
else if (sp<=70)
  return ("learned");
else  if (sp<=90)
  return ("master");
else if (sp<=100)
  return ("expert");
else
  return ("godly");

}dilend

/* Following dil put in by Eirinn to circumvent status_dil problem */
dilbegin aware cmd_interpreter(); /* Dil command interpreter. Ideally this
will
                                    work like skills.def but without over-
                                    ruling it. */
code
{
quit;
}
dilend /* cmd_interpreter */

dilbegin petrify (arg : string);

var
   pc        : unitptr;
   tempu     : unitptr;
   tempu2    : unitptr;
   i         : integer;

   expd      : extraptr;

code
{
if (self.level<200)
 {
 sendtext ("You do not have access to that command.",self);
 quit;
 }

   if (arg == "")
   {
      act("Petrify what?",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   pc := findunit(self, arg, FIND_UNIT_GLOBAL, null);

   if ((pc == null) or (not(visible(self, pc))))
   {
      act("No such person in the world right now.", A_ALWAYS, self, null,
null, TO_CHAR);
      quit;
   }

   if (pc.level >= self.level)
   {
      act("I doubt $2e'd see the joke...",A_ALWAYS, self, pc, null,
TO_CHAR);
      quit;
   }

   if (pc.type == UNIT_ST_OBJ)
   {
      act("Why petrify that? It's already inanimate...", A_ALWAYS, self, pc,
null, TO_CHAR);
      quit;
   }

   if (pc.type == UNIT_ST_NPC)
   {
      if ("$petrified" in pc.extra)
      {
      tempu := findunit(self, "statue_" + pc.nameidx, FIND_UNIT_GLOBAL,
null);

      if (tempu != null)
      {
         expd := "$petrified" in pc.extra;
         tempu2 := load(expd.descr);
         link (tempu2, tempu.outside);
      }

      act("You are returned to flesh...", A_ALWAYS, self, null, pc,
TO_VICT);
      act("$3n's statue returns to flesh...",  A_SOMEONE, self, null, pc,
TO_NOTVICT);
      act("You return $2n to flesh.", A_ALWAYS, self, pc, null, TO_CHAR);

      tempu := findunit(self, "statue_" + pc.nameidx, FIND_UNIT_GLOBAL,
null);
      destroy(tempu);
      subextra(pc.extra, "$petrified");
      exec("look", pc);
      quit;
      }

      else
      {
         tempu := load("petrify_statue@commands");

         link(tempu, pc.outside);
         addstring(tempu.names, "statue_" + pc.nameidx);

         tempu.outside_descr := "A statue of " + pc.name + " stands here, "
+
                                "outside of time.";
         addstring(tempu.names, "statue of " + pc.title);
         addstring(tempu.names, "statue");
         tempu.title := "statue of " + pc.name;

         act("You are turned to stone by $1n's gaze...", A_ALWAYS, self,
null, pc, TO_VICT);
         act("You gaze into $3n's eyes and $3n turns to stone...", A_ALWAYS,
self, null, pc, TO_CHAR);
         act("$1n gazes into $3n's eyes and $3n turns to stone...",A_SOMEONE, self, null, pc, TO_NOTVICT);
         destroy(pc);

         quit;
      }
   }

   if ("$petrified" in pc.extra)
   {
      tempu := findunit(self, "statue_" + pc.name, FIND_UNIT_GLOBAL, null);

      if (tempu != null)
      {
         link (pc, tempu.outside);
         while (pc.outside.type != UNIT_ST_ROOM)
            link (pc, pc.outside.outside);
      }
      else
      {
         expd := "$petrified" in pc.extra;
         link (pc, findroom(expd.descr));
      }

      pc.minv := 0;
      i := dildestroy("petrified@commands", pc);

      act("You are returned to flesh...",A_ALWAYS, self, null, pc, TO_VICT);
      act("$3n's statue returns to flesh...",A_SOMEONE, self, null, pc,
TO_NOTVICT);
      act("You return $2n to flesh.",
          A_ALWAYS, self, pc, null, TO_CHAR);

      tempu := findunit(self, "statue_" + pc.name, FIND_UNIT_GLOBAL, null);
      destroy(tempu);
      subextra(pc.extra, "$petrified");
      exec("look", pc);
      quit;
   }

   if (isset(pc.pcflags, PC_SPIRIT))
   {
      act("$2n is dead right now. Wait until $2e comes back to life.",A_ALWAYS, self, pc, null, TO_CHAR);
      quit;
   }

   tempu := load("petrify_statue@commands");

   link(tempu, pc.outside);
   addstring(tempu.names, "statue_" + pc.name);

   tempu.outside_descr := "A statue of " + pc.name + " stands here, " +
                          "outside of time.";
   addstring(tempu.names, "statue of " + pc.name);
   addstring(tempu.names, "statue");
   tempu.title := "statue of " + pc.name;

   dilcopy("petrified@commands", pc);
   pc.minv := 220;

addextra(pc.extra,{"$petrified"},pc.outside.nameidx+"@"+pc.outside.zoneidx);
   link(pc, findroom("hold_room@commands"));

   act("You are turned to stone by $1n's gaze...", A_ALWAYS, self, null, pc,
TO_VICT);
   act("You gaze into $3n's eyes and $3n turns to stone...",A_ALWAYS, self,
null, pc, TO_CHAR);
   act("$1n gazes into $3n's eyes and $3n turns to stone...",A_SOMEONE,
self, null, pc, TO_NOTVICT);

   log(self.name + " turned " + pc.name + " to stone.");

   quit;
}
dilend /* petrify */


dilbegin gtitle (arg:string);
var
 pname:string;
 pc:unitptr;
code
{
if (self.level<200)
 {
 sendtext ("You don't have access tot he 'title' command.<br/>",self);
 quit;
 }

pname:=getword(arg);

pc:=findunit(self,pname,FIND_UNIT_WORLD,null);
if (pc==null)
 {
 sendtext("No such person found.<br/>", self);
 quit;
 }

if ((pc.type!=UNIT_ST_PC) or
(not(visible(self,pc))))
 {
 sendtext("No such person found.<br/>", self);
 quit;
 }

log (self.name+" set "+pc.name+"'s  title to "+arg);
arg:=arg+"</div>";
arg:=textformat(arg);
pc.title:=arg;
sendtext ("You set "+pc.name+"'s title to '"+arg+"'",self);
quit;
}
dilend

dilbegin aware describe (arg:string);
var
 side:string;
oneword:stringlist;
 location:string;
 ln:integer;
 args:stringlist;
 temp:string;
 i:integer;
 x:extraptr;
code
{

if (self.type!=UNIT_ST_PC)
 quit;
if (self.position <POSITION_SLEEPING)
{
act ("Recover first and then you can describe your body parts.",A_ALWAYS,self,null,null,TO_CHAR);
quit;
}

args:=getwords(arg);
ln:=length(args);
if ((ln<1) or (ln>2))
 {
 sendtext ("No such location to describe.",self);
 quit;
 }
 else if (ln>1)
  goto two_word;

:one_word:
if ((arg==left("help",length(arg))) or
(arg==""))
goto hlp_dscr;
oneword:={"arms","butt","ears","eyes","face","feet","General","chest","hair","hands",
"head","legs","mouth","back","neck","nose","nostrils","teeth","toes","tongue"};

i:=0;
ln:=length(args.[0]);
temp:="ERROR";
while (i<18)
 {
 if (args.[0]==left(oneword.[i],ln))
  {
  temp:=oneword.[i];
  break;
  }
 i:=i+1;
 }

if (temp=="ERROR")
 {
 sendtext ("No such location to describe.",self);
 quit;
 }

goto describe;

:two_word:
oneword:={"arm","leg","foot","hand","eye","ear"};
temp:="ERROR";
ln:=length(args.[0]);
if (args.[0] == left("left",ln))
 side:="left";
else if (args.[0] == left("right",ln))
 side:="right";
else
 {
 sendtext ("No such location to describe.",self);
 quit;
 }

i:=0;
while (i<6)
 {
 if (args.[1]==left(oneword.[i],ln))
  {
  temp:=oneword.[i];
  break;
  }
 i:=i+1;
 }

if (temp=="ERROR")
 {
 sendtext ("No such location to describe.",self);
 quit;
 }

temp:=side+" "+temp;

:describe:
if (temp=="General")
 location:="";
else
 location:=temp;

x:=location in self.extra;
if (x!=null)
 if (location=="")
 sendtext("your Current description for your body is:<br/>"+x.descr+"<br/>",self);
else
  sendtext("your Current description for your "+location+" is:<br/>"+x.descr+"<br/>",self);


 if (location=="")
 sendtext ("Enter a text you would like others to see when they look at your body.<br/>",self);
else
 sendtext ("Enter a text you would like others to see when they look at your"+location+".<br/>",self);

 beginedit (self);
 wait(SFB_EDIT,self==activator) ;
temp:=textformat(argument);
oneword:=null;
subextra(self.extra,location);
addstring (oneword, location);
addextra (self.extra,oneword,temp);
sendtext ("Description added.<br/>",self);
quit;
:hlp_dscr:

sendtext ("<br/>Correct usage of 'describe':<br/><br/>",self);
sendtext ("describe <position><br/><br/>",self);
sendtext("<position> being one of the following:<br/><br/>",self);
sendtext( "arms        butt        ears        eyes<br/>"+
     "face        feet        General     hair<br/>"+
     "hands      head        left arm    left leg<br/>"+
     "left foot   left hand   left eye    left ear<br/>"+
     "legs        mouth       neck        nose<br/>"+
     "nostrils    right arm   right leg   right foot<br/>"+
     "right hand  right eye   right ear   teeth<br/>"+
     "toes        tongue      back        chest<br/><br/>",self);
sendtext ("Example:  <br/><br/>",self);
sendtext ("describe left leg<br/>",self);
quit;
}
dilend


dilbegin aware petrified();

code
{
   heartbeat := PULSE_SEC * 600;
   interrupt(SFB_TICK, TRUE, food);
:start:
   wait(SFB_CMD, activator == self);

   block;
   act("You are stone. You cannot do anything.",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto start;

:food:
   self.thirst := 25;
   self.full   := 25;
   goto start;
}
dilend /* petrified */
dilbegin apply_poison (pc:unitptr,pois:integer,amount:integer);
code
{

if ((pois>0) and (pc.level<200))
 {
 act("Oops, it tasted rather strange ?!!?",
 A_SOMEONE, pc, null, null, TO_CHAR);
 act("$1n chokes and utters some strange sounds.",
  A_HIDEINV, pc, null, null, TO_REST);

  dilcopy("spl_poison@spells("+itoa(amount*pois)+")", pc);
 }


 return;
 }
 dilend

dilbegin integer dv(d_obj:unitptr,s:string);
var
 x:extraptr;
code
{
if (s=="thirst")
 {
 x:="$drink_thirst" in d_obj.extra;
 if (x==null)
  return (0);
 else if (x.descr=="")
  return (0);
 else
  return (atoi(x.descr));
 }
else if (s=="full")
 {
 x:="$drink_full" in d_obj.extra;
 if (x==null)
  return (0);
 else if (x.descr=="")
  return (0);
 else
  return (atoi(x.descr));
 }
else if (s=="drunk")
 {
 x:="$drink_drunk" in d_obj.extra;
 if (x==null)
  return (0);
 else if (x.descr=="")
  return (0);
 else
  return (atoi(x.descr));
 }

return (0);
}
dilend

dilbegin gain_cond(pc:unitptr,cond:string, i:integer);
var
 dr:integer;/*drunk*/
code
{
dr:=pc.drunk;

if (pc.type!=UNIT_ST_PC)
 return;
if ((cond=="thirst") and (pc.thirst>=48))
 return;
else if (cond=="thirst")
 {
 pc.thirst:=pc.thirst+i;
 if (pc.thirst>24)
  pc.thirst:=24;
 if (pc.thirst<-96)
   pc.thirst:=-96;
 if (pc.thirst>3)
  return;
 if (pc.thirst>-4)
  sendtext("You are thirsty.<br/>",pc);
 else if (pc.thirst>-8)
  sendtext("You are very thirsty.<br/>",pc);
 else if (pc.thirst>-12)
  sendtext("You are dehydrated.<br/>",pc);
 }
else if ((cond=="full") and (pc.full>=48))
 return;
else if (cond=="full")
 {
 pc.full:=pc.full+i;
 if (pc.full>24)
  pc.full:=24;
  if (pc.full<-96)
   pc.full:=-96;
 if (pc.full>3)
  return;
 if (pc.full>-4)
 sendtext("You are hungry.<br/>",pc);
 else if (pc.full>-8)
 sendtext("You are very hungry.<br/>",pc);
 else if (pc.full>-12)
 sendtext("You are starving.<br/>",pc);
 }
else if ((cond=="drunk") and (pc.drunk>=48))
 return;
else if (cond=="drunk")
 {
 pc.drunk:=pc.drunk+i;
 if ((pc.drunk<dr) and (pc.drunk==0))
  sendtext ("You sober up!<br/>",pc);
 if (pc.drunk>24)
  pc.drunk:=24;
  if (pc.drunk<0)
   pc.drunk:=0;/*you can't get any more sober than this*/
   if (pc.drunk>11)
    sendtext ("You are seeing double!<br/>",pc);
 else if (pc.drunk>7)
  sendtext("You are feeling very light headed.<br/>",pc);
 else if (pc.drunk>3)
  sendtext ("You are getting tipsy.",pc);
 }

return;
}
dilend

dilbegin sub_drink_info(d_obj:unitptr);
var
 x:extraptr;
code
{
 setweight(d_obj,d_obj.weight+(-(d_obj.value[0])));
 d_obj.value[0]:=0;
 d_obj.value[3]:=0;
 substring (d_obj.names,d_obj.names.[length (d_obj.names)-1]);
 subextra (d_obj.extra,"$drink_color");
 subextra (d_obj.extra,"$drink_thirst");
 subextra (d_obj.extra,"$drink_full");
 subextra (d_obj.extra,"$drink_drunk");
 return ;
 }
 dilend


dilbegin do_drink(arg:string);
external
   sub_drink_info (u:unitptr);
   apply_poison (pc:unitptr,pois:integer,amount:integer);
   gain_cond(pc:unitptr,cond:string,i:integer);
   integer dv (d_obj:unitptr,s:string);

var
   d_obj:unitptr;
   amount:integer;
   i:integer;
   pois:integer;

code
{
   if (arg=="")
   {
      sendtext("What do you want to drink?<br/>", self);
      quit;
   }

   d_obj:=findunit(self,arg,FIND_UNIT_HERE,null);
   if (d_obj==null)
   {
      act("You can't find it!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if ((d_obj.type!=UNIT_ST_OBJ) or (d_obj.objecttype!=ITEM_DRINKCON))
   {
      act("You can not drink from that.", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (d_obj.value[0]<-1)
   {
      act ("Drink Container Error report to an admin.",
      A_ALWAYS,self,null,null,TO_CHAR);
      quit;
   }

   if (d_obj.value[0]==-1)
      amount:=rnd(3, 10);
   else if (self.level>=200)
      amount:=10;
   else
      amount:=rnd(3,10);

   if (d_obj.value[0] <amount)
      amount:=d_obj.value[0];

   if (amount < 0) /* Straange... Only value "0" should be negative*/
      amount := 0;

   if (d_obj.value[0]<=0)
   {
      act("The $2N is empty.",
      A_SOMEONE, self, d_obj, null, TO_CHAR);
      quit;
   }

   if (self.level<200)
   {
      if (self.drunk>=24)
      {
         /* The pig is drunk */
         act("You simply fail to reach your mouth!", A_SOMEONE, self, null, null,
         TO_CHAR);
         act("$1n tried to drink but missed $1s mouth!",A_HIDEINV, self, null,
         null, TO_REST);
         quit;
      }

      if (self.thirst>=24)
      {
         /* Stomach full */
         act("Your stomach can't contain anymore!", A_SOMEONE, self, null, null,
         TO_CHAR);
         quit;
      }
   }

   if ((d_obj.value[0]>=0) and (amount >=d_obj.value[0]))
      amount:=d_obj.value[0];

   act("$1n drinks $2n.",
      A_HIDEINV, self, d_obj, d_obj.names.[length(d_obj.names)-1], TO_REST);

   act("You drink $2n.",
      A_SOMEONE, self, d_obj, d_obj.names.[length(d_obj.names)-1] , TO_CHAR);

/* MS2020 - that's so odd? The last name? Why? :)
   act("$1n drinks $3t from $2n.",
      A_HIDEINV, self, d_obj, d_obj.names.[length(d_obj.names)-1], TO_REST);

   act("You drink the $2t.",
      A_SOMEONE, self,d_obj.names.[length(d_obj.names)-1] , null, TO_CHAR);
*/
   i:=dv(d_obj,"drunk");
   gain_cond(self, "drunk",((i*amount)/4));
   i:=dv(d_obj,"full");
   gain_cond(self, "full",((i*amount)/4));
   i:=dv(d_obj,"thirst");
   gain_cond(self, "thirst",((i*amount)/4));
   pois:=d_obj.value[3];
   apply_poison(self,pois,amount);

   if (d_obj.capacity>0)
   {
      /* empty the container, and no longer poison. */
      d_obj.value[0]:=d_obj.value[0]-amount;
      setweight(d_obj, d_obj.weight-amount); /* Subtract amount */
      if (d_obj.value[0]<=0)
      {
         sub_drink_info(d_obj);
      }
   }

   if (self.drunk>10)
      act("You feel drunk.", A_ALWAYS, self, null, null, TO_CHAR);

   if (self.thirst<15)
      act("You still feel thirsty.", A_ALWAYS, self, null, null, TO_CHAR);

   if (self.full<15)
      act("You still feel hungry.", A_ALWAYS, self, null, null, TO_CHAR);
   
   send_done("drink",self,d_obj,null,pois,"",null);
   quit;
}
dilend

dilbegin unitptr find_here(arg:string);
var
 ln:integer;
 count:integer;
 item:unitptr;
 args:stringlist;

code
{
  args:=split(arg,".");
  ln:=length (args);
  if (ln>1)
  {
  	arg:=args.[1];
	count:=atoi(args.[0]);
	}
else
count:=1;

item:=self.inside;
while (item!=null){
if (not(visible(self,item))){

item:=item.next;
continue;
}

if (arg in item.names){
if (count>1){
count:=count-1;
item:=item.next;
continue;
}

return (item);
}

item:=item.next;
}

item:=self.outside.inside;
while (item!=null){
if ((not(visible(self,item))) or
(isset(item.flags,UNIT_FL_BURIED))){
item:=item.next;
continue;
}

 if (arg in item.names){
 if (count>1){
 count:=count-1;
 item:=item.next;
 continue;
 }
 return (item);
 }
 item:=item.next;
}
item:=null;
return (item);
}
dilend

dilbegin do_eat (arg:string);
external
unitptr find_here (s:string);
apply_poison (pc:unitptr,pois:integer,amount:integer);
 gain_cond(pc:unitptr,cond:string,i:integer);
var
 food:unitptr;
 pois:integer;
 amount:integer;
 eat_str:string;
code
{
if (eat_str=="logging on")
quit;
if (arg=="")
 {
 sendtext("What do you want to eat?<br/>",self);
 quit;
 }

food:=find_here(arg);

if (food==null)
 {
 act("You've got no such food.", A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }
else if ((food.type==UNIT_ST_OBJ) and (food.objecttype==ITEM_FOOD) and
(self.level<200))
 {
 if ((self.type==UNIT_ST_PC) and (self.level<200) and (self.full>=24))
  {
  act("You are too full to eat more!",A_SOMEONE, self, null, null, TO_CHAR);
  quit;
  }
 if (food.value[0]<=0)
  {
  act("There is nothing left to eat.", A_SOMEONE, self, food, null,
TO_CHAR);
  quit;
  }

  amount:=food.value[0];

 act("$1n eats $2n.",
 A_HIDEINV, self,   food, null, TO_REST);
 act("You eat $2n.",   A_SOMEONE, self, food, null, TO_CHAR);

gain_cond(self, "full", amount);

pois:=food.value[3];
apply_poison(self,pois,amount);

 food.value[0]:=food.value[0]-amount;
 }
else if ((self.level<200) or (food.type==UNIT_ST_ROOM))
 {
 act("Your stomach refuses to eat that!?!",
  A_SOMEONE, self, null, null, TO_CHAR);
  quit;
  }
else
 {
 act("$1n eats $2n.",  A_HIDEINV, self, food, null, TO_REST);
 act("You eat $2n.",   A_HIDEINV, self, food, null, TO_CHAR);
 }

if (self.level<200)
 {

if (self.drunk>10)
 act("You feel drunk.", A_ALWAYS, self, null, null, TO_CHAR);

if (self.thirst<15)
 act("You still feel thirsty.",  A_ALWAYS, self, null, null, TO_CHAR);

if (self.full<15)
 act("You still feel hungry.",   A_ALWAYS, self, null, null, TO_CHAR);
  }
send_done ("eat",self,food,null,pois,"",null);
eat_str:="logging on";
 destroy (food);
quit;
}
dilend

dilbegin do_sip(arg:string);
external
unitptr find_here (s:string);
 sub_drink_info (u:unitptr);
apply_poison (pc:unitptr,pois:integer,amount:integer);
 gain_cond(pc:unitptr,cond:string,i:integer);
 integer dv (d_obj:unitptr,s:string);
var
i:integer;
pois:integer;
 d_obj:unitptr;
 amount:integer;
code
{
if (arg=="")
 act("What do you want to sip?",
  A_SOMEONE, self, null, null, TO_CHAR);
d_obj:=find_here(arg);

if (d_obj==null)
 {
 act("You can't find it!", A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }

if ((d_obj.type!=UNIT_ST_OBJ) or (d_obj.objecttype!=ITEM_DRINKCON))
 {
 act("You can't sip from that.",
  A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }

amount:=1;
if (d_obj.value[0]<=0)
 {
 act("The $2N is empty.",
  A_SOMEONE, self, d_obj, null, TO_CHAR);
 quit;
 }

if (self.level<200)
 {
 if (self.drunk>=24)
  {
  /* The pig is drunk */
  act("You simply fail to reach your mouth!", A_SOMEONE, self, null, null,
TO_CHAR);
   act("$1n tried to sip but missed $1s mouth!",A_HIDEINV, self, null, null,
TO_REST);
  quit;
  }

 if (self.thirst>=24)
  {
  /* Stomach full */
  act("Your stomach can't contain anymore!", A_SOMEONE, self, null, null,
TO_CHAR);
  quit;
  }
 }

if ((d_obj.value[0]>=0) and (amount >=d_obj.value[0]))
 amount:=d_obj.value[0];

act("$1n sips $3t from $2n.",
 A_HIDEINV, self, d_obj,d_obj.names.[length(d_obj.names)-1], TO_REST);
act("You sip the $2t.",
 A_SOMEONE, self,d_obj.names.[length(d_obj.names)-1] , null, TO_CHAR);

i:=dv(d_obj,"drunk");
gain_cond(self, "drunk",(i*amount)/4);
i:=dv(d_obj,"full");
gain_cond(self, "full",(i*amount)/4);
i:=dv(d_obj,"thirst");
gain_cond(self, "thirst",(i*amount)/4);

pois:=d_obj.value[3];
apply_poison(self,pois,amount);

if (d_obj.capacity>0)
 {
  /* empty the container, and no longer poison. */
 d_obj.value[0]:=d_obj.value[0]-amount;
 setweight(d_obj, d_obj.weight-amount); /* Subtract amount */
 if (d_obj.value[0]<=0)
  {

 sub_drink_info(d_obj);
 }
 }
if (self.drunk>10)
 act("You feel drunk.",
  A_ALWAYS, self, null, null, TO_CHAR);

if (self.thirst<15)
 act("You still feel thirsty.",
  A_ALWAYS, self, null, null, TO_CHAR);

if (self.full<15)
 act("You still feel hungry.",
  A_ALWAYS, self, null, null, TO_CHAR);
quit;
}
dilend

dilbegin do_taste(arg:string);
external
unitptr find_here (s:string);
 sub_drink_info (u:unitptr);
apply_poison (pc:unitptr,pois:integer,amount:integer);
 gain_cond(pc:unitptr,cond:string,i:integer);
 integer dv (d_obj:unitptr,s:string);
var
pois:integer;
 food:unitptr;
 amount:integer;
 i:integer;
code
{
if (arg=="")
 {
 sendtext("What do you want to taste?<br/>",self);
 quit;
 }

food:=find_here(arg);

if (food==null)
 {
 act("You've got no such food.",
 A_SOMEONE, self, null, null, TO_CHAR);
quit;
}

if (food.type!=UNIT_ST_OBJ)
 {
 act("You can't taste from that.",
  A_SOMEONE, self, null, null, TO_CHAR);
  quit;
  }

if ((food.objecttype!=ITEM_FOOD) and (food.objecttype!= ITEM_DRINKCON))
 {
 act("Taste that?!? Your stomach refuses!", A_SOMEONE, self, null, null,
TO_CHAR);
 quit;
 }

 amount:=1;

 if (food.objecttype==ITEM_DRINKCON)
  {
  if (food.value[0]<=0)
   {
   act("The $2N is empty.",
    A_SOMEONE, self, food, null, TO_CHAR);
   quit;
   }

  if (self.level<200)
   {
   if (self.drunk>=24)
    {
    /* The pig is drunk */
    act("You simply fail to reach your mouth!", A_SOMEONE, self, null, null,
TO_CHAR);
    act("$1n tried to sip but missed $1s mouth!",A_HIDEINV, self, null,
null, TO_REST);
    quit;
     }

   if (self.thirst>=24)
    {
    /* Stomach full */
    act("Your stomach can't contain anymore!",A_SOMEONE, self, null, null,
TO_CHAR);
    quit;
    }
   }

  if ((food.value[0]>=0) and (amount >=food.value[0]))
   amount:=food.value[0];

  act("$1n tastes $3t from $2n.", A_HIDEINV, self,
food,food.names.[length(food.names)-1], TO_REST);
  act("You sip the $2t.", A_SOMEONE, self,food.names.[length(food.names)-1]
, null, TO_CHAR);

  i:=dv(food,"drunk");
  gain_cond(self, "drunk",(i*amount)/4);
  i:=dv(food,"full");
  gain_cond(self, "full",(i*amount)/4);
  i:=dv(food,"thirst");
  gain_cond(self, "thirst",(i*amount)/4);
  pois:=food.value[3];
apply_poison(self,pois,amount);
  if (food.capacity>0)
   {
   /* empty the container, and no longer poison. */
 food.value[0]:=food.value[0]-amount;
 setweight(food, food.weight-amount); /* Subtract amount */
 if (food.value[0]<=0)
  {   /* The last bit */
 setweight(food,food.weight+(-(food.value[0])));
 food.value[0]:=0;
  food.value[3]:=0;
  substring (food.names,food.names.[length(food.names)-1]);
  }
 }

 }
else/*food*/
 {
 if ((self.type==UNIT_ST_PC) and (self.level<200) and (self.full>=24))
  {
  act("You are too full to taste more!",
   A_SOMEONE, self, null, null, TO_CHAR);
  quit;
  }
 if (food.value[0]<=0)
  {
  act("There is nothing left to taste.",A_SOMEONE, self, food, null,
TO_CHAR);
  quit;
  }

 if (amount> food.value[0])
  amount:=food.value[0];

 act("$1n tastes $2n.", A_HIDEINV, self, food, null, TO_REST);
 act("You taste $2n.", A_SOMEONE, self, food, null, TO_CHAR);

gain_cond(self, "full", amount);

pois:=food.value[3];
apply_poison(self,pois,amount);

 food.value[0]:=food.value[0]-amount;
 if (food.value[0]<=0)
  destroy (food);
else if ((self.level<200) or (food.type==UNIT_ST_ROOM))
 act("Your stomach refuses to taste that!?!",A_SOMEONE, self, null, null,
TO_CHAR);
else
 {
 act("$1n tastes $2n.", A_HIDEINV, self, food, null, TO_REST);
 act("You taste $2n.", A_HIDEINV, self, food, null, TO_CHAR);
 destroy (food);
  quit;
 }
}


if (self.drunk>10)
 act("You feel drunk.", A_ALWAYS, self, null, null, TO_CHAR);

if (self.thirst<15)
 act("You still feel thirsty.",  A_ALWAYS, self, null, null, TO_CHAR);

if (self.full<15)
 act("You still feel hungry.", A_ALWAYS, self, null, null, TO_CHAR);
quit;
}
dilend



dilbegin do_pour (arg:string);
external
unitptr find_here (s:string);
 sub_drink_info (u:unitptr);
 integer dv (d_obj:unitptr,s:string);
var
 f_obj:unitptr;
 t_obj:unitptr;
 org:string;
 amount:integer;
 tx:extraptr;

 fx:extraptr;
 dx:extraptr;
 cx:extraptr;

  args:stringlist;
  temp:string;


code
{
if (arg=="")
 {
 act("What do you want to pour from?",
  A_SOMEONE, self, null, null, TO_CHAR);
  quit;
  }

                            args:=split(arg," into ");
						    if (length(args)>1)
   goto pour_in;


  args:=split(arg," in ");
  if (length(args)>1)
   goto pour_in;

if (right(arg,3)!="out")
{
 act("Where do you want it? Out or in what?",A_SOMEONE, self, null, null,
TO_CHAR);
 quit;
 }
 
   if ("out"==right(arg,3))
   {
   arg:=left(arg,length(arg)-4);
f_obj:=find_here (arg);
arg:="out";
}
else
                       f_obj:=find_here (arg);

 
if (f_obj==null)
 {
 act("You can't find it!",
  A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }
 
if ((f_obj.type!=UNIT_ST_OBJ) or (f_obj.objecttype!=ITEM_DRINKCON))
 {
 act("You can not pour from that.",A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }

if (f_obj.value[0]<=0)
 {
 act("The $2N is empty.", A_SOMEONE, self, f_obj, null, TO_CHAR);
 quit;
 }

if (arg=="out")
{
 if (f_obj.outside!=self)
  {
  act("You must carry it in order to empty it.", A_SOMEONE, self, null,
null, TO_CHAR);
  quit;
  }

 if (f_obj.capacity==-1)
  {
  act("It is impossible to empty $2n.", A_SOMEONE, self, f_obj, null,
TO_CHAR);
  quit;
  }

 act("$1n empties $2n.",A_HIDEINV, self, f_obj, null, TO_ROOM);
 act("You empty $2n.",A_SOMEONE, self, f_obj, null, TO_CHAR);

 sub_drink_info(f_obj);
send_done ("pour",self,f_obj,self.outside,0,"",null);
 quit;
 }


 :pour_in:
                        f_obj:=find_here (args.[0]);

if (f_obj==null)
 {
 act("You can't find it!",
  A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }

if ((f_obj.type!=UNIT_ST_OBJ) or (f_obj.objecttype!=ITEM_DRINKCON))
 {
 act("You can not pour from that.",A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }

if (f_obj.value[0]<=0)
 {
 act("The $2N is empty.", A_SOMEONE, self, f_obj, null, TO_CHAR);
 quit;
 }
temp:=args.[1];
t_obj:=find_here(args.[1]);
if (t_obj==null)
 {
 act ("You can't find "+temp+" to pour into.", A_ALWAYS,self,null,null,TO_CHAR);
 quit;
 }

if (t_obj==f_obj)
 {
 act("You can't pour it into itself!",A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }

if ((t_obj.type!=UNIT_ST_OBJ) or (t_obj.objecttype!=ITEM_DRINKCON))
 {
 act("You can't pour anything into that.", A_SOMEONE, self, null, null,
TO_CHAR);
 quit;
 }

if ((t_obj.value[0]!=0) and
 (t_obj.names.[length(t_obj.names)-1]!=f_obj.names.[length(f_obj.names)-1]))
 {
 act("There is already another liquid in it!", A_SOMEONE, self,null,
null,TO_CHAR);
 quit;
 }

if (t_obj.capacity<=t_obj.value[0])
 {
 act("There is no room for more.",A_SOMEONE, self, null, null, TO_CHAR);
 quit;
 }


act("You pour the $2t into $3n.",A_SOMEONE,
self,f_obj.names.[length(f_obj.names)-1], t_obj,TO_CHAR);

if (t_obj.value[0]==0)
 {
 tx:="$drink_thirst" in f_obj.extra;
 if (tx==null)
  {
  :error:
  log ("Drink container error on "+f_obj.nameidx+"@"+f_obj.zoneidx);
  act ("Drink container error do to new container code replace your container.",
   A_ALWAYS, self,null,null,TO_CHAR);
  quit;
  }

 fx:="$drink_full" in f_obj.extra;
 if (fx==null)
  goto error;

 cx:="$drink_color" in f_obj.extra;
 if (cx==null)
  goto error;
 dx:="$drink_drunk" in f_obj.extra;
 if (dx==null)
  goto error;

 subextra (t_obj.extra,"$drink_color");
 subextra (t_obj.extra,"$drink_thirst");
 subextra (t_obj.extra,"$drink_full");
 subextra (t_obj.extra,"$drink_drunk");
 addextra (t_obj.extra,cx.names,cx.descr);
 addextra (t_obj.extra,tx.names,tx.descr);
 addextra (t_obj.extra,fx.names,fx.descr);
 addextra (t_obj.extra,dx.names,dx.descr);
 addstring (t_obj.names,f_obj.names.[length (f_obj.names)-1]);
 }


if (f_obj.value[0]==-1)
 {
 if (t_obj.capacity==0)
  amount:=0;
 else
  amount:=t_obj.capacity-t_obj.value[0];
 }
else if (t_obj.value[0]==-1)
 amount:=f_obj.value[0];
else

 {
 amount:=t_obj.capacity-t_obj.value[0];
 if (f_obj.value[0]<amount)
  amount:=f_obj.value[0];
 if (amount <0)
  amount:=0;
 }

 if (f_obj.value[0]>=0)
 {
 f_obj.value[0]:=f_obj.value[0]-amount;
 setweight (f_obj, f_obj.weight-amount);
 }

if (t_obj.value[0]>=0)
 {
 t_obj.value[0]:=t_obj.value[0]+amount;
 setweight (t_obj,t_obj.weight+amount);
 }

  /* Then the poison boogie */
if (f_obj.value[3]>t_obj.value[3])
t_obj.value[3]:=rnd(f_obj.value[3],t_obj.value[3]);

if (f_obj.value[0]==0)
 {
 sub_drink_info(f_obj);
 }

send_done ("pour",self,f_obj,t_obj,0,"",null);
quit;
}
dilend

#define SPLIT_CHARS UNIT_ST_PC

dilbegin do_split(arg: string);

external string coinstring@function(coins: integer, typ: string, ext:
integer);
         integer transfercoins@function (a: unitptr, t: unitptr,
                                         coins: integer, typ: string);
var mast : unitptr;
    sel  : integer;

    in_gr: integer;
    kids : integer;
    coins: integer;
    spval: integer;
    ctype: string;
    done : integer;

    u    : unitptr;
    ms   : string;
    s    : string;
    tmp  : string;
    i    : integer;
    l    : integer;

//    beta_list: stringlist;

code
{

// Not used til something gets wrong
/* beta_list := {"Stormtamer", "Whistler", "Tooth", "Ginger", "Jashiree",
"Aelf",
    "Tiggy", "Gothmog"};

if (not (self.name in beta_list)) // Hardcoded list for beta testing
    {
    sendtext("Sorry, this command is under evaluation.<br/>", self);
    return;
    }
*/
arg:= getword(arg);
sel:= arg in {"iron", "copper", "silver", "gold", "platinum", "all"};

if (sel <= 0)
    sel := arg in {"ip", "cp", "sp", "gp", "pp"};

if (sel <= 0) /* still not found */
    {
    act ("You can only split iron, copper, silver, gold, or platinum pieces"+
        "(or all of them).", A_ALWAYS, self, null, null, TO_CHAR);
    return;
    }

sel:= sel - 1;
kids:= 1; /* We expect at least one splitter, self */

if (self.master)
    {
    if (self.master.master)
        {
        mast := self;
        in_gr := FALSE;
        }

    else if (not isset (self.charflags, CHAR_GROUP) or
        not isset(self.master.charflags, CHAR_GROUP))
        {
        mast := self;
        in_gr := FALSE;
        }

    else
        {
        mast := self.master;
        in_gr := TRUE;

        foreach (UNIT_ST_PC|UNIT_ST_NPC, u)
            {
            if (u == self) continue;
            if ((u.master != mast) and (u != mast)) continue;
            if (not isset(u.charflags, CHAR_GROUP)) continue;

            kids := kids + 1; /* To know how many groupies there are in room
*/
            }

        }
    }

else
    {
    mast := self;

    if (not self.follower)
        in_gr := FALSE;

    else if (not isset(self.charflags, CHAR_GROUP))
        in_gr := FALSE;

    else foreach (SPLIT_CHARS, u)
        {
        if (u == self) continue;
        if (not visible(self, u)) continue;

        if (u.master != mast) continue;
        if (not isset(u.charflags, CHAR_GROUP)) continue;

        in_gr := TRUE;
        kids := kids + 1;
        }
    }

if (not in_gr)
    {
    act("You become rather picky with your loot.",A_ALWAYS, self, null,
null, TO_CHAR);
    act("$1n peers around, greedily playing with $1s money.",A_HIDEINV,
self, null, null, TO_REST);
    return;
    }

i:= flog ("split.log", asctime(realtime)+": "+self.name+" called the split"+
        "command ("+itoa(sel)+")", "a");

if (sel == 5)
    goto split_all;

if (sel == 0)
    ctype := IRON_PIECE;
if (sel == 1)
    ctype := COPPER_PIECE;
if (sel == 2)
    ctype := SILVER_PIECE;
if (sel == 3)
    ctype := GOLD_PIECE;
if (sel == 4)
    ctype := PLATINUM_PIECE;

coins:= purse(self, ctype);

if (coins < kids) /* There are less coins of that type than group members */
    {
    act("Splitting "+itoa(coins)+" coins evenly between "+itoa(kids)+
        " people might be quite a puzzle...",A_ALWAYS, self, null, null,
TO_CHAR);
    return;
    }

spval:= coins / kids;

ms:= coinstring@function (coins, ctype, TRUE);

tmp:= ms;
s:= getword(tmp);
s:= tmp; /* To get the "platinum pieces" or such, without the amount */

ms:= coinstring@function (spval, ctype, TRUE);

act ("You start splitting your "+s+" between your group members.",
    A_ALWAYS, self, null, null, TO_CHAR);
act ("$1n starts splitting $1s "+s+".",A_HIDEINV, self, null, null,
TO_REST);

foreach (SPLIT_CHARS, u)
    {

    if (u == self)
        {
        act("You keep "+ms+" for yourself.",A_ALWAYS, self, null, null,
TO_CHAR);
        continue;
        }

    if (not visible(self, u)) continue;

    if ( ((u.master != mast) and (u != mast)) or
        not isset(u.charflags, CHAR_GROUP))
        continue; /* Not a grouped */

    act ("You give $3n "+ms+".", A_HIDEINV, self, null, u, TO_CHAR);
    act ("$1n gives $3n "+ms+".", A_HIDEINV, self, null, u, TO_NOTVICT);
    act ("$1n gives you "+ms+".", A_HIDEINV, self, null, u, TO_VICT);

    i := flog ("split.log", asctime(realtime)+": "+self.name+" split "+
        itoa(coins)+" "+ctype+" to "+ms+" (to "+u.name+")", "a");

    i := transfercoins@function (self, u, spval, ctype);

    if (i == FALSE)
        act("You realize something is wrong with $1n's money.",
            A_HIDEINV, self, null, u, TO_VICT);
    }

i:= flog ("split.log", asctime(realtime)+": "+self.name+" returned from the"+
    "split command.", "a");
return;

:split_all:

act ("You start splitting your money between your group members.",
    A_ALWAYS, self, null, null, TO_CHAR);
act ("$1n starts splitting $1s money.",
    A_HIDEINV, self, null, null, TO_REST);


l:= MAX_MONEY;
ms:= "";

while (l >= 0)
    {
    if (l == 0)
        ctype := IRON_PIECE;
    if (l == 1)
        ctype := COPPER_PIECE;
    if (l == 2)
        ctype := SILVER_PIECE;
    if (l == 3)
        ctype := GOLD_PIECE;
    if (l == 4)
        ctype := PLATINUM_PIECE;

    coins := purse(self, ctype);

    if (coins < kids)
        {
        l := l - 1;
        continue;
        }

    spval := coins / kids;
    s := coinstring@function (spval, ctype, TRUE);

    if (ms == "")
        ms := s;

    else
        ms := ms + ", " + s;

    foreach (SPLIT_CHARS, u)
        {

        if (u == self)
            continue;

        if (not visible(self, u)) continue;

        if ( ((u.master != mast) and (u != mast)) or
        not isset(u.charflags, CHAR_GROUP))
        continue; /* Not a grouped */

        i := transfercoins@function (self, u, spval, ctype);

        if (i == FALSE)
act("You realize something is wrong with $1n's money.",A_HIDEINV, self,
null, u, TO_VICT);

        i := flog ("split.log", asctime(realtime)+": "+self.name+" split "+
            itoa(coins)+" "+ctype+" to "+s+" (to "+u.name+")", "a");

        }

    done := TRUE;
    l := l - 1;
    }

foreach (SPLIT_CHARS, u)
    {
    if (u == self)
        {
        act("You keep "+ms+" for yourself.",A_ALWAYS, self, null, null,
TO_CHAR);
        continue;
        }

    if (not visible(self, u)) continue;

    if ( ((u.master != mast) and (u != mast)) or
        not isset(u.charflags, CHAR_GROUP))
        continue; /* Not a grouped */

    act ("You give $3n "+ms+".", A_HIDEINV, self, null, u, TO_CHAR);
    act ("$1n gives $3n "+ms+".", A_HIDEINV, self, null, u, TO_NOTVICT);
    act ("$1n gives you "+ms+".", A_HIDEINV, self, null, u, TO_VICT);
    }

if (not done)
    {
    act("You realize you do not have enough money to split it between all "+
        "your party members.", A_ALWAYS, self, null, null, TO_CHAR);
    act("$1n seems to realize $1s purse is empty.",
        A_HIDEINV, self, null, null, TO_REST);
    }

i:= flog ("split.log", asctime(realtime)+": "+self.name+" returned from the"+
        "split command.", "a");
return;

}

dilend

dilbegin no_shout (arg : string);

var
   pc       : unitptr;

   pcname   : string;
   time_str : string;
   type_str : string;

   i        : integer;
   ns_time  : integer;

code
{
   block;
   if ("New Player Helper" in self.quests) goto proceed;


   if (self.level < 200)
   {
      act("Arglebargle, glop-glyf!?!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

:proceed:
   pcname := getword(arg);

   pc := findunit(self, pcname, FIND_UNIT_WORLD, null);

   if ((pc == null) or (pc.type != UNIT_ST_PC) or (pc.minv > self.level))
   {
      act("No such PC in the world.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }
if (self.name=="ginger")
 goto gingers;

   if (self.level <= pc.level)
   {
      act("I don't think $3e would appreciate that.",A_ALWAYS, self, null,
pc, TO_CHAR);
      quit;
   }
 if (("New Player Helper" in self.quests) and (pc.level > 20))
  {
 act ("that person is not a newbie this only works for level 20 and down.",
  A_ALWAYS, self, null, null, TO_CHAR);
 quit;
 }

:gingers:
   if ((self.level <200) and (pc.level>=200))
   {
      act("I don't think $3e would appreciate that.",A_ALWAYS, self, null,
pc, TO_CHAR);
      quit;
   }

   if (isset(pc.pcflags, PC_NOSHOUTING))
   {
      act("Noshouting removed from $3n.",A_ALWAYS, self, null, pc, TO_CHAR);
      act("Your sore throat suddenly clears up.",A_ALWAYS, pc, null, null,
TO_CHAR);
      subextra(pc.quests, "$noshout");
      unset(pc.pcflags, PC_NOSHOUTING);
      i := dildestroy("no_shouted@commands", pc);
      log("NOSHOUT: " + self.name + " removed the noshout on " +
          pc.name + ".");
      quit;
   }

   time_str := getword(arg);
   type_str := getword(arg);

   /* Default noshout time is 30 real minutes */
   if (time_str == "")
   {
      ns_time := (PULSE_SEC * SECS_PER_REAL_HOUR) / 2;
      time_str := "30";
      type_str := "min";
      goto no_shout;
   }

   ns_time := atoi(time_str);

   if (not(ns_time))
   {
      act("Invalid time period.",A_ALWAYS, self, null, null, TO_CHAR);
      goto syntax;
   }

   if (type_str in "mins")
   {
      ns_time := ns_time * PULSE_SEC * SECS_PER_REAL_MIN;
      goto no_shout;
   }

   else if (type_str in "hours")
   {
      ns_time := ns_time * PULSE_SEC * SECS_PER_REAL_HOUR;
      goto no_shout;
   }

   else goto syntax;

:no_shout:

   set(pc.pcflags, PC_NOSHOUTING);
   act("Noshouting set on $3n.",A_ALWAYS, self, null, pc, TO_CHAR);
   act("You suddenly get a sore throat!",A_ALWAYS, pc, null, null, TO_CHAR);
   dilcopy("no_shouted@commands(" + itoa(ns_time) + ")", pc);
   addextra(pc.quests, {"$noshout"}, self.name + " " + asctime(realtime));
   log("NOSHOUT: " + self.name + " noshouted " + pc.name + " for " +
       time_str + " " + type_str + ".");

   quit;

:syntax:
      act("Syntax: 'Noshout player 1 hour' or 'Noshout player 25 min'." +
          "<br/>Note time is real time, not mud time.",A_ALWAYS, self, null,
null, TO_CHAR);
      quit;
}
dilend /* revoke */

dilbegin recall aware no_shouted (ns_time : integer);

var
   ticks_so_far : integer;
   hours: integer;
   mins: integer;
   secs: integer;
   td: string;
   tl: string;

code
{
   ticks_so_far := 0;
   heartbeat := (PULSE_SEC * SECS_PER_REAL_MIN) / 3;
   interrupt (SFB_CMD, (command("noshouted") and (self == activator)),
shou);

:re_tick:
   wait(SFB_TICK, TRUE);
   ticks_so_far := ticks_so_far + heartbeat;
   if (ticks_so_far >= ns_time) goto end;
   else goto re_tick;

:end:
   unset(self.pcflags, PC_NOSHOUTING);
   act("Your sore throat clears up.",A_ALWAYS, self, null, null, TO_CHAR);
   subextra(self.quests, "$noshout");
   log("NOSHOUT: " + self.name + "'s noshout has worn off.");
   quit;

:shou:
block;
hours:= 0;mins := 0;td := "";tl := "";
secs:= ticks_so_far / 4;

while (secs >= 3600) {
 secs := secs - 3600;
 hours := hours + 1;
 }
while (secs >= 60) {
 secs := secs - 60;
 mins := mins + 1;
 }

td:= itoa(hours) + " hours, "+itoa(mins)+" minutes, "+itoa(secs)+
  " seconds";

hours:= 0; mins := 0;
secs:= ns_time / 4;

while (secs >= 3600) {
 secs := secs - 3600;
 hours := hours + 1;
 }
while (secs >= 60) {
 secs := secs - 60;
 mins := mins + 1;
 }

tl:= itoa(hours) + " hours, "+itoa(mins)+" minutes, "+itoa(secs)+
  " seconds";

act ("You have "+td+" done off your noshout, out of "+tl+" to do.",
  A_ALWAYS,self,null,null,TO_CHAR);

goto re_tick;

}
dilend /* no_shouted */

dilbegin seize (arg : string);

var
   pc       : unitptr;
   targ     : unitptr;

   pcname   : string;
   targname : string;

code
{
   if (self.level < 240)
   {
      act("Arglebargle, glop-glyf!?!",A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
:incorrect:
      act("Seize what from whom?",A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   targname := getword(arg);

:loop:
   pcname := getword(arg);

   if (pcname == "") goto incorrect;

   if ((pcname != "from") and (pcname != "f") and (pcname != "fr") and
       (pcname != "fro"))
   {
      targname := targname + pcname;
      goto loop;
   }

   else
      pcname := arg;

   if (pcname == "") goto incorrect;

   pc := findunit(self, pcname, FIND_UNIT_WORLD, null);

   if ((not(pc)) or (not(pc.type & (UNIT_ST_PC | UNIT_ST_NPC))) or
       (pc.minv > self.level))
   {
      act("There is no such person/mobile in the world.",A_ALWAYS, self,
null, null, TO_CHAR);
      quit;
   }

   if (pc.level >= self.level)
   {
      act("I don't think $3e would appreciate that. Better ask
first.",A_ALWAYS, self, null, pc, TO_CHAR);
      quit;
   }

   targ := findunit(pc, targname, FIND_UNIT_IN_ME, null);

   if (not(targ))
   {
      act("$3n doesn't have that item.",A_ALWAYS, self, null, pc, TO_CHAR);
      quit;
   }

   link(targ, self);
   act("$1n has taken $2n from you.",A_HIDEINV, self, targ, pc, TO_VICT);
   act("You take $3n from $2N.",A_ALWAYS, self, pc, targ, TO_CHAR);
   log("SEIZE: " + self.name + " has taken " + targ.title + " from " +
       pc.name + ".");

   quit;

}
dilend /* seize */

dilbegin string exclaim_ask (s:string);
var
 punct:stringlist;
code
{
if ("!" in s)
 {
 if ("?" in s)
  goto d_punct;/*both ! and ?*/
 return ("exclaiming ");
 }
else if ("?" in s)
 return ("asking ");
else
 return ("");

:d_punct:
punct:=split(s,"!");
if (length (punct)==1)
 return ("exclaiming ");
else if ("?" in punct.[length(punct)-1])
 return ("asking ");
else
 return ("exclaiming ");
}
dilend


dilbegin reply (arg:string);
external
 string exclaim_ask(s:string);
var
sx:string;
  person:extraptr;
  pc:unitptr;
 punct:string;
  code
  {

if (arg=="")
  {
  act ("<div class='respond'>Respond what?</div>",A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

person:="$reply" in self.quests;

if (person==null)
  {
  act ("<div class='respond'>No one to respond
to.</div>",A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

pc:=findunit (self,person.descr,FIND_UNIT_WORLD,null);
if (pc==null)
{
act ("<div class='respond'>No one to respond
to.</div>",A_ALWAYS,self,null,null,TO_CHAR);
quit;
 }

:speak:

if (isset (self.pcflags, PC_NOTELLING))
 {
 act ("You have lost your telepathic
ability.",A_ALWAYS,self,null,null,TO_CHAR);
 quit;
 }

punct:=exclaim_ask(arg);

if (visible(self,pc))
 sendtext("<div class='respond'>You respond to "+pc.name+" "+punct+"'"+arg+"'</div>", self);
else
 {
 if ((pc.sex==SEX_MALE) or (pc.sex==SEX_FEMALE))
  sx:="Someone";
 else
  sx:="Something";
 sendtext("<div class='respond'>You respond to "+sx+" "+punct+"'"+arg+"'</div>",
self);
 }

if (visible (pc,self))
 sendtext("<div class='respond'>"+self.name+" responds "+punct+"'"+arg+"'</div>",pc);
else
 {
 if ((self.sex==SEX_MALE) or (self.sex==SEX_FEMALE))
  sx:="Someone";
 else
  sx:="Something";
 sendtext("<div class='respond'>"+sx+" responds "+punct+"'"+arg+"'</div>",pc);
 }

subextra (pc.quests,"$reply");
addextra (pc.quests,{"$reply"},self.name);
quit;

}
dilend


// do_who
dilbegin who_dil ( arg: string );
var
   buff:string;
   gld:string;
   rc:string;
   ln:integer;
   u:unitptr;
   ply_list:stringlist;
   i:integer;
   temp:string;
   temps:string;
   tempp:string;
   path_guild : string;
   x:extraptr;
   ox:extraptr;
   gex : extraptr;
   gcolor : string;
code
{
   u := ghead();

   if (arg=="")
   {
      arg:="<u>Players:</u><br/>";
      temp:="";
      temps:="player";
      tempp:="players";
      goto who_all;
   }
   else if (arg in "newbie")
   {
      if ("New Player Helper" in self.quests)
      {
         arg:="<u>Newbies:</u><br/>";
         temp:="";
         temps:="newbie";
         tempp:="newbies";
         goto who_newbie;
      }
      else
      {
         act ("Only the newbie council can check newbies online.",A_ALWAYS,self,null,null,TO_CHAR);
         quit;
      }
   }
   else if (arg in "guide")
   {
      arg:="<u>Newbie Helpers:</u><br/>";
      temp:="";
      temps:="helper";
      tempp:="helpers";
      goto who_guide;
   }
   else if (arg in "builder")
   {
      arg:="<u>Valhalla Builders:</u><br/>";
      temp:="";
      temps:="builder";
      tempp:="builders";
      goto who_builder;
   }
   else if (arg in "clan")
   {
      arg:="<u>Clan Members:</u><br/>";
      temp:="";
      temps:="member";
      tempp:="members";
      goto who_clan;
   }
   else if (arg in "friend")
   {
      arg:="<u>Valhalla Friend:</u><br/>";
      temp:="";
      temps:="friend";
      tempp:="friends";
      goto who_friend;
   }
   else if (arg in "admin")
   {
      arg:="<u>Valhalla Admins:</u><br/>";
      temp:="";
      temps:="admin";
      tempp:="admins";
      goto who_admin;
   }

   arg:="<u>Players:</u><br/>";
   temp:="";
   temps:="player";
   tempp:="players";

   :who_all:
   while (u.type==UNIT_ST_PC)
   {
      if (visible(self,u))
      {
         if (u.level >= OVERSEER_LEVEL)
            gld:="(Admin)";
         else if (u.level>=CREATOR_LEVEL)
            gld:="(Creator)";
         else if (u.level>IMMORTAL_LEVEL)
            gld:="(Immortal)";
         else
            gld:="";

         buff:="<div class='who_name'>"+u.name+"</div><div class='who_title'> "+u.title+" "+gld+"</div> ";
         if (u.minv>0)
            buff:=buff+"<div class='who_inv'>[ WIZINV "+itoa(u.minv)+" ]</div> ";
         else if (isaff(u, ID_INVISIBILITY))
            buff:=buff+"<div class='who_inv'>[ INV ]<div class='who'>";
         if ("valhalla builder" in u.quests)
            buff:=buff+" * Builder *</div>";
         if ("valhalla friend" in u.quests)
            buff:=buff+" * Friend *</div>";  
         if ("New Player Helper" in u.quests)
         {
            if (u.extra.["$whoguidecolor"] != null)
            gcolor := textformat(u.extra.["$whoguidecolor"].descr);
            else gcolor := "";
            buff:=buff+" *"+gcolor+" Guide "+"</div>*";
         }
         buff:=buff+" <br/>";
         addstring (ply_list,buff);
      }
      u:=u.gnext;
   }
   goto p_who;

   :who_newbie:
   while (u.type==UNIT_ST_PC)
   {
   if ((visible(self,u)) and
   (u.level <= 20))
   {
   if (u.level >= OVERSEER_LEVEL)
   gld:="(Admin)";
   else if (u.level>=CREATOR_LEVEL)
   gld:="(Creator)";
   else if (u.level>IMMORTAL_LEVEL)
   gld:="(Immortal)";
   else gld:="";

   buff:="<div class='who_name'>"+u.name+"</div><div class='who_title'> "+u.title+" "+gld+"</div> ";
   if (u.minv>0)
   buff:=buff+"<div class='who_inv'>[ WIZINV "+itoa(u.minv)+" ]</div> ";
   else if (isaff(u, ID_INVISIBILITY))
   buff:=buff+"<div class='who_inv'>[ INV ]</div><div class='who'>";
   if ("valhalla builder" in u.quests)
   buff:=buff+" * Builder *</div>";
   if ("valhalla friend" in u.quests)
   buff:=buff+" * Friend *</div>";  
   if ("New Player Helper" in u.quests)
   {
   if (u.extra.["$whoguidecolor"] != null)
   gcolor := textformat(u.extra.["$whoguidecolor"].descr);
   else gcolor := "";
   buff:=buff+" *"+gcolor+" Guide "+"</div>*";
   }
   buff:=buff+" <br/>";
   addstring (ply_list,buff);
   }
   u:=u.gnext;
   }
   goto p_who;
   :who_admin:
   while (u.type==UNIT_ST_PC)
   {
   if ((visible(self,u)) and
   (u.level >= 253))
   {
   if (u.level >= OVERSEER_LEVEL)
   gld:="(Admin)";
   else if (u.level>=CREATOR_LEVEL)
   gld:="(Creator)";
   else if (u.level>IMMORTAL_LEVEL)
   gld:="(Immortal)";
   else gld:="";

   buff:="<div class='who_name'>"+u.name+"</div><div class='who_title'> "+u.title+" "+gld+"</div> ";
   if (u.minv>0)
   buff:=buff+"<div class='who_inv'>[ WIZINV "+itoa(u.minv)+" ]</div> ";
   else if (isaff(u, ID_INVISIBILITY))
   buff:=buff+"<div class='who_inv'>[ INV ]</div><div class='who'>";
   if ("valhalla builder" in u.quests)
   buff:=buff+" * Builder *</div>";
   if ("valhalla friend" in u.quests)
   buff:=buff+" * Friend *</div>";  
   if ("New Player Helper" in u.quests)
   {
   if (u.extra.["$whoguidecolor"] != null)
   gcolor := textformat(u.extra.["$whoguidecolor"].descr);
   else gcolor := "";
   buff:=buff+" *"+gcolor+" Guide "+"</div>*";
   }
   buff:=buff+" <br/>";
   addstring (ply_list,buff);
   }
   u:=u.gnext;
   }
   goto p_who;
   :who_guide:
   while (u.type==UNIT_ST_PC)
   {
   if ((visible(self,u)) and
   ("New Player Helper" in u.quests))
   {
   if (u.level >= OVERSEER_LEVEL)
   gld:="(Admin)";
   else if (u.level>=CREATOR_LEVEL)
   gld:="(Creator)";
   else if (u.level>IMMORTAL_LEVEL)
   gld:="(Immortal)";
   else gld:="";

   buff:="<div class='who_name'>"+u.name+"</div><div class='who_title'> "+u.title+" "+gld+"</div> ";
   if (u.minv>0)
   buff:=buff+"<div class='who_inv'>[ WIZINV "+itoa(u.minv)+" ]</div> ";
   else if (isaff(u, ID_INVISIBILITY))
   buff:=buff+"<div class='who_inv'>[ INV ]</div><div class='who'>";
   if ("New Player Helper" in u.quests)
   {
   if (u.extra.["$whoguidecolor"] != null)
   gcolor := textformat(u.extra.["$whoguidecolor"].descr);
   else gcolor := "";
   buff:=buff+" *"+gcolor+" Guide "+"</div>*";
   }

   buff:=buff+" <br/>";
   addstring (ply_list,buff);
   }
   u:=u.gnext;
   }
   :who_friend:
   while (u.type==UNIT_ST_PC)
   {
   if ((visible(self,u)) and
   ("valhalla friend" in u.quests))
   {
   if (u.level >= OVERSEER_LEVEL)
   gld:="(Admin)";
   else if (u.level>=CREATOR_LEVEL)
   gld:="(Creator)";
   else if (u.level>IMMORTAL_LEVEL)
   gld:="(Immortal)";
   else gld:="";

   buff:="<div class='who_name'>"+u.name+"</div> <div class='who_title'> "+u.title+" "+gld+"</div> ";
   if (u.minv>0)
   buff:=buff+"<div class='who_inv'>[ WIZINV "+itoa(u.minv)+" ]</div> ";
   else if (isaff(u, ID_INVISIBILITY))
   buff:=buff+"<div class='who_inv'>[ INV ]<div class='who'>";
   if ("valhalla friend" in u.quests)
   buff:=buff+" * Friend *</div>";  
   buff:=buff+" <br/>";
   addstring (ply_list,buff);
   }
   u:=u.gnext;
   }
   :who_builder:
   while (u.type==UNIT_ST_PC)
   {
   if ((visible(self,u)) and
   ("valhalla builder" in u.quests))
   {
   if (u.level >= OVERSEER_LEVEL)
   gld:="(Admin)";
   else if (u.level>=CREATOR_LEVEL)
   gld:="(Creator)";
   else if (u.level>IMMORTAL_LEVEL)
   gld:="(Immortal)";
   else gld:="";

   buff:="<div class='who_name'>"+u.name+"</div><div class='who_title'> "+u.title+" "+gld+"</div> ";
   if (u.minv>0)
   buff:=buff+"<div class='who_inv'>[ WIZINV "+itoa(u.minv)+" ]</div> ";
   else if (isaff(u, ID_INVISIBILITY))
   buff:=buff+"<div class='who_inv'>[ INV ]</div><div class='who'>";
   if ("valhalla builder" in u.quests)
   buff:=buff+" * Builder *</div>";

   buff:=buff+" <br/>";
   addstring (ply_list,buff);
   }
   u:=u.gnext;
   }
   :who_clan:
   while (u.type==UNIT_ST_PC)
   {
   x:=CLAN_NAME in self.extra;
   if (x==null)
   {
   u:=u.gnext;
   continue;
   }
   ox:=CLAN_NAME in u.extra;
   if (ox==null)
   {
   u:=u.gnext;
   continue;
   }
   if (ox.descr!=x.descr)
   {
   u:=u.gnext;
   continue;
   }
   if (visible(self,u))
   {
   if (u.level >= OVERSEER_LEVEL)
   gld:="(Admin)";
   else if (u.level>=CREATOR_LEVEL)
   gld:="(Creator)";
   else if (u.level>IMMORTAL_LEVEL)
   gld:="(Immortal)";
   else gld:="";

   buff:="<div class='who_name'>"+u.name+"</div> <div class='who_title'>"+u.title+"</div>"+gld+"</div> ";
   if (u.minv>0)
   buff:=buff+"<div class='who_inv'>[ WIZINV "+itoa(u.minv)+" ]</div> ";
   else if (isaff(u, ID_INVISIBILITY))
   buff:=buff+"<div class='who_inv'>[ INV ]<div class='who'>";
   if ("valhalla builder" in u.quests)
   buff:=buff+" * Builder *</div>";
   if ("valhalla friend" in u.quests)
   buff:=buff+" * Friend *</div>";  
   if ("New Player Helper" in u.quests)
   {
   if (u.extra.["$whoguidecolor"] != null)
   gcolor := textformat(u.extra.["$whoguidecolor"].descr);
   else gcolor := "";
   buff:=buff+" *"+gcolor+" Guide "+"</div>*";
   }
   buff:=buff+" <br/>";
   addstring (ply_list,buff);
   }
   u:=u.gnext;
   }

   :p_who:
   buff:="";
   ln:=length(ply_list);
   //buff:="<div class='who'>"+arg+"</div>";
   buff:=arg;
   /*buff:=buff+"<div class='who'>"+temp+"</div>";*/

   if (ln <= 0)
      buff:=buff+"None<br/>";
   else
   {
      i:=0;
      while (i<ln)
      {
         buff:=buff+ply_list.[i];
         i:=i+1;
      }
   }
   if (ln==1)
      buff:=buff+"There is " +itoa(ln)+ " "+temps+" visible to you.<br/>";
   else
      buff:=buff+"There are " +itoa(ln)+ " "+tempp+" visible to you.<br/>";

   pagestring(buff,self);
   quit;
}
dilend



dilbegin string sizestring(cm : integer);
var
   ftn : integer;
   fts : string;
   inn : integer;
   ins : string;
code
{
   /* One inch equals 2,54 cm. There are 12 inches (30.48 cm) to a foot */
   ftn := cm / 30;
   inn := (10*(cm % 30))/25;
   if (ftn == 1)
     fts := "one foot";
   else if (ftn > 1)
     fts := itoa(ftn)+" feet";
   else
     fts := "";

   if (inn == 1)
     ins := "one inch";
   else if (inn > 1)
     ins := itoa(inn)+" inches";
   else
     ins := "";

   if (fts != "")
   {
      if (ins != "")
        fts := fts + " and ";
   }
   else
   {
      if (inn < 1)
 ins := "less than an inch";
   }

   return (fts + ins);
}
dilend
dilbegin string weightstring(p : integer);
var
   s : string;
code
{
   if (p == 1)
     s := "one pound";
   else if (p > 1)
     s := itoa(p)+" pounds";
   else
     s := "less than a pound";

   return (s);
}
dilend




dilbegin affect(arg:string);
var
 spl_aff:stringlist;
 i:integer;
 ln:integer;
code
{
   if (isaff(self, ID_BLESS))
 addstring(spl_aff,"Bless<br/>");
if (isaff(self, ID_DETECT_ALIGN))
 addstring(spl_aff,"Detect Alignment<br/>");
if (isaff(self, ID_DETECT_INVISIBLE))
 addstring(spl_aff,"Detect Invisibility<br/>");
if (isaff(self, ID_DETECT_MAGIC))
 addstring(spl_aff,"Detect Magic<br/>");
if (isaff(self, ID_DETECT_POISON))
 addstring(spl_aff,"Detect Poison<br/>");
if (isaff(self, ID_DETECT_UNDEAD))
 addstring(spl_aff,"Detect Undead<br/>");
if (isaff(self, ID_DETECT_CURSE ))
 addstring(spl_aff,"Detect Curse<br/>");
if (isaff(self, ID_DETECT_LIFE))
 addstring(spl_aff,"Detect Life<br/>");
if (isaff(self, ID_INVISIBILITY))
 addstring(spl_aff,"Invisibility<br/>");
if (isaff(self, ID_HOLD))
 addstring(spl_aff,"Hold<br/>");
if (isaff(self, ID_MAGIC_LIGHT))
 addstring(spl_aff,"Magic Light<br/>");
if (isaff(self, ID_MAGIC_DARK))
 addstring(spl_aff,"Magic Dark<br/>");
if (isaff(self, ID_SPL_RAISE_MAG))
 addstring(spl_aff,"Raise Magic<br/>");
if (isaff(self, ID_SPL_RAISE_DIV))
 addstring(spl_aff,"Raise Divine<br/>");
if (isaff(self, ID_SPL_RAISE_STR))
 addstring(spl_aff,"Raise Strength<br/>");
if (isaff(self, ID_SPL_RAISE_DEX))
 addstring(spl_aff,"Raise Dexterity<br/>");
if (isaff(self, ID_SPL_RAISE_CON))
 addstring(spl_aff,"Raise Constitution<br/>");
if (isaff(self, ID_SPL_RAISE_CHA))
 addstring(spl_aff,"Raise Charisma<br/>");
if (isaff(self, ID_SPL_RAISE_BRA))
 addstring(spl_aff,"Raise Brain<br/>");
if (isaff(self, ID_SPL_RAISE_HPP))
 addstring(spl_aff,"Raise Hit Points<br/>");
if (isaff(self, ID_SPL_RAISE_DIVINE))
 addstring(spl_aff,"Raise Divine Sphere<br/>");
if (isaff(self, ID_SPL_RAISE_SUMMONING))
 addstring(spl_aff,"Raise Summoning Sphere<br/>");
if (isaff(self, ID_SPL_RAISE_MIND))
 addstring(spl_aff,"Raise Mind Sphere<br/>");
if (isaff(self, ID_SPL_RAISE_HEAT))
 addstring(spl_aff,"Raise Heat Sphere<br/>");
if (isaff(self, ID_SPL_RAISE_COLD))
 addstring(spl_aff,"Raise Cold Sphere<br/>");
if (isaff(self, ID_SPL_RAISE_CELL))
 addstring(spl_aff,"Raise Electricity Sphere<br/>");
if (isaff(self, ID_SPL_RAISE_INTERNAL))
 addstring(spl_aff,"Raise Poison Sphere<br/>");
if (isaff(self, ID_SPL_RAISE_EXTERNAL))
 addstring(spl_aff,"Raise Acid Sphere<br/>");
if (isaff(self, ID_POISON))
 addstring(spl_aff,"Poison<br/>");
if (isaff(self, ID_SPEED))
 addstring(spl_aff,"Magic Speed<br/>");
if (isaff(self, ID_LIFE_PROTECTION))
        addstring(spl_aff,"Life Protection<br/>");
if (isaff(self, ID_SANCTUARY))
        addstring(spl_aff,"Sanctuary<br/>");
if (isaff(self, ID_PROT_EVIL))
        addstring(spl_aff,"Protection from Evil<br/>");
if (isaff(self, ID_PROT_GOOD))
        addstring(spl_aff,"Protection from Good<br/>");
if (isaff(self, ID_BLIND_CHAR))
        addstring(spl_aff,"Blind<br/>");
if (isaff(self, ID_FEAR))
        addstring(spl_aff,"Fear<br/>");
if (isaff(self, ID_SLEEP))
        addstring(spl_aff,"Sleep<br/>");
if (isaff(self, ID_CURSE))
        addstring(spl_aff,"Curse<br/>");
if (isaff(self, ID_INSANITY))
        addstring(spl_aff,"Madness<br/>");
if (isaff(self, ID_SUSTAIN))
        addstring(spl_aff,"Sustained from Hunger<br/>");
if (isaff(self, ID_PLAGUE))
        addstring(spl_aff,"Plague<br/>");
if (isaff(self, ID_ENERGY_DRAIN))
        addstring(spl_aff,"Energy Drain<br/>");
if (isaff(self, ID_CONFUSION))
        addstring(spl_aff,"Confusion<br/>");
if (isaff(self, ID_NATURAL_ARMOUR))
        addstring(spl_aff,"Magical Natural Armor<br/>");
if (isaff(self, ID_FOCUS))
        addstring(spl_aff,"Focus<br/>");
if (isaff(self, ID_MIRE))
        addstring(spl_aff,"Mired<br/>");
if (isaff(self, ID_CONDEMN))
        addstring(spl_aff,"Condemned<br/>");

ln:=length (spl_aff);

if(self.position == POSITION_FIGHTING)
{
 sendtext("You decide it best to focus your energies on the battle at hand!<br/>", self);
 quit;
}


if (ln<1)
 {
 act ("You are not affected by magic.",
  A_ALWAYS,self,null,null,TO_CHAR);
  goto hide_sneak ;
  }
i:=0;
act ("You are affected by:<br/>",
 A_ALWAYS,self,null,null,TO_CHAR);

while (i<ln)
 {
 sendtext (spl_aff.[i],self);
 i:=i+1;
 }

:hide_sneak:

if ((isset(self.charflags, CHAR_HIDE)) and (isset(self.charflags,
CHAR_SNEAK))){
 sendtext ("<br/>You are hiding and sneaking.<br/>",self);}
else if (isset(self.charflags, CHAR_HIDE)){
 sendtext ("<br/>You are hiding.<br/>",self);}
else if (isset(self.charflags, CHAR_SNEAK)){
 sendtext ("<br/>You are sneaking.<br/>",self);}
quit;
}
dilend


dilbegin report(arg:string);
var
u: unitptr;
code
{
if(self.type!=UNIT_ST_PC)
quit;

if(arg==""){
  act(self.name+" reports: "+itoa(self.hp)+"/"+itoa(self.max_hp)+
    " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
    " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana",
    A_SOMEONE, self, null, null, TO_REST);
  act("You report: "+itoa(self.hp)+"/"+itoa(self.max_hp)+
    " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
    " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana",
    A_ALWAYS, self, null, null, TO_CHAR);
}
else if(arg=="group") {
foreach (UNIT_ST_PC, u)
{
 if(u==self)
 {
  act("You report: "+itoa(self.hp)+"/"+itoa(self.max_hp)+
    " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
    " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana"+
    " to the group.", A_ALWAYS, self, null, null, TO_CHAR);
 }
 else if(u.master==self)
 {
  act("$1n reports: "+itoa(self.hp)+"/"+itoa(self.max_hp)+
    " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
    " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana"+
    " to the group.", A_SOMEONE, self, null, u, TO_VICT);
 }
 else if(u==self.master) {
  act("$1n reports: "+itoa(self.hp)+"/"+itoa(self.max_hp)+
    " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
    " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana"+
    " to the group.", A_SOMEONE, self, null, u, TO_VICT);
 }
 else if(u.master==self.master)
 {
  act("$1n reports: "+itoa(self.hp)+"/"+itoa(self.max_hp)+
    " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
    " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana"+
    " to the group.", A_SOMEONE, self, null, u, TO_VICT);
 }
}
}
else
{
 u:=findunit(self, arg, FIND_UNIT_SURRO, null);
 if(u==null)
 {
   act("That person is not here.", A_ALWAYS, self, null, null, TO_CHAR);
 }
 else
 {
  act("$1n reports: "+itoa(self.hp)+"/"+itoa(self.max_hp)+
    " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
    " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana"+
    " to you.", A_SOMEONE, self, null, u, TO_VICT);
  act("You report: "+itoa(self.hp)+"/"+itoa(self.max_hp)+
    " Hitpoints, "+itoa(self.endurance)+"/"+itoa(self.max_endurance)+
    " Endurance, "+itoa(self.mana)+"/"+itoa(self.max_mana)+" Mana"+
    " to $3n.", A_ALWAYS, self, null, u, TO_CHAR);
 }
}
  quit;
}
dilend

dilbegin transfer(arg : string);
var
dest_s: unitptr;
dest_t: unitptr;
tgt: unitptr;
str: string;

code
{

 if(arg == "")
  {
   act("<br/>Usage : transfer &lt;person&gt;<br/>
        transfer &lt;person&gt; &lt;place&gt;<br/>
        transfer &lt;person&gt; &lt;room@zone&gt;<br/>
        transfer &lt;all&gt; Use with care!",
       A_ALWAYS, self, null, null, TO_CHAR);
   quit;
  }

  if((arg == "all") or (arg == "all now"))
  goto transall;

 tgt := findunit(self,arg,FIND_UNIT_GLOBAL,null);

 if((tgt == null) or (not(visible(self,tgt))))
  {
   act("No such person found.",A_ALWAYS, self, null, null, TO_CHAR);
   quit;
  }

 if(tgt == self)
  {
   act("DOH", A_ALWAYS, self, null, null, TO_CHAR);
   quit;
  }

 if(not(tgt.type & (UNIT_ST_PC|UNIT_ST_NPC)))
 {
  act("Transfer is for players and mobiles only!",A_ALWAYS, self, null,
null, TO_CHAR);
  quit;
 }

 if(arg == "") /* lone transfer..ex. transfer domino */
 {
  dest_s := self.outside;
  dest_t := tgt.outside;

  if((("$NO_TRANS" in dest_s.extra) or ("NO_TRANS" in dest_t.extra)) and
      (self.level < 250))
  {
   act("Sorry, you are unable to transfer that person.", A_ALWAYS, self,
null, null, TO_CHAR);
   quit;
  }

  if((isset(tgt.pcflags,PC_SPIRIT)) and (self.level < 250))
  {
   act("You are unable to transfer dead persons.",A_ALWAYS, self, null,
null, TO_CHAR);
   quit;
  }

 act("Ok.", A_ALWAYS, self, null, null, TO_CHAR);
 act("$1n disappears in a mushroom cloud.", A_HIDEINV, tgt, null, null,
TO_REST);
 act("$3n has transferred you!",A_SOMEONE, tgt, null, self, TO_CHAR);
 link(tgt,dest_s);
 exec("look", tgt);
 act("$1n appears in a puff of smoke.",A_HIDEINV, tgt, null, null, TO_REST);
 quit;
 }
 else if("@" in arg) /* transfer domino temple@udgaard */
 {
  dest_s := findroom(arg);
  if(dest_s == null)
  {
   act("No such room!", A_ALWAYS, self, null, null, TO_CHAR);
   quit;
  }
  dest_t := tgt.outside;

  if(("NO_TRANS" in dest_t.extra) and
      (self.level < 250))
  {
   act("Sorry, you are unable to transfer that person.",A_ALWAYS, self,
null, null, TO_CHAR);
   quit;
  }

  if((isset(tgt.pcflags,PC_SPIRIT)) and (self.level < 250))
  {
   act("You are unable to transfer dead persons",A_ALWAYS, self, null, null,
TO_CHAR);
   quit;
  }

  act("Ok.", A_ALWAYS, self, null, null, TO_CHAR);
  act("$1n disappears in a mushroom cloud.",A_HIDEINV, tgt, null, null,
TO_REST);
  act("$3n has transferred you!",A_SOMEONE, tgt, null, self, TO_CHAR);
  link(tgt,dest_s);
  exec("look", tgt);
  act("$1n appears in a puff of smoke.",A_HIDEINV, tgt, null, null,
TO_REST);
  quit;
 }
 else /* transfer domino boobar the giantslayer */
  {
   dest_s := findunit(self,arg, FIND_UNIT_WORLD, null);

   if(dest_s == null)
   {
    act("No such place to transfer $3n to!",A_ALWAYS, self, null, tgt,
TO_CHAR);
    quit;
   }

 if(dest_s.type != UNIT_ST_ROOM)
  {
   while(dest_s.type != UNIT_ST_ROOM)
     dest_s := dest_s.outside;
  }

  dest_t := tgt.outside;

  if(("NO_TRANS" in dest_t.extra) and
      (self.level < 250))
  {
   act("Sorry, you are unable to transfer that person.", A_ALWAYS, self,
null, null, TO_CHAR);
   quit;
  }

  if((isset(tgt.pcflags,PC_SPIRIT)) and (self.level < 250))
  {
   act("You are unable to transfer dead persons",A_ALWAYS, self, null, null,
TO_CHAR);
   quit;
  }

  act("Ok.", A_ALWAYS, self, null, null, TO_CHAR);
  act("$1n disappears in a mushroom cloud.",A_HIDEINV, tgt, null, null,
TO_REST);
  act("$3n has transferred you!",A_SOMEONE, tgt, null, self, TO_CHAR);
  link(tgt,dest_s);
  exec("look", tgt);
  act("$1n appears in a puff of smoke.", A_SOMEONE, tgt, null, null,
TO_REST);
  quit;
 }

 :transall:

  if(arg != "all now")
  {
   act("You must type transfer all now</div>.",A_ALWAYS, self, null,
null, TO_CHAR);
   quit;
  }

  act("Ok.", A_ALWAYS, self, null, null, TO_CHAR);

 tgt := ghead();

 while(tgt.type == UNIT_ST_PC)
 {

  if((visible(self,tgt)) and (tgt != self))
  {

   act("$1n disappears in a mushroom cloud.",
   A_SOMEONE, tgt, null, null,TO_REST);
   act("$3n has transferred you!",
   A_SOMEONE, tgt, null, self, TO_CHAR);
   link(tgt, self.outside);
   exec("look", tgt);
   act("$1n appears in a puff of smoke.",
   A_SOMEONE, tgt, null, null,TO_REST);
  }

 tgt := tgt.gnext;
 }


quit;
}
dilend


dilbegin assist(arg : string);
var
   u : unitptr;
   s : string;
code
{
if(arg=="") {
  act("Assist who??",A_SOMEONE,self,null,null,TO_CHAR);
  quit; }
u:=findunit(self,arg,FIND_UNIT_SURRO,null);
secure(u,losthim);
if(u==null) {
  act("No such person by that name!.",A_SOMEONE,self,null,null,TO_CHAR);
  quit; }
if(u==self) {
  act("Assist yourself?  Your in pretty bad shape if your the only one who
can help you.",A_SOMEONE,self,null,null,TO_CHAR);
  quit; }
if(self.fighting) {
  act("No way! You are too busy fighting for your
life!",A_ALWAYS,self,null,null,TO_CHAR);
  quit; }
if(u.fighting==null) {
  act("Assist $3n? $3e isn't fighting anything.",
      A_SOMEONE,self,null,u,TO_CHAR);
  quit; }
if((self.type==UNIT_ST_PC) and (u.fighting.type==UNIT_ST_PC)) {
  if(not(isset(u.fighting.pcflags,PC_PK_RELAXED))) {
    act("You cannot do this until $3n has signed the book of blood.",
        A_SOMEONE,self,null,u.fighting,TO_CHAR);
    quit; }
  if(not(isset(self.pcflags,PC_PK_RELAXED))) {
    act("You are not allowed to do this until you sign the book of blood.",
        A_ALWAYS,self,null,u.fighting,TO_CHAR);
    quit; } }
act("You bravely come to $3n's assistance.",
A_SOMEONE,self,null,u,TO_CHAR);
act("$1n bravely comes to your assistance.",
A_SOMEONE,self,null,u,TO_VICT);
act("$1n bravely comes to $3n's assistance.",
A_SOMEONE,self,null,u,TO_NOTVICT);
set_fighting(self,u.fighting);

:losthim:
quit;
}
dilend

/*Quaff dil
Made by Mesmer for the Realms Of The Past MUD
realms.pdt.net 4242
*/

dilbegin quaff_dil(arg : string);
var
potion: unitptr;
n: integer;

code
{

 if(arg == "")
 {
 act("What do you want to quaff?",A_ALWAYS, self, null, null, TO_CHAR);
 quit;
 }

 potion := findunit(self,arg,FIND_UNIT_IN_ME,null);

 if(potion == null)
 {
 act("You do not have that item.",A_ALWAYS, self, null, null, TO_CHAR);
 quit;
 }

 if(potion.objecttype != ITEM_POTION)
 {
 act("You can only quaff potions.",A_ALWAYS, self, null, null, TO_CHAR);
 quit;
 }

 potion.spells[SPL_ALL] := potion.value[0];

 if(self.position == POSITION_FIGHTING) change_speed(self,PULSE_VIOLENCE*2);

 act("You quaff $2t which dissolves.", A_ALWAYS, self, potion.title, null,
TO_CHAR);
 act("$1N quaffs $2t.",
      A_SOMEONE, self,potion.title, null, TO_REST);
 n := cast_spell(potion.value[1],self,potion,self,"");
 n := cast_spell(potion.value[2],self,potion,self,"");
 n := cast_spell(potion.value[3],self,potion,self,"");
 destroy(potion);
 quit;

}
dilend




/* The cuff skill.

   The skill is implemented on the hand cuffs themselves.

*/

dilbegin cuff(arg : string);
code
{
   act("You seem to be missing a pair of hand cuffs.",A_ALWAYS, self, null,
null, TO_CHAR);
   quit;
}
dilend


dilbegin evaluate(arg : string);

external
   string sizestring@commands(cm : integer);
   string weightstring@commands(cm : integer);

var
   u : unitptr;
   s : string;
   degrade : integer;
code
{
   if (arg == "")
   {
      act("What do you wish to evaluate?",A_SOMEONE, self, null,null,TO_CHAR);
      quit;
   }

   u := findunit(self, arg, FIND_UNIT_HERE, null);

   if ((u == null) or not visible(self, u))
   {
      act("No such thing by that name!", A_SOMEONE, self, null,null,TO_CHAR);
      quit;
   }

   if (u.type != UNIT_ST_OBJ)
   {
      act("You can't evaluate $3m.",A_SOMEONE, self, null, u, TO_CHAR);
      quit;
   }

   s := weightstring@commands(u.weight);
   act("The $3N weighs "+s+".",A_SOMEONE, self, null, u, TO_CHAR);

   if ((u.manipulate & (MANIPULATE_WEAR_FINGER | MANIPULATE_WEAR_NECK  |
   MANIPULATE_WEAR_BODY   | MANIPULATE_WEAR_HEAD  |
   MANIPULATE_WEAR_LEGS   | MANIPULATE_WEAR_FEET  |
   MANIPULATE_WEAR_HANDS  | MANIPULATE_WEAR_ARMS  |
   MANIPULATE_WEAR_SHIELD | MANIPULATE_WEAR_ABOUT |
   MANIPULATE_WEAR_WAIST  | MANIPULATE_WEAR_WRIST |
   MANIPULATE_WIELD       | MANIPULATE_WEAR_EAR   |
   MANIPULATE_WEAR_BACK   | MANIPULATE_WEAR_CHEST |
   MANIPULATE_WEAR_ANKLE)) or
       (u.objecttype == ITEM_WEAPON))
   {
      s := sizestring@commands(u.height);
      act("$3e has been made to fit a person of "+s+".",
	  A_SOMEONE, self,null, u, TO_CHAR);
   }
   if (u.max_hp == -1)
   {
 act("The $3N appears to be in godly condition.</div>",A_ALWAYS, self, null, u, TO_CHAR);
   quit;
   }
   if ((u.max_hp > 0) and (u.hp > 0))
   {
      degrade := (100*u.hp) / u.max_hp;

      if (degrade >= 90)
 s := "in an excellent condition.";
      else if (degrade >= 75)
 s := "in a good condition.";
      else if (degrade >= 50)
 s := "worn.";
      else if (degrade >= 30)
 s := "in a poor condition";
      else if (degrade >= 10)
 s := "in a horrible condition.";
      else
 s := "nearly broken.";
   }
   else if (u.max_hp == -1) // indestructible (able?)
     s := "in godly condition.";
   else
     s := "broken.";

   act("The $3N appears to be "+s,
       A_ALWAYS, self, null, u, TO_CHAR);

   if (u.objecttype == ITEM_ARMOR)
     on u.value[0] goto clothes,leather,leather,metal,metal;
   else if (u.objecttype == ITEM_SHIELD)
     goto metal;
   else if (u.objecttype == ITEM_WEAPON)
     goto metal;
   else if (u.objecttype == ITEM_WORN)
     goto clothes;
   else
   {
      if ((u.manipulate & (MANIPULATE_WEAR_FINGER | MANIPULATE_WEAR_NECK  |
        MANIPULATE_WEAR_BODY   | MANIPULATE_WEAR_HEAD  |
        MANIPULATE_WEAR_LEGS   | MANIPULATE_WEAR_FEET  |
        MANIPULATE_WEAR_HANDS  | MANIPULATE_WEAR_ARMS  |
        MANIPULATE_WEAR_SHIELD | MANIPULATE_WEAR_ABOUT |
        MANIPULATE_WEAR_WAIST  | MANIPULATE_WEAR_WRIST |
        MANIPULATE_WIELD       | MANIPULATE_WEAR_EAR   |
        MANIPULATE_WEAR_BACK   | MANIPULATE_WEAR_CHEST |
        MANIPULATE_WEAR_ANKLE)) == 0)
      {
         goto nextstep;
      }
      goto metal; /* What else can one do? */
   }
   goto nextstep;

   :clothes:
   act ("Refitting the size of it, requires tailoring
skills.",A_ALWAYS,self,null, null,TO_CHAR);
   goto nextstep;

   :leather:
   act ("Refitting the size of it, requires leather working
skills.",A_ALWAYS,self,null, null,TO_CHAR);
   goto nextstep;

   :metal:
   act ("Refitting the size of it, requires metal
skills.",A_ALWAYS,self,null, null,TO_CHAR);
   goto nextstep;

   :nextstep:

   /* Eventually add

      Material Lore
      Appraisal
      Spell Lore
    */

   quit;
}
dilend



dilbegin guild_wipe();

var
   pc     : unitptr;
   i      : integer;

code
{
:start:

   wait(SFB_CMD, (command("gwipe") and (self.outside.type == UNIT_ST_PC)
and
                  (self.outside.level >= 240) and (activator ==
self.outside)));
   block;
   if (argument == "")
      {
         act("You must supply a the name of a player",A_ALWAYS,
self.outside, null, null, TO_CHAR);
         goto start;
      }

   pc := findunit(self.outside, argument, FIND_UNIT_WORLD, null);

   if ((pc == null) or (pc.type != UNIT_ST_PC))
      {
         act("No such player online currently.",A_ALWAYS, self.outside,
null, null, TO_CHAR);
         goto start;
      }
   if (pc.guild != "")
      {
         act("They are still in a guild - get them to quit first", A_ALWAYS,
self.outside, null, null, TO_CHAR);
         goto start;
      }

   if (pc.level > self.outside.level)
      {
         act(pc.name + " might object to that.",
             A_ALWAYS, self.outside, null, null, TO_CHAR);
         goto start;
      }

   secure(pc, lost_pc);

:remove_guilds:

   if ("$guild" in pc.quests)
      {
         subextra(pc.quests, "$guild");
         goto remove_guilds;
      }

   i := (pc.exp / 100);
   i := i * 75;

   act(pc.name + " has been guild-wiped.<br/>Don't forget to set " +
       "the appropriate new experience <br/> (usually 75%, " +
       "which in this case is " + itoa(i) + ")!",
       A_ALWAYS, self.outside, null, null, TO_CHAR);
   act("You have been guild-wiped.",
       A_ALWAYS, pc, null, null, TO_CHAR);

   log(pc.name + " was guild-wiped by " + self.outside.name);

:lost_pc:
   unsecure(pc);
   goto start;
}
dilend /* guild_wipe */

dilbegin ctnrent(arg: string);

var clerk: unitptr;
 cont : unitptr;

 ext  : extraptr;
 town : string;
 i    : integer;

code
{

clerk:= findunit (self, "clerk", FIND_UNIT_SURRO, null);

if (not visible(self, clerk))
    {
 sendtext ("You see no clerk around here.<br/>", self);
 return;
 }

if (not ("$storage clerk" in clerk.extra) ) {
 sendtext ("This clerk is not a storage clerk.<br/>", self);
    return;
    }

town:= left (clerk.zoneidx, 3);
cont:= findunit (self, town+"container", FIND_UNIT_IN_ME, null);

if ((cont != null) and ("$storage container" in cont.extra)) {
    sendtext ("You already have rented space in this town.<br/>", self);
    return;
    }

i:= transfermoney(self, clerk, PLATINUM_MULT);

if (i == FALSE) {
    sendtext ("You cannot afford the required price for storage space.<br/>",
self);
    return;
    }

sendtext ("You rent some storage space.<br/>", self);
cont:= load ("container@commands");
cont.capacity:= 300;
cont.alignment:=0;
self.weight:=self.weight-cont.weight;
cont.weight:=0;
cont.baseweight:=0;
link (cont, self);


addstring (cont.names, town+"container");

return;

}

dilend

dilbegin ctnstore(arg: string);

var clerk: unitptr;
    cont : unitptr;
    item : unitptr;

    ext  : extraptr;
    town : string;
    iname: string;
 twei : integer;

code
{

clerk:= findunit (self, "clerk", FIND_UNIT_SURRO, null);

if (not visible(clerk, self))
    {
    sendtext ("You see no clerk around here.<br/>", self);
    return;
    }

if (not ("$storage clerk" in clerk.extra) )
    {
    sendtext ("This clerk is not a storage clerk.<br/>", self);
    return;
    }

town:= left (clerk.zoneidx, 3);
cont:= findunit (self, town+"container", FIND_UNIT_IN_ME, null);

if ((cont == null) or not ("$storage container" in cont.extra))
    {
    sendtext ("You do not have storage space in this town; rent some!<br/>",
self);
    return;
    }

iname:= arg;
if (iname == "")
    {
    sendtext ("Store what?<br/>", self);
    return;
    }

item:= findunit (self, iname, FIND_UNIT_INVEN, null);
if ((item.type != UNIT_ST_OBJ) or not (visible (self, item)) )
    {
    sendtext ("You can't find this in your inventory.<br/>", self);
    return;
    }
if ("$donotstore" in item.extra)
{
 sendtext ("Sorry, you can not store that.<br/>", self);
 return;
}
if ("$storage container" in item.extra)
    {
 sendtext ("You don't want to do this, trust me.<br/>", self);
 return;
 }

if (item.objecttype == ITEM_CONTAINER)
    {
    sendtext("We do not accept to store containers anymore, sorry.<br/>",
self);
    return;
    }

if ((item.weight+item.alignment)>cont.capacity)
    {
    sendtext ("You cannot store any more in this storage space.<br/>", self);
    return;
    }

act ("$3n stores $2n for you.", A_ALWAYS, self, item, clerk, TO_CHAR);
act ("$3n stores something for $1n.", A_ALWAYS, self, item, clerk, TO_REST);
cont.alignment:=cont.alignment+item.weight;
addextra (item.extra, {"$stored"}, itoa(mudyear) );
link(cont,self.outside);
link (item, cont);
cont.weight:=0;
cont.baseweight:=0;
link(cont,self);
return;

}

dilend


dilbegin ctnwithdraw(arg: string);

var clerk: unitptr;
    cont : unitptr;
    item : unitptr;

    ext  : extraptr;
    town : string;
    iname: string;
    scost: integer;
    i    : integer;

code
{

clerk:= findunit (self, "clerk", FIND_UNIT_SURRO, null);

if (not visible(self, clerk))
    {
    sendtext ("You see no clerk around here.<br/>", self);
    return;
    }

if (not ("$storage clerk" in clerk.extra) )
    {
    sendtext ("This clerk is not a storage clerk.<br/>", self);
    return;
    }

town:= left (clerk.zoneidx, 3);
cont:= findunit (self, town+"container", FIND_UNIT_IN_ME, null);

if ((cont == null) or not ("$storage container" in cont.extra))
    {
    sendtext ("You do not have storage space in this town; rent some!<br/>",
self);
    return;
    }

iname:= arg;
if (iname == "")
    {
    sendtext ("Withdraw what?<br/>", self);
    return;
    }

item:= findunit (cont, iname, 0, cont.inside);
if (item == null)
    {
    sendtext ("You have no such thing stored here.<br/>", self);
    return;
    }

i:= can_carry(self, item, 1); // This func should be cant_carry

if (i == 1)
    {
    sendtext ("You cannot carry that many items.<br/>", self);
    return;
    }

if (i == 2)
    {
    sendtext ("You cannot carry that much weight.<br/>", self);
    return;
    }

ext:= "$stored" in item.extra;
scost:= atoi(ext.descr);

scost:= mudyear - scost;
if (scost <= 0) scost := 1;
if (scost > 10) scost := 10;

if (ext == null) scost := 0;

i:= transfermoney (self, null, scost * GOLD_MULT);

if (i == FALSE)
    {
    sendtext ("You cannot afford the "+itoa(scost)+" gold piece(s) "+
        "required.<br/>", self);
    return;
    }

else sendtext ("You pay "+itoa(scost)+" gold pieces to the clerk.<br/>", self);

subextra (item.extra, "$stored");

act ("$3n gives you your $2N.", A_ALWAYS, self, item, clerk, TO_CHAR);
act ("$3n gives $1n $2n.", A_ALWAYS, self, item, clerk, TO_REST);
sendto ("unstore",item);
cont.alignment:=cont.alignment-item.weight;
link(cont,self.outside);
link (item, self);
cont.weight:=0;
cont.baseweight:=0;
link(cont,self);
return;

}

dilend

dilbegin ctnstorage(arg: string);
var
   clerk: unitptr;
   cont : unitptr;
   item : unitptr;
   ext  : extraptr;
   town : string;
   i    : integer;

code
{

clerk:= findunit (self, "clerk", FIND_UNIT_SURRO, null);

if (not visible(self, clerk))
    {
    sendtext ("You see no clerk around here.<br/>", self);
    return;
    }

if (not ("$storage clerk" in clerk.extra) )
    {
    sendtext ("This clerk is not a storage clerk.<br/>", self);
    return;
    }

town:= left (clerk.zoneidx, 3);
cont:= findunit (self, town+"container", FIND_UNIT_IN_ME, null);

if ((cont == null) or not ("$storage container" in cont.extra))
    {
    sendtext ("You do not have storage space in this town; rent some!<br/>",
self);
    return;
    }

item:= cont.inside;

if (item == null)
    {
    sendtext ("Your storage container is empty.<br/>", self);
    return;
    }

sendtext ("Your storage contains : <br/>", self);

while (item != null) {
    sendtext (item.title+"<br/>", self);
    item := item.next;
    }

return;

}
dilend

// MS2020 xxx
// do_path: Wiz command to show the result of the shortest path algorithm.
dilbegin do_wpath(arg: string);
var
   dir : integer;
   u : unitptr;
   uin : unitptr;
   sl : stringlist;

code
{
   if (arg == "")
   {
      sendtext("Please specify an object you'd like a path to.<br/>", self);
      return;
   }

   log("1");
   u := findunit(self, arg, FIND_UNIT_WORLD, null, UNIT_ST_PC|UNIT_ST_NPC|UNIT_ST_OBJ|UNIT_ST_ROOM);

   log("2");
   if (not u)
   {
      u := findsymbolic(arg);

      if (not u)
      {
         sendtext("Can't locate a unit named " + arg + "<br/>", self);
         return;
      }
   }

   uin := u;
   while (uin.type != UNIT_ST_ROOM)
      uin := uin.outside;

   dir := pathto(self, u);

   log("3b");
   sl := DIR_SL_LONG;

   log("4");
   sendtext("Ola<br/>", self);
   sendtext("Found "+u.nameidx+"@"+u.zoneidx+" which is located in <a cmd='goto #'>" + uin.nameidx + "@" + uin.zoneidx + "</a><br/>", self);
   sendtext("Direction: " + sl.[dir] + "("+itoa(dir)+")<br/>", self);
   log("5");
   quit;
}
dilend


%rooms

hold_room
names null
title "In Stone"
descr

"You have been turned to stone. Time stands still for you."

flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT, UNIT_FL_SACRED}

minv 25

dilcopy boot_area();

end /* hold_room */
                                   menuroom
title "The Commands Room"
descr
"Token room."
movement SECT_INSIDE
flags {UNIT_FL_NO_WEATHER}
ALWAYS_LIGHT
end


%objects

container
names {"storage container"}
title "a storage container"
descr "Something's wrong, this container should not be on the floor."

extra {"$storage container"} ""

minv 253
end

petrify_statue
names {}
title ""
descr ""

extra {}
"This statue is so life-like, it has to be a divine creation. It looks like
the person was petrified suddenly because there isn't even a look of
surprise
on its face..."

type ITEM_OTHER

end /* petrify_statue */

guild_obj
names {"guild-wipe object", "wipe object", "guild object", "object"}
title "a guild-wipe object"
descr
"A guild-wipe object has been left here."
extra {}
"This object is used to remove guild details from a player. Don't
forget to remove exp from the player after using it. Simple type
'gwipe <playername>'."

manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD}

type ITEM_OTHER

dilcopy guild_wipe@commands();

end /* guild_obj */
%mobiles
                                       hel
names {"hel"}
title "Hel"
descr "Hel the grim reaper is here."
extra {} "Dressed in black."
romflags {CHAR_DETECT_INVISIBLE}
ATTACK_DEFENSE(+500, +500)

M_NORSE_GOD_GODLY(199,SEX_FEMALE)
dilcopy test1();




end

%end
